import * as _ from 'lodash';
import { Injectable } from '@angular/core';
import { IEntityProcessor } from '@libs/platform/data-access';
import { IEstResourceEntity } from '@libs/estimate/interfaces';
import { LazyInjectable, LazyInjectionToken } from '@libs/platform/common';

export const ESTIMATE_MAIN_RESOURCE_IMAGE_PROCESSOR_TOKEN = new LazyInjectionToken<EstimateMainResourceImageProcessor<IEstResourceEntity>>('estimate.main.resource.image.processor.service');

@LazyInjectable({
	token: ESTIMATE_MAIN_RESOURCE_IMAGE_PROCESSOR_TOKEN,
	useAngularInjection: true
})
@Injectable({ providedIn: 'root' })
export class EstimateMainResourceImageProcessor<T extends IEstResourceEntity> implements IEntityProcessor<T>{
	public process(resItem: T) {

		if (resItem) {
			const imageMap : {[key : number]: string} = { // EstResourceTypeFk
				1: 'ico-res-type-c',
				2: 'ico-res-type-m',
				3: 'ico-res-type-p',
				4: 'ico-res-type-a',
				5: 'ico-res-type-s',
				6: 'ico-res-type-p',
				7: 'ico-res-type-t',
				8: 'ico-res-type-i',
				10:'ico-res-type-r'
			};

			// special case: sub item with assembly reference (generated by resolving an assembly)
			if (resItem.EstResourceTypeFk === 5 && resItem.EstAssemblyFk !== null) {
				resItem.image = 'ico-res-type-as';
			} else {
				resItem.image = imageMap[resItem.EstResourceTypeFk];
			}

			// If any rule fk has not null value append -r to image path
			if (_.isNumber(resItem.EstRuleSourceFk) && resItem.EstRuleSourceFk > 0) {
				resItem.image += '-r';
			}
		}
	}

	public processItems(items: T[]) {
		items.forEach((item) => {
			this.process(item);
		});
	}

	public revertProcess(toProcess:  T): void{

	}
}