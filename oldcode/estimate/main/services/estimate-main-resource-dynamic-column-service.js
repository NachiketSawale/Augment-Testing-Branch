/**
 * Created by mov on 9/5/2017.
 */

(function () {
	'use strict';
	/* global _ */
	let moduleName = 'estimate.main';
	/**
	 * @ngdoc service
	 * @name estimateMainResourceDynamicColumnService
	 * @function
	 *
	 * @description
	 * estimateMainResourceDynamicColumnService is the data service for characteristic resource container.
	 */

	angular.module(moduleName).factory('estimateMainResourceDynamicColumnService', [
		'$injector', '$q', '$http', 'platformGridAPI', 'estimateMainCommonService', 'estimateMainResourceService', 'estimateMainResourceConfigurationService', 'estimateMainService', 'platformTranslateService',
		function($injector, $q, $http, platformGridAPI, estimateMainCommonService, estimateMainResourceService, estimateMainResourceConfigurationService, estimateMainService, platformTranslateService){

			let service = {};
			let sectionId = 33;
			let charactCols = [];

			angular.extend(service, {
				reloadDynamicColumnAndData: reloadDynamicColumnAndData,
				asyncLoadDynamicColumns: asyncLoadDynamicColumns,
				resizeGrid: resizeGrid,
				addColumn: addColumn,
				removeColumn: removeColumn,
				isExistColumn: isExistColumn,
				appendCharacteristicColumnDataAndRefreshGrid: appendCharacteristicColumnDataAndRefreshGrid,
				setDynCharCols: setDynCharCols
			});

			let estAssemblyStandardConfig = getEstAssemblyStandardConfig();

			return service;

			function reloadDynamicColumnAndData() {
				asyncLoadDynamicColumns();
			}

			function appendCharacteristicColumnDataAndRefreshGrid(data, estimateMainResourceService){
				estimateMainCommonService.appendCharactiricColumnData(data, estimateMainResourceService);
				// characteristic column
				charactCols = estimateMainCommonService.getCharactCols(data);
				resizeGrid();

				// if the resource item is generated by rule(s), then set the characteristic cols as editable
				if(charactCols && charactCols.length > 0){
					setCharactColsReadOnly(charactCols);
				}

				return charactCols;
			}

			function asyncLoadDynamicColumns() {
				function refreshColumns() {
					estimateMainCommonService.generateCharacteristicColumns(estimateMainResourceService, sectionId).then(function (data) {
						return appendCharacteristicColumnDataAndRefreshGrid(data, estimateMainResourceService);
					});
				}

				let estHeaderId = estimateMainService.getSelectedEstHeaderId() || -1;
				let qDefer = $q.defer();
				if (estHeaderId >= -1) {
					let cols = refreshColumns();
					qDefer.resolve(cols);
				} else {
					qDefer.resolve([]);
				}
				return qDefer.promise;
			}

			function resizeGrid() {
				let assemblyGridId = estimateMainResourceService.getGridId();
				if (true === platformGridAPI.grids.exist(assemblyGridId)) {

					// characterColumnsToAdd, these cols are necessary to be added or the grid control will throw error when settings the columns to the grid in configuration.
					_.forEach(platformGridAPI.columns.configuration(assemblyGridId).current, function(item){
						if (item.field.includes('charactercolumn_')){
							if (_.findIndex(charactCols, { 'field': item.field }) === -1){
								charactCols.push(item);
							}
						}
					});

					platformGridAPI.columns.configuration(assemblyGridId, getStaticColumns().concat(charactCols));
					platformGridAPI.grids.resize(assemblyGridId);
				}
			}

			function getStaticColumns() {
				let loadedCols = {};
				let originalCols = estAssemblyStandardConfig && estAssemblyStandardConfig.columns ? angular.copy(estAssemblyStandardConfig.columns) : [];

				// current = hidden + visible;
				// current: all loaded columns
				let assemblyGridId = estimateMainResourceService.getGridId();
				let currentColumns = (platformGridAPI.columns.configuration(assemblyGridId) || {}).current || [];
				_.map(currentColumns, function (col, index) {
					let colId = col.id;
					if (!_.isEmpty(colId)) {
						col.dynamicSorting = index;
						loadedCols[colId] = col;
					}
				});

				let modifiedCols = _.map(originalCols, function (oriCol) {
					let colId = oriCol.id;
					if (!_.isEmpty(colId) && loadedCols[colId]) {
						oriCol = _.merge(oriCol, loadedCols[colId]);
					}
					return oriCol;
				});

				let modifiedColsSorted = _.sortBy(modifiedCols, 'dynamicSorting');
				return angular.copy(modifiedColsSorted);
			}

			function getEstAssemblyStandardConfig() {

				let standardConfig = estimateMainResourceConfigurationService.getStandardConfigForListView();

				if (!standardConfig.isTranslated) {

					platformTranslateService.translateGridConfig(standardConfig.columns);

					standardConfig.isTranslated = true;
				}

				return standardConfig;
			}

			function isExistColumn(idorField) {
				let colData = _.filter(charactCols, {'id': idorField});
				if (!colData || (colData && colData.length === 0)) {
					return false;
				}
				return true;
			}

			function addColumn(item, columnIdorField, columnName) {
				let charCol = estimateMainCommonService.createCharactCol(item, columnIdorField, columnName);
				let charCols = [];
				charCols.push(charCol);
				charactCols = charactCols.concat(charCols);
			}

			function removeColumn(oldIdorField) {
				charactCols = _.filter(charactCols, function (col) {
					return col.id !== oldIdorField;
				});
			}

			function setCharactColsReadOnly(charactCols){
				let itemList = estimateMainResourceService.getList();
				let fieldCharacts = [];
				angular.forEach(charactCols, function(charact){
					let field = {field: charact.field , readonly: false};
					fieldCharacts.push(field);
				});

				angular.forEach(itemList, function(item){
					if(item && item.EstRuleSourceFk) {
						$injector.get('platformRuntimeDataService').readonly(item, fieldCharacts);
					}
				});


			}

			function setDynCharCols(value){
				charactCols = value;
			}
		}
	]);
})();
