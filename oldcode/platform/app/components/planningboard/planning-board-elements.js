//const copyGlobalForElem = _.cloneDeep(global);
var useAngularElement = false;

if (useAngularElement) {
	var PlanningBoardDataServiceInterfaceService = (function () {
		const copyGlobalForElem = _.cloneDeep(global);
		var __create = Object.create;
		var __defProp = Object.defineProperty;
		var __defProps = Object.defineProperties;
		var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
		var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
		var __getOwnPropNames = Object.getOwnPropertyNames;
		var __getOwnPropSymbols = Object.getOwnPropertySymbols;
		var __getProtoOf = Object.getPrototypeOf;
		var __hasOwnProp = Object.prototype.hasOwnProperty;
		var __propIsEnum = Object.prototype.propertyIsEnumerable;
		var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
		var __spreadValues = (a, b) => {
		  for (var prop in b ||= {})
			 if (__hasOwnProp.call(b, prop))
				__defNormalProp(a, prop, b[prop]);
		  if (__getOwnPropSymbols)
			 for (var prop of __getOwnPropSymbols(b)) {
				if (__propIsEnum.call(b, prop))
				  __defNormalProp(a, prop, b[prop]);
			 }
		  return a;
		};
		var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
		var __commonJS = (cb, mod) => function __require() {
		  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
		};
		var __copyProps = (to, from2, except, desc) => {
		  if (from2 && typeof from2 === "object" || typeof from2 === "function") {
			 for (let key of __getOwnPropNames(from2))
				if (!__hasOwnProp.call(to, key) && key !== except)
				  __defProp(to, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
		  }
		  return to;
		};
		var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
		  // If the importer is in node compatibility mode or this is not an ESM
		  // file that has been converted to a CommonJS file using a Babel-
		  // compatible transform (i.e. "__esModule" has not been set), then set
		  // "default" to the CommonJS "module.exports" for node compatibility.
		  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
		  mod
		));
		var __async = (__this, __arguments, generator) => {
		  return new Promise((resolve, reject) => {
			 var fulfilled = (value) => {
				try {
				  step(generator.next(value));
				} catch (e) {
				  reject(e);
				}
			 };
			 var rejected = (value) => {
				try {
				  step(generator.throw(value));
				} catch (e) {
				  reject(e);
				}
			 };
			 var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
			 step((generator = generator.apply(__this, __arguments)).next());
		  });
		};

		// node_modules/lodash/lodash.js
		var require_lodash = __commonJS({
		  "node_modules/lodash/lodash.js"(exports, module) {
			 "use strict";
			 (function() {
				var undefined2;
				var VERSION5 = "4.17.21";
				var LARGE_ARRAY_SIZE = 200;
				var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
				var HASH_UNDEFINED = "__lodash_hash_undefined__";
				var MAX_MEMOIZE_SIZE = 500;
				var PLACEHOLDER = "__lodash_placeholder__";
				var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
				var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
				var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
				var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
				var HOT_COUNT = 800, HOT_SPAN = 16;
				var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
				var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
				var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
				var wrapFlags = [
				  ["ary", WRAP_ARY_FLAG],
				  ["bind", WRAP_BIND_FLAG],
				  ["bindKey", WRAP_BIND_KEY_FLAG],
				  ["curry", WRAP_CURRY_FLAG],
				  ["curryRight", WRAP_CURRY_RIGHT_FLAG],
				  ["flip", WRAP_FLIP_FLAG],
				  ["partial", WRAP_PARTIAL_FLAG],
				  ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
				  ["rearg", WRAP_REARG_FLAG]
				];
				var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
				var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
				var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
				var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
				var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
				var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
				var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
				var reTrimStart = /^\s+/;
				var reWhitespace = /\s/;
				var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
				var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
				var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
				var reEscapeChar = /\\(\\)?/g;
				var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
				var reFlags = /\w*$/;
				var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
				var reIsBinary = /^0b[01]+$/i;
				var reIsHostCtor = /^\[object .+?Constructor\]$/;
				var reIsOctal = /^0o[0-7]+$/i;
				var reIsUint = /^(?:0|[1-9]\d*)$/;
				var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
				var reNoMatch = /($^)/;
				var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
				var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
				var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
				var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
				var reApos = RegExp(rsApos, "g");
				var reComboMark = RegExp(rsCombo, "g");
				var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
				var reUnicodeWord = RegExp([
				  rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
				  rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
				  rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
				  rsUpper + "+" + rsOptContrUpper,
				  rsOrdUpper,
				  rsOrdLower,
				  rsDigits,
				  rsEmoji
				].join("|"), "g");
				var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
				var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
				var contextProps = [
				  "Array",
				  "Buffer",
				  "DataView",
				  "Date",
				  "Error",
				  "Float32Array",
				  "Float64Array",
				  "Function",
				  "Int8Array",
				  "Int16Array",
				  "Int32Array",
				  "Map",
				  "Math",
				  "Object",
				  "Promise",
				  "RegExp",
				  "Set",
				  "String",
				  "Symbol",
				  "TypeError",
				  "Uint8Array",
				  "Uint8ClampedArray",
				  "Uint16Array",
				  "Uint32Array",
				  "WeakMap",
				  "_",
				  "clearTimeout",
				  "isFinite",
				  "parseInt",
				  "setTimeout"
				];
				var templateCounter = -1;
				var typedArrayTags = {};
				typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
				typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
				var cloneableTags = {};
				cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
				cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
				var deburredLetters = {
				  // Latin-1 Supplement block.
				  "\xC0": "A",
				  "\xC1": "A",
				  "\xC2": "A",
				  "\xC3": "A",
				  "\xC4": "A",
				  "\xC5": "A",
				  "\xE0": "a",
				  "\xE1": "a",
				  "\xE2": "a",
				  "\xE3": "a",
				  "\xE4": "a",
				  "\xE5": "a",
				  "\xC7": "C",
				  "\xE7": "c",
				  "\xD0": "D",
				  "\xF0": "d",
				  "\xC8": "E",
				  "\xC9": "E",
				  "\xCA": "E",
				  "\xCB": "E",
				  "\xE8": "e",
				  "\xE9": "e",
				  "\xEA": "e",
				  "\xEB": "e",
				  "\xCC": "I",
				  "\xCD": "I",
				  "\xCE": "I",
				  "\xCF": "I",
				  "\xEC": "i",
				  "\xED": "i",
				  "\xEE": "i",
				  "\xEF": "i",
				  "\xD1": "N",
				  "\xF1": "n",
				  "\xD2": "O",
				  "\xD3": "O",
				  "\xD4": "O",
				  "\xD5": "O",
				  "\xD6": "O",
				  "\xD8": "O",
				  "\xF2": "o",
				  "\xF3": "o",
				  "\xF4": "o",
				  "\xF5": "o",
				  "\xF6": "o",
				  "\xF8": "o",
				  "\xD9": "U",
				  "\xDA": "U",
				  "\xDB": "U",
				  "\xDC": "U",
				  "\xF9": "u",
				  "\xFA": "u",
				  "\xFB": "u",
				  "\xFC": "u",
				  "\xDD": "Y",
				  "\xFD": "y",
				  "\xFF": "y",
				  "\xC6": "Ae",
				  "\xE6": "ae",
				  "\xDE": "Th",
				  "\xFE": "th",
				  "\xDF": "ss",
				  // Latin Extended-A block.
				  "\u0100": "A",
				  "\u0102": "A",
				  "\u0104": "A",
				  "\u0101": "a",
				  "\u0103": "a",
				  "\u0105": "a",
				  "\u0106": "C",
				  "\u0108": "C",
				  "\u010A": "C",
				  "\u010C": "C",
				  "\u0107": "c",
				  "\u0109": "c",
				  "\u010B": "c",
				  "\u010D": "c",
				  "\u010E": "D",
				  "\u0110": "D",
				  "\u010F": "d",
				  "\u0111": "d",
				  "\u0112": "E",
				  "\u0114": "E",
				  "\u0116": "E",
				  "\u0118": "E",
				  "\u011A": "E",
				  "\u0113": "e",
				  "\u0115": "e",
				  "\u0117": "e",
				  "\u0119": "e",
				  "\u011B": "e",
				  "\u011C": "G",
				  "\u011E": "G",
				  "\u0120": "G",
				  "\u0122": "G",
				  "\u011D": "g",
				  "\u011F": "g",
				  "\u0121": "g",
				  "\u0123": "g",
				  "\u0124": "H",
				  "\u0126": "H",
				  "\u0125": "h",
				  "\u0127": "h",
				  "\u0128": "I",
				  "\u012A": "I",
				  "\u012C": "I",
				  "\u012E": "I",
				  "\u0130": "I",
				  "\u0129": "i",
				  "\u012B": "i",
				  "\u012D": "i",
				  "\u012F": "i",
				  "\u0131": "i",
				  "\u0134": "J",
				  "\u0135": "j",
				  "\u0136": "K",
				  "\u0137": "k",
				  "\u0138": "k",
				  "\u0139": "L",
				  "\u013B": "L",
				  "\u013D": "L",
				  "\u013F": "L",
				  "\u0141": "L",
				  "\u013A": "l",
				  "\u013C": "l",
				  "\u013E": "l",
				  "\u0140": "l",
				  "\u0142": "l",
				  "\u0143": "N",
				  "\u0145": "N",
				  "\u0147": "N",
				  "\u014A": "N",
				  "\u0144": "n",
				  "\u0146": "n",
				  "\u0148": "n",
				  "\u014B": "n",
				  "\u014C": "O",
				  "\u014E": "O",
				  "\u0150": "O",
				  "\u014D": "o",
				  "\u014F": "o",
				  "\u0151": "o",
				  "\u0154": "R",
				  "\u0156": "R",
				  "\u0158": "R",
				  "\u0155": "r",
				  "\u0157": "r",
				  "\u0159": "r",
				  "\u015A": "S",
				  "\u015C": "S",
				  "\u015E": "S",
				  "\u0160": "S",
				  "\u015B": "s",
				  "\u015D": "s",
				  "\u015F": "s",
				  "\u0161": "s",
				  "\u0162": "T",
				  "\u0164": "T",
				  "\u0166": "T",
				  "\u0163": "t",
				  "\u0165": "t",
				  "\u0167": "t",
				  "\u0168": "U",
				  "\u016A": "U",
				  "\u016C": "U",
				  "\u016E": "U",
				  "\u0170": "U",
				  "\u0172": "U",
				  "\u0169": "u",
				  "\u016B": "u",
				  "\u016D": "u",
				  "\u016F": "u",
				  "\u0171": "u",
				  "\u0173": "u",
				  "\u0174": "W",
				  "\u0175": "w",
				  "\u0176": "Y",
				  "\u0177": "y",
				  "\u0178": "Y",
				  "\u0179": "Z",
				  "\u017B": "Z",
				  "\u017D": "Z",
				  "\u017A": "z",
				  "\u017C": "z",
				  "\u017E": "z",
				  "\u0132": "IJ",
				  "\u0133": "ij",
				  "\u0152": "Oe",
				  "\u0153": "oe",
				  "\u0149": "'n",
				  "\u017F": "s"
				};
				var htmlEscapes = {
				  "&": "&amp;",
				  "<": "&lt;",
				  ">": "&gt;",
				  '"': "&quot;",
				  "'": "&#39;"
				};
				var htmlUnescapes = {
				  "&amp;": "&",
				  "&lt;": "<",
				  "&gt;": ">",
				  "&quot;": '"',
				  "&#39;": "'"
				};
				var stringEscapes = {
				  "\\": "\\",
				  "'": "'",
				  "\n": "n",
				  "\r": "r",
				  "\u2028": "u2028",
				  "\u2029": "u2029"
				};
				var freeParseFloat = parseFloat, freeParseInt = parseInt;
				var freeGlobal = typeof copyGlobalForElem == "object" && copyGlobalForElem && copyGlobalForElem.Object === Object && copyGlobalForElem;
				var freeSelf = typeof self == "object" && self && self.Object === Object && self;
				var root2 = freeGlobal || freeSelf || Function("return this")();
				var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
				var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
				var moduleExports = freeModule && freeModule.exports === freeExports;
				var freeProcess = moduleExports && freeGlobal.process;
				var nodeUtil = function() {
				  try {
					 var types = freeModule && freeModule.require && freeModule.require("util").types;
					 if (types) {
						return types;
					 }
					 return freeProcess && freeProcess.binding && freeProcess.binding("util");
				  } catch (e) {
				  }
				}();
				var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
				function apply(func, thisArg, args) {
				  switch (args.length) {
					 case 0:
						return func.call(thisArg);
					 case 1:
						return func.call(thisArg, args[0]);
					 case 2:
						return func.call(thisArg, args[0], args[1]);
					 case 3:
						return func.call(thisArg, args[0], args[1], args[2]);
				  }
				  return func.apply(thisArg, args);
				}
				function arrayAggregator(array2, setter, iteratee, accumulator) {
				  var index = -1, length = array2 == null ? 0 : array2.length;
				  while (++index < length) {
					 var value = array2[index];
					 setter(accumulator, value, iteratee(value), array2);
				  }
				  return accumulator;
				}
				function arrayEach(array2, iteratee) {
				  var index = -1, length = array2 == null ? 0 : array2.length;
				  while (++index < length) {
					 if (iteratee(array2[index], index, array2) === false) {
						break;
					 }
				  }
				  return array2;
				}
				function arrayEachRight(array2, iteratee) {
				  var length = array2 == null ? 0 : array2.length;
				  while (length--) {
					 if (iteratee(array2[length], length, array2) === false) {
						break;
					 }
				  }
				  return array2;
				}
				function arrayEvery(array2, predicate) {
				  var index = -1, length = array2 == null ? 0 : array2.length;
				  while (++index < length) {
					 if (!predicate(array2[index], index, array2)) {
						return false;
					 }
				  }
				  return true;
				}
				function arrayFilter(array2, predicate) {
				  var index = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
				  while (++index < length) {
					 var value = array2[index];
					 if (predicate(value, index, array2)) {
						result[resIndex++] = value;
					 }
				  }
				  return result;
				}
				function arrayIncludes(array2, value) {
				  var length = array2 == null ? 0 : array2.length;
				  return !!length && baseIndexOf(array2, value, 0) > -1;
				}
				function arrayIncludesWith(array2, value, comparator) {
				  var index = -1, length = array2 == null ? 0 : array2.length;
				  while (++index < length) {
					 if (comparator(value, array2[index])) {
						return true;
					 }
				  }
				  return false;
				}
				function arrayMap(array2, iteratee) {
				  var index = -1, length = array2 == null ? 0 : array2.length, result = Array(length);
				  while (++index < length) {
					 result[index] = iteratee(array2[index], index, array2);
				  }
				  return result;
				}
				function arrayPush(array2, values) {
				  var index = -1, length = values.length, offset = array2.length;
				  while (++index < length) {
					 array2[offset + index] = values[index];
				  }
				  return array2;
				}
				function arrayReduce(array2, iteratee, accumulator, initAccum) {
				  var index = -1, length = array2 == null ? 0 : array2.length;
				  if (initAccum && length) {
					 accumulator = array2[++index];
				  }
				  while (++index < length) {
					 accumulator = iteratee(accumulator, array2[index], index, array2);
				  }
				  return accumulator;
				}
				function arrayReduceRight(array2, iteratee, accumulator, initAccum) {
				  var length = array2 == null ? 0 : array2.length;
				  if (initAccum && length) {
					 accumulator = array2[--length];
				  }
				  while (length--) {
					 accumulator = iteratee(accumulator, array2[length], length, array2);
				  }
				  return accumulator;
				}
				function arraySome(array2, predicate) {
				  var index = -1, length = array2 == null ? 0 : array2.length;
				  while (++index < length) {
					 if (predicate(array2[index], index, array2)) {
						return true;
					 }
				  }
				  return false;
				}
				var asciiSize = baseProperty("length");
				function asciiToArray(string) {
				  return string.split("");
				}
				function asciiWords(string) {
				  return string.match(reAsciiWord) || [];
				}
				function baseFindKey(collection, predicate, eachFunc) {
				  var result;
				  eachFunc(collection, function(value, key, collection2) {
					 if (predicate(value, key, collection2)) {
						result = key;
						return false;
					 }
				  });
				  return result;
				}
				function baseFindIndex(array2, predicate, fromIndex, fromRight) {
				  var length = array2.length, index = fromIndex + (fromRight ? 1 : -1);
				  while (fromRight ? index-- : ++index < length) {
					 if (predicate(array2[index], index, array2)) {
						return index;
					 }
				  }
				  return -1;
				}
				function baseIndexOf(array2, value, fromIndex) {
				  return value === value ? strictIndexOf(array2, value, fromIndex) : baseFindIndex(array2, baseIsNaN, fromIndex);
				}
				function baseIndexOfWith(array2, value, fromIndex, comparator) {
				  var index = fromIndex - 1, length = array2.length;
				  while (++index < length) {
					 if (comparator(array2[index], value)) {
						return index;
					 }
				  }
				  return -1;
				}
				function baseIsNaN(value) {
				  return value !== value;
				}
				function baseMean(array2, iteratee) {
				  var length = array2 == null ? 0 : array2.length;
				  return length ? baseSum(array2, iteratee) / length : NAN;
				}
				function baseProperty(key) {
				  return function(object) {
					 return object == null ? undefined2 : object[key];
				  };
				}
				function basePropertyOf(object) {
				  return function(key) {
					 return object == null ? undefined2 : object[key];
				  };
				}
				function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
				  eachFunc(collection, function(value, index, collection2) {
					 accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
				  });
				  return accumulator;
				}
				function baseSortBy(array2, comparer) {
				  var length = array2.length;
				  array2.sort(comparer);
				  while (length--) {
					 array2[length] = array2[length].value;
				  }
				  return array2;
				}
				function baseSum(array2, iteratee) {
				  var result, index = -1, length = array2.length;
				  while (++index < length) {
					 var current = iteratee(array2[index]);
					 if (current !== undefined2) {
						result = result === undefined2 ? current : result + current;
					 }
				  }
				  return result;
				}
				function baseTimes(n, iteratee) {
				  var index = -1, result = Array(n);
				  while (++index < n) {
					 result[index] = iteratee(index);
				  }
				  return result;
				}
				function baseToPairs(object, props) {
				  return arrayMap(props, function(key) {
					 return [key, object[key]];
				  });
				}
				function baseTrim(string) {
				  return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
				}
				function baseUnary(func) {
				  return function(value) {
					 return func(value);
				  };
				}
				function baseValues(object, props) {
				  return arrayMap(props, function(key) {
					 return object[key];
				  });
				}
				function cacheHas(cache, key) {
				  return cache.has(key);
				}
				function charsStartIndex(strSymbols, chrSymbols) {
				  var index = -1, length = strSymbols.length;
				  while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
				  }
				  return index;
				}
				function charsEndIndex(strSymbols, chrSymbols) {
				  var index = strSymbols.length;
				  while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
				  }
				  return index;
				}
				function countHolders(array2, placeholder) {
				  var length = array2.length, result = 0;
				  while (length--) {
					 if (array2[length] === placeholder) {
						++result;
					 }
				  }
				  return result;
				}
				var deburrLetter = basePropertyOf(deburredLetters);
				var escapeHtmlChar = basePropertyOf(htmlEscapes);
				function escapeStringChar(chr) {
				  return "\\" + stringEscapes[chr];
				}
				function getValue(object, key) {
				  return object == null ? undefined2 : object[key];
				}
				function hasUnicode(string) {
				  return reHasUnicode.test(string);
				}
				function hasUnicodeWord(string) {
				  return reHasUnicodeWord.test(string);
				}
				function iteratorToArray(iterator2) {
				  var data, result = [];
				  while (!(data = iterator2.next()).done) {
					 result.push(data.value);
				  }
				  return result;
				}
				function mapToArray(map3) {
				  var index = -1, result = Array(map3.size);
				  map3.forEach(function(value, key) {
					 result[++index] = [key, value];
				  });
				  return result;
				}
				function overArg(func, transform2) {
				  return function(arg) {
					 return func(transform2(arg));
				  };
				}
				function replaceHolders(array2, placeholder) {
				  var index = -1, length = array2.length, resIndex = 0, result = [];
				  while (++index < length) {
					 var value = array2[index];
					 if (value === placeholder || value === PLACEHOLDER) {
						array2[index] = PLACEHOLDER;
						result[resIndex++] = index;
					 }
				  }
				  return result;
				}
				function setToArray(set3) {
				  var index = -1, result = Array(set3.size);
				  set3.forEach(function(value) {
					 result[++index] = value;
				  });
				  return result;
				}
				function setToPairs(set3) {
				  var index = -1, result = Array(set3.size);
				  set3.forEach(function(value) {
					 result[++index] = [value, value];
				  });
				  return result;
				}
				function strictIndexOf(array2, value, fromIndex) {
				  var index = fromIndex - 1, length = array2.length;
				  while (++index < length) {
					 if (array2[index] === value) {
						return index;
					 }
				  }
				  return -1;
				}
				function strictLastIndexOf(array2, value, fromIndex) {
				  var index = fromIndex + 1;
				  while (index--) {
					 if (array2[index] === value) {
						return index;
					 }
				  }
				  return index;
				}
				function stringSize(string) {
				  return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
				}
				function stringToArray(string) {
				  return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
				}
				function trimmedEndIndex(string) {
				  var index = string.length;
				  while (index-- && reWhitespace.test(string.charAt(index))) {
				  }
				  return index;
				}
				var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
				function unicodeSize(string) {
				  var result = reUnicode.lastIndex = 0;
				  while (reUnicode.test(string)) {
					 ++result;
				  }
				  return result;
				}
				function unicodeToArray(string) {
				  return string.match(reUnicode) || [];
				}
				function unicodeWords(string) {
				  return string.match(reUnicodeWord) || [];
				}
				var runInContext = function runInContext2(context2) {
				  context2 = context2 == null ? root2 : _2.defaults(root2.Object(), context2, _2.pick(root2, contextProps));
				  var Array2 = context2.Array, Date2 = context2.Date, Error2 = context2.Error, Function2 = context2.Function, Math2 = context2.Math, Object2 = context2.Object, RegExp2 = context2.RegExp, String2 = context2.String, TypeError2 = context2.TypeError;
				  var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
				  var coreJsData = context2["__core-js_shared__"];
				  var funcToString = funcProto.toString;
				  var hasOwnProperty = objectProto.hasOwnProperty;
				  var idCounter = 0;
				  var maskSrcKey = function() {
					 var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
					 return uid ? "Symbol(src)_1." + uid : "";
				  }();
				  var nativeObjectToString = objectProto.toString;
				  var objectCtorString = funcToString.call(Object2);
				  var oldDash = root2._;
				  var reIsNative = RegExp2(
					 "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
				  );
				  var Buffer2 = moduleExports ? context2.Buffer : undefined2, Symbol2 = context2.Symbol, Uint8Array2 = context2.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
				  var defineProperty = function() {
					 try {
						var func = getNative(Object2, "defineProperty");
						func({}, "", {});
						return func;
					 } catch (e) {
					 }
				  }();
				  var ctxClearTimeout = context2.clearTimeout !== root2.clearTimeout && context2.clearTimeout, ctxNow = Date2 && Date2.now !== root2.Date.now && Date2.now, ctxSetTimeout = context2.setTimeout !== root2.setTimeout && context2.setTimeout;
				  var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context2.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context2.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
				  var DataView2 = getNative(context2, "DataView"), Map2 = getNative(context2, "Map"), Promise2 = getNative(context2, "Promise"), Set2 = getNative(context2, "Set"), WeakMap2 = getNative(context2, "WeakMap"), nativeCreate = getNative(Object2, "create");
				  var metaMap = WeakMap2 && new WeakMap2();
				  var realNames = {};
				  var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
				  var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
				  function lodash(value) {
					 if (isObjectLike(value) && !isArray2(value) && !(value instanceof LazyWrapper)) {
						if (value instanceof LodashWrapper) {
						  return value;
						}
						if (hasOwnProperty.call(value, "__wrapped__")) {
						  return wrapperClone(value);
						}
					 }
					 return new LodashWrapper(value);
				  }
				  var baseCreate = /* @__PURE__ */ function() {
					 function object() {
					 }
					 return function(proto) {
						if (!isObject2(proto)) {
						  return {};
						}
						if (objectCreate) {
						  return objectCreate(proto);
						}
						object.prototype = proto;
						var result2 = new object();
						object.prototype = undefined2;
						return result2;
					 };
				  }();
				  function baseLodash() {
				  }
				  function LodashWrapper(value, chainAll) {
					 this.__wrapped__ = value;
					 this.__actions__ = [];
					 this.__chain__ = !!chainAll;
					 this.__index__ = 0;
					 this.__values__ = undefined2;
				  }
				  lodash.templateSettings = {
					 /**
					  * Used to detect `data` property values to be HTML-escaped.
					  *
					  * @memberOf _.templateSettings
					  * @type {RegExp}
					  */
					 "escape": reEscape,
					 /**
					  * Used to detect code to be evaluated.
					  *
					  * @memberOf _.templateSettings
					  * @type {RegExp}
					  */
					 "evaluate": reEvaluate,
					 /**
					  * Used to detect `data` property values to inject.
					  *
					  * @memberOf _.templateSettings
					  * @type {RegExp}
					  */
					 "interpolate": reInterpolate,
					 /**
					  * Used to reference the data object in the template text.
					  *
					  * @memberOf _.templateSettings
					  * @type {string}
					  */
					 "variable": "",
					 /**
					  * Used to import variables into the compiled template.
					  *
					  * @memberOf _.templateSettings
					  * @type {Object}
					  */
					 "imports": {
						/**
						 * A reference to the `lodash` function.
						 *
						 * @memberOf _.templateSettings.imports
						 * @type {Function}
						 */
						"_": lodash
					 }
				  };
				  lodash.prototype = baseLodash.prototype;
				  lodash.prototype.constructor = lodash;
				  LodashWrapper.prototype = baseCreate(baseLodash.prototype);
				  LodashWrapper.prototype.constructor = LodashWrapper;
				  function LazyWrapper(value) {
					 this.__wrapped__ = value;
					 this.__actions__ = [];
					 this.__dir__ = 1;
					 this.__filtered__ = false;
					 this.__iteratees__ = [];
					 this.__takeCount__ = MAX_ARRAY_LENGTH;
					 this.__views__ = [];
				  }
				  function lazyClone() {
					 var result2 = new LazyWrapper(this.__wrapped__);
					 result2.__actions__ = copyArray(this.__actions__);
					 result2.__dir__ = this.__dir__;
					 result2.__filtered__ = this.__filtered__;
					 result2.__iteratees__ = copyArray(this.__iteratees__);
					 result2.__takeCount__ = this.__takeCount__;
					 result2.__views__ = copyArray(this.__views__);
					 return result2;
				  }
				  function lazyReverse() {
					 if (this.__filtered__) {
						var result2 = new LazyWrapper(this);
						result2.__dir__ = -1;
						result2.__filtered__ = true;
					 } else {
						result2 = this.clone();
						result2.__dir__ *= -1;
					 }
					 return result2;
				  }
				  function lazyValue() {
					 var array2 = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray2(array2), isRight = dir < 0, arrLength = isArr ? array2.length : 0, view = getView(0, arrLength, this.__views__), start2 = view.start, end = view.end, length = end - start2, index = isRight ? end : start2 - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
					 if (!isArr || !isRight && arrLength == length && takeCount == length) {
						return baseWrapperValue(array2, this.__actions__);
					 }
					 var result2 = [];
					 outer:
						while (length-- && resIndex < takeCount) {
						  index += dir;
						  var iterIndex = -1, value = array2[index];
						  while (++iterIndex < iterLength) {
							 var data = iteratees[iterIndex], iteratee2 = data.iteratee, type2 = data.type, computed = iteratee2(value);
							 if (type2 == LAZY_MAP_FLAG) {
								value = computed;
							 } else if (!computed) {
								if (type2 == LAZY_FILTER_FLAG) {
								  continue outer;
								} else {
								  break outer;
								}
							 }
						  }
						  result2[resIndex++] = value;
						}
					 return result2;
				  }
				  LazyWrapper.prototype = baseCreate(baseLodash.prototype);
				  LazyWrapper.prototype.constructor = LazyWrapper;
				  function Hash(entries) {
					 var index = -1, length = entries == null ? 0 : entries.length;
					 this.clear();
					 while (++index < length) {
						var entry = entries[index];
						this.set(entry[0], entry[1]);
					 }
				  }
				  function hashClear() {
					 this.__data__ = nativeCreate ? nativeCreate(null) : {};
					 this.size = 0;
				  }
				  function hashDelete(key) {
					 var result2 = this.has(key) && delete this.__data__[key];
					 this.size -= result2 ? 1 : 0;
					 return result2;
				  }
				  function hashGet(key) {
					 var data = this.__data__;
					 if (nativeCreate) {
						var result2 = data[key];
						return result2 === HASH_UNDEFINED ? undefined2 : result2;
					 }
					 return hasOwnProperty.call(data, key) ? data[key] : undefined2;
				  }
				  function hashHas(key) {
					 var data = this.__data__;
					 return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);
				  }
				  function hashSet(key, value) {
					 var data = this.__data__;
					 this.size += this.has(key) ? 0 : 1;
					 data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
					 return this;
				  }
				  Hash.prototype.clear = hashClear;
				  Hash.prototype["delete"] = hashDelete;
				  Hash.prototype.get = hashGet;
				  Hash.prototype.has = hashHas;
				  Hash.prototype.set = hashSet;
				  function ListCache(entries) {
					 var index = -1, length = entries == null ? 0 : entries.length;
					 this.clear();
					 while (++index < length) {
						var entry = entries[index];
						this.set(entry[0], entry[1]);
					 }
				  }
				  function listCacheClear() {
					 this.__data__ = [];
					 this.size = 0;
				  }
				  function listCacheDelete(key) {
					 var data = this.__data__, index = assocIndexOf(data, key);
					 if (index < 0) {
						return false;
					 }
					 var lastIndex = data.length - 1;
					 if (index == lastIndex) {
						data.pop();
					 } else {
						splice.call(data, index, 1);
					 }
					 --this.size;
					 return true;
				  }
				  function listCacheGet(key) {
					 var data = this.__data__, index = assocIndexOf(data, key);
					 return index < 0 ? undefined2 : data[index][1];
				  }
				  function listCacheHas(key) {
					 return assocIndexOf(this.__data__, key) > -1;
				  }
				  function listCacheSet(key, value) {
					 var data = this.__data__, index = assocIndexOf(data, key);
					 if (index < 0) {
						++this.size;
						data.push([key, value]);
					 } else {
						data[index][1] = value;
					 }
					 return this;
				  }
				  ListCache.prototype.clear = listCacheClear;
				  ListCache.prototype["delete"] = listCacheDelete;
				  ListCache.prototype.get = listCacheGet;
				  ListCache.prototype.has = listCacheHas;
				  ListCache.prototype.set = listCacheSet;
				  function MapCache(entries) {
					 var index = -1, length = entries == null ? 0 : entries.length;
					 this.clear();
					 while (++index < length) {
						var entry = entries[index];
						this.set(entry[0], entry[1]);
					 }
				  }
				  function mapCacheClear() {
					 this.size = 0;
					 this.__data__ = {
						"hash": new Hash(),
						"map": new (Map2 || ListCache)(),
						"string": new Hash()
					 };
				  }
				  function mapCacheDelete(key) {
					 var result2 = getMapData(this, key)["delete"](key);
					 this.size -= result2 ? 1 : 0;
					 return result2;
				  }
				  function mapCacheGet(key) {
					 return getMapData(this, key).get(key);
				  }
				  function mapCacheHas(key) {
					 return getMapData(this, key).has(key);
				  }
				  function mapCacheSet(key, value) {
					 var data = getMapData(this, key), size2 = data.size;
					 data.set(key, value);
					 this.size += data.size == size2 ? 0 : 1;
					 return this;
				  }
				  MapCache.prototype.clear = mapCacheClear;
				  MapCache.prototype["delete"] = mapCacheDelete;
				  MapCache.prototype.get = mapCacheGet;
				  MapCache.prototype.has = mapCacheHas;
				  MapCache.prototype.set = mapCacheSet;
				  function SetCache(values2) {
					 var index = -1, length = values2 == null ? 0 : values2.length;
					 this.__data__ = new MapCache();
					 while (++index < length) {
						this.add(values2[index]);
					 }
				  }
				  function setCacheAdd(value) {
					 this.__data__.set(value, HASH_UNDEFINED);
					 return this;
				  }
				  function setCacheHas(value) {
					 return this.__data__.has(value);
				  }
				  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
				  SetCache.prototype.has = setCacheHas;
				  function Stack(entries) {
					 var data = this.__data__ = new ListCache(entries);
					 this.size = data.size;
				  }
				  function stackClear() {
					 this.__data__ = new ListCache();
					 this.size = 0;
				  }
				  function stackDelete(key) {
					 var data = this.__data__, result2 = data["delete"](key);
					 this.size = data.size;
					 return result2;
				  }
				  function stackGet(key) {
					 return this.__data__.get(key);
				  }
				  function stackHas(key) {
					 return this.__data__.has(key);
				  }
				  function stackSet(key, value) {
					 var data = this.__data__;
					 if (data instanceof ListCache) {
						var pairs = data.__data__;
						if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
						  pairs.push([key, value]);
						  this.size = ++data.size;
						  return this;
						}
						data = this.__data__ = new MapCache(pairs);
					 }
					 data.set(key, value);
					 this.size = data.size;
					 return this;
				  }
				  Stack.prototype.clear = stackClear;
				  Stack.prototype["delete"] = stackDelete;
				  Stack.prototype.get = stackGet;
				  Stack.prototype.has = stackHas;
				  Stack.prototype.set = stackSet;
				  function arrayLikeKeys(value, inherited) {
					 var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType2 = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType2, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
					 for (var key in value) {
						if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
						(key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
						isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
						isType2 && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
						isIndex(key, length)))) {
						  result2.push(key);
						}
					 }
					 return result2;
				  }
				  function arraySample(array2) {
					 var length = array2.length;
					 return length ? array2[baseRandom(0, length - 1)] : undefined2;
				  }
				  function arraySampleSize(array2, n) {
					 return shuffleSelf(copyArray(array2), baseClamp(n, 0, array2.length));
				  }
				  function arrayShuffle(array2) {
					 return shuffleSelf(copyArray(array2));
				  }
				  function assignMergeValue(object, key, value) {
					 if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
						baseAssignValue(object, key, value);
					 }
				  }
				  function assignValue(object, key, value) {
					 var objValue = object[key];
					 if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
						baseAssignValue(object, key, value);
					 }
				  }
				  function assocIndexOf(array2, key) {
					 var length = array2.length;
					 while (length--) {
						if (eq(array2[length][0], key)) {
						  return length;
						}
					 }
					 return -1;
				  }
				  function baseAggregator(collection, setter, iteratee2, accumulator) {
					 baseEach(collection, function(value, key, collection2) {
						setter(accumulator, value, iteratee2(value), collection2);
					 });
					 return accumulator;
				  }
				  function baseAssign(object, source) {
					 return object && copyObject(source, keys(source), object);
				  }
				  function baseAssignIn(object, source) {
					 return object && copyObject(source, keysIn(source), object);
				  }
				  function baseAssignValue(object, key, value) {
					 if (key == "__proto__" && defineProperty) {
						defineProperty(object, key, {
						  "configurable": true,
						  "enumerable": true,
						  "value": value,
						  "writable": true
						});
					 } else {
						object[key] = value;
					 }
				  }
				  function baseAt(object, paths) {
					 var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
					 while (++index < length) {
						result2[index] = skip ? undefined2 : get4(object, paths[index]);
					 }
					 return result2;
				  }
				  function baseClamp(number5, lower2, upper) {
					 if (number5 === number5) {
						if (upper !== undefined2) {
						  number5 = number5 <= upper ? number5 : upper;
						}
						if (lower2 !== undefined2) {
						  number5 = number5 >= lower2 ? number5 : lower2;
						}
					 }
					 return number5;
				  }
				  function baseClone(value, bitmask, customizer, key, object, stack) {
					 var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
					 if (customizer) {
						result2 = object ? customizer(value, key, object, stack) : customizer(value);
					 }
					 if (result2 !== undefined2) {
						return result2;
					 }
					 if (!isObject2(value)) {
						return value;
					 }
					 var isArr = isArray2(value);
					 if (isArr) {
						result2 = initCloneArray(value);
						if (!isDeep) {
						  return copyArray(value, result2);
						}
					 } else {
						var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
						if (isBuffer(value)) {
						  return cloneBuffer(value, isDeep);
						}
						if (tag == objectTag || tag == argsTag || isFunc && !object) {
						  result2 = isFlat || isFunc ? {} : initCloneObject(value);
						  if (!isDeep) {
							 return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
						  }
						} else {
						  if (!cloneableTags[tag]) {
							 return object ? value : {};
						  }
						  result2 = initCloneByTag(value, tag, isDeep);
						}
					 }
					 stack || (stack = new Stack());
					 var stacked = stack.get(value);
					 if (stacked) {
						return stacked;
					 }
					 stack.set(value, result2);
					 if (isSet(value)) {
						value.forEach(function(subValue) {
						  result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
						});
					 } else if (isMap(value)) {
						value.forEach(function(subValue, key2) {
						  result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
						});
					 }
					 var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
					 var props = isArr ? undefined2 : keysFunc(value);
					 arrayEach(props || value, function(subValue, key2) {
						if (props) {
						  key2 = subValue;
						  subValue = value[key2];
						}
						assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
					 });
					 return result2;
				  }
				  function baseConforms(source) {
					 var props = keys(source);
					 return function(object) {
						return baseConformsTo(object, source, props);
					 };
				  }
				  function baseConformsTo(object, source, props) {
					 var length = props.length;
					 if (object == null) {
						return !length;
					 }
					 object = Object2(object);
					 while (length--) {
						var key = props[length], predicate = source[key], value = object[key];
						if (value === undefined2 && !(key in object) || !predicate(value)) {
						  return false;
						}
					 }
					 return true;
				  }
				  function baseDelay(func, wait, args) {
					 if (typeof func != "function") {
						throw new TypeError2(FUNC_ERROR_TEXT);
					 }
					 return setTimeout2(function() {
						func.apply(undefined2, args);
					 }, wait);
				  }
				  function baseDifference(array2, values2, iteratee2, comparator) {
					 var index = -1, includes3 = arrayIncludes, isCommon = true, length = array2.length, result2 = [], valuesLength = values2.length;
					 if (!length) {
						return result2;
					 }
					 if (iteratee2) {
						values2 = arrayMap(values2, baseUnary(iteratee2));
					 }
					 if (comparator) {
						includes3 = arrayIncludesWith;
						isCommon = false;
					 } else if (values2.length >= LARGE_ARRAY_SIZE) {
						includes3 = cacheHas;
						isCommon = false;
						values2 = new SetCache(values2);
					 }
					 outer:
						while (++index < length) {
						  var value = array2[index], computed = iteratee2 == null ? value : iteratee2(value);
						  value = comparator || value !== 0 ? value : 0;
						  if (isCommon && computed === computed) {
							 var valuesIndex = valuesLength;
							 while (valuesIndex--) {
								if (values2[valuesIndex] === computed) {
								  continue outer;
								}
							 }
							 result2.push(value);
						  } else if (!includes3(values2, computed, comparator)) {
							 result2.push(value);
						  }
						}
					 return result2;
				  }
				  var baseEach = createBaseEach(baseForOwn);
				  var baseEachRight = createBaseEach(baseForOwnRight, true);
				  function baseEvery(collection, predicate) {
					 var result2 = true;
					 baseEach(collection, function(value, index, collection2) {
						result2 = !!predicate(value, index, collection2);
						return result2;
					 });
					 return result2;
				  }
				  function baseExtremum(array2, iteratee2, comparator) {
					 var index = -1, length = array2.length;
					 while (++index < length) {
						var value = array2[index], current = iteratee2(value);
						if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
						  var computed = current, result2 = value;
						}
					 }
					 return result2;
				  }
				  function baseFill(array2, value, start2, end) {
					 var length = array2.length;
					 start2 = toInteger(start2);
					 if (start2 < 0) {
						start2 = -start2 > length ? 0 : length + start2;
					 }
					 end = end === undefined2 || end > length ? length : toInteger(end);
					 if (end < 0) {
						end += length;
					 }
					 end = start2 > end ? 0 : toLength(end);
					 while (start2 < end) {
						array2[start2++] = value;
					 }
					 return array2;
				  }
				  function baseFilter(collection, predicate) {
					 var result2 = [];
					 baseEach(collection, function(value, index, collection2) {
						if (predicate(value, index, collection2)) {
						  result2.push(value);
						}
					 });
					 return result2;
				  }
				  function baseFlatten(array2, depth, predicate, isStrict, result2) {
					 var index = -1, length = array2.length;
					 predicate || (predicate = isFlattenable);
					 result2 || (result2 = []);
					 while (++index < length) {
						var value = array2[index];
						if (depth > 0 && predicate(value)) {
						  if (depth > 1) {
							 baseFlatten(value, depth - 1, predicate, isStrict, result2);
						  } else {
							 arrayPush(result2, value);
						  }
						} else if (!isStrict) {
						  result2[result2.length] = value;
						}
					 }
					 return result2;
				  }
				  var baseFor = createBaseFor();
				  var baseForRight = createBaseFor(true);
				  function baseForOwn(object, iteratee2) {
					 return object && baseFor(object, iteratee2, keys);
				  }
				  function baseForOwnRight(object, iteratee2) {
					 return object && baseForRight(object, iteratee2, keys);
				  }
				  function baseFunctions(object, props) {
					 return arrayFilter(props, function(key) {
						return isFunction5(object[key]);
					 });
				  }
				  function baseGet(object, path) {
					 path = castPath(path, object);
					 var index = 0, length = path.length;
					 while (object != null && index < length) {
						object = object[toKey(path[index++])];
					 }
					 return index && index == length ? object : undefined2;
				  }
				  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
					 var result2 = keysFunc(object);
					 return isArray2(object) ? result2 : arrayPush(result2, symbolsFunc(object));
				  }
				  function baseGetTag(value) {
					 if (value == null) {
						return value === undefined2 ? undefinedTag : nullTag;
					 }
					 return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
				  }
				  function baseGt(value, other) {
					 return value > other;
				  }
				  function baseHas(object, key) {
					 return object != null && hasOwnProperty.call(object, key);
				  }
				  function baseHasIn(object, key) {
					 return object != null && key in Object2(object);
				  }
				  function baseInRange(number5, start2, end) {
					 return number5 >= nativeMin(start2, end) && number5 < nativeMax(start2, end);
				  }
				  function baseIntersection(arrays, iteratee2, comparator) {
					 var includes3 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
					 while (othIndex--) {
						var array2 = arrays[othIndex];
						if (othIndex && iteratee2) {
						  array2 = arrayMap(array2, baseUnary(iteratee2));
						}
						maxLength = nativeMin(array2.length, maxLength);
						caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array2.length >= 120) ? new SetCache(othIndex && array2) : undefined2;
					 }
					 array2 = arrays[0];
					 var index = -1, seen = caches[0];
					 outer:
						while (++index < length && result2.length < maxLength) {
						  var value = array2[index], computed = iteratee2 ? iteratee2(value) : value;
						  value = comparator || value !== 0 ? value : 0;
						  if (!(seen ? cacheHas(seen, computed) : includes3(result2, computed, comparator))) {
							 othIndex = othLength;
							 while (--othIndex) {
								var cache = caches[othIndex];
								if (!(cache ? cacheHas(cache, computed) : includes3(arrays[othIndex], computed, comparator))) {
								  continue outer;
								}
							 }
							 if (seen) {
								seen.push(computed);
							 }
							 result2.push(value);
						  }
						}
					 return result2;
				  }
				  function baseInverter(object, setter, iteratee2, accumulator) {
					 baseForOwn(object, function(value, key, object2) {
						setter(accumulator, iteratee2(value), key, object2);
					 });
					 return accumulator;
				  }
				  function baseInvoke(object, path, args) {
					 path = castPath(path, object);
					 object = parent(object, path);
					 var func = object == null ? object : object[toKey(last2(path))];
					 return func == null ? undefined2 : apply(func, object, args);
				  }
				  function baseIsArguments(value) {
					 return isObjectLike(value) && baseGetTag(value) == argsTag;
				  }
				  function baseIsArrayBuffer(value) {
					 return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
				  }
				  function baseIsDate(value) {
					 return isObjectLike(value) && baseGetTag(value) == dateTag;
				  }
				  function baseIsEqual(value, other, bitmask, customizer, stack) {
					 if (value === other) {
						return true;
					 }
					 if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
						return value !== value && other !== other;
					 }
					 return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
				  }
				  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
					 var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
					 objTag = objTag == argsTag ? objectTag : objTag;
					 othTag = othTag == argsTag ? objectTag : othTag;
					 var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
					 if (isSameTag && isBuffer(object)) {
						if (!isBuffer(other)) {
						  return false;
						}
						objIsArr = true;
						objIsObj = false;
					 }
					 if (isSameTag && !objIsObj) {
						stack || (stack = new Stack());
						return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
					 }
					 if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
						var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
						if (objIsWrapped || othIsWrapped) {
						  var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
						  stack || (stack = new Stack());
						  return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
						}
					 }
					 if (!isSameTag) {
						return false;
					 }
					 stack || (stack = new Stack());
					 return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
				  }
				  function baseIsMap(value) {
					 return isObjectLike(value) && getTag(value) == mapTag;
				  }
				  function baseIsMatch(object, source, matchData, customizer) {
					 var index = matchData.length, length = index, noCustomizer = !customizer;
					 if (object == null) {
						return !length;
					 }
					 object = Object2(object);
					 while (index--) {
						var data = matchData[index];
						if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
						  return false;
						}
					 }
					 while (++index < length) {
						data = matchData[index];
						var key = data[0], objValue = object[key], srcValue = data[1];
						if (noCustomizer && data[2]) {
						  if (objValue === undefined2 && !(key in object)) {
							 return false;
						  }
						} else {
						  var stack = new Stack();
						  if (customizer) {
							 var result2 = customizer(objValue, srcValue, key, object, source, stack);
						  }
						  if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
							 return false;
						  }
						}
					 }
					 return true;
				  }
				  function baseIsNative(value) {
					 if (!isObject2(value) || isMasked(value)) {
						return false;
					 }
					 var pattern = isFunction5(value) ? reIsNative : reIsHostCtor;
					 return pattern.test(toSource(value));
				  }
				  function baseIsRegExp(value) {
					 return isObjectLike(value) && baseGetTag(value) == regexpTag;
				  }
				  function baseIsSet(value) {
					 return isObjectLike(value) && getTag(value) == setTag;
				  }
				  function baseIsTypedArray(value) {
					 return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
				  }
				  function baseIteratee(value) {
					 if (typeof value == "function") {
						return value;
					 }
					 if (value == null) {
						return identity5;
					 }
					 if (typeof value == "object") {
						return isArray2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
					 }
					 return property(value);
				  }
				  function baseKeys(object) {
					 if (!isPrototype(object)) {
						return nativeKeys(object);
					 }
					 var result2 = [];
					 for (var key in Object2(object)) {
						if (hasOwnProperty.call(object, key) && key != "constructor") {
						  result2.push(key);
						}
					 }
					 return result2;
				  }
				  function baseKeysIn(object) {
					 if (!isObject2(object)) {
						return nativeKeysIn(object);
					 }
					 var isProto = isPrototype(object), result2 = [];
					 for (var key in object) {
						if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
						  result2.push(key);
						}
					 }
					 return result2;
				  }
				  function baseLt(value, other) {
					 return value < other;
				  }
				  function baseMap(collection, iteratee2) {
					 var index = -1, result2 = isArrayLike2(collection) ? Array2(collection.length) : [];
					 baseEach(collection, function(value, key, collection2) {
						result2[++index] = iteratee2(value, key, collection2);
					 });
					 return result2;
				  }
				  function baseMatches(source) {
					 var matchData = getMatchData(source);
					 if (matchData.length == 1 && matchData[0][2]) {
						return matchesStrictComparable(matchData[0][0], matchData[0][1]);
					 }
					 return function(object) {
						return object === source || baseIsMatch(object, source, matchData);
					 };
				  }
				  function baseMatchesProperty(path, srcValue) {
					 if (isKey(path) && isStrictComparable(srcValue)) {
						return matchesStrictComparable(toKey(path), srcValue);
					 }
					 return function(object) {
						var objValue = get4(object, path);
						return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
					 };
				  }
				  function baseMerge(object, source, srcIndex, customizer, stack) {
					 if (object === source) {
						return;
					 }
					 baseFor(source, function(srcValue, key) {
						stack || (stack = new Stack());
						if (isObject2(srcValue)) {
						  baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
						} else {
						  var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
						  if (newValue === undefined2) {
							 newValue = srcValue;
						  }
						  assignMergeValue(object, key, newValue);
						}
					 }, keysIn);
				  }
				  function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
					 var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
					 if (stacked) {
						assignMergeValue(object, key, stacked);
						return;
					 }
					 var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
					 var isCommon = newValue === undefined2;
					 if (isCommon) {
						var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
						newValue = srcValue;
						if (isArr || isBuff || isTyped) {
						  if (isArray2(objValue)) {
							 newValue = objValue;
						  } else if (isArrayLikeObject(objValue)) {
							 newValue = copyArray(objValue);
						  } else if (isBuff) {
							 isCommon = false;
							 newValue = cloneBuffer(srcValue, true);
						  } else if (isTyped) {
							 isCommon = false;
							 newValue = cloneTypedArray(srcValue, true);
						  } else {
							 newValue = [];
						  }
						} else if (isPlainObject(srcValue) || isArguments(srcValue)) {
						  newValue = objValue;
						  if (isArguments(objValue)) {
							 newValue = toPlainObject(objValue);
						  } else if (!isObject2(objValue) || isFunction5(objValue)) {
							 newValue = initCloneObject(srcValue);
						  }
						} else {
						  isCommon = false;
						}
					 }
					 if (isCommon) {
						stack.set(srcValue, newValue);
						mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
						stack["delete"](srcValue);
					 }
					 assignMergeValue(object, key, newValue);
				  }
				  function baseNth(array2, n) {
					 var length = array2.length;
					 if (!length) {
						return;
					 }
					 n += n < 0 ? length : 0;
					 return isIndex(n, length) ? array2[n] : undefined2;
				  }
				  function baseOrderBy(collection, iteratees, orders) {
					 if (iteratees.length) {
						iteratees = arrayMap(iteratees, function(iteratee2) {
						  if (isArray2(iteratee2)) {
							 return function(value) {
								return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
							 };
						  }
						  return iteratee2;
						});
					 } else {
						iteratees = [identity5];
					 }
					 var index = -1;
					 iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
					 var result2 = baseMap(collection, function(value, key, collection2) {
						var criteria = arrayMap(iteratees, function(iteratee2) {
						  return iteratee2(value);
						});
						return { "criteria": criteria, "index": ++index, "value": value };
					 });
					 return baseSortBy(result2, function(object, other) {
						return compareMultiple(object, other, orders);
					 });
				  }
				  function basePick(object, paths) {
					 return basePickBy(object, paths, function(value, path) {
						return hasIn(object, path);
					 });
				  }
				  function basePickBy(object, paths, predicate) {
					 var index = -1, length = paths.length, result2 = {};
					 while (++index < length) {
						var path = paths[index], value = baseGet(object, path);
						if (predicate(value, path)) {
						  baseSet(result2, castPath(path, object), value);
						}
					 }
					 return result2;
				  }
				  function basePropertyDeep(path) {
					 return function(object) {
						return baseGet(object, path);
					 };
				  }
				  function basePullAll(array2, values2, iteratee2, comparator) {
					 var indexOf3 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array2;
					 if (array2 === values2) {
						values2 = copyArray(values2);
					 }
					 if (iteratee2) {
						seen = arrayMap(array2, baseUnary(iteratee2));
					 }
					 while (++index < length) {
						var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
						while ((fromIndex = indexOf3(seen, computed, fromIndex, comparator)) > -1) {
						  if (seen !== array2) {
							 splice.call(seen, fromIndex, 1);
						  }
						  splice.call(array2, fromIndex, 1);
						}
					 }
					 return array2;
				  }
				  function basePullAt(array2, indexes) {
					 var length = array2 ? indexes.length : 0, lastIndex = length - 1;
					 while (length--) {
						var index = indexes[length];
						if (length == lastIndex || index !== previous) {
						  var previous = index;
						  if (isIndex(index)) {
							 splice.call(array2, index, 1);
						  } else {
							 baseUnset(array2, index);
						  }
						}
					 }
					 return array2;
				  }
				  function baseRandom(lower2, upper) {
					 return lower2 + nativeFloor(nativeRandom() * (upper - lower2 + 1));
				  }
				  function baseRange(start2, end, step, fromRight) {
					 var index = -1, length = nativeMax(nativeCeil((end - start2) / (step || 1)), 0), result2 = Array2(length);
					 while (length--) {
						result2[fromRight ? length : ++index] = start2;
						start2 += step;
					 }
					 return result2;
				  }
				  function baseRepeat(string, n) {
					 var result2 = "";
					 if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
						return result2;
					 }
					 do {
						if (n % 2) {
						  result2 += string;
						}
						n = nativeFloor(n / 2);
						if (n) {
						  string += string;
						}
					 } while (n);
					 return result2;
				  }
				  function baseRest(func, start2) {
					 return setToString(overRest(func, start2, identity5), func + "");
				  }
				  function baseSample(collection) {
					 return arraySample(values(collection));
				  }
				  function baseSampleSize(collection, n) {
					 var array2 = values(collection);
					 return shuffleSelf(array2, baseClamp(n, 0, array2.length));
				  }
				  function baseSet(object, path, value, customizer) {
					 if (!isObject2(object)) {
						return object;
					 }
					 path = castPath(path, object);
					 var index = -1, length = path.length, lastIndex = length - 1, nested = object;
					 while (nested != null && ++index < length) {
						var key = toKey(path[index]), newValue = value;
						if (key === "__proto__" || key === "constructor" || key === "prototype") {
						  return object;
						}
						if (index != lastIndex) {
						  var objValue = nested[key];
						  newValue = customizer ? customizer(objValue, key, nested) : undefined2;
						  if (newValue === undefined2) {
							 newValue = isObject2(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
						  }
						}
						assignValue(nested, key, newValue);
						nested = nested[key];
					 }
					 return object;
				  }
				  var baseSetData = !metaMap ? identity5 : function(func, data) {
					 metaMap.set(func, data);
					 return func;
				  };
				  var baseSetToString = !defineProperty ? identity5 : function(func, string) {
					 return defineProperty(func, "toString", {
						"configurable": true,
						"enumerable": false,
						"value": constant(string),
						"writable": true
					 });
				  };
				  function baseShuffle(collection) {
					 return shuffleSelf(values(collection));
				  }
				  function baseSlice(array2, start2, end) {
					 var index = -1, length = array2.length;
					 if (start2 < 0) {
						start2 = -start2 > length ? 0 : length + start2;
					 }
					 end = end > length ? length : end;
					 if (end < 0) {
						end += length;
					 }
					 length = start2 > end ? 0 : end - start2 >>> 0;
					 start2 >>>= 0;
					 var result2 = Array2(length);
					 while (++index < length) {
						result2[index] = array2[index + start2];
					 }
					 return result2;
				  }
				  function baseSome(collection, predicate) {
					 var result2;
					 baseEach(collection, function(value, index, collection2) {
						result2 = predicate(value, index, collection2);
						return !result2;
					 });
					 return !!result2;
				  }
				  function baseSortedIndex(array2, value, retHighest) {
					 var low = 0, high = array2 == null ? low : array2.length;
					 if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
						while (low < high) {
						  var mid = low + high >>> 1, computed = array2[mid];
						  if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
							 low = mid + 1;
						  } else {
							 high = mid;
						  }
						}
						return high;
					 }
					 return baseSortedIndexBy(array2, value, identity5, retHighest);
				  }
				  function baseSortedIndexBy(array2, value, iteratee2, retHighest) {
					 var low = 0, high = array2 == null ? 0 : array2.length;
					 if (high === 0) {
						return 0;
					 }
					 value = iteratee2(value);
					 var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
					 while (low < high) {
						var mid = nativeFloor((low + high) / 2), computed = iteratee2(array2[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
						if (valIsNaN) {
						  var setLow = retHighest || othIsReflexive;
						} else if (valIsUndefined) {
						  setLow = othIsReflexive && (retHighest || othIsDefined);
						} else if (valIsNull) {
						  setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
						} else if (valIsSymbol) {
						  setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
						} else if (othIsNull || othIsSymbol) {
						  setLow = false;
						} else {
						  setLow = retHighest ? computed <= value : computed < value;
						}
						if (setLow) {
						  low = mid + 1;
						} else {
						  high = mid;
						}
					 }
					 return nativeMin(high, MAX_ARRAY_INDEX);
				  }
				  function baseSortedUniq(array2, iteratee2) {
					 var index = -1, length = array2.length, resIndex = 0, result2 = [];
					 while (++index < length) {
						var value = array2[index], computed = iteratee2 ? iteratee2(value) : value;
						if (!index || !eq(computed, seen)) {
						  var seen = computed;
						  result2[resIndex++] = value === 0 ? 0 : value;
						}
					 }
					 return result2;
				  }
				  function baseToNumber(value) {
					 if (typeof value == "number") {
						return value;
					 }
					 if (isSymbol(value)) {
						return NAN;
					 }
					 return +value;
				  }
				  function baseToString(value) {
					 if (typeof value == "string") {
						return value;
					 }
					 if (isArray2(value)) {
						return arrayMap(value, baseToString) + "";
					 }
					 if (isSymbol(value)) {
						return symbolToString ? symbolToString.call(value) : "";
					 }
					 var result2 = value + "";
					 return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
				  }
				  function baseUniq(array2, iteratee2, comparator) {
					 var index = -1, includes3 = arrayIncludes, length = array2.length, isCommon = true, result2 = [], seen = result2;
					 if (comparator) {
						isCommon = false;
						includes3 = arrayIncludesWith;
					 } else if (length >= LARGE_ARRAY_SIZE) {
						var set4 = iteratee2 ? null : createSet(array2);
						if (set4) {
						  return setToArray(set4);
						}
						isCommon = false;
						includes3 = cacheHas;
						seen = new SetCache();
					 } else {
						seen = iteratee2 ? [] : result2;
					 }
					 outer:
						while (++index < length) {
						  var value = array2[index], computed = iteratee2 ? iteratee2(value) : value;
						  value = comparator || value !== 0 ? value : 0;
						  if (isCommon && computed === computed) {
							 var seenIndex = seen.length;
							 while (seenIndex--) {
								if (seen[seenIndex] === computed) {
								  continue outer;
								}
							 }
							 if (iteratee2) {
								seen.push(computed);
							 }
							 result2.push(value);
						  } else if (!includes3(seen, computed, comparator)) {
							 if (seen !== result2) {
								seen.push(computed);
							 }
							 result2.push(value);
						  }
						}
					 return result2;
				  }
				  function baseUnset(object, path) {
					 path = castPath(path, object);
					 object = parent(object, path);
					 return object == null || delete object[toKey(last2(path))];
				  }
				  function baseUpdate(object, path, updater, customizer) {
					 return baseSet(object, path, updater(baseGet(object, path)), customizer);
				  }
				  function baseWhile(array2, predicate, isDrop, fromRight) {
					 var length = array2.length, index = fromRight ? length : -1;
					 while ((fromRight ? index-- : ++index < length) && predicate(array2[index], index, array2)) {
					 }
					 return isDrop ? baseSlice(array2, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array2, fromRight ? index + 1 : 0, fromRight ? length : index);
				  }
				  function baseWrapperValue(value, actions) {
					 var result2 = value;
					 if (result2 instanceof LazyWrapper) {
						result2 = result2.value();
					 }
					 return arrayReduce(actions, function(result3, action) {
						return action.func.apply(action.thisArg, arrayPush([result3], action.args));
					 }, result2);
				  }
				  function baseXor(arrays, iteratee2, comparator) {
					 var length = arrays.length;
					 if (length < 2) {
						return length ? baseUniq(arrays[0]) : [];
					 }
					 var index = -1, result2 = Array2(length);
					 while (++index < length) {
						var array2 = arrays[index], othIndex = -1;
						while (++othIndex < length) {
						  if (othIndex != index) {
							 result2[index] = baseDifference(result2[index] || array2, arrays[othIndex], iteratee2, comparator);
						  }
						}
					 }
					 return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
				  }
				  function baseZipObject(props, values2, assignFunc) {
					 var index = -1, length = props.length, valsLength = values2.length, result2 = {};
					 while (++index < length) {
						var value = index < valsLength ? values2[index] : undefined2;
						assignFunc(result2, props[index], value);
					 }
					 return result2;
				  }
				  function castArrayLikeObject(value) {
					 return isArrayLikeObject(value) ? value : [];
				  }
				  function castFunction(value) {
					 return typeof value == "function" ? value : identity5;
				  }
				  function castPath(value, object) {
					 if (isArray2(value)) {
						return value;
					 }
					 return isKey(value, object) ? [value] : stringToPath(toString(value));
				  }
				  var castRest = baseRest;
				  function castSlice(array2, start2, end) {
					 var length = array2.length;
					 end = end === undefined2 ? length : end;
					 return !start2 && end >= length ? array2 : baseSlice(array2, start2, end);
				  }
				  var clearTimeout2 = ctxClearTimeout || function(id3) {
					 return root2.clearTimeout(id3);
				  };
				  function cloneBuffer(buffer, isDeep) {
					 if (isDeep) {
						return buffer.slice();
					 }
					 var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
					 buffer.copy(result2);
					 return result2;
				  }
				  function cloneArrayBuffer(arrayBuffer) {
					 var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
					 new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
					 return result2;
				  }
				  function cloneDataView(dataView, isDeep) {
					 var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
					 return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
				  }
				  function cloneRegExp(regexp) {
					 var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
					 result2.lastIndex = regexp.lastIndex;
					 return result2;
				  }
				  function cloneSymbol(symbol) {
					 return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
				  }
				  function cloneTypedArray(typedArray, isDeep) {
					 var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
					 return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
				  }
				  function compareAscending(value, other) {
					 if (value !== other) {
						var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
						var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
						if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
						  return 1;
						}
						if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
						  return -1;
						}
					 }
					 return 0;
				  }
				  function compareMultiple(object, other, orders) {
					 var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
					 while (++index < length) {
						var result2 = compareAscending(objCriteria[index], othCriteria[index]);
						if (result2) {
						  if (index >= ordersLength) {
							 return result2;
						  }
						  var order = orders[index];
						  return result2 * (order == "desc" ? -1 : 1);
						}
					 }
					 return object.index - other.index;
				  }
				  function composeArgs(args, partials, holders, isCurried) {
					 var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
					 while (++leftIndex < leftLength) {
						result2[leftIndex] = partials[leftIndex];
					 }
					 while (++argsIndex < holdersLength) {
						if (isUncurried || argsIndex < argsLength) {
						  result2[holders[argsIndex]] = args[argsIndex];
						}
					 }
					 while (rangeLength--) {
						result2[leftIndex++] = args[argsIndex++];
					 }
					 return result2;
				  }
				  function composeArgsRight(args, partials, holders, isCurried) {
					 var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
					 while (++argsIndex < rangeLength) {
						result2[argsIndex] = args[argsIndex];
					 }
					 var offset = argsIndex;
					 while (++rightIndex < rightLength) {
						result2[offset + rightIndex] = partials[rightIndex];
					 }
					 while (++holdersIndex < holdersLength) {
						if (isUncurried || argsIndex < argsLength) {
						  result2[offset + holders[holdersIndex]] = args[argsIndex++];
						}
					 }
					 return result2;
				  }
				  function copyArray(source, array2) {
					 var index = -1, length = source.length;
					 array2 || (array2 = Array2(length));
					 while (++index < length) {
						array2[index] = source[index];
					 }
					 return array2;
				  }
				  function copyObject(source, props, object, customizer) {
					 var isNew = !object;
					 object || (object = {});
					 var index = -1, length = props.length;
					 while (++index < length) {
						var key = props[index];
						var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
						if (newValue === undefined2) {
						  newValue = source[key];
						}
						if (isNew) {
						  baseAssignValue(object, key, newValue);
						} else {
						  assignValue(object, key, newValue);
						}
					 }
					 return object;
				  }
				  function copySymbols(source, object) {
					 return copyObject(source, getSymbols(source), object);
				  }
				  function copySymbolsIn(source, object) {
					 return copyObject(source, getSymbolsIn(source), object);
				  }
				  function createAggregator(setter, initializer) {
					 return function(collection, iteratee2) {
						var func = isArray2(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
						return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
					 };
				  }
				  function createAssigner(assigner) {
					 return baseRest(function(object, sources) {
						var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
						customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
						if (guard && isIterateeCall(sources[0], sources[1], guard)) {
						  customizer = length < 3 ? undefined2 : customizer;
						  length = 1;
						}
						object = Object2(object);
						while (++index < length) {
						  var source = sources[index];
						  if (source) {
							 assigner(object, source, index, customizer);
						  }
						}
						return object;
					 });
				  }
				  function createBaseEach(eachFunc, fromRight) {
					 return function(collection, iteratee2) {
						if (collection == null) {
						  return collection;
						}
						if (!isArrayLike2(collection)) {
						  return eachFunc(collection, iteratee2);
						}
						var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
						while (fromRight ? index-- : ++index < length) {
						  if (iteratee2(iterable[index], index, iterable) === false) {
							 break;
						  }
						}
						return collection;
					 };
				  }
				  function createBaseFor(fromRight) {
					 return function(object, iteratee2, keysFunc) {
						var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
						while (length--) {
						  var key = props[fromRight ? length : ++index];
						  if (iteratee2(iterable[key], key, iterable) === false) {
							 break;
						  }
						}
						return object;
					 };
				  }
				  function createBind(func, bitmask, thisArg) {
					 var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
					 function wrapper() {
						var fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
						return fn.apply(isBind ? thisArg : this, arguments);
					 }
					 return wrapper;
				  }
				  function createCaseFirst(methodName) {
					 return function(string) {
						string = toString(string);
						var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
						var chr = strSymbols ? strSymbols[0] : string.charAt(0);
						var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
						return chr[methodName]() + trailing;
					 };
				  }
				  function createCompounder(callback) {
					 return function(string) {
						return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
					 };
				  }
				  function createCtor(Ctor) {
					 return function() {
						var args = arguments;
						switch (args.length) {
						  case 0:
							 return new Ctor();
						  case 1:
							 return new Ctor(args[0]);
						  case 2:
							 return new Ctor(args[0], args[1]);
						  case 3:
							 return new Ctor(args[0], args[1], args[2]);
						  case 4:
							 return new Ctor(args[0], args[1], args[2], args[3]);
						  case 5:
							 return new Ctor(args[0], args[1], args[2], args[3], args[4]);
						  case 6:
							 return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
						  case 7:
							 return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
						}
						var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
						return isObject2(result2) ? result2 : thisBinding;
					 };
				  }
				  function createCurry(func, bitmask, arity) {
					 var Ctor = createCtor(func);
					 function wrapper() {
						var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
						while (index--) {
						  args[index] = arguments[index];
						}
						var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
						length -= holders.length;
						if (length < arity) {
						  return createRecurry(
							 func,
							 bitmask,
							 createHybrid,
							 wrapper.placeholder,
							 undefined2,
							 args,
							 holders,
							 undefined2,
							 undefined2,
							 arity - length
						  );
						}
						var fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
						return apply(fn, this, args);
					 }
					 return wrapper;
				  }
				  function createFind(findIndexFunc) {
					 return function(collection, predicate, fromIndex) {
						var iterable = Object2(collection);
						if (!isArrayLike2(collection)) {
						  var iteratee2 = getIteratee(predicate, 3);
						  collection = keys(collection);
						  predicate = function(key) {
							 return iteratee2(iterable[key], key, iterable);
						  };
						}
						var index = findIndexFunc(collection, predicate, fromIndex);
						return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
					 };
				  }
				  function createFlow(fromRight) {
					 return flatRest(function(funcs) {
						var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
						if (fromRight) {
						  funcs.reverse();
						}
						while (index--) {
						  var func = funcs[index];
						  if (typeof func != "function") {
							 throw new TypeError2(FUNC_ERROR_TEXT);
						  }
						  if (prereq && !wrapper && getFuncName(func) == "wrapper") {
							 var wrapper = new LodashWrapper([], true);
						  }
						}
						index = wrapper ? index : length;
						while (++index < length) {
						  func = funcs[index];
						  var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
						  if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
							 wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
						  } else {
							 wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
						  }
						}
						return function() {
						  var args = arguments, value = args[0];
						  if (wrapper && args.length == 1 && isArray2(value)) {
							 return wrapper.plant(value).value();
						  }
						  var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
						  while (++index2 < length) {
							 result2 = funcs[index2].call(this, result2);
						  }
						  return result2;
						};
					 });
				  }
				  function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
					 var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
					 function wrapper() {
						var length = arguments.length, args = Array2(length), index = length;
						while (index--) {
						  args[index] = arguments[index];
						}
						if (isCurried) {
						  var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
						}
						if (partials) {
						  args = composeArgs(args, partials, holders, isCurried);
						}
						if (partialsRight) {
						  args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
						}
						length -= holdersCount;
						if (isCurried && length < arity) {
						  var newHolders = replaceHolders(args, placeholder);
						  return createRecurry(
							 func,
							 bitmask,
							 createHybrid,
							 wrapper.placeholder,
							 thisArg,
							 args,
							 newHolders,
							 argPos,
							 ary2,
							 arity - length
						  );
						}
						var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
						length = args.length;
						if (argPos) {
						  args = reorder(args, argPos);
						} else if (isFlip && length > 1) {
						  args.reverse();
						}
						if (isAry && ary2 < length) {
						  args.length = ary2;
						}
						if (this && this !== root2 && this instanceof wrapper) {
						  fn = Ctor || createCtor(fn);
						}
						return fn.apply(thisBinding, args);
					 }
					 return wrapper;
				  }
				  function createInverter(setter, toIteratee) {
					 return function(object, iteratee2) {
						return baseInverter(object, setter, toIteratee(iteratee2), {});
					 };
				  }
				  function createMathOperation(operator, defaultValue) {
					 return function(value, other) {
						var result2;
						if (value === undefined2 && other === undefined2) {
						  return defaultValue;
						}
						if (value !== undefined2) {
						  result2 = value;
						}
						if (other !== undefined2) {
						  if (result2 === undefined2) {
							 return other;
						  }
						  if (typeof value == "string" || typeof other == "string") {
							 value = baseToString(value);
							 other = baseToString(other);
						  } else {
							 value = baseToNumber(value);
							 other = baseToNumber(other);
						  }
						  result2 = operator(value, other);
						}
						return result2;
					 };
				  }
				  function createOver(arrayFunc) {
					 return flatRest(function(iteratees) {
						iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
						return baseRest(function(args) {
						  var thisArg = this;
						  return arrayFunc(iteratees, function(iteratee2) {
							 return apply(iteratee2, thisArg, args);
						  });
						});
					 });
				  }
				  function createPadding(length, chars) {
					 chars = chars === undefined2 ? " " : baseToString(chars);
					 var charsLength = chars.length;
					 if (charsLength < 2) {
						return charsLength ? baseRepeat(chars, length) : chars;
					 }
					 var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
					 return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
				  }
				  function createPartial(func, bitmask, thisArg, partials) {
					 var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
					 function wrapper() {
						var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
						while (++leftIndex < leftLength) {
						  args[leftIndex] = partials[leftIndex];
						}
						while (argsLength--) {
						  args[leftIndex++] = arguments[++argsIndex];
						}
						return apply(fn, isBind ? thisArg : this, args);
					 }
					 return wrapper;
				  }
				  function createRange(fromRight) {
					 return function(start2, end, step) {
						if (step && typeof step != "number" && isIterateeCall(start2, end, step)) {
						  end = step = undefined2;
						}
						start2 = toFinite(start2);
						if (end === undefined2) {
						  end = start2;
						  start2 = 0;
						} else {
						  end = toFinite(end);
						}
						step = step === undefined2 ? start2 < end ? 1 : -1 : toFinite(step);
						return baseRange(start2, end, step, fromRight);
					 };
				  }
				  function createRelationalOperation(operator) {
					 return function(value, other) {
						if (!(typeof value == "string" && typeof other == "string")) {
						  value = toNumber2(value);
						  other = toNumber2(other);
						}
						return operator(value, other);
					 };
				  }
				  function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
					 var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
					 bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
					 bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
					 if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
						bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
					 }
					 var newData = [
						func,
						bitmask,
						thisArg,
						newPartials,
						newHolders,
						newPartialsRight,
						newHoldersRight,
						argPos,
						ary2,
						arity
					 ];
					 var result2 = wrapFunc.apply(undefined2, newData);
					 if (isLaziable(func)) {
						setData(result2, newData);
					 }
					 result2.placeholder = placeholder;
					 return setWrapToString(result2, func, bitmask);
				  }
				  function createRound(methodName) {
					 var func = Math2[methodName];
					 return function(number5, precision) {
						number5 = toNumber2(number5);
						precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
						if (precision && nativeIsFinite(number5)) {
						  var pair = (toString(number5) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
						  pair = (toString(value) + "e").split("e");
						  return +(pair[0] + "e" + (+pair[1] - precision));
						}
						return func(number5);
					 };
				  }
				  var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop5 : function(values2) {
					 return new Set2(values2);
				  };
				  function createToPairs(keysFunc) {
					 return function(object) {
						var tag = getTag(object);
						if (tag == mapTag) {
						  return mapToArray(object);
						}
						if (tag == setTag) {
						  return setToPairs(object);
						}
						return baseToPairs(object, keysFunc(object));
					 };
				  }
				  function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
					 var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
					 if (!isBindKey && typeof func != "function") {
						throw new TypeError2(FUNC_ERROR_TEXT);
					 }
					 var length = partials ? partials.length : 0;
					 if (!length) {
						bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
						partials = holders = undefined2;
					 }
					 ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
					 arity = arity === undefined2 ? arity : toInteger(arity);
					 length -= holders ? holders.length : 0;
					 if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
						var partialsRight = partials, holdersRight = holders;
						partials = holders = undefined2;
					 }
					 var data = isBindKey ? undefined2 : getData(func);
					 var newData = [
						func,
						bitmask,
						thisArg,
						partials,
						holders,
						partialsRight,
						holdersRight,
						argPos,
						ary2,
						arity
					 ];
					 if (data) {
						mergeData(newData, data);
					 }
					 func = newData[0];
					 bitmask = newData[1];
					 thisArg = newData[2];
					 partials = newData[3];
					 holders = newData[4];
					 arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
					 if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
						bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
					 }
					 if (!bitmask || bitmask == WRAP_BIND_FLAG) {
						var result2 = createBind(func, bitmask, thisArg);
					 } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
						result2 = createCurry(func, bitmask, arity);
					 } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
						result2 = createPartial(func, bitmask, thisArg, partials);
					 } else {
						result2 = createHybrid.apply(undefined2, newData);
					 }
					 var setter = data ? baseSetData : setData;
					 return setWrapToString(setter(result2, newData), func, bitmask);
				  }
				  function customDefaultsAssignIn(objValue, srcValue, key, object) {
					 if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
						return srcValue;
					 }
					 return objValue;
				  }
				  function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
					 if (isObject2(objValue) && isObject2(srcValue)) {
						stack.set(srcValue, objValue);
						baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
						stack["delete"](srcValue);
					 }
					 return objValue;
				  }
				  function customOmitClone(value) {
					 return isPlainObject(value) ? undefined2 : value;
				  }
				  function equalArrays(array2, other, bitmask, customizer, equalFunc, stack) {
					 var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array2.length, othLength = other.length;
					 if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
						return false;
					 }
					 var arrStacked = stack.get(array2);
					 var othStacked = stack.get(other);
					 if (arrStacked && othStacked) {
						return arrStacked == other && othStacked == array2;
					 }
					 var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
					 stack.set(array2, other);
					 stack.set(other, array2);
					 while (++index < arrLength) {
						var arrValue = array2[index], othValue = other[index];
						if (customizer) {
						  var compared = isPartial ? customizer(othValue, arrValue, index, other, array2, stack) : customizer(arrValue, othValue, index, array2, other, stack);
						}
						if (compared !== undefined2) {
						  if (compared) {
							 continue;
						  }
						  result2 = false;
						  break;
						}
						if (seen) {
						  if (!arraySome(other, function(othValue2, othIndex) {
							 if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
								return seen.push(othIndex);
							 }
						  })) {
							 result2 = false;
							 break;
						  }
						} else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
						  result2 = false;
						  break;
						}
					 }
					 stack["delete"](array2);
					 stack["delete"](other);
					 return result2;
				  }
				  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
					 switch (tag) {
						case dataViewTag:
						  if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
							 return false;
						  }
						  object = object.buffer;
						  other = other.buffer;
						case arrayBufferTag:
						  if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
							 return false;
						  }
						  return true;
						case boolTag:
						case dateTag:
						case numberTag:
						  return eq(+object, +other);
						case errorTag:
						  return object.name == other.name && object.message == other.message;
						case regexpTag:
						case stringTag:
						  return object == other + "";
						case mapTag:
						  var convert = mapToArray;
						case setTag:
						  var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
						  convert || (convert = setToArray);
						  if (object.size != other.size && !isPartial) {
							 return false;
						  }
						  var stacked = stack.get(object);
						  if (stacked) {
							 return stacked == other;
						  }
						  bitmask |= COMPARE_UNORDERED_FLAG;
						  stack.set(object, other);
						  var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
						  stack["delete"](object);
						  return result2;
						case symbolTag:
						  if (symbolValueOf) {
							 return symbolValueOf.call(object) == symbolValueOf.call(other);
						  }
					 }
					 return false;
				  }
				  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
					 var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
					 if (objLength != othLength && !isPartial) {
						return false;
					 }
					 var index = objLength;
					 while (index--) {
						var key = objProps[index];
						if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
						  return false;
						}
					 }
					 var objStacked = stack.get(object);
					 var othStacked = stack.get(other);
					 if (objStacked && othStacked) {
						return objStacked == other && othStacked == object;
					 }
					 var result2 = true;
					 stack.set(object, other);
					 stack.set(other, object);
					 var skipCtor = isPartial;
					 while (++index < objLength) {
						key = objProps[index];
						var objValue = object[key], othValue = other[key];
						if (customizer) {
						  var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
						}
						if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
						  result2 = false;
						  break;
						}
						skipCtor || (skipCtor = key == "constructor");
					 }
					 if (result2 && !skipCtor) {
						var objCtor = object.constructor, othCtor = other.constructor;
						if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
						  result2 = false;
						}
					 }
					 stack["delete"](object);
					 stack["delete"](other);
					 return result2;
				  }
				  function flatRest(func) {
					 return setToString(overRest(func, undefined2, flatten2), func + "");
				  }
				  function getAllKeys(object) {
					 return baseGetAllKeys(object, keys, getSymbols);
				  }
				  function getAllKeysIn(object) {
					 return baseGetAllKeys(object, keysIn, getSymbolsIn);
				  }
				  var getData = !metaMap ? noop5 : function(func) {
					 return metaMap.get(func);
				  };
				  function getFuncName(func) {
					 var result2 = func.name + "", array2 = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array2.length : 0;
					 while (length--) {
						var data = array2[length], otherFunc = data.func;
						if (otherFunc == null || otherFunc == func) {
						  return data.name;
						}
					 }
					 return result2;
				  }
				  function getHolder(func) {
					 var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
					 return object.placeholder;
				  }
				  function getIteratee() {
					 var result2 = lodash.iteratee || iteratee;
					 result2 = result2 === iteratee ? baseIteratee : result2;
					 return arguments.length ? result2(arguments[0], arguments[1]) : result2;
				  }
				  function getMapData(map4, key) {
					 var data = map4.__data__;
					 return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
				  }
				  function getMatchData(object) {
					 var result2 = keys(object), length = result2.length;
					 while (length--) {
						var key = result2[length], value = object[key];
						result2[length] = [key, value, isStrictComparable(value)];
					 }
					 return result2;
				  }
				  function getNative(object, key) {
					 var value = getValue(object, key);
					 return baseIsNative(value) ? value : undefined2;
				  }
				  function getRawTag(value) {
					 var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
					 try {
						value[symToStringTag] = undefined2;
						var unmasked = true;
					 } catch (e) {
					 }
					 var result2 = nativeObjectToString.call(value);
					 if (unmasked) {
						if (isOwn) {
						  value[symToStringTag] = tag;
						} else {
						  delete value[symToStringTag];
						}
					 }
					 return result2;
				  }
				  var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
					 if (object == null) {
						return [];
					 }
					 object = Object2(object);
					 return arrayFilter(nativeGetSymbols(object), function(symbol) {
						return propertyIsEnumerable.call(object, symbol);
					 });
				  };
				  var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
					 var result2 = [];
					 while (object) {
						arrayPush(result2, getSymbols(object));
						object = getPrototype(object);
					 }
					 return result2;
				  };
				  var getTag = baseGetTag;
				  if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
					 getTag = function(value) {
						var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
						if (ctorString) {
						  switch (ctorString) {
							 case dataViewCtorString:
								return dataViewTag;
							 case mapCtorString:
								return mapTag;
							 case promiseCtorString:
								return promiseTag;
							 case setCtorString:
								return setTag;
							 case weakMapCtorString:
								return weakMapTag;
						  }
						}
						return result2;
					 };
				  }
				  function getView(start2, end, transforms) {
					 var index = -1, length = transforms.length;
					 while (++index < length) {
						var data = transforms[index], size2 = data.size;
						switch (data.type) {
						  case "drop":
							 start2 += size2;
							 break;
						  case "dropRight":
							 end -= size2;
							 break;
						  case "take":
							 end = nativeMin(end, start2 + size2);
							 break;
						  case "takeRight":
							 start2 = nativeMax(start2, end - size2);
							 break;
						}
					 }
					 return { "start": start2, "end": end };
				  }
				  function getWrapDetails(source) {
					 var match23 = source.match(reWrapDetails);
					 return match23 ? match23[1].split(reSplitDetails) : [];
				  }
				  function hasPath(object, path, hasFunc) {
					 path = castPath(path, object);
					 var index = -1, length = path.length, result2 = false;
					 while (++index < length) {
						var key = toKey(path[index]);
						if (!(result2 = object != null && hasFunc(object, key))) {
						  break;
						}
						object = object[key];
					 }
					 if (result2 || ++index != length) {
						return result2;
					 }
					 length = object == null ? 0 : object.length;
					 return !!length && isLength(length) && isIndex(key, length) && (isArray2(object) || isArguments(object));
				  }
				  function initCloneArray(array2) {
					 var length = array2.length, result2 = new array2.constructor(length);
					 if (length && typeof array2[0] == "string" && hasOwnProperty.call(array2, "index")) {
						result2.index = array2.index;
						result2.input = array2.input;
					 }
					 return result2;
				  }
				  function initCloneObject(object) {
					 return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
				  }
				  function initCloneByTag(object, tag, isDeep) {
					 var Ctor = object.constructor;
					 switch (tag) {
						case arrayBufferTag:
						  return cloneArrayBuffer(object);
						case boolTag:
						case dateTag:
						  return new Ctor(+object);
						case dataViewTag:
						  return cloneDataView(object, isDeep);
						case float32Tag:
						case float64Tag:
						case int8Tag:
						case int16Tag:
						case int32Tag:
						case uint8Tag:
						case uint8ClampedTag:
						case uint16Tag:
						case uint32Tag:
						  return cloneTypedArray(object, isDeep);
						case mapTag:
						  return new Ctor();
						case numberTag:
						case stringTag:
						  return new Ctor(object);
						case regexpTag:
						  return cloneRegExp(object);
						case setTag:
						  return new Ctor();
						case symbolTag:
						  return cloneSymbol(object);
					 }
				  }
				  function insertWrapDetails(source, details) {
					 var length = details.length;
					 if (!length) {
						return source;
					 }
					 var lastIndex = length - 1;
					 details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
					 details = details.join(length > 2 ? ", " : " ");
					 return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
				  }
				  function isFlattenable(value) {
					 return isArray2(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
				  }
				  function isIndex(value, length) {
					 var type2 = typeof value;
					 length = length == null ? MAX_SAFE_INTEGER : length;
					 return !!length && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
				  }
				  function isIterateeCall(value, index, object) {
					 if (!isObject2(object)) {
						return false;
					 }
					 var type2 = typeof index;
					 if (type2 == "number" ? isArrayLike2(object) && isIndex(index, object.length) : type2 == "string" && index in object) {
						return eq(object[index], value);
					 }
					 return false;
				  }
				  function isKey(value, object) {
					 if (isArray2(value)) {
						return false;
					 }
					 var type2 = typeof value;
					 if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol(value)) {
						return true;
					 }
					 return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
				  }
				  function isKeyable(value) {
					 var type2 = typeof value;
					 return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
				  }
				  function isLaziable(func) {
					 var funcName = getFuncName(func), other = lodash[funcName];
					 if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
						return false;
					 }
					 if (func === other) {
						return true;
					 }
					 var data = getData(other);
					 return !!data && func === data[0];
				  }
				  function isMasked(func) {
					 return !!maskSrcKey && maskSrcKey in func;
				  }
				  var isMaskable = coreJsData ? isFunction5 : stubFalse;
				  function isPrototype(value) {
					 var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
					 return value === proto;
				  }
				  function isStrictComparable(value) {
					 return value === value && !isObject2(value);
				  }
				  function matchesStrictComparable(key, srcValue) {
					 return function(object) {
						if (object == null) {
						  return false;
						}
						return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
					 };
				  }
				  function memoizeCapped(func) {
					 var result2 = memoize(func, function(key) {
						if (cache.size === MAX_MEMOIZE_SIZE) {
						  cache.clear();
						}
						return key;
					 });
					 var cache = result2.cache;
					 return result2;
				  }
				  function mergeData(data, source) {
					 var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
					 var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
					 if (!(isCommon || isCombo)) {
						return data;
					 }
					 if (srcBitmask & WRAP_BIND_FLAG) {
						data[2] = source[2];
						newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
					 }
					 var value = source[3];
					 if (value) {
						var partials = data[3];
						data[3] = partials ? composeArgs(partials, value, source[4]) : value;
						data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
					 }
					 value = source[5];
					 if (value) {
						partials = data[5];
						data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
						data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
					 }
					 value = source[7];
					 if (value) {
						data[7] = value;
					 }
					 if (srcBitmask & WRAP_ARY_FLAG) {
						data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
					 }
					 if (data[9] == null) {
						data[9] = source[9];
					 }
					 data[0] = source[0];
					 data[1] = newBitmask;
					 return data;
				  }
				  function nativeKeysIn(object) {
					 var result2 = [];
					 if (object != null) {
						for (var key in Object2(object)) {
						  result2.push(key);
						}
					 }
					 return result2;
				  }
				  function objectToString(value) {
					 return nativeObjectToString.call(value);
				  }
				  function overRest(func, start2, transform3) {
					 start2 = nativeMax(start2 === undefined2 ? func.length - 1 : start2, 0);
					 return function() {
						var args = arguments, index = -1, length = nativeMax(args.length - start2, 0), array2 = Array2(length);
						while (++index < length) {
						  array2[index] = args[start2 + index];
						}
						index = -1;
						var otherArgs = Array2(start2 + 1);
						while (++index < start2) {
						  otherArgs[index] = args[index];
						}
						otherArgs[start2] = transform3(array2);
						return apply(func, this, otherArgs);
					 };
				  }
				  function parent(object, path) {
					 return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
				  }
				  function reorder(array2, indexes) {
					 var arrLength = array2.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array2);
					 while (length--) {
						var index = indexes[length];
						array2[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
					 }
					 return array2;
				  }
				  function safeGet(object, key) {
					 if (key === "constructor" && typeof object[key] === "function") {
						return;
					 }
					 if (key == "__proto__") {
						return;
					 }
					 return object[key];
				  }
				  var setData = shortOut(baseSetData);
				  var setTimeout2 = ctxSetTimeout || function(func, wait) {
					 return root2.setTimeout(func, wait);
				  };
				  var setToString = shortOut(baseSetToString);
				  function setWrapToString(wrapper, reference, bitmask) {
					 var source = reference + "";
					 return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
				  }
				  function shortOut(func) {
					 var count = 0, lastCalled = 0;
					 return function() {
						var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
						lastCalled = stamp;
						if (remaining > 0) {
						  if (++count >= HOT_COUNT) {
							 return arguments[0];
						  }
						} else {
						  count = 0;
						}
						return func.apply(undefined2, arguments);
					 };
				  }
				  function shuffleSelf(array2, size2) {
					 var index = -1, length = array2.length, lastIndex = length - 1;
					 size2 = size2 === undefined2 ? length : size2;
					 while (++index < size2) {
						var rand = baseRandom(index, lastIndex), value = array2[rand];
						array2[rand] = array2[index];
						array2[index] = value;
					 }
					 array2.length = size2;
					 return array2;
				  }
				  var stringToPath = memoizeCapped(function(string) {
					 var result2 = [];
					 if (string.charCodeAt(0) === 46) {
						result2.push("");
					 }
					 string.replace(rePropName, function(match23, number5, quote, subString) {
						result2.push(quote ? subString.replace(reEscapeChar, "$1") : number5 || match23);
					 });
					 return result2;
				  });
				  function toKey(value) {
					 if (typeof value == "string" || isSymbol(value)) {
						return value;
					 }
					 var result2 = value + "";
					 return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
				  }
				  function toSource(func) {
					 if (func != null) {
						try {
						  return funcToString.call(func);
						} catch (e) {
						}
						try {
						  return func + "";
						} catch (e) {
						}
					 }
					 return "";
				  }
				  function updateWrapDetails(details, bitmask) {
					 arrayEach(wrapFlags, function(pair) {
						var value = "_." + pair[0];
						if (bitmask & pair[1] && !arrayIncludes(details, value)) {
						  details.push(value);
						}
					 });
					 return details.sort();
				  }
				  function wrapperClone(wrapper) {
					 if (wrapper instanceof LazyWrapper) {
						return wrapper.clone();
					 }
					 var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
					 result2.__actions__ = copyArray(wrapper.__actions__);
					 result2.__index__ = wrapper.__index__;
					 result2.__values__ = wrapper.__values__;
					 return result2;
				  }
				  function chunk(array2, size2, guard) {
					 if (guard ? isIterateeCall(array2, size2, guard) : size2 === undefined2) {
						size2 = 1;
					 } else {
						size2 = nativeMax(toInteger(size2), 0);
					 }
					 var length = array2 == null ? 0 : array2.length;
					 if (!length || size2 < 1) {
						return [];
					 }
					 var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
					 while (index < length) {
						result2[resIndex++] = baseSlice(array2, index, index += size2);
					 }
					 return result2;
				  }
				  function compact(array2) {
					 var index = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result2 = [];
					 while (++index < length) {
						var value = array2[index];
						if (value) {
						  result2[resIndex++] = value;
						}
					 }
					 return result2;
				  }
				  function concat() {
					 var length = arguments.length;
					 if (!length) {
						return [];
					 }
					 var args = Array2(length - 1), array2 = arguments[0], index = length;
					 while (index--) {
						args[index - 1] = arguments[index];
					 }
					 return arrayPush(isArray2(array2) ? copyArray(array2) : [array2], baseFlatten(args, 1));
				  }
				  var difference2 = baseRest(function(array2, values2) {
					 return isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
				  });
				  var differenceBy = baseRest(function(array2, values2) {
					 var iteratee2 = last2(values2);
					 if (isArrayLikeObject(iteratee2)) {
						iteratee2 = undefined2;
					 }
					 return isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
				  });
				  var differenceWith = baseRest(function(array2, values2) {
					 var comparator = last2(values2);
					 if (isArrayLikeObject(comparator)) {
						comparator = undefined2;
					 }
					 return isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
				  });
				  function drop(array2, n, guard) {
					 var length = array2 == null ? 0 : array2.length;
					 if (!length) {
						return [];
					 }
					 n = guard || n === undefined2 ? 1 : toInteger(n);
					 return baseSlice(array2, n < 0 ? 0 : n, length);
				  }
				  function dropRight(array2, n, guard) {
					 var length = array2 == null ? 0 : array2.length;
					 if (!length) {
						return [];
					 }
					 n = guard || n === undefined2 ? 1 : toInteger(n);
					 n = length - n;
					 return baseSlice(array2, 0, n < 0 ? 0 : n);
				  }
				  function dropRightWhile(array2, predicate) {
					 return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), true, true) : [];
				  }
				  function dropWhile(array2, predicate) {
					 return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), true) : [];
				  }
				  function fill(array2, value, start2, end) {
					 var length = array2 == null ? 0 : array2.length;
					 if (!length) {
						return [];
					 }
					 if (start2 && typeof start2 != "number" && isIterateeCall(array2, value, start2)) {
						start2 = 0;
						end = length;
					 }
					 return baseFill(array2, value, start2, end);
				  }
				  function findIndex3(array2, predicate, fromIndex) {
					 var length = array2 == null ? 0 : array2.length;
					 if (!length) {
						return -1;
					 }
					 var index = fromIndex == null ? 0 : toInteger(fromIndex);
					 if (index < 0) {
						index = nativeMax(length + index, 0);
					 }
					 return baseFindIndex(array2, getIteratee(predicate, 3), index);
				  }
				  function findLastIndex(array2, predicate, fromIndex) {
					 var length = array2 == null ? 0 : array2.length;
					 if (!length) {
						return -1;
					 }
					 var index = length - 1;
					 if (fromIndex !== undefined2) {
						index = toInteger(fromIndex);
						index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
					 }
					 return baseFindIndex(array2, getIteratee(predicate, 3), index, true);
				  }
				  function flatten2(array2) {
					 var length = array2 == null ? 0 : array2.length;
					 return length ? baseFlatten(array2, 1) : [];
				  }
				  function flattenDeep(array2) {
					 var length = array2 == null ? 0 : array2.length;
					 return length ? baseFlatten(array2, INFINITY) : [];
				  }
				  function flattenDepth(array2, depth) {
					 var length = array2 == null ? 0 : array2.length;
					 if (!length) {
						return [];
					 }
					 depth = depth === undefined2 ? 1 : toInteger(depth);
					 return baseFlatten(array2, depth);
				  }
				  function fromPairs(pairs) {
					 var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
					 while (++index < length) {
						var pair = pairs[index];
						result2[pair[0]] = pair[1];
					 }
					 return result2;
				  }
				  function head(array2) {
					 return array2 && array2.length ? array2[0] : undefined2;
				  }
				  function indexOf2(array2, value, fromIndex) {
					 var length = array2 == null ? 0 : array2.length;
					 if (!length) {
						return -1;
					 }
					 var index = fromIndex == null ? 0 : toInteger(fromIndex);
					 if (index < 0) {
						index = nativeMax(length + index, 0);
					 }
					 return baseIndexOf(array2, value, index);
				  }
				  function initial(array2) {
					 var length = array2 == null ? 0 : array2.length;
					 return length ? baseSlice(array2, 0, -1) : [];
				  }
				  var intersection = baseRest(function(arrays) {
					 var mapped = arrayMap(arrays, castArrayLikeObject);
					 return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
				  });
				  var intersectionBy = baseRest(function(arrays) {
					 var iteratee2 = last2(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
					 if (iteratee2 === last2(mapped)) {
						iteratee2 = undefined2;
					 } else {
						mapped.pop();
					 }
					 return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
				  });
				  var intersectionWith = baseRest(function(arrays) {
					 var comparator = last2(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
					 comparator = typeof comparator == "function" ? comparator : undefined2;
					 if (comparator) {
						mapped.pop();
					 }
					 return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
				  });
				  function join(array2, separator) {
					 return array2 == null ? "" : nativeJoin.call(array2, separator);
				  }
				  function last2(array2) {
					 var length = array2 == null ? 0 : array2.length;
					 return length ? array2[length - 1] : undefined2;
				  }
				  function lastIndexOf(array2, value, fromIndex) {
					 var length = array2 == null ? 0 : array2.length;
					 if (!length) {
						return -1;
					 }
					 var index = length;
					 if (fromIndex !== undefined2) {
						index = toInteger(fromIndex);
						index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
					 }
					 return value === value ? strictLastIndexOf(array2, value, index) : baseFindIndex(array2, baseIsNaN, index, true);
				  }
				  function nth(array2, n) {
					 return array2 && array2.length ? baseNth(array2, toInteger(n)) : undefined2;
				  }
				  var pull = baseRest(pullAll);
				  function pullAll(array2, values2) {
					 return array2 && array2.length && values2 && values2.length ? basePullAll(array2, values2) : array2;
				  }
				  function pullAllBy(array2, values2, iteratee2) {
					 return array2 && array2.length && values2 && values2.length ? basePullAll(array2, values2, getIteratee(iteratee2, 2)) : array2;
				  }
				  function pullAllWith(array2, values2, comparator) {
					 return array2 && array2.length && values2 && values2.length ? basePullAll(array2, values2, undefined2, comparator) : array2;
				  }
				  var pullAt = flatRest(function(array2, indexes) {
					 var length = array2 == null ? 0 : array2.length, result2 = baseAt(array2, indexes);
					 basePullAt(array2, arrayMap(indexes, function(index) {
						return isIndex(index, length) ? +index : index;
					 }).sort(compareAscending));
					 return result2;
				  });
				  function remove4(array2, predicate) {
					 var result2 = [];
					 if (!(array2 && array2.length)) {
						return result2;
					 }
					 var index = -1, indexes = [], length = array2.length;
					 predicate = getIteratee(predicate, 3);
					 while (++index < length) {
						var value = array2[index];
						if (predicate(value, index, array2)) {
						  result2.push(value);
						  indexes.push(index);
						}
					 }
					 basePullAt(array2, indexes);
					 return result2;
				  }
				  function reverse(array2) {
					 return array2 == null ? array2 : nativeReverse.call(array2);
				  }
				  function slice(array2, start2, end) {
					 var length = array2 == null ? 0 : array2.length;
					 if (!length) {
						return [];
					 }
					 if (end && typeof end != "number" && isIterateeCall(array2, start2, end)) {
						start2 = 0;
						end = length;
					 } else {
						start2 = start2 == null ? 0 : toInteger(start2);
						end = end === undefined2 ? length : toInteger(end);
					 }
					 return baseSlice(array2, start2, end);
				  }
				  function sortedIndex(array2, value) {
					 return baseSortedIndex(array2, value);
				  }
				  function sortedIndexBy(array2, value, iteratee2) {
					 return baseSortedIndexBy(array2, value, getIteratee(iteratee2, 2));
				  }
				  function sortedIndexOf(array2, value) {
					 var length = array2 == null ? 0 : array2.length;
					 if (length) {
						var index = baseSortedIndex(array2, value);
						if (index < length && eq(array2[index], value)) {
						  return index;
						}
					 }
					 return -1;
				  }
				  function sortedLastIndex(array2, value) {
					 return baseSortedIndex(array2, value, true);
				  }
				  function sortedLastIndexBy(array2, value, iteratee2) {
					 return baseSortedIndexBy(array2, value, getIteratee(iteratee2, 2), true);
				  }
				  function sortedLastIndexOf(array2, value) {
					 var length = array2 == null ? 0 : array2.length;
					 if (length) {
						var index = baseSortedIndex(array2, value, true) - 1;
						if (eq(array2[index], value)) {
						  return index;
						}
					 }
					 return -1;
				  }
				  function sortedUniq(array2) {
					 return array2 && array2.length ? baseSortedUniq(array2) : [];
				  }
				  function sortedUniqBy(array2, iteratee2) {
					 return array2 && array2.length ? baseSortedUniq(array2, getIteratee(iteratee2, 2)) : [];
				  }
				  function tail(array2) {
					 var length = array2 == null ? 0 : array2.length;
					 return length ? baseSlice(array2, 1, length) : [];
				  }
				  function take(array2, n, guard) {
					 if (!(array2 && array2.length)) {
						return [];
					 }
					 n = guard || n === undefined2 ? 1 : toInteger(n);
					 return baseSlice(array2, 0, n < 0 ? 0 : n);
				  }
				  function takeRight(array2, n, guard) {
					 var length = array2 == null ? 0 : array2.length;
					 if (!length) {
						return [];
					 }
					 n = guard || n === undefined2 ? 1 : toInteger(n);
					 n = length - n;
					 return baseSlice(array2, n < 0 ? 0 : n, length);
				  }
				  function takeRightWhile(array2, predicate) {
					 return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), false, true) : [];
				  }
				  function takeWhile(array2, predicate) {
					 return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3)) : [];
				  }
				  var union = baseRest(function(arrays) {
					 return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
				  });
				  var unionBy2 = baseRest(function(arrays) {
					 var iteratee2 = last2(arrays);
					 if (isArrayLikeObject(iteratee2)) {
						iteratee2 = undefined2;
					 }
					 return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
				  });
				  var unionWith = baseRest(function(arrays) {
					 var comparator = last2(arrays);
					 comparator = typeof comparator == "function" ? comparator : undefined2;
					 return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
				  });
				  function uniq2(array2) {
					 return array2 && array2.length ? baseUniq(array2) : [];
				  }
				  function uniqBy2(array2, iteratee2) {
					 return array2 && array2.length ? baseUniq(array2, getIteratee(iteratee2, 2)) : [];
				  }
				  function uniqWith(array2, comparator) {
					 comparator = typeof comparator == "function" ? comparator : undefined2;
					 return array2 && array2.length ? baseUniq(array2, undefined2, comparator) : [];
				  }
				  function unzip(array2) {
					 if (!(array2 && array2.length)) {
						return [];
					 }
					 var length = 0;
					 array2 = arrayFilter(array2, function(group) {
						if (isArrayLikeObject(group)) {
						  length = nativeMax(group.length, length);
						  return true;
						}
					 });
					 return baseTimes(length, function(index) {
						return arrayMap(array2, baseProperty(index));
					 });
				  }
				  function unzipWith(array2, iteratee2) {
					 if (!(array2 && array2.length)) {
						return [];
					 }
					 var result2 = unzip(array2);
					 if (iteratee2 == null) {
						return result2;
					 }
					 return arrayMap(result2, function(group) {
						return apply(iteratee2, undefined2, group);
					 });
				  }
				  var without = baseRest(function(array2, values2) {
					 return isArrayLikeObject(array2) ? baseDifference(array2, values2) : [];
				  });
				  var xor = baseRest(function(arrays) {
					 return baseXor(arrayFilter(arrays, isArrayLikeObject));
				  });
				  var xorBy = baseRest(function(arrays) {
					 var iteratee2 = last2(arrays);
					 if (isArrayLikeObject(iteratee2)) {
						iteratee2 = undefined2;
					 }
					 return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
				  });
				  var xorWith = baseRest(function(arrays) {
					 var comparator = last2(arrays);
					 comparator = typeof comparator == "function" ? comparator : undefined2;
					 return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
				  });
				  var zip = baseRest(unzip);
				  function zipObject(props, values2) {
					 return baseZipObject(props || [], values2 || [], assignValue);
				  }
				  function zipObjectDeep(props, values2) {
					 return baseZipObject(props || [], values2 || [], baseSet);
				  }
				  var zipWith = baseRest(function(arrays) {
					 var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
					 iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
					 return unzipWith(arrays, iteratee2);
				  });
				  function chain(value) {
					 var result2 = lodash(value);
					 result2.__chain__ = true;
					 return result2;
				  }
				  function tap(value, interceptor) {
					 interceptor(value);
					 return value;
				  }
				  function thru(value, interceptor) {
					 return interceptor(value);
				  }
				  var wrapperAt = flatRest(function(paths) {
					 var length = paths.length, start2 = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
						return baseAt(object, paths);
					 };
					 if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start2)) {
						return this.thru(interceptor);
					 }
					 value = value.slice(start2, +start2 + (length ? 1 : 0));
					 value.__actions__.push({
						"func": thru,
						"args": [interceptor],
						"thisArg": undefined2
					 });
					 return new LodashWrapper(value, this.__chain__).thru(function(array2) {
						if (length && !array2.length) {
						  array2.push(undefined2);
						}
						return array2;
					 });
				  });
				  function wrapperChain() {
					 return chain(this);
				  }
				  function wrapperCommit() {
					 return new LodashWrapper(this.value(), this.__chain__);
				  }
				  function wrapperNext() {
					 if (this.__values__ === undefined2) {
						this.__values__ = toArray(this.value());
					 }
					 var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
					 return { "done": done, "value": value };
				  }
				  function wrapperToIterator() {
					 return this;
				  }
				  function wrapperPlant(value) {
					 var result2, parent2 = this;
					 while (parent2 instanceof baseLodash) {
						var clone3 = wrapperClone(parent2);
						clone3.__index__ = 0;
						clone3.__values__ = undefined2;
						if (result2) {
						  previous.__wrapped__ = clone3;
						} else {
						  result2 = clone3;
						}
						var previous = clone3;
						parent2 = parent2.__wrapped__;
					 }
					 previous.__wrapped__ = value;
					 return result2;
				  }
				  function wrapperReverse() {
					 var value = this.__wrapped__;
					 if (value instanceof LazyWrapper) {
						var wrapped = value;
						if (this.__actions__.length) {
						  wrapped = new LazyWrapper(this);
						}
						wrapped = wrapped.reverse();
						wrapped.__actions__.push({
						  "func": thru,
						  "args": [reverse],
						  "thisArg": undefined2
						});
						return new LodashWrapper(wrapped, this.__chain__);
					 }
					 return this.thru(reverse);
				  }
				  function wrapperValue() {
					 return baseWrapperValue(this.__wrapped__, this.__actions__);
				  }
				  var countBy = createAggregator(function(result2, value, key) {
					 if (hasOwnProperty.call(result2, key)) {
						++result2[key];
					 } else {
						baseAssignValue(result2, key, 1);
					 }
				  });
				  function every(collection, predicate, guard) {
					 var func = isArray2(collection) ? arrayEvery : baseEvery;
					 if (guard && isIterateeCall(collection, predicate, guard)) {
						predicate = undefined2;
					 }
					 return func(collection, getIteratee(predicate, 3));
				  }
				  function filter2(collection, predicate) {
					 var func = isArray2(collection) ? arrayFilter : baseFilter;
					 return func(collection, getIteratee(predicate, 3));
				  }
				  var find3 = createFind(findIndex3);
				  var findLast = createFind(findLastIndex);
				  function flatMap2(collection, iteratee2) {
					 return baseFlatten(map3(collection, iteratee2), 1);
				  }
				  function flatMapDeep(collection, iteratee2) {
					 return baseFlatten(map3(collection, iteratee2), INFINITY);
				  }
				  function flatMapDepth(collection, iteratee2, depth) {
					 depth = depth === undefined2 ? 1 : toInteger(depth);
					 return baseFlatten(map3(collection, iteratee2), depth);
				  }
				  function forEach2(collection, iteratee2) {
					 var func = isArray2(collection) ? arrayEach : baseEach;
					 return func(collection, getIteratee(iteratee2, 3));
				  }
				  function forEachRight2(collection, iteratee2) {
					 var func = isArray2(collection) ? arrayEachRight : baseEachRight;
					 return func(collection, getIteratee(iteratee2, 3));
				  }
				  var groupBy2 = createAggregator(function(result2, value, key) {
					 if (hasOwnProperty.call(result2, key)) {
						result2[key].push(value);
					 } else {
						baseAssignValue(result2, key, [value]);
					 }
				  });
				  function includes2(collection, value, fromIndex, guard) {
					 collection = isArrayLike2(collection) ? collection : values(collection);
					 fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
					 var length = collection.length;
					 if (fromIndex < 0) {
						fromIndex = nativeMax(length + fromIndex, 0);
					 }
					 return isString2(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
				  }
				  var invokeMap = baseRest(function(collection, path, args) {
					 var index = -1, isFunc = typeof path == "function", result2 = isArrayLike2(collection) ? Array2(collection.length) : [];
					 baseEach(collection, function(value) {
						result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
					 });
					 return result2;
				  });
				  var keyBy = createAggregator(function(result2, value, key) {
					 baseAssignValue(result2, key, value);
				  });
				  function map3(collection, iteratee2) {
					 var func = isArray2(collection) ? arrayMap : baseMap;
					 return func(collection, getIteratee(iteratee2, 3));
				  }
				  function orderBy2(collection, iteratees, orders, guard) {
					 if (collection == null) {
						return [];
					 }
					 if (!isArray2(iteratees)) {
						iteratees = iteratees == null ? [] : [iteratees];
					 }
					 orders = guard ? undefined2 : orders;
					 if (!isArray2(orders)) {
						orders = orders == null ? [] : [orders];
					 }
					 return baseOrderBy(collection, iteratees, orders);
				  }
				  var partition = createAggregator(function(result2, value, key) {
					 result2[key ? 0 : 1].push(value);
				  }, function() {
					 return [[], []];
				  });
				  function reduce(collection, iteratee2, accumulator) {
					 var func = isArray2(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
					 return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
				  }
				  function reduceRight(collection, iteratee2, accumulator) {
					 var func = isArray2(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
					 return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
				  }
				  function reject(collection, predicate) {
					 var func = isArray2(collection) ? arrayFilter : baseFilter;
					 return func(collection, negate(getIteratee(predicate, 3)));
				  }
				  function sample(collection) {
					 var func = isArray2(collection) ? arraySample : baseSample;
					 return func(collection);
				  }
				  function sampleSize(collection, n, guard) {
					 if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {
						n = 1;
					 } else {
						n = toInteger(n);
					 }
					 var func = isArray2(collection) ? arraySampleSize : baseSampleSize;
					 return func(collection, n);
				  }
				  function shuffle(collection) {
					 var func = isArray2(collection) ? arrayShuffle : baseShuffle;
					 return func(collection);
				  }
				  function size(collection) {
					 if (collection == null) {
						return 0;
					 }
					 if (isArrayLike2(collection)) {
						return isString2(collection) ? stringSize(collection) : collection.length;
					 }
					 var tag = getTag(collection);
					 if (tag == mapTag || tag == setTag) {
						return collection.size;
					 }
					 return baseKeys(collection).length;
				  }
				  function some(collection, predicate, guard) {
					 var func = isArray2(collection) ? arraySome : baseSome;
					 if (guard && isIterateeCall(collection, predicate, guard)) {
						predicate = undefined2;
					 }
					 return func(collection, getIteratee(predicate, 3));
				  }
				  var sortBy2 = baseRest(function(collection, iteratees) {
					 if (collection == null) {
						return [];
					 }
					 var length = iteratees.length;
					 if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
						iteratees = [];
					 } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
						iteratees = [iteratees[0]];
					 }
					 return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
				  });
				  var now2 = ctxNow || function() {
					 return root2.Date.now();
				  };
				  function after(n, func) {
					 if (typeof func != "function") {
						throw new TypeError2(FUNC_ERROR_TEXT);
					 }
					 n = toInteger(n);
					 return function() {
						if (--n < 1) {
						  return func.apply(this, arguments);
						}
					 };
				  }
				  function ary(func, n, guard) {
					 n = guard ? undefined2 : n;
					 n = func && n == null ? func.length : n;
					 return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
				  }
				  function before(n, func) {
					 var result2;
					 if (typeof func != "function") {
						throw new TypeError2(FUNC_ERROR_TEXT);
					 }
					 n = toInteger(n);
					 return function() {
						if (--n > 0) {
						  result2 = func.apply(this, arguments);
						}
						if (n <= 1) {
						  func = undefined2;
						}
						return result2;
					 };
				  }
				  var bind2 = baseRest(function(func, thisArg, partials) {
					 var bitmask = WRAP_BIND_FLAG;
					 if (partials.length) {
						var holders = replaceHolders(partials, getHolder(bind2));
						bitmask |= WRAP_PARTIAL_FLAG;
					 }
					 return createWrap(func, bitmask, thisArg, partials, holders);
				  });
				  var bindKey2 = baseRest(function(object, key, partials) {
					 var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
					 if (partials.length) {
						var holders = replaceHolders(partials, getHolder(bindKey2));
						bitmask |= WRAP_PARTIAL_FLAG;
					 }
					 return createWrap(key, bitmask, object, partials, holders);
				  });
				  function curry(func, arity, guard) {
					 arity = guard ? undefined2 : arity;
					 var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
					 result2.placeholder = curry.placeholder;
					 return result2;
				  }
				  function curryRight(func, arity, guard) {
					 arity = guard ? undefined2 : arity;
					 var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
					 result2.placeholder = curryRight.placeholder;
					 return result2;
				  }
				  function debounce(func, wait, options) {
					 var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
					 if (typeof func != "function") {
						throw new TypeError2(FUNC_ERROR_TEXT);
					 }
					 wait = toNumber2(wait) || 0;
					 if (isObject2(options)) {
						leading = !!options.leading;
						maxing = "maxWait" in options;
						maxWait = maxing ? nativeMax(toNumber2(options.maxWait) || 0, wait) : maxWait;
						trailing = "trailing" in options ? !!options.trailing : trailing;
					 }
					 function invokeFunc(time) {
						var args = lastArgs, thisArg = lastThis;
						lastArgs = lastThis = undefined2;
						lastInvokeTime = time;
						result2 = func.apply(thisArg, args);
						return result2;
					 }
					 function leadingEdge(time) {
						lastInvokeTime = time;
						timerId = setTimeout2(timerExpired, wait);
						return leading ? invokeFunc(time) : result2;
					 }
					 function remainingWait(time) {
						var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
						return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
					 }
					 function shouldInvoke(time) {
						var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
						return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
					 }
					 function timerExpired() {
						var time = now2();
						if (shouldInvoke(time)) {
						  return trailingEdge(time);
						}
						timerId = setTimeout2(timerExpired, remainingWait(time));
					 }
					 function trailingEdge(time) {
						timerId = undefined2;
						if (trailing && lastArgs) {
						  return invokeFunc(time);
						}
						lastArgs = lastThis = undefined2;
						return result2;
					 }
					 function cancel() {
						if (timerId !== undefined2) {
						  clearTimeout2(timerId);
						}
						lastInvokeTime = 0;
						lastArgs = lastCallTime = lastThis = timerId = undefined2;
					 }
					 function flush() {
						return timerId === undefined2 ? result2 : trailingEdge(now2());
					 }
					 function debounced() {
						var time = now2(), isInvoking = shouldInvoke(time);
						lastArgs = arguments;
						lastThis = this;
						lastCallTime = time;
						if (isInvoking) {
						  if (timerId === undefined2) {
							 return leadingEdge(lastCallTime);
						  }
						  if (maxing) {
							 clearTimeout2(timerId);
							 timerId = setTimeout2(timerExpired, wait);
							 return invokeFunc(lastCallTime);
						  }
						}
						if (timerId === undefined2) {
						  timerId = setTimeout2(timerExpired, wait);
						}
						return result2;
					 }
					 debounced.cancel = cancel;
					 debounced.flush = flush;
					 return debounced;
				  }
				  var defer = baseRest(function(func, args) {
					 return baseDelay(func, 1, args);
				  });
				  var delay = baseRest(function(func, wait, args) {
					 return baseDelay(func, toNumber2(wait) || 0, args);
				  });
				  function flip(func) {
					 return createWrap(func, WRAP_FLIP_FLAG);
				  }
				  function memoize(func, resolver) {
					 if (typeof func != "function" || resolver != null && typeof resolver != "function") {
						throw new TypeError2(FUNC_ERROR_TEXT);
					 }
					 var memoized = function() {
						var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
						if (cache.has(key)) {
						  return cache.get(key);
						}
						var result2 = func.apply(this, args);
						memoized.cache = cache.set(key, result2) || cache;
						return result2;
					 };
					 memoized.cache = new (memoize.Cache || MapCache)();
					 return memoized;
				  }
				  memoize.Cache = MapCache;
				  function negate(predicate) {
					 if (typeof predicate != "function") {
						throw new TypeError2(FUNC_ERROR_TEXT);
					 }
					 return function() {
						var args = arguments;
						switch (args.length) {
						  case 0:
							 return !predicate.call(this);
						  case 1:
							 return !predicate.call(this, args[0]);
						  case 2:
							 return !predicate.call(this, args[0], args[1]);
						  case 3:
							 return !predicate.call(this, args[0], args[1], args[2]);
						}
						return !predicate.apply(this, args);
					 };
				  }
				  function once(func) {
					 return before(2, func);
				  }
				  var overArgs = castRest(function(func, transforms) {
					 transforms = transforms.length == 1 && isArray2(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
					 var funcsLength = transforms.length;
					 return baseRest(function(args) {
						var index = -1, length = nativeMin(args.length, funcsLength);
						while (++index < length) {
						  args[index] = transforms[index].call(this, args[index]);
						}
						return apply(func, this, args);
					 });
				  });
				  var partial = baseRest(function(func, partials) {
					 var holders = replaceHolders(partials, getHolder(partial));
					 return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
				  });
				  var partialRight = baseRest(function(func, partials) {
					 var holders = replaceHolders(partials, getHolder(partialRight));
					 return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
				  });
				  var rearg = flatRest(function(func, indexes) {
					 return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
				  });
				  function rest(func, start2) {
					 if (typeof func != "function") {
						throw new TypeError2(FUNC_ERROR_TEXT);
					 }
					 start2 = start2 === undefined2 ? start2 : toInteger(start2);
					 return baseRest(func, start2);
				  }
				  function spread(func, start2) {
					 if (typeof func != "function") {
						throw new TypeError2(FUNC_ERROR_TEXT);
					 }
					 start2 = start2 == null ? 0 : nativeMax(toInteger(start2), 0);
					 return baseRest(function(args) {
						var array2 = args[start2], otherArgs = castSlice(args, 0, start2);
						if (array2) {
						  arrayPush(otherArgs, array2);
						}
						return apply(func, this, otherArgs);
					 });
				  }
				  function throttle(func, wait, options) {
					 var leading = true, trailing = true;
					 if (typeof func != "function") {
						throw new TypeError2(FUNC_ERROR_TEXT);
					 }
					 if (isObject2(options)) {
						leading = "leading" in options ? !!options.leading : leading;
						trailing = "trailing" in options ? !!options.trailing : trailing;
					 }
					 return debounce(func, wait, {
						"leading": leading,
						"maxWait": wait,
						"trailing": trailing
					 });
				  }
				  function unary(func) {
					 return ary(func, 1);
				  }
				  function wrap(value, wrapper) {
					 return partial(castFunction(wrapper), value);
				  }
				  function castArray() {
					 if (!arguments.length) {
						return [];
					 }
					 var value = arguments[0];
					 return isArray2(value) ? value : [value];
				  }
				  function clone2(value) {
					 return baseClone(value, CLONE_SYMBOLS_FLAG);
				  }
				  function cloneWith(value, customizer) {
					 customizer = typeof customizer == "function" ? customizer : undefined2;
					 return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
				  }
				  function cloneDeep2(value) {
					 return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
				  }
				  function cloneDeepWith(value, customizer) {
					 customizer = typeof customizer == "function" ? customizer : undefined2;
					 return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
				  }
				  function conformsTo(object, source) {
					 return source == null || baseConformsTo(object, source, keys(source));
				  }
				  function eq(value, other) {
					 return value === other || value !== value && other !== other;
				  }
				  var gt = createRelationalOperation(baseGt);
				  var gte = createRelationalOperation(function(value, other) {
					 return value >= other;
				  });
				  var isArguments = baseIsArguments(/* @__PURE__ */ function() {
					 return arguments;
				  }()) ? baseIsArguments : function(value) {
					 return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
				  };
				  var isArray2 = Array2.isArray;
				  var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
				  function isArrayLike2(value) {
					 return value != null && isLength(value.length) && !isFunction5(value);
				  }
				  function isArrayLikeObject(value) {
					 return isObjectLike(value) && isArrayLike2(value);
				  }
				  function isBoolean(value) {
					 return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
				  }
				  var isBuffer = nativeIsBuffer || stubFalse;
				  var isDate3 = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
				  function isElement2(value) {
					 return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
				  }
				  function isEmpty2(value) {
					 if (value == null) {
						return true;
					 }
					 if (isArrayLike2(value) && (isArray2(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
						return !value.length;
					 }
					 var tag = getTag(value);
					 if (tag == mapTag || tag == setTag) {
						return !value.size;
					 }
					 if (isPrototype(value)) {
						return !baseKeys(value).length;
					 }
					 for (var key in value) {
						if (hasOwnProperty.call(value, key)) {
						  return false;
						}
					 }
					 return true;
				  }
				  function isEqual2(value, other) {
					 return baseIsEqual(value, other);
				  }
				  function isEqualWith(value, other, customizer) {
					 customizer = typeof customizer == "function" ? customizer : undefined2;
					 var result2 = customizer ? customizer(value, other) : undefined2;
					 return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
				  }
				  function isError(value) {
					 if (!isObjectLike(value)) {
						return false;
					 }
					 var tag = baseGetTag(value);
					 return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
				  }
				  function isFinite2(value) {
					 return typeof value == "number" && nativeIsFinite(value);
				  }
				  function isFunction5(value) {
					 if (!isObject2(value)) {
						return false;
					 }
					 var tag = baseGetTag(value);
					 return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
				  }
				  function isInteger(value) {
					 return typeof value == "number" && value == toInteger(value);
				  }
				  function isLength(value) {
					 return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
				  }
				  function isObject2(value) {
					 var type2 = typeof value;
					 return value != null && (type2 == "object" || type2 == "function");
				  }
				  function isObjectLike(value) {
					 return value != null && typeof value == "object";
				  }
				  var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
				  function isMatch(object, source) {
					 return object === source || baseIsMatch(object, source, getMatchData(source));
				  }
				  function isMatchWith(object, source, customizer) {
					 customizer = typeof customizer == "function" ? customizer : undefined2;
					 return baseIsMatch(object, source, getMatchData(source), customizer);
				  }
				  function isNaN2(value) {
					 return isNumber3(value) && value != +value;
				  }
				  function isNative(value) {
					 if (isMaskable(value)) {
						throw new Error2(CORE_ERROR_TEXT);
					 }
					 return baseIsNative(value);
				  }
				  function isNull2(value) {
					 return value === null;
				  }
				  function isNil2(value) {
					 return value == null;
				  }
				  function isNumber3(value) {
					 return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
				  }
				  function isPlainObject(value) {
					 if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
						return false;
					 }
					 var proto = getPrototype(value);
					 if (proto === null) {
						return true;
					 }
					 var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
					 return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
				  }
				  var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
				  function isSafeInteger(value) {
					 return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
				  }
				  var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
				  function isString2(value) {
					 return typeof value == "string" || !isArray2(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
				  }
				  function isSymbol(value) {
					 return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
				  }
				  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
				  function isUndefined2(value) {
					 return value === undefined2;
				  }
				  function isWeakMap(value) {
					 return isObjectLike(value) && getTag(value) == weakMapTag;
				  }
				  function isWeakSet(value) {
					 return isObjectLike(value) && baseGetTag(value) == weakSetTag;
				  }
				  var lt2 = createRelationalOperation(baseLt);
				  var lte = createRelationalOperation(function(value, other) {
					 return value <= other;
				  });
				  function toArray(value) {
					 if (!value) {
						return [];
					 }
					 if (isArrayLike2(value)) {
						return isString2(value) ? stringToArray(value) : copyArray(value);
					 }
					 if (symIterator && value[symIterator]) {
						return iteratorToArray(value[symIterator]());
					 }
					 var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
					 return func(value);
				  }
				  function toFinite(value) {
					 if (!value) {
						return value === 0 ? value : 0;
					 }
					 value = toNumber2(value);
					 if (value === INFINITY || value === -INFINITY) {
						var sign = value < 0 ? -1 : 1;
						return sign * MAX_INTEGER;
					 }
					 return value === value ? value : 0;
				  }
				  function toInteger(value) {
					 var result2 = toFinite(value), remainder = result2 % 1;
					 return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
				  }
				  function toLength(value) {
					 return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
				  }
				  function toNumber2(value) {
					 if (typeof value == "number") {
						return value;
					 }
					 if (isSymbol(value)) {
						return NAN;
					 }
					 if (isObject2(value)) {
						var other = typeof value.valueOf == "function" ? value.valueOf() : value;
						value = isObject2(other) ? other + "" : other;
					 }
					 if (typeof value != "string") {
						return value === 0 ? value : +value;
					 }
					 value = baseTrim(value);
					 var isBinary = reIsBinary.test(value);
					 return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
				  }
				  function toPlainObject(value) {
					 return copyObject(value, keysIn(value));
				  }
				  function toSafeInteger(value) {
					 return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
				  }
				  function toString(value) {
					 return value == null ? "" : baseToString(value);
				  }
				  var assign2 = createAssigner(function(object, source) {
					 if (isPrototype(source) || isArrayLike2(source)) {
						copyObject(source, keys(source), object);
						return;
					 }
					 for (var key in source) {
						if (hasOwnProperty.call(source, key)) {
						  assignValue(object, key, source[key]);
						}
					 }
				  });
				  var assignIn = createAssigner(function(object, source) {
					 copyObject(source, keysIn(source), object);
				  });
				  var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
					 copyObject(source, keysIn(source), object, customizer);
				  });
				  var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
					 copyObject(source, keys(source), object, customizer);
				  });
				  var at = flatRest(baseAt);
				  function create2(prototype, properties) {
					 var result2 = baseCreate(prototype);
					 return properties == null ? result2 : baseAssign(result2, properties);
				  }
				  var defaults = baseRest(function(object, sources) {
					 object = Object2(object);
					 var index = -1;
					 var length = sources.length;
					 var guard = length > 2 ? sources[2] : undefined2;
					 if (guard && isIterateeCall(sources[0], sources[1], guard)) {
						length = 1;
					 }
					 while (++index < length) {
						var source = sources[index];
						var props = keysIn(source);
						var propsIndex = -1;
						var propsLength = props.length;
						while (++propsIndex < propsLength) {
						  var key = props[propsIndex];
						  var value = object[key];
						  if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
							 object[key] = source[key];
						  }
						}
					 }
					 return object;
				  });
				  var defaultsDeep = baseRest(function(args) {
					 args.push(undefined2, customDefaultsMerge);
					 return apply(mergeWith, undefined2, args);
				  });
				  function findKey2(object, predicate) {
					 return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
				  }
				  function findLastKey(object, predicate) {
					 return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
				  }
				  function forIn(object, iteratee2) {
					 return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
				  }
				  function forInRight(object, iteratee2) {
					 return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
				  }
				  function forOwn(object, iteratee2) {
					 return object && baseForOwn(object, getIteratee(iteratee2, 3));
				  }
				  function forOwnRight(object, iteratee2) {
					 return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
				  }
				  function functions(object) {
					 return object == null ? [] : baseFunctions(object, keys(object));
				  }
				  function functionsIn(object) {
					 return object == null ? [] : baseFunctions(object, keysIn(object));
				  }
				  function get4(object, path, defaultValue) {
					 var result2 = object == null ? undefined2 : baseGet(object, path);
					 return result2 === undefined2 ? defaultValue : result2;
				  }
				  function has(object, path) {
					 return object != null && hasPath(object, path, baseHas);
				  }
				  function hasIn(object, path) {
					 return object != null && hasPath(object, path, baseHasIn);
				  }
				  var invert = createInverter(function(result2, value, key) {
					 if (value != null && typeof value.toString != "function") {
						value = nativeObjectToString.call(value);
					 }
					 result2[value] = key;
				  }, constant(identity5));
				  var invertBy = createInverter(function(result2, value, key) {
					 if (value != null && typeof value.toString != "function") {
						value = nativeObjectToString.call(value);
					 }
					 if (hasOwnProperty.call(result2, value)) {
						result2[value].push(key);
					 } else {
						result2[value] = [key];
					 }
				  }, getIteratee);
				  var invoke = baseRest(baseInvoke);
				  function keys(object) {
					 return isArrayLike2(object) ? arrayLikeKeys(object) : baseKeys(object);
				  }
				  function keysIn(object) {
					 return isArrayLike2(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
				  }
				  function mapKeys(object, iteratee2) {
					 var result2 = {};
					 iteratee2 = getIteratee(iteratee2, 3);
					 baseForOwn(object, function(value, key, object2) {
						baseAssignValue(result2, iteratee2(value, key, object2), value);
					 });
					 return result2;
				  }
				  function mapValues(object, iteratee2) {
					 var result2 = {};
					 iteratee2 = getIteratee(iteratee2, 3);
					 baseForOwn(object, function(value, key, object2) {
						baseAssignValue(result2, key, iteratee2(value, key, object2));
					 });
					 return result2;
				  }
				  var merge3 = createAssigner(function(object, source, srcIndex) {
					 baseMerge(object, source, srcIndex);
				  });
				  var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
					 baseMerge(object, source, srcIndex, customizer);
				  });
				  var omit = flatRest(function(object, paths) {
					 var result2 = {};
					 if (object == null) {
						return result2;
					 }
					 var isDeep = false;
					 paths = arrayMap(paths, function(path) {
						path = castPath(path, object);
						isDeep || (isDeep = path.length > 1);
						return path;
					 });
					 copyObject(object, getAllKeysIn(object), result2);
					 if (isDeep) {
						result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
					 }
					 var length = paths.length;
					 while (length--) {
						baseUnset(result2, paths[length]);
					 }
					 return result2;
				  });
				  function omitBy(object, predicate) {
					 return pickBy(object, negate(getIteratee(predicate)));
				  }
				  var pick = flatRest(function(object, paths) {
					 return object == null ? {} : basePick(object, paths);
				  });
				  function pickBy(object, predicate) {
					 if (object == null) {
						return {};
					 }
					 var props = arrayMap(getAllKeysIn(object), function(prop) {
						return [prop];
					 });
					 predicate = getIteratee(predicate);
					 return basePickBy(object, props, function(value, path) {
						return predicate(value, path[0]);
					 });
				  }
				  function result(object, path, defaultValue) {
					 path = castPath(path, object);
					 var index = -1, length = path.length;
					 if (!length) {
						length = 1;
						object = undefined2;
					 }
					 while (++index < length) {
						var value = object == null ? undefined2 : object[toKey(path[index])];
						if (value === undefined2) {
						  index = length;
						  value = defaultValue;
						}
						object = isFunction5(value) ? value.call(object) : value;
					 }
					 return object;
				  }
				  function set3(object, path, value) {
					 return object == null ? object : baseSet(object, path, value);
				  }
				  function setWith(object, path, value, customizer) {
					 customizer = typeof customizer == "function" ? customizer : undefined2;
					 return object == null ? object : baseSet(object, path, value, customizer);
				  }
				  var toPairs = createToPairs(keys);
				  var toPairsIn = createToPairs(keysIn);
				  function transform2(object, iteratee2, accumulator) {
					 var isArr = isArray2(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
					 iteratee2 = getIteratee(iteratee2, 4);
					 if (accumulator == null) {
						var Ctor = object && object.constructor;
						if (isArrLike) {
						  accumulator = isArr ? new Ctor() : [];
						} else if (isObject2(object)) {
						  accumulator = isFunction5(Ctor) ? baseCreate(getPrototype(object)) : {};
						} else {
						  accumulator = {};
						}
					 }
					 (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
						return iteratee2(accumulator, value, index, object2);
					 });
					 return accumulator;
				  }
				  function unset(object, path) {
					 return object == null ? true : baseUnset(object, path);
				  }
				  function update(object, path, updater) {
					 return object == null ? object : baseUpdate(object, path, castFunction(updater));
				  }
				  function updateWith(object, path, updater, customizer) {
					 customizer = typeof customizer == "function" ? customizer : undefined2;
					 return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
				  }
				  function values(object) {
					 return object == null ? [] : baseValues(object, keys(object));
				  }
				  function valuesIn(object) {
					 return object == null ? [] : baseValues(object, keysIn(object));
				  }
				  function clamp(number5, lower2, upper) {
					 if (upper === undefined2) {
						upper = lower2;
						lower2 = undefined2;
					 }
					 if (upper !== undefined2) {
						upper = toNumber2(upper);
						upper = upper === upper ? upper : 0;
					 }
					 if (lower2 !== undefined2) {
						lower2 = toNumber2(lower2);
						lower2 = lower2 === lower2 ? lower2 : 0;
					 }
					 return baseClamp(toNumber2(number5), lower2, upper);
				  }
				  function inRange(number5, start2, end) {
					 start2 = toFinite(start2);
					 if (end === undefined2) {
						end = start2;
						start2 = 0;
					 } else {
						end = toFinite(end);
					 }
					 number5 = toNumber2(number5);
					 return baseInRange(number5, start2, end);
				  }
				  function random(lower2, upper, floating) {
					 if (floating && typeof floating != "boolean" && isIterateeCall(lower2, upper, floating)) {
						upper = floating = undefined2;
					 }
					 if (floating === undefined2) {
						if (typeof upper == "boolean") {
						  floating = upper;
						  upper = undefined2;
						} else if (typeof lower2 == "boolean") {
						  floating = lower2;
						  lower2 = undefined2;
						}
					 }
					 if (lower2 === undefined2 && upper === undefined2) {
						lower2 = 0;
						upper = 1;
					 } else {
						lower2 = toFinite(lower2);
						if (upper === undefined2) {
						  upper = lower2;
						  lower2 = 0;
						} else {
						  upper = toFinite(upper);
						}
					 }
					 if (lower2 > upper) {
						var temp = lower2;
						lower2 = upper;
						upper = temp;
					 }
					 if (floating || lower2 % 1 || upper % 1) {
						var rand = nativeRandom();
						return nativeMin(lower2 + rand * (upper - lower2 + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
					 }
					 return baseRandom(lower2, upper);
				  }
				  var camelCase = createCompounder(function(result2, word, index) {
					 word = word.toLowerCase();
					 return result2 + (index ? capitalize(word) : word);
				  });
				  function capitalize(string) {
					 return upperFirst(toString(string).toLowerCase());
				  }
				  function deburr(string) {
					 string = toString(string);
					 return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
				  }
				  function endsWith(string, target, position) {
					 string = toString(string);
					 target = baseToString(target);
					 var length = string.length;
					 position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
					 var end = position;
					 position -= target.length;
					 return position >= 0 && string.slice(position, end) == target;
				  }
				  function escape(string) {
					 string = toString(string);
					 return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
				  }
				  function escapeRegExp(string) {
					 string = toString(string);
					 return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
				  }
				  var kebabCase = createCompounder(function(result2, word, index) {
					 return result2 + (index ? "-" : "") + word.toLowerCase();
				  });
				  var lowerCase = createCompounder(function(result2, word, index) {
					 return result2 + (index ? " " : "") + word.toLowerCase();
				  });
				  var lowerFirst = createCaseFirst("toLowerCase");
				  function pad2(string, length, chars) {
					 string = toString(string);
					 length = toInteger(length);
					 var strLength = length ? stringSize(string) : 0;
					 if (!length || strLength >= length) {
						return string;
					 }
					 var mid = (length - strLength) / 2;
					 return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
				  }
				  function padEnd(string, length, chars) {
					 string = toString(string);
					 length = toInteger(length);
					 var strLength = length ? stringSize(string) : 0;
					 return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
				  }
				  function padStart2(string, length, chars) {
					 string = toString(string);
					 length = toInteger(length);
					 var strLength = length ? stringSize(string) : 0;
					 return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
				  }
				  function parseInt2(string, radix, guard) {
					 if (guard || radix == null) {
						radix = 0;
					 } else if (radix) {
						radix = +radix;
					 }
					 return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
				  }
				  function repeat(string, n, guard) {
					 if (guard ? isIterateeCall(string, n, guard) : n === undefined2) {
						n = 1;
					 } else {
						n = toInteger(n);
					 }
					 return baseRepeat(toString(string), n);
				  }
				  function replace() {
					 var args = arguments, string = toString(args[0]);
					 return args.length < 3 ? string : string.replace(args[1], args[2]);
				  }
				  var snakeCase = createCompounder(function(result2, word, index) {
					 return result2 + (index ? "_" : "") + word.toLowerCase();
				  });
				  function split2(string, separator, limit) {
					 if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
						separator = limit = undefined2;
					 }
					 limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
					 if (!limit) {
						return [];
					 }
					 string = toString(string);
					 if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
						separator = baseToString(separator);
						if (!separator && hasUnicode(string)) {
						  return castSlice(stringToArray(string), 0, limit);
						}
					 }
					 return string.split(separator, limit);
				  }
				  var startCase = createCompounder(function(result2, word, index) {
					 return result2 + (index ? " " : "") + upperFirst(word);
				  });
				  function startsWith(string, target, position) {
					 string = toString(string);
					 position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
					 target = baseToString(target);
					 return string.slice(position, position + target.length) == target;
				  }
				  function template(string, options, guard) {
					 var settings = lodash.templateSettings;
					 if (guard && isIterateeCall(string, options, guard)) {
						options = undefined2;
					 }
					 string = toString(string);
					 options = assignInWith({}, options, settings, customDefaultsAssignIn);
					 var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
					 var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
					 var reDelimiters = RegExp2(
						(options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
						"g"
					 );
					 var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
					 string.replace(reDelimiters, function(match23, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
						interpolateValue || (interpolateValue = esTemplateValue);
						source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
						if (escapeValue) {
						  isEscaping = true;
						  source += "' +\n__e(" + escapeValue + ") +\n'";
						}
						if (evaluateValue) {
						  isEvaluating = true;
						  source += "';\n" + evaluateValue + ";\n__p += '";
						}
						if (interpolateValue) {
						  source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
						}
						index = offset + match23.length;
						return match23;
					 });
					 source += "';\n";
					 var variable = hasOwnProperty.call(options, "variable") && options.variable;
					 if (!variable) {
						source = "with (obj) {\n" + source + "\n}\n";
					 } else if (reForbiddenIdentifierChars.test(variable)) {
						throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
					 }
					 source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
					 source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
					 var result2 = attempt(function() {
						return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
					 });
					 result2.source = source;
					 if (isError(result2)) {
						throw result2;
					 }
					 return result2;
				  }
				  function toLower(value) {
					 return toString(value).toLowerCase();
				  }
				  function toUpper(value) {
					 return toString(value).toUpperCase();
				  }
				  function trim(string, chars, guard) {
					 string = toString(string);
					 if (string && (guard || chars === undefined2)) {
						return baseTrim(string);
					 }
					 if (!string || !(chars = baseToString(chars))) {
						return string;
					 }
					 var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start2 = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
					 return castSlice(strSymbols, start2, end).join("");
				  }
				  function trimEnd(string, chars, guard) {
					 string = toString(string);
					 if (string && (guard || chars === undefined2)) {
						return string.slice(0, trimmedEndIndex(string) + 1);
					 }
					 if (!string || !(chars = baseToString(chars))) {
						return string;
					 }
					 var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
					 return castSlice(strSymbols, 0, end).join("");
				  }
				  function trimStart(string, chars, guard) {
					 string = toString(string);
					 if (string && (guard || chars === undefined2)) {
						return string.replace(reTrimStart, "");
					 }
					 if (!string || !(chars = baseToString(chars))) {
						return string;
					 }
					 var strSymbols = stringToArray(string), start2 = charsStartIndex(strSymbols, stringToArray(chars));
					 return castSlice(strSymbols, start2).join("");
				  }
				  function truncate(string, options) {
					 var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
					 if (isObject2(options)) {
						var separator = "separator" in options ? options.separator : separator;
						length = "length" in options ? toInteger(options.length) : length;
						omission = "omission" in options ? baseToString(options.omission) : omission;
					 }
					 string = toString(string);
					 var strLength = string.length;
					 if (hasUnicode(string)) {
						var strSymbols = stringToArray(string);
						strLength = strSymbols.length;
					 }
					 if (length >= strLength) {
						return string;
					 }
					 var end = length - stringSize(omission);
					 if (end < 1) {
						return omission;
					 }
					 var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
					 if (separator === undefined2) {
						return result2 + omission;
					 }
					 if (strSymbols) {
						end += result2.length - end;
					 }
					 if (isRegExp(separator)) {
						if (string.slice(end).search(separator)) {
						  var match23, substring = result2;
						  if (!separator.copyGlobalForElem) {
							 separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
						  }
						  separator.lastIndex = 0;
						  while (match23 = separator.exec(substring)) {
							 var newEnd = match23.index;
						  }
						  result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
						}
					 } else if (string.indexOf(baseToString(separator), end) != end) {
						var index = result2.lastIndexOf(separator);
						if (index > -1) {
						  result2 = result2.slice(0, index);
						}
					 }
					 return result2 + omission;
				  }
				  function unescape(string) {
					 string = toString(string);
					 return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
				  }
				  var upperCase = createCompounder(function(result2, word, index) {
					 return result2 + (index ? " " : "") + word.toUpperCase();
				  });
				  var upperFirst = createCaseFirst("toUpperCase");
				  function words(string, pattern, guard) {
					 string = toString(string);
					 pattern = guard ? undefined2 : pattern;
					 if (pattern === undefined2) {
						return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
					 }
					 return string.match(pattern) || [];
				  }
				  var attempt = baseRest(function(func, args) {
					 try {
						return apply(func, undefined2, args);
					 } catch (e) {
						return isError(e) ? e : new Error2(e);
					 }
				  });
				  var bindAll = flatRest(function(object, methodNames) {
					 arrayEach(methodNames, function(key) {
						key = toKey(key);
						baseAssignValue(object, key, bind2(object[key], object));
					 });
					 return object;
				  });
				  function cond(pairs) {
					 var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
					 pairs = !length ? [] : arrayMap(pairs, function(pair) {
						if (typeof pair[1] != "function") {
						  throw new TypeError2(FUNC_ERROR_TEXT);
						}
						return [toIteratee(pair[0]), pair[1]];
					 });
					 return baseRest(function(args) {
						var index = -1;
						while (++index < length) {
						  var pair = pairs[index];
						  if (apply(pair[0], this, args)) {
							 return apply(pair[1], this, args);
						  }
						}
					 });
				  }
				  function conforms(source) {
					 return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
				  }
				  function constant(value) {
					 return function() {
						return value;
					 };
				  }
				  function defaultTo(value, defaultValue) {
					 return value == null || value !== value ? defaultValue : value;
				  }
				  var flow = createFlow();
				  var flowRight = createFlow(true);
				  function identity5(value) {
					 return value;
				  }
				  function iteratee(func) {
					 return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
				  }
				  function matches(source) {
					 return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
				  }
				  function matchesProperty(path, srcValue) {
					 return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
				  }
				  var method = baseRest(function(path, args) {
					 return function(object) {
						return baseInvoke(object, path, args);
					 };
				  });
				  var methodOf = baseRest(function(object, args) {
					 return function(path) {
						return baseInvoke(object, path, args);
					 };
				  });
				  function mixin(object, source, options) {
					 var props = keys(source), methodNames = baseFunctions(source, props);
					 if (options == null && !(isObject2(source) && (methodNames.length || !props.length))) {
						options = source;
						source = object;
						object = this;
						methodNames = baseFunctions(source, keys(source));
					 }
					 var chain2 = !(isObject2(options) && "chain" in options) || !!options.chain, isFunc = isFunction5(object);
					 arrayEach(methodNames, function(methodName) {
						var func = source[methodName];
						object[methodName] = func;
						if (isFunc) {
						  object.prototype[methodName] = function() {
							 var chainAll = this.__chain__;
							 if (chain2 || chainAll) {
								var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
								actions.push({ "func": func, "args": arguments, "thisArg": object });
								result2.__chain__ = chainAll;
								return result2;
							 }
							 return func.apply(object, arrayPush([this.value()], arguments));
						  };
						}
					 });
					 return object;
				  }
				  function noConflict() {
					 if (root2._ === this) {
						root2._ = oldDash;
					 }
					 return this;
				  }
				  function noop5() {
				  }
				  function nthArg(n) {
					 n = toInteger(n);
					 return baseRest(function(args) {
						return baseNth(args, n);
					 });
				  }
				  var over2 = createOver(arrayMap);
				  var overEvery = createOver(arrayEvery);
				  var overSome = createOver(arraySome);
				  function property(path) {
					 return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
				  }
				  function propertyOf(object) {
					 return function(path) {
						return object == null ? undefined2 : baseGet(object, path);
					 };
				  }
				  var range = createRange();
				  var rangeRight = createRange(true);
				  function stubArray() {
					 return [];
				  }
				  function stubFalse() {
					 return false;
				  }
				  function stubObject() {
					 return {};
				  }
				  function stubString() {
					 return "";
				  }
				  function stubTrue() {
					 return true;
				  }
				  function times(n, iteratee2) {
					 n = toInteger(n);
					 if (n < 1 || n > MAX_SAFE_INTEGER) {
						return [];
					 }
					 var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
					 iteratee2 = getIteratee(iteratee2);
					 n -= MAX_ARRAY_LENGTH;
					 var result2 = baseTimes(length, iteratee2);
					 while (++index < n) {
						iteratee2(index);
					 }
					 return result2;
				  }
				  function toPath(value) {
					 if (isArray2(value)) {
						return arrayMap(value, toKey);
					 }
					 return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
				  }
				  function uniqueId2(prefix) {
					 var id3 = ++idCounter;
					 return toString(prefix) + id3;
				  }
				  var add2 = createMathOperation(function(augend, addend) {
					 return augend + addend;
				  }, 0);
				  var ceil = createRound("ceil");
				  var divide = createMathOperation(function(dividend, divisor) {
					 return dividend / divisor;
				  }, 1);
				  var floor = createRound("floor");
				  function max3(array2) {
					 return array2 && array2.length ? baseExtremum(array2, identity5, baseGt) : undefined2;
				  }
				  function maxBy(array2, iteratee2) {
					 return array2 && array2.length ? baseExtremum(array2, getIteratee(iteratee2, 2), baseGt) : undefined2;
				  }
				  function mean(array2) {
					 return baseMean(array2, identity5);
				  }
				  function meanBy(array2, iteratee2) {
					 return baseMean(array2, getIteratee(iteratee2, 2));
				  }
				  function min3(array2) {
					 return array2 && array2.length ? baseExtremum(array2, identity5, baseLt) : undefined2;
				  }
				  function minBy(array2, iteratee2) {
					 return array2 && array2.length ? baseExtremum(array2, getIteratee(iteratee2, 2), baseLt) : undefined2;
				  }
				  var multiply = createMathOperation(function(multiplier, multiplicand) {
					 return multiplier * multiplicand;
				  }, 1);
				  var round2 = createRound("round");
				  var subtract = createMathOperation(function(minuend, subtrahend) {
					 return minuend - subtrahend;
				  }, 0);
				  function sum(array2) {
					 return array2 && array2.length ? baseSum(array2, identity5) : 0;
				  }
				  function sumBy(array2, iteratee2) {
					 return array2 && array2.length ? baseSum(array2, getIteratee(iteratee2, 2)) : 0;
				  }
				  lodash.after = after;
				  lodash.ary = ary;
				  lodash.assign = assign2;
				  lodash.assignIn = assignIn;
				  lodash.assignInWith = assignInWith;
				  lodash.assignWith = assignWith;
				  lodash.at = at;
				  lodash.before = before;
				  lodash.bind = bind2;
				  lodash.bindAll = bindAll;
				  lodash.bindKey = bindKey2;
				  lodash.castArray = castArray;
				  lodash.chain = chain;
				  lodash.chunk = chunk;
				  lodash.compact = compact;
				  lodash.concat = concat;
				  lodash.cond = cond;
				  lodash.conforms = conforms;
				  lodash.constant = constant;
				  lodash.countBy = countBy;
				  lodash.create = create2;
				  lodash.curry = curry;
				  lodash.curryRight = curryRight;
				  lodash.debounce = debounce;
				  lodash.defaults = defaults;
				  lodash.defaultsDeep = defaultsDeep;
				  lodash.defer = defer;
				  lodash.delay = delay;
				  lodash.difference = difference2;
				  lodash.differenceBy = differenceBy;
				  lodash.differenceWith = differenceWith;
				  lodash.drop = drop;
				  lodash.dropRight = dropRight;
				  lodash.dropRightWhile = dropRightWhile;
				  lodash.dropWhile = dropWhile;
				  lodash.fill = fill;
				  lodash.filter = filter2;
				  lodash.flatMap = flatMap2;
				  lodash.flatMapDeep = flatMapDeep;
				  lodash.flatMapDepth = flatMapDepth;
				  lodash.flatten = flatten2;
				  lodash.flattenDeep = flattenDeep;
				  lodash.flattenDepth = flattenDepth;
				  lodash.flip = flip;
				  lodash.flow = flow;
				  lodash.flowRight = flowRight;
				  lodash.fromPairs = fromPairs;
				  lodash.functions = functions;
				  lodash.functionsIn = functionsIn;
				  lodash.groupBy = groupBy2;
				  lodash.initial = initial;
				  lodash.intersection = intersection;
				  lodash.intersectionBy = intersectionBy;
				  lodash.intersectionWith = intersectionWith;
				  lodash.invert = invert;
				  lodash.invertBy = invertBy;
				  lodash.invokeMap = invokeMap;
				  lodash.iteratee = iteratee;
				  lodash.keyBy = keyBy;
				  lodash.keys = keys;
				  lodash.keysIn = keysIn;
				  lodash.map = map3;
				  lodash.mapKeys = mapKeys;
				  lodash.mapValues = mapValues;
				  lodash.matches = matches;
				  lodash.matchesProperty = matchesProperty;
				  lodash.memoize = memoize;
				  lodash.merge = merge3;
				  lodash.mergeWith = mergeWith;
				  lodash.method = method;
				  lodash.methodOf = methodOf;
				  lodash.mixin = mixin;
				  lodash.negate = negate;
				  lodash.nthArg = nthArg;
				  lodash.omit = omit;
				  lodash.omitBy = omitBy;
				  lodash.once = once;
				  lodash.orderBy = orderBy2;
				  lodash.over = over2;
				  lodash.overArgs = overArgs;
				  lodash.overEvery = overEvery;
				  lodash.overSome = overSome;
				  lodash.partial = partial;
				  lodash.partialRight = partialRight;
				  lodash.partition = partition;
				  lodash.pick = pick;
				  lodash.pickBy = pickBy;
				  lodash.property = property;
				  lodash.propertyOf = propertyOf;
				  lodash.pull = pull;
				  lodash.pullAll = pullAll;
				  lodash.pullAllBy = pullAllBy;
				  lodash.pullAllWith = pullAllWith;
				  lodash.pullAt = pullAt;
				  lodash.range = range;
				  lodash.rangeRight = rangeRight;
				  lodash.rearg = rearg;
				  lodash.reject = reject;
				  lodash.remove = remove4;
				  lodash.rest = rest;
				  lodash.reverse = reverse;
				  lodash.sampleSize = sampleSize;
				  lodash.set = set3;
				  lodash.setWith = setWith;
				  lodash.shuffle = shuffle;
				  lodash.slice = slice;
				  lodash.sortBy = sortBy2;
				  lodash.sortedUniq = sortedUniq;
				  lodash.sortedUniqBy = sortedUniqBy;
				  lodash.split = split2;
				  lodash.spread = spread;
				  lodash.tail = tail;
				  lodash.take = take;
				  lodash.takeRight = takeRight;
				  lodash.takeRightWhile = takeRightWhile;
				  lodash.takeWhile = takeWhile;
				  lodash.tap = tap;
				  lodash.throttle = throttle;
				  lodash.thru = thru;
				  lodash.toArray = toArray;
				  lodash.toPairs = toPairs;
				  lodash.toPairsIn = toPairsIn;
				  lodash.toPath = toPath;
				  lodash.toPlainObject = toPlainObject;
				  lodash.transform = transform2;
				  lodash.unary = unary;
				  lodash.union = union;
				  lodash.unionBy = unionBy2;
				  lodash.unionWith = unionWith;
				  lodash.uniq = uniq2;
				  lodash.uniqBy = uniqBy2;
				  lodash.uniqWith = uniqWith;
				  lodash.unset = unset;
				  lodash.unzip = unzip;
				  lodash.unzipWith = unzipWith;
				  lodash.update = update;
				  lodash.updateWith = updateWith;
				  lodash.values = values;
				  lodash.valuesIn = valuesIn;
				  lodash.without = without;
				  lodash.words = words;
				  lodash.wrap = wrap;
				  lodash.xor = xor;
				  lodash.xorBy = xorBy;
				  lodash.xorWith = xorWith;
				  lodash.zip = zip;
				  lodash.zipObject = zipObject;
				  lodash.zipObjectDeep = zipObjectDeep;
				  lodash.zipWith = zipWith;
				  lodash.entries = toPairs;
				  lodash.entriesIn = toPairsIn;
				  lodash.extend = assignIn;
				  lodash.extendWith = assignInWith;
				  mixin(lodash, lodash);
				  lodash.add = add2;
				  lodash.attempt = attempt;
				  lodash.camelCase = camelCase;
				  lodash.capitalize = capitalize;
				  lodash.ceil = ceil;
				  lodash.clamp = clamp;
				  lodash.clone = clone2;
				  lodash.cloneDeep = cloneDeep2;
				  lodash.cloneDeepWith = cloneDeepWith;
				  lodash.cloneWith = cloneWith;
				  lodash.conformsTo = conformsTo;
				  lodash.deburr = deburr;
				  lodash.defaultTo = defaultTo;
				  lodash.divide = divide;
				  lodash.endsWith = endsWith;
				  lodash.eq = eq;
				  lodash.escape = escape;
				  lodash.escapeRegExp = escapeRegExp;
				  lodash.every = every;
				  lodash.find = find3;
				  lodash.findIndex = findIndex3;
				  lodash.findKey = findKey2;
				  lodash.findLast = findLast;
				  lodash.findLastIndex = findLastIndex;
				  lodash.findLastKey = findLastKey;
				  lodash.floor = floor;
				  lodash.forEach = forEach2;
				  lodash.forEachRight = forEachRight2;
				  lodash.forIn = forIn;
				  lodash.forInRight = forInRight;
				  lodash.forOwn = forOwn;
				  lodash.forOwnRight = forOwnRight;
				  lodash.get = get4;
				  lodash.gt = gt;
				  lodash.gte = gte;
				  lodash.has = has;
				  lodash.hasIn = hasIn;
				  lodash.head = head;
				  lodash.identity = identity5;
				  lodash.includes = includes2;
				  lodash.indexOf = indexOf2;
				  lodash.inRange = inRange;
				  lodash.invoke = invoke;
				  lodash.isArguments = isArguments;
				  lodash.isArray = isArray2;
				  lodash.isArrayBuffer = isArrayBuffer;
				  lodash.isArrayLike = isArrayLike2;
				  lodash.isArrayLikeObject = isArrayLikeObject;
				  lodash.isBoolean = isBoolean;
				  lodash.isBuffer = isBuffer;
				  lodash.isDate = isDate3;
				  lodash.isElement = isElement2;
				  lodash.isEmpty = isEmpty2;
				  lodash.isEqual = isEqual2;
				  lodash.isEqualWith = isEqualWith;
				  lodash.isError = isError;
				  lodash.isFinite = isFinite2;
				  lodash.isFunction = isFunction5;
				  lodash.isInteger = isInteger;
				  lodash.isLength = isLength;
				  lodash.isMap = isMap;
				  lodash.isMatch = isMatch;
				  lodash.isMatchWith = isMatchWith;
				  lodash.isNaN = isNaN2;
				  lodash.isNative = isNative;
				  lodash.isNil = isNil2;
				  lodash.isNull = isNull2;
				  lodash.isNumber = isNumber3;
				  lodash.isObject = isObject2;
				  lodash.isObjectLike = isObjectLike;
				  lodash.isPlainObject = isPlainObject;
				  lodash.isRegExp = isRegExp;
				  lodash.isSafeInteger = isSafeInteger;
				  lodash.isSet = isSet;
				  lodash.isString = isString2;
				  lodash.isSymbol = isSymbol;
				  lodash.isTypedArray = isTypedArray;
				  lodash.isUndefined = isUndefined2;
				  lodash.isWeakMap = isWeakMap;
				  lodash.isWeakSet = isWeakSet;
				  lodash.join = join;
				  lodash.kebabCase = kebabCase;
				  lodash.last = last2;
				  lodash.lastIndexOf = lastIndexOf;
				  lodash.lowerCase = lowerCase;
				  lodash.lowerFirst = lowerFirst;
				  lodash.lt = lt2;
				  lodash.lte = lte;
				  lodash.max = max3;
				  lodash.maxBy = maxBy;
				  lodash.mean = mean;
				  lodash.meanBy = meanBy;
				  lodash.min = min3;
				  lodash.minBy = minBy;
				  lodash.stubArray = stubArray;
				  lodash.stubFalse = stubFalse;
				  lodash.stubObject = stubObject;
				  lodash.stubString = stubString;
				  lodash.stubTrue = stubTrue;
				  lodash.multiply = multiply;
				  lodash.nth = nth;
				  lodash.noConflict = noConflict;
				  lodash.noop = noop5;
				  lodash.now = now2;
				  lodash.pad = pad2;
				  lodash.padEnd = padEnd;
				  lodash.padStart = padStart2;
				  lodash.parseInt = parseInt2;
				  lodash.random = random;
				  lodash.reduce = reduce;
				  lodash.reduceRight = reduceRight;
				  lodash.repeat = repeat;
				  lodash.replace = replace;
				  lodash.result = result;
				  lodash.round = round2;
				  lodash.runInContext = runInContext2;
				  lodash.sample = sample;
				  lodash.size = size;
				  lodash.snakeCase = snakeCase;
				  lodash.some = some;
				  lodash.sortedIndex = sortedIndex;
				  lodash.sortedIndexBy = sortedIndexBy;
				  lodash.sortedIndexOf = sortedIndexOf;
				  lodash.sortedLastIndex = sortedLastIndex;
				  lodash.sortedLastIndexBy = sortedLastIndexBy;
				  lodash.sortedLastIndexOf = sortedLastIndexOf;
				  lodash.startCase = startCase;
				  lodash.startsWith = startsWith;
				  lodash.subtract = subtract;
				  lodash.sum = sum;
				  lodash.sumBy = sumBy;
				  lodash.template = template;
				  lodash.times = times;
				  lodash.toFinite = toFinite;
				  lodash.toInteger = toInteger;
				  lodash.toLength = toLength;
				  lodash.toLower = toLower;
				  lodash.toNumber = toNumber2;
				  lodash.toSafeInteger = toSafeInteger;
				  lodash.toString = toString;
				  lodash.toUpper = toUpper;
				  lodash.trim = trim;
				  lodash.trimEnd = trimEnd;
				  lodash.trimStart = trimStart;
				  lodash.truncate = truncate;
				  lodash.unescape = unescape;
				  lodash.uniqueId = uniqueId2;
				  lodash.upperCase = upperCase;
				  lodash.upperFirst = upperFirst;
				  lodash.each = forEach2;
				  lodash.eachRight = forEachRight2;
				  lodash.first = head;
				  mixin(lodash, function() {
					 var source = {};
					 baseForOwn(lodash, function(func, methodName) {
						if (!hasOwnProperty.call(lodash.prototype, methodName)) {
						  source[methodName] = func;
						}
					 });
					 return source;
				  }(), { "chain": false });
				  lodash.VERSION = VERSION5;
				  arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
					 lodash[methodName].placeholder = lodash;
				  });
				  arrayEach(["drop", "take"], function(methodName, index) {
					 LazyWrapper.prototype[methodName] = function(n) {
						n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);
						var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
						if (result2.__filtered__) {
						  result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
						} else {
						  result2.__views__.push({
							 "size": nativeMin(n, MAX_ARRAY_LENGTH),
							 "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
						  });
						}
						return result2;
					 };
					 LazyWrapper.prototype[methodName + "Right"] = function(n) {
						return this.reverse()[methodName](n).reverse();
					 };
				  });
				  arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
					 var type2 = index + 1, isFilter = type2 == LAZY_FILTER_FLAG || type2 == LAZY_WHILE_FLAG;
					 LazyWrapper.prototype[methodName] = function(iteratee2) {
						var result2 = this.clone();
						result2.__iteratees__.push({
						  "iteratee": getIteratee(iteratee2, 3),
						  "type": type2
						});
						result2.__filtered__ = result2.__filtered__ || isFilter;
						return result2;
					 };
				  });
				  arrayEach(["head", "last"], function(methodName, index) {
					 var takeName = "take" + (index ? "Right" : "");
					 LazyWrapper.prototype[methodName] = function() {
						return this[takeName](1).value()[0];
					 };
				  });
				  arrayEach(["initial", "tail"], function(methodName, index) {
					 var dropName = "drop" + (index ? "" : "Right");
					 LazyWrapper.prototype[methodName] = function() {
						return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
					 };
				  });
				  LazyWrapper.prototype.compact = function() {
					 return this.filter(identity5);
				  };
				  LazyWrapper.prototype.find = function(predicate) {
					 return this.filter(predicate).head();
				  };
				  LazyWrapper.prototype.findLast = function(predicate) {
					 return this.reverse().find(predicate);
				  };
				  LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
					 if (typeof path == "function") {
						return new LazyWrapper(this);
					 }
					 return this.map(function(value) {
						return baseInvoke(value, path, args);
					 });
				  });
				  LazyWrapper.prototype.reject = function(predicate) {
					 return this.filter(negate(getIteratee(predicate)));
				  };
				  LazyWrapper.prototype.slice = function(start2, end) {
					 start2 = toInteger(start2);
					 var result2 = this;
					 if (result2.__filtered__ && (start2 > 0 || end < 0)) {
						return new LazyWrapper(result2);
					 }
					 if (start2 < 0) {
						result2 = result2.takeRight(-start2);
					 } else if (start2) {
						result2 = result2.drop(start2);
					 }
					 if (end !== undefined2) {
						end = toInteger(end);
						result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start2);
					 }
					 return result2;
				  };
				  LazyWrapper.prototype.takeRightWhile = function(predicate) {
					 return this.reverse().takeWhile(predicate).reverse();
				  };
				  LazyWrapper.prototype.toArray = function() {
					 return this.take(MAX_ARRAY_LENGTH);
				  };
				  baseForOwn(LazyWrapper.prototype, function(func, methodName) {
					 var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
					 if (!lodashFunc) {
						return;
					 }
					 lodash.prototype[methodName] = function() {
						var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray2(value);
						var interceptor = function(value2) {
						  var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
						  return isTaker && chainAll ? result3[0] : result3;
						};
						if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
						  isLazy = useLazy = false;
						}
						var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
						if (!retUnwrapped && useLazy) {
						  value = onlyLazy ? value : new LazyWrapper(this);
						  var result2 = func.apply(value, args);
						  result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
						  return new LodashWrapper(result2, chainAll);
						}
						if (isUnwrapped && onlyLazy) {
						  return func.apply(this, args);
						}
						result2 = this.thru(interceptor);
						return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
					 };
				  });
				  arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
					 var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
					 lodash.prototype[methodName] = function() {
						var args = arguments;
						if (retUnwrapped && !this.__chain__) {
						  var value = this.value();
						  return func.apply(isArray2(value) ? value : [], args);
						}
						return this[chainName](function(value2) {
						  return func.apply(isArray2(value2) ? value2 : [], args);
						});
					 };
				  });
				  baseForOwn(LazyWrapper.prototype, function(func, methodName) {
					 var lodashFunc = lodash[methodName];
					 if (lodashFunc) {
						var key = lodashFunc.name + "";
						if (!hasOwnProperty.call(realNames, key)) {
						  realNames[key] = [];
						}
						realNames[key].push({ "name": methodName, "func": lodashFunc });
					 }
				  });
				  realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
					 "name": "wrapper",
					 "func": undefined2
				  }];
				  LazyWrapper.prototype.clone = lazyClone;
				  LazyWrapper.prototype.reverse = lazyReverse;
				  LazyWrapper.prototype.value = lazyValue;
				  lodash.prototype.at = wrapperAt;
				  lodash.prototype.chain = wrapperChain;
				  lodash.prototype.commit = wrapperCommit;
				  lodash.prototype.next = wrapperNext;
				  lodash.prototype.plant = wrapperPlant;
				  lodash.prototype.reverse = wrapperReverse;
				  lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
				  lodash.prototype.first = lodash.prototype.head;
				  if (symIterator) {
					 lodash.prototype[symIterator] = wrapperToIterator;
				  }
				  return lodash;
				};
				var _2 = runInContext();
				if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
				  root2._ = _2;
				  define(function() {
					 return _2;
				  });
				} else if (freeModule) {
				  (freeModule.exports = _2)._ = _2;
				  freeExports._ = _2;
				} else {
				  root2._ = _2;
				}
			 }).call(exports);
		  }
		});

		// node_modules/jquery/dist/jquery.js
		var require_jquery = __commonJS({
		  "node_modules/jquery/dist/jquery.js"(exports, module) {
			 "use strict";
			 (function(global3, factory) {
				"use strict";
				if (typeof module === "object" && typeof module.exports === "object") {
				  module.exports = global3.document ? factory(global3, true) : function(w) {
					 if (!w.document) {
						throw new Error("jQuery requires a window with a document");
					 }
					 return factory(w);
				  };
				} else {
				  factory(global3);
				}
			 })(typeof window !== "undefined" ? window : exports, function(window2, noGlobal) {
				"use strict";
				var arr = [];
				var getProto = Object.getPrototypeOf;
				var slice = arr.slice;
				var flat = arr.flat ? function(array2) {
				  return arr.flat.call(array2);
				} : function(array2) {
				  return arr.concat.apply([], array2);
				};
				var push = arr.push;
				var indexOf2 = arr.indexOf;
				var class2type = {};
				var toString = class2type.toString;
				var hasOwn = class2type.hasOwnProperty;
				var fnToString = hasOwn.toString;
				var ObjectFunctionString = fnToString.call(Object);
				var support = {};
				var isFunction5 = function isFunction6(obj) {
				  return typeof obj === "function" && typeof obj.nodeType !== "number" && typeof obj.item !== "function";
				};
				var isWindow = function isWindow2(obj) {
				  return obj != null && obj === obj.window;
				};
				var document2 = window2.document;
				var preservedScriptAttributes = {
				  type: true,
				  src: true,
				  nonce: true,
				  noModule: true
				};
				function DOMEval(code, node, doc) {
				  doc = doc || document2;
				  var i, val, script = doc.createElement("script");
				  script.text = code;
				  if (node) {
					 for (i in preservedScriptAttributes) {
						val = node[i] || node.getAttribute && node.getAttribute(i);
						if (val) {
						  script.setAttribute(i, val);
						}
					 }
				  }
				  doc.head.appendChild(script).parentNode.removeChild(script);
				}
				function toType(obj) {
				  if (obj == null) {
					 return obj + "";
				  }
				  return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
				}
				var version = "3.7.1", rhtmlSuffix = /HTML$/i, jQuery = function(selector, context2) {
				  return new jQuery.fn.init(selector, context2);
				};
				jQuery.fn = jQuery.prototype = {
				  // The current version of jQuery being used
				  jquery: version,
				  constructor: jQuery,
				  // The default length of a jQuery object is 0
				  length: 0,
				  toArray: function() {
					 return slice.call(this);
				  },
				  // Get the Nth element in the matched element set OR
				  // Get the whole matched element set as a clean array
				  get: function(num) {
					 if (num == null) {
						return slice.call(this);
					 }
					 return num < 0 ? this[num + this.length] : this[num];
				  },
				  // Take an array of elements and push it onto the stack
				  // (returning the new matched element set)
				  pushStack: function(elems) {
					 var ret = jQuery.merge(this.constructor(), elems);
					 ret.prevObject = this;
					 return ret;
				  },
				  // Execute a callback for every element in the matched set.
				  each: function(callback) {
					 return jQuery.each(this, callback);
				  },
				  map: function(callback) {
					 return this.pushStack(jQuery.map(this, function(elem2, i) {
						return callback.call(elem2, i, elem2);
					 }));
				  },
				  slice: function() {
					 return this.pushStack(slice.apply(this, arguments));
				  },
				  first: function() {
					 return this.eq(0);
				  },
				  last: function() {
					 return this.eq(-1);
				  },
				  even: function() {
					 return this.pushStack(jQuery.grep(this, function(_elem, i) {
						return (i + 1) % 2;
					 }));
				  },
				  odd: function() {
					 return this.pushStack(jQuery.grep(this, function(_elem, i) {
						return i % 2;
					 }));
				  },
				  eq: function(i) {
					 var len = this.length, j = +i + (i < 0 ? len : 0);
					 return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
				  },
				  end: function() {
					 return this.prevObject || this.constructor();
				  },
				  // For internal use only.
				  // Behaves like an Array's method, not like a jQuery method.
				  push,
				  sort: arr.sort,
				  splice: arr.splice
				};
				jQuery.extend = jQuery.fn.extend = function() {
				  var options, name, src, copy2, copyIsArray, clone2, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
				  if (typeof target === "boolean") {
					 deep = target;
					 target = arguments[i] || {};
					 i++;
				  }
				  if (typeof target !== "object" && !isFunction5(target)) {
					 target = {};
				  }
				  if (i === length) {
					 target = this;
					 i--;
				  }
				  for (; i < length; i++) {
					 if ((options = arguments[i]) != null) {
						for (name in options) {
						  copy2 = options[name];
						  if (name === "__proto__" || target === copy2) {
							 continue;
						  }
						  if (deep && copy2 && (jQuery.isPlainObject(copy2) || (copyIsArray = Array.isArray(copy2)))) {
							 src = target[name];
							 if (copyIsArray && !Array.isArray(src)) {
								clone2 = [];
							 } else if (!copyIsArray && !jQuery.isPlainObject(src)) {
								clone2 = {};
							 } else {
								clone2 = src;
							 }
							 copyIsArray = false;
							 target[name] = jQuery.extend(deep, clone2, copy2);
						  } else if (copy2 !== void 0) {
							 target[name] = copy2;
						  }
						}
					 }
				  }
				  return target;
				};
				jQuery.extend({
				  // Unique for each copy of jQuery on the page
				  expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
				  // Assume jQuery is ready without the ready module
				  isReady: true,
				  error: function(msg) {
					 throw new Error(msg);
				  },
				  noop: function() {
				  },
				  isPlainObject: function(obj) {
					 var proto, Ctor;
					 if (!obj || toString.call(obj) !== "[object Object]") {
						return false;
					 }
					 proto = getProto(obj);
					 if (!proto) {
						return true;
					 }
					 Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
					 return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
				  },
				  isEmptyObject: function(obj) {
					 var name;
					 for (name in obj) {
						return false;
					 }
					 return true;
				  },
				  // Evaluates a script in a provided context; falls back to the copyGlobalForElem one
				  // if not specified.
				  globalEval: function(code, options, doc) {
					 DOMEval(code, { nonce: options && options.nonce }, doc);
				  },
				  each: function(obj, callback) {
					 var length, i = 0;
					 if (isArrayLike2(obj)) {
						length = obj.length;
						for (; i < length; i++) {
						  if (callback.call(obj[i], i, obj[i]) === false) {
							 break;
						  }
						}
					 } else {
						for (i in obj) {
						  if (callback.call(obj[i], i, obj[i]) === false) {
							 break;
						  }
						}
					 }
					 return obj;
				  },
				  // Retrieve the text value of an array of DOM nodes
				  text: function(elem2) {
					 var node, ret = "", i = 0, nodeType = elem2.nodeType;
					 if (!nodeType) {
						while (node = elem2[i++]) {
						  ret += jQuery.text(node);
						}
					 }
					 if (nodeType === 1 || nodeType === 11) {
						return elem2.textContent;
					 }
					 if (nodeType === 9) {
						return elem2.documentElement.textContent;
					 }
					 if (nodeType === 3 || nodeType === 4) {
						return elem2.nodeValue;
					 }
					 return ret;
				  },
				  // results is for internal usage only
				  makeArray: function(arr2, results) {
					 var ret = results || [];
					 if (arr2 != null) {
						if (isArrayLike2(Object(arr2))) {
						  jQuery.merge(
							 ret,
							 typeof arr2 === "string" ? [arr2] : arr2
						  );
						} else {
						  push.call(ret, arr2);
						}
					 }
					 return ret;
				  },
				  inArray: function(elem2, arr2, i) {
					 return arr2 == null ? -1 : indexOf2.call(arr2, elem2, i);
				  },
				  isXMLDoc: function(elem2) {
					 var namespace = elem2 && elem2.namespaceURI, docElem = elem2 && (elem2.ownerDocument || elem2).documentElement;
					 return !rhtmlSuffix.test(namespace || docElem && docElem.nodeName || "HTML");
				  },
				  // Support: Android <=4.0 only, PhantomJS 1 only
				  // push.apply(_, arraylike) throws on ancient WebKit
				  merge: function(first2, second2) {
					 var len = +second2.length, j = 0, i = first2.length;
					 for (; j < len; j++) {
						first2[i++] = second2[j];
					 }
					 first2.length = i;
					 return first2;
				  },
				  grep: function(elems, callback, invert) {
					 var callbackInverse, matches = [], i = 0, length = elems.length, callbackExpect = !invert;
					 for (; i < length; i++) {
						callbackInverse = !callback(elems[i], i);
						if (callbackInverse !== callbackExpect) {
						  matches.push(elems[i]);
						}
					 }
					 return matches;
				  },
				  // arg is for internal usage only
				  map: function(elems, callback, arg) {
					 var length, value, i = 0, ret = [];
					 if (isArrayLike2(elems)) {
						length = elems.length;
						for (; i < length; i++) {
						  value = callback(elems[i], i, arg);
						  if (value != null) {
							 ret.push(value);
						  }
						}
					 } else {
						for (i in elems) {
						  value = callback(elems[i], i, arg);
						  if (value != null) {
							 ret.push(value);
						  }
						}
					 }
					 return flat(ret);
				  },
				  // A copyGlobalForElem GUID counter for objects
				  guid: 1,
				  // jQuery.support is not used in Core but other projects attach their
				  // properties to it so it needs to exist.
				  support
				});
				if (typeof Symbol === "function") {
				  jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
				}
				jQuery.each(
				  "Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),
				  function(_i, name) {
					 class2type["[object " + name + "]"] = name.toLowerCase();
				  }
				);
				function isArrayLike2(obj) {
				  var length = !!obj && "length" in obj && obj.length, type2 = toType(obj);
				  if (isFunction5(obj) || isWindow(obj)) {
					 return false;
				  }
				  return type2 === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
				}
				function nodeName(elem2, name) {
				  return elem2.nodeName && elem2.nodeName.toLowerCase() === name.toLowerCase();
				}
				var pop = arr.pop;
				var sort = arr.sort;
				var splice = arr.splice;
				var whitespace = "[\\x20\\t\\r\\n\\f]";
				var rtrimCSS = new RegExp(
				  "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$",
				  "g"
				);
				jQuery.contains = function(a, b) {
				  var bup = b && b.parentNode;
				  return a === bup || !!(bup && bup.nodeType === 1 && // Support: IE 9 - 11+
				  // IE doesn't have `contains` on SVG.
				  (a.contains ? a.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
				};
				var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;
				function fcssescape(ch, asCodePoint) {
				  if (asCodePoint) {
					 if (ch === "\0") {
						return "\uFFFD";
					 }
					 return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
				  }
				  return "\\" + ch;
				}
				jQuery.escapeSelector = function(sel) {
				  return (sel + "").replace(rcssescape, fcssescape);
				};
				var preferredDoc = document2, pushNative = push;
				(function() {
				  var i, Expr, outermostContext, sortInput, hasDuplicate, push2 = pushNative, document3, documentElement2, documentIsHTML, rbuggyQSA, matches, expando = jQuery.expando, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), nonnativeSelectorCache = createCache(), sortOrder = function(a, b) {
					 if (a === b) {
						hasDuplicate = true;
					 }
					 return 0;
				  }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+", attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + // Operator (capture 2)
				  "*([*^$|!~]?=)" + whitespace + // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
				  `*(?:'((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)"|(` + identifier + "))|)" + whitespace + "*\\]", pseudos = ":(" + identifier + `)(?:\\((('((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)")|((?:\\\\.|[^\\\\()[\\]]|` + attributes + ")*)|.*)\\)|)", rwhitespace = new RegExp(whitespace + "+", "g"), rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"), rleadingCombinator = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"), rdescend = new RegExp(whitespace + "|>"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
					 ID: new RegExp("^#(" + identifier + ")"),
					 CLASS: new RegExp("^\\.(" + identifier + ")"),
					 TAG: new RegExp("^(" + identifier + "|[*])"),
					 ATTR: new RegExp("^" + attributes),
					 PSEUDO: new RegExp("^" + pseudos),
					 CHILD: new RegExp(
						"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)",
						"i"
					 ),
					 bool: new RegExp("^(?:" + booleans + ")$", "i"),
					 // For use in libraries implementing .is()
					 // We use this for POS matching in `select`
					 needsContext: new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
				  }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rquickExpr2 = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, runescape = new RegExp("\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g"), funescape = function(escape, nonHex) {
					 var high = "0x" + escape.slice(1) - 65536;
					 if (nonHex) {
						return nonHex;
					 }
					 return high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
				  }, unloadHandler = function() {
					 setDocument2();
				  }, inDisabledFieldset = addCombinator(
					 function(elem2) {
						return elem2.disabled === true && nodeName(elem2, "fieldset");
					 },
					 { dir: "parentNode", next: "legend" }
				  );
				  function safeActiveElement() {
					 try {
						return document3.activeElement;
					 } catch (err) {
					 }
				  }
				  try {
					 push2.apply(
						arr = slice.call(preferredDoc.childNodes),
						preferredDoc.childNodes
					 );
					 arr[preferredDoc.childNodes.length].nodeType;
				  } catch (e) {
					 push2 = {
						apply: function(target, els) {
						  pushNative.apply(target, slice.call(els));
						},
						call: function(target) {
						  pushNative.apply(target, slice.call(arguments, 1));
						}
					 };
				  }
				  function find3(selector, context2, results, seed) {
					 var m, i2, elem2, nid, match23, groups, newSelector, newContext = context2 && context2.ownerDocument, nodeType = context2 ? context2.nodeType : 9;
					 results = results || [];
					 if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
						return results;
					 }
					 if (!seed) {
						setDocument2(context2);
						context2 = context2 || document3;
						if (documentIsHTML) {
						  if (nodeType !== 11 && (match23 = rquickExpr2.exec(selector))) {
							 if (m = match23[1]) {
								if (nodeType === 9) {
								  if (elem2 = context2.getElementById(m)) {
									 if (elem2.id === m) {
										push2.call(results, elem2);
										return results;
									 }
								  } else {
									 return results;
								  }
								} else {
								  if (newContext && (elem2 = newContext.getElementById(m)) && find3.contains(context2, elem2) && elem2.id === m) {
									 push2.call(results, elem2);
									 return results;
								  }
								}
							 } else if (match23[2]) {
								push2.apply(results, context2.getElementsByTagName(selector));
								return results;
							 } else if ((m = match23[3]) && context2.getElementsByClassName) {
								push2.apply(results, context2.getElementsByClassName(m));
								return results;
							 }
						  }
						  if (!nonnativeSelectorCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
							 newSelector = selector;
							 newContext = context2;
							 if (nodeType === 1 && (rdescend.test(selector) || rleadingCombinator.test(selector))) {
								newContext = rsibling.test(selector) && testContext(context2.parentNode) || context2;
								if (newContext != context2 || !support.scope) {
								  if (nid = context2.getAttribute("id")) {
									 nid = jQuery.escapeSelector(nid);
								  } else {
									 context2.setAttribute("id", nid = expando);
								  }
								}
								groups = tokenize(selector);
								i2 = groups.length;
								while (i2--) {
								  groups[i2] = (nid ? "#" + nid : ":scope") + " " + toSelector(groups[i2]);
								}
								newSelector = groups.join(",");
							 }
							 try {
								push2.apply(
								  results,
								  newContext.querySelectorAll(newSelector)
								);
								return results;
							 } catch (qsaError) {
								nonnativeSelectorCache(selector, true);
							 } finally {
								if (nid === expando) {
								  context2.removeAttribute("id");
								}
							 }
						  }
						}
					 }
					 return select(selector.replace(rtrimCSS, "$1"), context2, results, seed);
				  }
				  function createCache() {
					 var keys = [];
					 function cache(key, value) {
						if (keys.push(key + " ") > Expr.cacheLength) {
						  delete cache[keys.shift()];
						}
						return cache[key + " "] = value;
					 }
					 return cache;
				  }
				  function markFunction(fn) {
					 fn[expando] = true;
					 return fn;
				  }
				  function assert(fn) {
					 var el = document3.createElement("fieldset");
					 try {
						return !!fn(el);
					 } catch (e) {
						return false;
					 } finally {
						if (el.parentNode) {
						  el.parentNode.removeChild(el);
						}
						el = null;
					 }
				  }
				  function createInputPseudo(type2) {
					 return function(elem2) {
						return nodeName(elem2, "input") && elem2.type === type2;
					 };
				  }
				  function createButtonPseudo(type2) {
					 return function(elem2) {
						return (nodeName(elem2, "input") || nodeName(elem2, "button")) && elem2.type === type2;
					 };
				  }
				  function createDisabledPseudo(disabled) {
					 return function(elem2) {
						if ("form" in elem2) {
						  if (elem2.parentNode && elem2.disabled === false) {
							 if ("label" in elem2) {
								if ("label" in elem2.parentNode) {
								  return elem2.parentNode.disabled === disabled;
								} else {
								  return elem2.disabled === disabled;
								}
							 }
							 return elem2.isDisabled === disabled || // Where there is no isDisabled, check manually
							 elem2.isDisabled !== !disabled && inDisabledFieldset(elem2) === disabled;
						  }
						  return elem2.disabled === disabled;
						} else if ("label" in elem2) {
						  return elem2.disabled === disabled;
						}
						return false;
					 };
				  }
				  function createPositionalPseudo(fn) {
					 return markFunction(function(argument) {
						argument = +argument;
						return markFunction(function(seed, matches2) {
						  var j, matchIndexes = fn([], seed.length, argument), i2 = matchIndexes.length;
						  while (i2--) {
							 if (seed[j = matchIndexes[i2]]) {
								seed[j] = !(matches2[j] = seed[j]);
							 }
						  }
						});
					 });
				  }
				  function testContext(context2) {
					 return context2 && typeof context2.getElementsByTagName !== "undefined" && context2;
				  }
				  function setDocument2(node) {
					 var subWindow, doc = node ? node.ownerDocument || node : preferredDoc;
					 if (doc == document3 || doc.nodeType !== 9 || !doc.documentElement) {
						return document3;
					 }
					 document3 = doc;
					 documentElement2 = document3.documentElement;
					 documentIsHTML = !jQuery.isXMLDoc(document3);
					 matches = documentElement2.matches || documentElement2.webkitMatchesSelector || documentElement2.msMatchesSelector;
					 if (documentElement2.msMatchesSelector && // Support: IE 11+, Edge 17 - 18+
					 // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
					 // two documents; shallow comparisons work.
					 // eslint-disable-next-line eqeqeq
					 preferredDoc != document3 && (subWindow = document3.defaultView) && subWindow.top !== subWindow) {
						subWindow.addEventListener("unload", unloadHandler);
					 }
					 support.getById = assert(function(el) {
						documentElement2.appendChild(el).id = jQuery.expando;
						return !document3.getElementsByName || !document3.getElementsByName(jQuery.expando).length;
					 });
					 support.disconnectedMatch = assert(function(el) {
						return matches.call(el, "*");
					 });
					 support.scope = assert(function() {
						return document3.querySelectorAll(":scope");
					 });
					 support.cssHas = assert(function() {
						try {
						  document3.querySelector(":has(*,:jqfake)");
						  return false;
						} catch (e) {
						  return true;
						}
					 });
					 if (support.getById) {
						Expr.filter.ID = function(id3) {
						  var attrId = id3.replace(runescape, funescape);
						  return function(elem2) {
							 return elem2.getAttribute("id") === attrId;
						  };
						};
						Expr.find.ID = function(id3, context2) {
						  if (typeof context2.getElementById !== "undefined" && documentIsHTML) {
							 var elem2 = context2.getElementById(id3);
							 return elem2 ? [elem2] : [];
						  }
						};
					 } else {
						Expr.filter.ID = function(id3) {
						  var attrId = id3.replace(runescape, funescape);
						  return function(elem2) {
							 var node2 = typeof elem2.getAttributeNode !== "undefined" && elem2.getAttributeNode("id");
							 return node2 && node2.value === attrId;
						  };
						};
						Expr.find.ID = function(id3, context2) {
						  if (typeof context2.getElementById !== "undefined" && documentIsHTML) {
							 var node2, i2, elems, elem2 = context2.getElementById(id3);
							 if (elem2) {
								node2 = elem2.getAttributeNode("id");
								if (node2 && node2.value === id3) {
								  return [elem2];
								}
								elems = context2.getElementsByName(id3);
								i2 = 0;
								while (elem2 = elems[i2++]) {
								  node2 = elem2.getAttributeNode("id");
								  if (node2 && node2.value === id3) {
									 return [elem2];
								  }
								}
							 }
							 return [];
						  }
						};
					 }
					 Expr.find.TAG = function(tag, context2) {
						if (typeof context2.getElementsByTagName !== "undefined") {
						  return context2.getElementsByTagName(tag);
						} else {
						  return context2.querySelectorAll(tag);
						}
					 };
					 Expr.find.CLASS = function(className, context2) {
						if (typeof context2.getElementsByClassName !== "undefined" && documentIsHTML) {
						  return context2.getElementsByClassName(className);
						}
					 };
					 rbuggyQSA = [];
					 assert(function(el) {
						var input2;
						documentElement2.appendChild(el).innerHTML = "<a id='" + expando + "' href='' disabled='disabled'></a><select id='" + expando + "-\r\\' disabled='disabled'><option selected=''></option></select>";
						if (!el.querySelectorAll("[selected]").length) {
						  rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
						}
						if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
						  rbuggyQSA.push("~=");
						}
						if (!el.querySelectorAll("a#" + expando + "+*").length) {
						  rbuggyQSA.push(".#.+[+~]");
						}
						if (!el.querySelectorAll(":checked").length) {
						  rbuggyQSA.push(":checked");
						}
						input2 = document3.createElement("input");
						input2.setAttribute("type", "hidden");
						el.appendChild(input2).setAttribute("name", "D");
						documentElement2.appendChild(el).disabled = true;
						if (el.querySelectorAll(":disabled").length !== 2) {
						  rbuggyQSA.push(":enabled", ":disabled");
						}
						input2 = document3.createElement("input");
						input2.setAttribute("name", "");
						el.appendChild(input2);
						if (!el.querySelectorAll("[name='']").length) {
						  rbuggyQSA.push("\\[" + whitespace + "*name" + whitespace + "*=" + whitespace + `*(?:''|"")`);
						}
					 });
					 if (!support.cssHas) {
						rbuggyQSA.push(":has");
					 }
					 rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
					 sortOrder = function(a, b) {
						if (a === b) {
						  hasDuplicate = true;
						  return 0;
						}
						var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
						if (compare) {
						  return compare;
						}
						compare = (a.ownerDocument || a) == (b.ownerDocument || b) ? a.compareDocumentPosition(b) : (
						  // Otherwise we know they are disconnected
						  1
						);
						if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
						  if (a === document3 || a.ownerDocument == preferredDoc && find3.contains(preferredDoc, a)) {
							 return -1;
						  }
						  if (b === document3 || b.ownerDocument == preferredDoc && find3.contains(preferredDoc, b)) {
							 return 1;
						  }
						  return sortInput ? indexOf2.call(sortInput, a) - indexOf2.call(sortInput, b) : 0;
						}
						return compare & 4 ? -1 : 1;
					 };
					 return document3;
				  }
				  find3.matches = function(expr, elements) {
					 return find3(expr, null, null, elements);
				  };
				  find3.matchesSelector = function(elem2, expr) {
					 setDocument2(elem2);
					 if (documentIsHTML && !nonnativeSelectorCache[expr + " "] && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
						try {
						  var ret = matches.call(elem2, expr);
						  if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document
						  // fragment in IE 9
						  elem2.document && elem2.document.nodeType !== 11) {
							 return ret;
						  }
						} catch (e) {
						  nonnativeSelectorCache(expr, true);
						}
					 }
					 return find3(expr, document3, null, [elem2]).length > 0;
				  };
				  find3.contains = function(context2, elem2) {
					 if ((context2.ownerDocument || context2) != document3) {
						setDocument2(context2);
					 }
					 return jQuery.contains(context2, elem2);
				  };
				  find3.attr = function(elem2, name) {
					 if ((elem2.ownerDocument || elem2) != document3) {
						setDocument2(elem2);
					 }
					 var fn = Expr.attrHandle[name.toLowerCase()], val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem2, name, !documentIsHTML) : void 0;
					 if (val !== void 0) {
						return val;
					 }
					 return elem2.getAttribute(name);
				  };
				  find3.error = function(msg) {
					 throw new Error("Syntax error, unrecognized expression: " + msg);
				  };
				  jQuery.uniqueSort = function(results) {
					 var elem2, duplicates = [], j = 0, i2 = 0;
					 hasDuplicate = !support.sortStable;
					 sortInput = !support.sortStable && slice.call(results, 0);
					 sort.call(results, sortOrder);
					 if (hasDuplicate) {
						while (elem2 = results[i2++]) {
						  if (elem2 === results[i2]) {
							 j = duplicates.push(i2);
						  }
						}
						while (j--) {
						  splice.call(results, duplicates[j], 1);
						}
					 }
					 sortInput = null;
					 return results;
				  };
				  jQuery.fn.uniqueSort = function() {
					 return this.pushStack(jQuery.uniqueSort(slice.apply(this)));
				  };
				  Expr = jQuery.expr = {
					 // Can be adjusted by the user
					 cacheLength: 50,
					 createPseudo: markFunction,
					 match: matchExpr,
					 attrHandle: {},
					 find: {},
					 relative: {
						">": { dir: "parentNode", first: true },
						" ": { dir: "parentNode" },
						"+": { dir: "previousSibling", first: true },
						"~": { dir: "previousSibling" }
					 },
					 preFilter: {
						ATTR: function(match23) {
						  match23[1] = match23[1].replace(runescape, funescape);
						  match23[3] = (match23[3] || match23[4] || match23[5] || "").replace(runescape, funescape);
						  if (match23[2] === "~=") {
							 match23[3] = " " + match23[3] + " ";
						  }
						  return match23.slice(0, 4);
						},
						CHILD: function(match23) {
						  match23[1] = match23[1].toLowerCase();
						  if (match23[1].slice(0, 3) === "nth") {
							 if (!match23[3]) {
								find3.error(match23[0]);
							 }
							 match23[4] = +(match23[4] ? match23[5] + (match23[6] || 1) : 2 * (match23[3] === "even" || match23[3] === "odd"));
							 match23[5] = +(match23[7] + match23[8] || match23[3] === "odd");
						  } else if (match23[3]) {
							 find3.error(match23[0]);
						  }
						  return match23;
						},
						PSEUDO: function(match23) {
						  var excess, unquoted = !match23[6] && match23[2];
						  if (matchExpr.CHILD.test(match23[0])) {
							 return null;
						  }
						  if (match23[3]) {
							 match23[2] = match23[4] || match23[5] || "";
						  } else if (unquoted && rpseudo.test(unquoted) && // Get excess from tokenize (recursively)
						  (excess = tokenize(unquoted, true)) && // advance to the next closing parenthesis
						  (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
							 match23[0] = match23[0].slice(0, excess);
							 match23[2] = unquoted.slice(0, excess);
						  }
						  return match23.slice(0, 3);
						}
					 },
					 filter: {
						TAG: function(nodeNameSelector) {
						  var expectedNodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
						  return nodeNameSelector === "*" ? function() {
							 return true;
						  } : function(elem2) {
							 return nodeName(elem2, expectedNodeName);
						  };
						},
						CLASS: function(className) {
						  var pattern = classCache[className + " "];
						  return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem2) {
							 return pattern.test(
								typeof elem2.className === "string" && elem2.className || typeof elem2.getAttribute !== "undefined" && elem2.getAttribute("class") || ""
							 );
						  });
						},
						ATTR: function(name, operator, check) {
						  return function(elem2) {
							 var result = find3.attr(elem2, name);
							 if (result == null) {
								return operator === "!=";
							 }
							 if (!operator) {
								return true;
							 }
							 result += "";
							 if (operator === "=") {
								return result === check;
							 }
							 if (operator === "!=") {
								return result !== check;
							 }
							 if (operator === "^=") {
								return check && result.indexOf(check) === 0;
							 }
							 if (operator === "*=") {
								return check && result.indexOf(check) > -1;
							 }
							 if (operator === "$=") {
								return check && result.slice(-check.length) === check;
							 }
							 if (operator === "~=") {
								return (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1;
							 }
							 if (operator === "|=") {
								return result === check || result.slice(0, check.length + 1) === check + "-";
							 }
							 return false;
						  };
						},
						CHILD: function(type2, what, _argument, first2, last2) {
						  var simple = type2.slice(0, 3) !== "nth", forward = type2.slice(-4) !== "last", ofType = what === "of-type";
						  return first2 === 1 && last2 === 0 ? (
							 // Shortcut for :nth-*(n)
							 function(elem2) {
								return !!elem2.parentNode;
							 }
						  ) : function(elem2, _context, xml) {
							 var cache, outerCache, node, nodeIndex, start2, dir2 = simple !== forward ? "nextSibling" : "previousSibling", parent = elem2.parentNode, name = ofType && elem2.nodeName.toLowerCase(), useCache = !xml && !ofType, diff = false;
							 if (parent) {
								if (simple) {
								  while (dir2) {
									 node = elem2;
									 while (node = node[dir2]) {
										if (ofType ? nodeName(node, name) : node.nodeType === 1) {
										  return false;
										}
									 }
									 start2 = dir2 = type2 === "only" && !start2 && "nextSibling";
								  }
								  return true;
								}
								start2 = [forward ? parent.firstChild : parent.lastChild];
								if (forward && useCache) {
								  outerCache = parent[expando] || (parent[expando] = {});
								  cache = outerCache[type2] || [];
								  nodeIndex = cache[0] === dirruns && cache[1];
								  diff = nodeIndex && cache[2];
								  node = nodeIndex && parent.childNodes[nodeIndex];
								  while (node = ++nodeIndex && node && node[dir2] || // Fallback to seeking `elem` from the start
								  (diff = nodeIndex = 0) || start2.pop()) {
									 if (node.nodeType === 1 && ++diff && node === elem2) {
										outerCache[type2] = [dirruns, nodeIndex, diff];
										break;
									 }
								  }
								} else {
								  if (useCache) {
									 outerCache = elem2[expando] || (elem2[expando] = {});
									 cache = outerCache[type2] || [];
									 nodeIndex = cache[0] === dirruns && cache[1];
									 diff = nodeIndex;
								  }
								  if (diff === false) {
									 while (node = ++nodeIndex && node && node[dir2] || (diff = nodeIndex = 0) || start2.pop()) {
										if ((ofType ? nodeName(node, name) : node.nodeType === 1) && ++diff) {
										  if (useCache) {
											 outerCache = node[expando] || (node[expando] = {});
											 outerCache[type2] = [dirruns, diff];
										  }
										  if (node === elem2) {
											 break;
										  }
										}
									 }
								  }
								}
								diff -= last2;
								return diff === first2 || diff % first2 === 0 && diff / first2 >= 0;
							 }
						  };
						},
						PSEUDO: function(pseudo, argument) {
						  var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || find3.error("unsupported pseudo: " + pseudo);
						  if (fn[expando]) {
							 return fn(argument);
						  }
						  if (fn.length > 1) {
							 args = [pseudo, pseudo, "", argument];
							 return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches2) {
								var idx, matched = fn(seed, argument), i2 = matched.length;
								while (i2--) {
								  idx = indexOf2.call(seed, matched[i2]);
								  seed[idx] = !(matches2[idx] = matched[i2]);
								}
							 }) : function(elem2) {
								return fn(elem2, 0, args);
							 };
						  }
						  return fn;
						}
					 },
					 pseudos: {
						// Potentially complex pseudos
						not: markFunction(function(selector) {
						  var input2 = [], results = [], matcher = compile(selector.replace(rtrimCSS, "$1"));
						  return matcher[expando] ? markFunction(function(seed, matches2, _context, xml) {
							 var elem2, unmatched = matcher(seed, null, xml, []), i2 = seed.length;
							 while (i2--) {
								if (elem2 = unmatched[i2]) {
								  seed[i2] = !(matches2[i2] = elem2);
								}
							 }
						  }) : function(elem2, _context, xml) {
							 input2[0] = elem2;
							 matcher(input2, null, xml, results);
							 input2[0] = null;
							 return !results.pop();
						  };
						}),
						has: markFunction(function(selector) {
						  return function(elem2) {
							 return find3(selector, elem2).length > 0;
						  };
						}),
						contains: markFunction(function(text) {
						  text = text.replace(runescape, funescape);
						  return function(elem2) {
							 return (elem2.textContent || jQuery.text(elem2)).indexOf(text) > -1;
						  };
						}),
						// "Whether an element is represented by a :lang() selector
						// is based solely on the element's language value
						// being equal to the identifier C,
						// or beginning with the identifier C immediately followed by "-".
						// The matching of C against the element's language value is performed case-insensitively.
						// The identifier C does not have to be a valid language name."
						// https://www.w3.org/TR/selectors/#lang-pseudo
						lang: markFunction(function(lang) {
						  if (!ridentifier.test(lang || "")) {
							 find3.error("unsupported lang: " + lang);
						  }
						  lang = lang.replace(runescape, funescape).toLowerCase();
						  return function(elem2) {
							 var elemLang;
							 do {
								if (elemLang = documentIsHTML ? elem2.lang : elem2.getAttribute("xml:lang") || elem2.getAttribute("lang")) {
								  elemLang = elemLang.toLowerCase();
								  return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
								}
							 } while ((elem2 = elem2.parentNode) && elem2.nodeType === 1);
							 return false;
						  };
						}),
						// Miscellaneous
						target: function(elem2) {
						  var hash = window2.location && window2.location.hash;
						  return hash && hash.slice(1) === elem2.id;
						},
						root: function(elem2) {
						  return elem2 === documentElement2;
						},
						focus: function(elem2) {
						  return elem2 === safeActiveElement() && document3.hasFocus() && !!(elem2.type || elem2.href || ~elem2.tabIndex);
						},
						// Boolean properties
						enabled: createDisabledPseudo(false),
						disabled: createDisabledPseudo(true),
						checked: function(elem2) {
						  return nodeName(elem2, "input") && !!elem2.checked || nodeName(elem2, "option") && !!elem2.selected;
						},
						selected: function(elem2) {
						  if (elem2.parentNode) {
							 elem2.parentNode.selectedIndex;
						  }
						  return elem2.selected === true;
						},
						// Contents
						empty: function(elem2) {
						  for (elem2 = elem2.firstChild; elem2; elem2 = elem2.nextSibling) {
							 if (elem2.nodeType < 6) {
								return false;
							 }
						  }
						  return true;
						},
						parent: function(elem2) {
						  return !Expr.pseudos.empty(elem2);
						},
						// Element/input types
						header: function(elem2) {
						  return rheader.test(elem2.nodeName);
						},
						input: function(elem2) {
						  return rinputs.test(elem2.nodeName);
						},
						button: function(elem2) {
						  return nodeName(elem2, "input") && elem2.type === "button" || nodeName(elem2, "button");
						},
						text: function(elem2) {
						  var attr;
						  return nodeName(elem2, "input") && elem2.type === "text" && // Support: IE <10 only
						  // New HTML5 attribute values (e.g., "search") appear
						  // with elem.type === "text"
						  ((attr = elem2.getAttribute("type")) == null || attr.toLowerCase() === "text");
						},
						// Position-in-collection
						first: createPositionalPseudo(function() {
						  return [0];
						}),
						last: createPositionalPseudo(function(_matchIndexes, length) {
						  return [length - 1];
						}),
						eq: createPositionalPseudo(function(_matchIndexes, length, argument) {
						  return [argument < 0 ? argument + length : argument];
						}),
						even: createPositionalPseudo(function(matchIndexes, length) {
						  var i2 = 0;
						  for (; i2 < length; i2 += 2) {
							 matchIndexes.push(i2);
						  }
						  return matchIndexes;
						}),
						odd: createPositionalPseudo(function(matchIndexes, length) {
						  var i2 = 1;
						  for (; i2 < length; i2 += 2) {
							 matchIndexes.push(i2);
						  }
						  return matchIndexes;
						}),
						lt: createPositionalPseudo(function(matchIndexes, length, argument) {
						  var i2;
						  if (argument < 0) {
							 i2 = argument + length;
						  } else if (argument > length) {
							 i2 = length;
						  } else {
							 i2 = argument;
						  }
						  for (; --i2 >= 0; ) {
							 matchIndexes.push(i2);
						  }
						  return matchIndexes;
						}),
						gt: createPositionalPseudo(function(matchIndexes, length, argument) {
						  var i2 = argument < 0 ? argument + length : argument;
						  for (; ++i2 < length; ) {
							 matchIndexes.push(i2);
						  }
						  return matchIndexes;
						})
					 }
				  };
				  Expr.pseudos.nth = Expr.pseudos.eq;
				  for (i in { radio: true, checkbox: true, file: true, password: true, image: true }) {
					 Expr.pseudos[i] = createInputPseudo(i);
				  }
				  for (i in { submit: true, reset: true }) {
					 Expr.pseudos[i] = createButtonPseudo(i);
				  }
				  function setFilters() {
				  }
				  setFilters.prototype = Expr.filters = Expr.pseudos;
				  Expr.setFilters = new setFilters();
				  function tokenize(selector, parseOnly) {
					 var matched, match23, tokens, type2, soFar, groups, preFilters, cached = tokenCache[selector + " "];
					 if (cached) {
						return parseOnly ? 0 : cached.slice(0);
					 }
					 soFar = selector;
					 groups = [];
					 preFilters = Expr.preFilter;
					 while (soFar) {
						if (!matched || (match23 = rcomma.exec(soFar))) {
						  if (match23) {
							 soFar = soFar.slice(match23[0].length) || soFar;
						  }
						  groups.push(tokens = []);
						}
						matched = false;
						if (match23 = rleadingCombinator.exec(soFar)) {
						  matched = match23.shift();
						  tokens.push({
							 value: matched,
							 // Cast descendant combinators to space
							 type: match23[0].replace(rtrimCSS, " ")
						  });
						  soFar = soFar.slice(matched.length);
						}
						for (type2 in Expr.filter) {
						  if ((match23 = matchExpr[type2].exec(soFar)) && (!preFilters[type2] || (match23 = preFilters[type2](match23)))) {
							 matched = match23.shift();
							 tokens.push({
								value: matched,
								type: type2,
								matches: match23
							 });
							 soFar = soFar.slice(matched.length);
						  }
						}
						if (!matched) {
						  break;
						}
					 }
					 if (parseOnly) {
						return soFar.length;
					 }
					 return soFar ? find3.error(selector) : (
						// Cache the tokens
						tokenCache(selector, groups).slice(0)
					 );
				  }
				  function toSelector(tokens) {
					 var i2 = 0, len = tokens.length, selector = "";
					 for (; i2 < len; i2++) {
						selector += tokens[i2].value;
					 }
					 return selector;
				  }
				  function addCombinator(matcher, combinator, base) {
					 var dir2 = combinator.dir, skip = combinator.next, key = skip || dir2, checkNonElements = base && key === "parentNode", doneName = done++;
					 return combinator.first ? (
						// Check against closest ancestor/preceding element
						function(elem2, context2, xml) {
						  while (elem2 = elem2[dir2]) {
							 if (elem2.nodeType === 1 || checkNonElements) {
								return matcher(elem2, context2, xml);
							 }
						  }
						  return false;
						}
					 ) : (
						// Check against all ancestor/preceding elements
						function(elem2, context2, xml) {
						  var oldCache, outerCache, newCache = [dirruns, doneName];
						  if (xml) {
							 while (elem2 = elem2[dir2]) {
								if (elem2.nodeType === 1 || checkNonElements) {
								  if (matcher(elem2, context2, xml)) {
									 return true;
								  }
								}
							 }
						  } else {
							 while (elem2 = elem2[dir2]) {
								if (elem2.nodeType === 1 || checkNonElements) {
								  outerCache = elem2[expando] || (elem2[expando] = {});
								  if (skip && nodeName(elem2, skip)) {
									 elem2 = elem2[dir2] || elem2;
								  } else if ((oldCache = outerCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
									 return newCache[2] = oldCache[2];
								  } else {
									 outerCache[key] = newCache;
									 if (newCache[2] = matcher(elem2, context2, xml)) {
										return true;
									 }
								  }
								}
							 }
						  }
						  return false;
						}
					 );
				  }
				  function elementMatcher(matchers) {
					 return matchers.length > 1 ? function(elem2, context2, xml) {
						var i2 = matchers.length;
						while (i2--) {
						  if (!matchers[i2](elem2, context2, xml)) {
							 return false;
						  }
						}
						return true;
					 } : matchers[0];
				  }
				  function multipleContexts(selector, contexts, results) {
					 var i2 = 0, len = contexts.length;
					 for (; i2 < len; i2++) {
						find3(selector, contexts[i2], results);
					 }
					 return results;
				  }
				  function condense(unmatched, map3, filter2, context2, xml) {
					 var elem2, newUnmatched = [], i2 = 0, len = unmatched.length, mapped = map3 != null;
					 for (; i2 < len; i2++) {
						if (elem2 = unmatched[i2]) {
						  if (!filter2 || filter2(elem2, context2, xml)) {
							 newUnmatched.push(elem2);
							 if (mapped) {
								map3.push(i2);
							 }
						  }
						}
					 }
					 return newUnmatched;
				  }
				  function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
					 if (postFilter && !postFilter[expando]) {
						postFilter = setMatcher(postFilter);
					 }
					 if (postFinder && !postFinder[expando]) {
						postFinder = setMatcher(postFinder, postSelector);
					 }
					 return markFunction(function(seed, results, context2, xml) {
						var temp, i2, elem2, matcherOut, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(
						  selector || "*",
						  context2.nodeType ? [context2] : context2,
						  []
						), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context2, xml) : elems;
						if (matcher) {
						  matcherOut = postFinder || (seed ? preFilter : preexisting || postFilter) ? (
							 // ...intermediate processing is necessary
							 []
						  ) : (
							 // ...otherwise use results directly
							 results
						  );
						  matcher(matcherIn, matcherOut, context2, xml);
						} else {
						  matcherOut = matcherIn;
						}
						if (postFilter) {
						  temp = condense(matcherOut, postMap);
						  postFilter(temp, [], context2, xml);
						  i2 = temp.length;
						  while (i2--) {
							 if (elem2 = temp[i2]) {
								matcherOut[postMap[i2]] = !(matcherIn[postMap[i2]] = elem2);
							 }
						  }
						}
						if (seed) {
						  if (postFinder || preFilter) {
							 if (postFinder) {
								temp = [];
								i2 = matcherOut.length;
								while (i2--) {
								  if (elem2 = matcherOut[i2]) {
									 temp.push(matcherIn[i2] = elem2);
								  }
								}
								postFinder(null, matcherOut = [], temp, xml);
							 }
							 i2 = matcherOut.length;
							 while (i2--) {
								if ((elem2 = matcherOut[i2]) && (temp = postFinder ? indexOf2.call(seed, elem2) : preMap[i2]) > -1) {
								  seed[temp] = !(results[temp] = elem2);
								}
							 }
						  }
						} else {
						  matcherOut = condense(
							 matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut
						  );
						  if (postFinder) {
							 postFinder(null, results, matcherOut, xml);
						  } else {
							 push2.apply(results, matcherOut);
						  }
						}
					 });
				  }
				  function matcherFromTokens(tokens) {
					 var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i2 = leadingRelative ? 1 : 0, matchContext = addCombinator(function(elem2) {
						return elem2 === checkContext;
					 }, implicitRelative, true), matchAnyContext = addCombinator(function(elem2) {
						return indexOf2.call(checkContext, elem2) > -1;
					 }, implicitRelative, true), matchers = [function(elem2, context2, xml) {
						var ret = !leadingRelative && (xml || context2 != outermostContext) || ((checkContext = context2).nodeType ? matchContext(elem2, context2, xml) : matchAnyContext(elem2, context2, xml));
						checkContext = null;
						return ret;
					 }];
					 for (; i2 < len; i2++) {
						if (matcher = Expr.relative[tokens[i2].type]) {
						  matchers = [addCombinator(elementMatcher(matchers), matcher)];
						} else {
						  matcher = Expr.filter[tokens[i2].type].apply(null, tokens[i2].matches);
						  if (matcher[expando]) {
							 j = ++i2;
							 for (; j < len; j++) {
								if (Expr.relative[tokens[j].type]) {
								  break;
								}
							 }
							 return setMatcher(
								i2 > 1 && elementMatcher(matchers),
								i2 > 1 && toSelector(
								  // If the preceding token was a descendant combinator, insert an implicit any-element `*`
								  tokens.slice(0, i2 - 1).concat({ value: tokens[i2 - 2].type === " " ? "*" : "" })
								).replace(rtrimCSS, "$1"),
								matcher,
								i2 < j && matcherFromTokens(tokens.slice(i2, j)),
								j < len && matcherFromTokens(tokens = tokens.slice(j)),
								j < len && toSelector(tokens)
							 );
						  }
						  matchers.push(matcher);
						}
					 }
					 return elementMatcher(matchers);
				  }
				  function matcherFromGroupMatchers(elementMatchers, setMatchers) {
					 var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context2, xml, results, outermost) {
						var elem2, j, matcher, matchedCount = 0, i2 = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find.TAG("*", outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
						if (outermost) {
						  outermostContext = context2 == document3 || context2 || outermost;
						}
						for (; i2 !== len && (elem2 = elems[i2]) != null; i2++) {
						  if (byElement && elem2) {
							 j = 0;
							 if (!context2 && elem2.ownerDocument != document3) {
								setDocument2(elem2);
								xml = !documentIsHTML;
							 }
							 while (matcher = elementMatchers[j++]) {
								if (matcher(elem2, context2 || document3, xml)) {
								  push2.call(results, elem2);
								  break;
								}
							 }
							 if (outermost) {
								dirruns = dirrunsUnique;
							 }
						  }
						  if (bySet) {
							 if (elem2 = !matcher && elem2) {
								matchedCount--;
							 }
							 if (seed) {
								unmatched.push(elem2);
							 }
						  }
						}
						matchedCount += i2;
						if (bySet && i2 !== matchedCount) {
						  j = 0;
						  while (matcher = setMatchers[j++]) {
							 matcher(unmatched, setMatched, context2, xml);
						  }
						  if (seed) {
							 if (matchedCount > 0) {
								while (i2--) {
								  if (!(unmatched[i2] || setMatched[i2])) {
									 setMatched[i2] = pop.call(results);
								  }
								}
							 }
							 setMatched = condense(setMatched);
						  }
						  push2.apply(results, setMatched);
						  if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
							 jQuery.uniqueSort(results);
						  }
						}
						if (outermost) {
						  dirruns = dirrunsUnique;
						  outermostContext = contextBackup;
						}
						return unmatched;
					 };
					 return bySet ? markFunction(superMatcher) : superMatcher;
				  }
				  function compile(selector, match23) {
					 var i2, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
					 if (!cached) {
						if (!match23) {
						  match23 = tokenize(selector);
						}
						i2 = match23.length;
						while (i2--) {
						  cached = matcherFromTokens(match23[i2]);
						  if (cached[expando]) {
							 setMatchers.push(cached);
						  } else {
							 elementMatchers.push(cached);
						  }
						}
						cached = compilerCache(
						  selector,
						  matcherFromGroupMatchers(elementMatchers, setMatchers)
						);
						cached.selector = selector;
					 }
					 return cached;
				  }
				  function select(selector, context2, results, seed) {
					 var i2, tokens, token, type2, find4, compiled = typeof selector === "function" && selector, match23 = !seed && tokenize(selector = compiled.selector || selector);
					 results = results || [];
					 if (match23.length === 1) {
						tokens = match23[0] = match23[0].slice(0);
						if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context2.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
						  context2 = (Expr.find.ID(
							 token.matches[0].replace(runescape, funescape),
							 context2
						  ) || [])[0];
						  if (!context2) {
							 return results;
						  } else if (compiled) {
							 context2 = context2.parentNode;
						  }
						  selector = selector.slice(tokens.shift().value.length);
						}
						i2 = matchExpr.needsContext.test(selector) ? 0 : tokens.length;
						while (i2--) {
						  token = tokens[i2];
						  if (Expr.relative[type2 = token.type]) {
							 break;
						  }
						  if (find4 = Expr.find[type2]) {
							 if (seed = find4(
								token.matches[0].replace(runescape, funescape),
								rsibling.test(tokens[0].type) && testContext(context2.parentNode) || context2
							 )) {
								tokens.splice(i2, 1);
								selector = seed.length && toSelector(tokens);
								if (!selector) {
								  push2.apply(results, seed);
								  return results;
								}
								break;
							 }
						  }
						}
					 }
					 (compiled || compile(selector, match23))(
						seed,
						context2,
						!documentIsHTML,
						results,
						!context2 || rsibling.test(selector) && testContext(context2.parentNode) || context2
					 );
					 return results;
				  }
				  support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
				  setDocument2();
				  support.sortDetached = assert(function(el) {
					 return el.compareDocumentPosition(document3.createElement("fieldset")) & 1;
				  });
				  jQuery.find = find3;
				  jQuery.expr[":"] = jQuery.expr.pseudos;
				  jQuery.unique = jQuery.uniqueSort;
				  find3.compile = compile;
				  find3.select = select;
				  find3.setDocument = setDocument2;
				  find3.tokenize = tokenize;
				  find3.escape = jQuery.escapeSelector;
				  find3.getText = jQuery.text;
				  find3.isXML = jQuery.isXMLDoc;
				  find3.selectors = jQuery.expr;
				  find3.support = jQuery.support;
				  find3.uniqueSort = jQuery.uniqueSort;
				})();
				var dir = function(elem2, dir2, until) {
				  var matched = [], truncate = until !== void 0;
				  while ((elem2 = elem2[dir2]) && elem2.nodeType !== 9) {
					 if (elem2.nodeType === 1) {
						if (truncate && jQuery(elem2).is(until)) {
						  break;
						}
						matched.push(elem2);
					 }
				  }
				  return matched;
				};
				var siblings = function(n, elem2) {
				  var matched = [];
				  for (; n; n = n.nextSibling) {
					 if (n.nodeType === 1 && n !== elem2) {
						matched.push(n);
					 }
				  }
				  return matched;
				};
				var rneedsContext = jQuery.expr.match.needsContext;
				var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
				function winnow(elements, qualifier, not) {
				  if (isFunction5(qualifier)) {
					 return jQuery.grep(elements, function(elem2, i) {
						return !!qualifier.call(elem2, i, elem2) !== not;
					 });
				  }
				  if (qualifier.nodeType) {
					 return jQuery.grep(elements, function(elem2) {
						return elem2 === qualifier !== not;
					 });
				  }
				  if (typeof qualifier !== "string") {
					 return jQuery.grep(elements, function(elem2) {
						return indexOf2.call(qualifier, elem2) > -1 !== not;
					 });
				  }
				  return jQuery.filter(qualifier, elements, not);
				}
				jQuery.filter = function(expr, elems, not) {
				  var elem2 = elems[0];
				  if (not) {
					 expr = ":not(" + expr + ")";
				  }
				  if (elems.length === 1 && elem2.nodeType === 1) {
					 return jQuery.find.matchesSelector(elem2, expr) ? [elem2] : [];
				  }
				  return jQuery.find.matches(expr, jQuery.grep(elems, function(elem3) {
					 return elem3.nodeType === 1;
				  }));
				};
				jQuery.fn.extend({
				  find: function(selector) {
					 var i, ret, len = this.length, self2 = this;
					 if (typeof selector !== "string") {
						return this.pushStack(jQuery(selector).filter(function() {
						  for (i = 0; i < len; i++) {
							 if (jQuery.contains(self2[i], this)) {
								return true;
							 }
						  }
						}));
					 }
					 ret = this.pushStack([]);
					 for (i = 0; i < len; i++) {
						jQuery.find(selector, self2[i], ret);
					 }
					 return len > 1 ? jQuery.uniqueSort(ret) : ret;
				  },
				  filter: function(selector) {
					 return this.pushStack(winnow(this, selector || [], false));
				  },
				  not: function(selector) {
					 return this.pushStack(winnow(this, selector || [], true));
				  },
				  is: function(selector) {
					 return !!winnow(
						this,
						// If this is a positional/relative selector, check membership in the returned set
						// so $("p:first").is("p:last") won't return true for a doc with two "p".
						typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [],
						false
					 ).length;
				  }
				});
				var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/, init2 = jQuery.fn.init = function(selector, context2, root2) {
				  var match23, elem2;
				  if (!selector) {
					 return this;
				  }
				  root2 = root2 || rootjQuery;
				  if (typeof selector === "string") {
					 if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
						match23 = [null, selector, null];
					 } else {
						match23 = rquickExpr.exec(selector);
					 }
					 if (match23 && (match23[1] || !context2)) {
						if (match23[1]) {
						  context2 = context2 instanceof jQuery ? context2[0] : context2;
						  jQuery.merge(this, jQuery.parseHTML(
							 match23[1],
							 context2 && context2.nodeType ? context2.ownerDocument || context2 : document2,
							 true
						  ));
						  if (rsingleTag.test(match23[1]) && jQuery.isPlainObject(context2)) {
							 for (match23 in context2) {
								if (isFunction5(this[match23])) {
								  this[match23](context2[match23]);
								} else {
								  this.attr(match23, context2[match23]);
								}
							 }
						  }
						  return this;
						} else {
						  elem2 = document2.getElementById(match23[2]);
						  if (elem2) {
							 this[0] = elem2;
							 this.length = 1;
						  }
						  return this;
						}
					 } else if (!context2 || context2.jquery) {
						return (context2 || root2).find(selector);
					 } else {
						return this.constructor(context2).find(selector);
					 }
				  } else if (selector.nodeType) {
					 this[0] = selector;
					 this.length = 1;
					 return this;
				  } else if (isFunction5(selector)) {
					 return root2.ready !== void 0 ? root2.ready(selector) : (
						// Execute immediately if ready is not present
						selector(jQuery)
					 );
				  }
				  return jQuery.makeArray(selector, this);
				};
				init2.prototype = jQuery.fn;
				rootjQuery = jQuery(document2);
				var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {
				  children: true,
				  contents: true,
				  next: true,
				  prev: true
				};
				jQuery.fn.extend({
				  has: function(target) {
					 var targets = jQuery(target, this), l = targets.length;
					 return this.filter(function() {
						var i = 0;
						for (; i < l; i++) {
						  if (jQuery.contains(this, targets[i])) {
							 return true;
						  }
						}
					 });
				  },
				  closest: function(selectors, context2) {
					 var cur, i = 0, l = this.length, matched = [], targets = typeof selectors !== "string" && jQuery(selectors);
					 if (!rneedsContext.test(selectors)) {
						for (; i < l; i++) {
						  for (cur = this[i]; cur && cur !== context2; cur = cur.parentNode) {
							 if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : (
								// Don't pass non-elements to jQuery#find
								cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors)
							 ))) {
								matched.push(cur);
								break;
							 }
						  }
						}
					 }
					 return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
				  },
				  // Determine the position of an element within the set
				  index: function(elem2) {
					 if (!elem2) {
						return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
					 }
					 if (typeof elem2 === "string") {
						return indexOf2.call(jQuery(elem2), this[0]);
					 }
					 return indexOf2.call(
						this,
						// If it receives a jQuery object, the first element is used
						elem2.jquery ? elem2[0] : elem2
					 );
				  },
				  add: function(selector, context2) {
					 return this.pushStack(
						jQuery.uniqueSort(
						  jQuery.merge(this.get(), jQuery(selector, context2))
						)
					 );
				  },
				  addBack: function(selector) {
					 return this.add(
						selector == null ? this.prevObject : this.prevObject.filter(selector)
					 );
				  }
				});
				function sibling(cur, dir2) {
				  while ((cur = cur[dir2]) && cur.nodeType !== 1) {
				  }
				  return cur;
				}
				jQuery.each({
				  parent: function(elem2) {
					 var parent = elem2.parentNode;
					 return parent && parent.nodeType !== 11 ? parent : null;
				  },
				  parents: function(elem2) {
					 return dir(elem2, "parentNode");
				  },
				  parentsUntil: function(elem2, _i, until) {
					 return dir(elem2, "parentNode", until);
				  },
				  next: function(elem2) {
					 return sibling(elem2, "nextSibling");
				  },
				  prev: function(elem2) {
					 return sibling(elem2, "previousSibling");
				  },
				  nextAll: function(elem2) {
					 return dir(elem2, "nextSibling");
				  },
				  prevAll: function(elem2) {
					 return dir(elem2, "previousSibling");
				  },
				  nextUntil: function(elem2, _i, until) {
					 return dir(elem2, "nextSibling", until);
				  },
				  prevUntil: function(elem2, _i, until) {
					 return dir(elem2, "previousSibling", until);
				  },
				  siblings: function(elem2) {
					 return siblings((elem2.parentNode || {}).firstChild, elem2);
				  },
				  children: function(elem2) {
					 return siblings(elem2.firstChild);
				  },
				  contents: function(elem2) {
					 if (elem2.contentDocument != null && // Support: IE 11+
					 // <object> elements with no `data` attribute has an object
					 // `contentDocument` with a `null` prototype.
					 getProto(elem2.contentDocument)) {
						return elem2.contentDocument;
					 }
					 if (nodeName(elem2, "template")) {
						elem2 = elem2.content || elem2;
					 }
					 return jQuery.merge([], elem2.childNodes);
				  }
				}, function(name, fn) {
				  jQuery.fn[name] = function(until, selector) {
					 var matched = jQuery.map(this, fn, until);
					 if (name.slice(-5) !== "Until") {
						selector = until;
					 }
					 if (selector && typeof selector === "string") {
						matched = jQuery.filter(selector, matched);
					 }
					 if (this.length > 1) {
						if (!guaranteedUnique[name]) {
						  jQuery.uniqueSort(matched);
						}
						if (rparentsprev.test(name)) {
						  matched.reverse();
						}
					 }
					 return this.pushStack(matched);
				  };
				});
				var rnothtmlwhite = /[^\x20\t\r\n\f]+/g;
				function createOptions(options) {
				  var object = {};
				  jQuery.each(options.match(rnothtmlwhite) || [], function(_2, flag) {
					 object[flag] = true;
				  });
				  return object;
				}
				jQuery.Callbacks = function(options) {
				  options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);
				  var firing, memory, fired, locked, list = [], queue = [], firingIndex = -1, fire = function() {
					 locked = locked || options.once;
					 fired = firing = true;
					 for (; queue.length; firingIndex = -1) {
						memory = queue.shift();
						while (++firingIndex < list.length) {
						  if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
							 firingIndex = list.length;
							 memory = false;
						  }
						}
					 }
					 if (!options.memory) {
						memory = false;
					 }
					 firing = false;
					 if (locked) {
						if (memory) {
						  list = [];
						} else {
						  list = "";
						}
					 }
				  }, self2 = {
					 // Add a callback or a collection of callbacks to the list
					 add: function() {
						if (list) {
						  if (memory && !firing) {
							 firingIndex = list.length - 1;
							 queue.push(memory);
						  }
						  (function add2(args) {
							 jQuery.each(args, function(_2, arg) {
								if (isFunction5(arg)) {
								  if (!options.unique || !self2.has(arg)) {
									 list.push(arg);
								  }
								} else if (arg && arg.length && toType(arg) !== "string") {
								  add2(arg);
								}
							 });
						  })(arguments);
						  if (memory && !firing) {
							 fire();
						  }
						}
						return this;
					 },
					 // Remove a callback from the list
					 remove: function() {
						jQuery.each(arguments, function(_2, arg) {
						  var index;
						  while ((index = jQuery.inArray(arg, list, index)) > -1) {
							 list.splice(index, 1);
							 if (index <= firingIndex) {
								firingIndex--;
							 }
						  }
						});
						return this;
					 },
					 // Check if a given callback is in the list.
					 // If no argument is given, return whether or not list has callbacks attached.
					 has: function(fn) {
						return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
					 },
					 // Remove all callbacks from the list
					 empty: function() {
						if (list) {
						  list = [];
						}
						return this;
					 },
					 // Disable .fire and .add
					 // Abort any current/pending executions
					 // Clear all callbacks and values
					 disable: function() {
						locked = queue = [];
						list = memory = "";
						return this;
					 },
					 disabled: function() {
						return !list;
					 },
					 // Disable .fire
					 // Also disable .add unless we have memory (since it would have no effect)
					 // Abort any pending executions
					 lock: function() {
						locked = queue = [];
						if (!memory && !firing) {
						  list = memory = "";
						}
						return this;
					 },
					 locked: function() {
						return !!locked;
					 },
					 // Call all callbacks with the given context and arguments
					 fireWith: function(context2, args) {
						if (!locked) {
						  args = args || [];
						  args = [context2, args.slice ? args.slice() : args];
						  queue.push(args);
						  if (!firing) {
							 fire();
						  }
						}
						return this;
					 },
					 // Call all the callbacks with the given arguments
					 fire: function() {
						self2.fireWith(this, arguments);
						return this;
					 },
					 // To know if the callbacks have already been called at least once
					 fired: function() {
						return !!fired;
					 }
				  };
				  return self2;
				};
				function Identity(v) {
				  return v;
				}
				function Thrower(ex) {
				  throw ex;
				}
				function adoptValue(value, resolve, reject, noValue) {
				  var method;
				  try {
					 if (value && isFunction5(method = value.promise)) {
						method.call(value).done(resolve).fail(reject);
					 } else if (value && isFunction5(method = value.then)) {
						method.call(value, resolve, reject);
					 } else {
						resolve.apply(void 0, [value].slice(noValue));
					 }
				  } catch (value2) {
					 reject.apply(void 0, [value2]);
				  }
				}
				jQuery.extend({
				  Deferred: function(func) {
					 var tuples = [
						// action, add listener, callbacks,
						// ... .then handlers, argument index, [final state]
						[
						  "notify",
						  "progress",
						  jQuery.Callbacks("memory"),
						  jQuery.Callbacks("memory"),
						  2
						],
						[
						  "resolve",
						  "done",
						  jQuery.Callbacks("once memory"),
						  jQuery.Callbacks("once memory"),
						  0,
						  "resolved"
						],
						[
						  "reject",
						  "fail",
						  jQuery.Callbacks("once memory"),
						  jQuery.Callbacks("once memory"),
						  1,
						  "rejected"
						]
					 ], state = "pending", promise = {
						state: function() {
						  return state;
						},
						always: function() {
						  deferred.done(arguments).fail(arguments);
						  return this;
						},
						"catch": function(fn) {
						  return promise.then(null, fn);
						},
						// Keep pipe for back-compat
						pipe: function() {
						  var fns = arguments;
						  return jQuery.Deferred(function(newDefer) {
							 jQuery.each(tuples, function(_i, tuple) {
								var fn = isFunction5(fns[tuple[4]]) && fns[tuple[4]];
								deferred[tuple[1]](function() {
								  var returned = fn && fn.apply(this, arguments);
								  if (returned && isFunction5(returned.promise)) {
									 returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
								  } else {
									 newDefer[tuple[0] + "With"](
										this,
										fn ? [returned] : arguments
									 );
								  }
								});
							 });
							 fns = null;
						  }).promise();
						},
						then: function(onFulfilled, onRejected, onProgress) {
						  var maxDepth = 0;
						  function resolve(depth, deferred2, handler, special2) {
							 return function() {
								var that = this, args = arguments, mightThrow = function() {
								  var returned, then;
								  if (depth < maxDepth) {
									 return;
								  }
								  returned = handler.apply(that, args);
								  if (returned === deferred2.promise()) {
									 throw new TypeError("Thenable self-resolution");
								  }
								  then = returned && // Support: Promises/A+ section 2.3.4
								  // https://promisesaplus.com/#point-64
								  // Only check objects and functions for thenability
								  (typeof returned === "object" || typeof returned === "function") && returned.then;
								  if (isFunction5(then)) {
									 if (special2) {
										then.call(
										  returned,
										  resolve(maxDepth, deferred2, Identity, special2),
										  resolve(maxDepth, deferred2, Thrower, special2)
										);
									 } else {
										maxDepth++;
										then.call(
										  returned,
										  resolve(maxDepth, deferred2, Identity, special2),
										  resolve(maxDepth, deferred2, Thrower, special2),
										  resolve(
											 maxDepth,
											 deferred2,
											 Identity,
											 deferred2.notifyWith
										  )
										);
									 }
								  } else {
									 if (handler !== Identity) {
										that = void 0;
										args = [returned];
									 }
									 (special2 || deferred2.resolveWith)(that, args);
								  }
								}, process2 = special2 ? mightThrow : function() {
								  try {
									 mightThrow();
								  } catch (e) {
									 if (jQuery.Deferred.exceptionHook) {
										jQuery.Deferred.exceptionHook(
										  e,
										  process2.error
										);
									 }
									 if (depth + 1 >= maxDepth) {
										if (handler !== Thrower) {
										  that = void 0;
										  args = [e];
										}
										deferred2.rejectWith(that, args);
									 }
								  }
								};
								if (depth) {
								  process2();
								} else {
								  if (jQuery.Deferred.getErrorHook) {
									 process2.error = jQuery.Deferred.getErrorHook();
								  } else if (jQuery.Deferred.getStackHook) {
									 process2.error = jQuery.Deferred.getStackHook();
								  }
								  window2.setTimeout(process2);
								}
							 };
						  }
						  return jQuery.Deferred(function(newDefer) {
							 tuples[0][3].add(
								resolve(
								  0,
								  newDefer,
								  isFunction5(onProgress) ? onProgress : Identity,
								  newDefer.notifyWith
								)
							 );
							 tuples[1][3].add(
								resolve(
								  0,
								  newDefer,
								  isFunction5(onFulfilled) ? onFulfilled : Identity
								)
							 );
							 tuples[2][3].add(
								resolve(
								  0,
								  newDefer,
								  isFunction5(onRejected) ? onRejected : Thrower
								)
							 );
						  }).promise();
						},
						// Get a promise for this deferred
						// If obj is provided, the promise aspect is added to the object
						promise: function(obj) {
						  return obj != null ? jQuery.extend(obj, promise) : promise;
						}
					 }, deferred = {};
					 jQuery.each(tuples, function(i, tuple) {
						var list = tuple[2], stateString = tuple[5];
						promise[tuple[1]] = list.add;
						if (stateString) {
						  list.add(
							 function() {
								state = stateString;
							 },
							 // rejected_callbacks.disable
							 // fulfilled_callbacks.disable
							 tuples[3 - i][2].disable,
							 // rejected_handlers.disable
							 // fulfilled_handlers.disable
							 tuples[3 - i][3].disable,
							 // progress_callbacks.lock
							 tuples[0][2].lock,
							 // progress_handlers.lock
							 tuples[0][3].lock
						  );
						}
						list.add(tuple[3].fire);
						deferred[tuple[0]] = function() {
						  deferred[tuple[0] + "With"](this === deferred ? void 0 : this, arguments);
						  return this;
						};
						deferred[tuple[0] + "With"] = list.fireWith;
					 });
					 promise.promise(deferred);
					 if (func) {
						func.call(deferred, deferred);
					 }
					 return deferred;
				  },
				  // Deferred helper
				  when: function(singleValue) {
					 var remaining = arguments.length, i = remaining, resolveContexts = Array(i), resolveValues = slice.call(arguments), primary = jQuery.Deferred(), updateFunc = function(i2) {
						return function(value) {
						  resolveContexts[i2] = this;
						  resolveValues[i2] = arguments.length > 1 ? slice.call(arguments) : value;
						  if (!--remaining) {
							 primary.resolveWith(resolveContexts, resolveValues);
						  }
						};
					 };
					 if (remaining <= 1) {
						adoptValue(
						  singleValue,
						  primary.done(updateFunc(i)).resolve,
						  primary.reject,
						  !remaining
						);
						if (primary.state() === "pending" || isFunction5(resolveValues[i] && resolveValues[i].then)) {
						  return primary.then();
						}
					 }
					 while (i--) {
						adoptValue(resolveValues[i], updateFunc(i), primary.reject);
					 }
					 return primary.promise();
				  }
				});
				var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
				jQuery.Deferred.exceptionHook = function(error, asyncError) {
				  if (window2.console && window2.console.warn && error && rerrorNames.test(error.name)) {
					 window2.console.warn(
						"jQuery.Deferred exception: " + error.message,
						error.stack,
						asyncError
					 );
				  }
				};
				jQuery.readyException = function(error) {
				  window2.setTimeout(function() {
					 throw error;
				  });
				};
				var readyList = jQuery.Deferred();
				jQuery.fn.ready = function(fn) {
				  readyList.then(fn).catch(function(error) {
					 jQuery.readyException(error);
				  });
				  return this;
				};
				jQuery.extend({
				  // Is the DOM ready to be used? Set to true once it occurs.
				  isReady: false,
				  // A counter to track how many items to wait for before
				  // the ready event fires. See trac-6781
				  readyWait: 1,
				  // Handle when the DOM is ready
				  ready: function(wait) {
					 if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
						return;
					 }
					 jQuery.isReady = true;
					 if (wait !== true && --jQuery.readyWait > 0) {
						return;
					 }
					 readyList.resolveWith(document2, [jQuery]);
				  }
				});
				jQuery.ready.then = readyList.then;
				function completed() {
				  document2.removeEventListener("DOMContentLoaded", completed);
				  window2.removeEventListener("load", completed);
				  jQuery.ready();
				}
				if (document2.readyState === "complete" || document2.readyState !== "loading" && !document2.documentElement.doScroll) {
				  window2.setTimeout(jQuery.ready);
				} else {
				  document2.addEventListener("DOMContentLoaded", completed);
				  window2.addEventListener("load", completed);
				}
				var access = function(elems, fn, key, value, chainable, emptyGet, raw) {
				  var i = 0, len = elems.length, bulk = key == null;
				  if (toType(key) === "object") {
					 chainable = true;
					 for (i in key) {
						access(elems, fn, i, key[i], true, emptyGet, raw);
					 }
				  } else if (value !== void 0) {
					 chainable = true;
					 if (!isFunction5(value)) {
						raw = true;
					 }
					 if (bulk) {
						if (raw) {
						  fn.call(elems, value);
						  fn = null;
						} else {
						  bulk = fn;
						  fn = function(elem2, _key, value2) {
							 return bulk.call(jQuery(elem2), value2);
						  };
						}
					 }
					 if (fn) {
						for (; i < len; i++) {
						  fn(
							 elems[i],
							 key,
							 raw ? value : value.call(elems[i], i, fn(elems[i], key))
						  );
						}
					 }
				  }
				  if (chainable) {
					 return elems;
				  }
				  if (bulk) {
					 return fn.call(elems);
				  }
				  return len ? fn(elems[0], key) : emptyGet;
				};
				var rmsPrefix = /^-ms-/, rdashAlpha = /-([a-z])/g;
				function fcamelCase(_all, letter) {
				  return letter.toUpperCase();
				}
				function camelCase(string) {
				  return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
				}
				var acceptData = function(owner) {
				  return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
				};
				function Data() {
				  this.expando = jQuery.expando + Data.uid++;
				}
				Data.uid = 1;
				Data.prototype = {
				  cache: function(owner) {
					 var value = owner[this.expando];
					 if (!value) {
						value = {};
						if (acceptData(owner)) {
						  if (owner.nodeType) {
							 owner[this.expando] = value;
						  } else {
							 Object.defineProperty(owner, this.expando, {
								value,
								configurable: true
							 });
						  }
						}
					 }
					 return value;
				  },
				  set: function(owner, data, value) {
					 var prop, cache = this.cache(owner);
					 if (typeof data === "string") {
						cache[camelCase(data)] = value;
					 } else {
						for (prop in data) {
						  cache[camelCase(prop)] = data[prop];
						}
					 }
					 return cache;
				  },
				  get: function(owner, key) {
					 return key === void 0 ? this.cache(owner) : (
						// Always use camelCase key (gh-2257)
						owner[this.expando] && owner[this.expando][camelCase(key)]
					 );
				  },
				  access: function(owner, key, value) {
					 if (key === void 0 || key && typeof key === "string" && value === void 0) {
						return this.get(owner, key);
					 }
					 this.set(owner, key, value);
					 return value !== void 0 ? value : key;
				  },
				  remove: function(owner, key) {
					 var i, cache = owner[this.expando];
					 if (cache === void 0) {
						return;
					 }
					 if (key !== void 0) {
						if (Array.isArray(key)) {
						  key = key.map(camelCase);
						} else {
						  key = camelCase(key);
						  key = key in cache ? [key] : key.match(rnothtmlwhite) || [];
						}
						i = key.length;
						while (i--) {
						  delete cache[key[i]];
						}
					 }
					 if (key === void 0 || jQuery.isEmptyObject(cache)) {
						if (owner.nodeType) {
						  owner[this.expando] = void 0;
						} else {
						  delete owner[this.expando];
						}
					 }
				  },
				  hasData: function(owner) {
					 var cache = owner[this.expando];
					 return cache !== void 0 && !jQuery.isEmptyObject(cache);
				  }
				};
				var dataPriv = new Data();
				var dataUser = new Data();
				var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /[A-Z]/g;
				function getData(data) {
				  if (data === "true") {
					 return true;
				  }
				  if (data === "false") {
					 return false;
				  }
				  if (data === "null") {
					 return null;
				  }
				  if (data === +data + "") {
					 return +data;
				  }
				  if (rbrace.test(data)) {
					 return JSON.parse(data);
				  }
				  return data;
				}
				function dataAttr(elem2, key, data) {
				  var name;
				  if (data === void 0 && elem2.nodeType === 1) {
					 name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
					 data = elem2.getAttribute(name);
					 if (typeof data === "string") {
						try {
						  data = getData(data);
						} catch (e) {
						}
						dataUser.set(elem2, key, data);
					 } else {
						data = void 0;
					 }
				  }
				  return data;
				}
				jQuery.extend({
				  hasData: function(elem2) {
					 return dataUser.hasData(elem2) || dataPriv.hasData(elem2);
				  },
				  data: function(elem2, name, data) {
					 return dataUser.access(elem2, name, data);
				  },
				  removeData: function(elem2, name) {
					 dataUser.remove(elem2, name);
				  },
				  // TODO: Now that all calls to _data and _removeData have been replaced
				  // with direct calls to dataPriv methods, these can be deprecated.
				  _data: function(elem2, name, data) {
					 return dataPriv.access(elem2, name, data);
				  },
				  _removeData: function(elem2, name) {
					 dataPriv.remove(elem2, name);
				  }
				});
				jQuery.fn.extend({
				  data: function(key, value) {
					 var i, name, data, elem2 = this[0], attrs = elem2 && elem2.attributes;
					 if (key === void 0) {
						if (this.length) {
						  data = dataUser.get(elem2);
						  if (elem2.nodeType === 1 && !dataPriv.get(elem2, "hasDataAttrs")) {
							 i = attrs.length;
							 while (i--) {
								if (attrs[i]) {
								  name = attrs[i].name;
								  if (name.indexOf("data-") === 0) {
									 name = camelCase(name.slice(5));
									 dataAttr(elem2, name, data[name]);
								  }
								}
							 }
							 dataPriv.set(elem2, "hasDataAttrs", true);
						  }
						}
						return data;
					 }
					 if (typeof key === "object") {
						return this.each(function() {
						  dataUser.set(this, key);
						});
					 }
					 return access(this, function(value2) {
						var data2;
						if (elem2 && value2 === void 0) {
						  data2 = dataUser.get(elem2, key);
						  if (data2 !== void 0) {
							 return data2;
						  }
						  data2 = dataAttr(elem2, key);
						  if (data2 !== void 0) {
							 return data2;
						  }
						  return;
						}
						this.each(function() {
						  dataUser.set(this, key, value2);
						});
					 }, null, value, arguments.length > 1, null, true);
				  },
				  removeData: function(key) {
					 return this.each(function() {
						dataUser.remove(this, key);
					 });
				  }
				});
				jQuery.extend({
				  queue: function(elem2, type2, data) {
					 var queue;
					 if (elem2) {
						type2 = (type2 || "fx") + "queue";
						queue = dataPriv.get(elem2, type2);
						if (data) {
						  if (!queue || Array.isArray(data)) {
							 queue = dataPriv.access(elem2, type2, jQuery.makeArray(data));
						  } else {
							 queue.push(data);
						  }
						}
						return queue || [];
					 }
				  },
				  dequeue: function(elem2, type2) {
					 type2 = type2 || "fx";
					 var queue = jQuery.queue(elem2, type2), startLength = queue.length, fn = queue.shift(), hooks = jQuery._queueHooks(elem2, type2), next = function() {
						jQuery.dequeue(elem2, type2);
					 };
					 if (fn === "inprogress") {
						fn = queue.shift();
						startLength--;
					 }
					 if (fn) {
						if (type2 === "fx") {
						  queue.unshift("inprogress");
						}
						delete hooks.stop;
						fn.call(elem2, next, hooks);
					 }
					 if (!startLength && hooks) {
						hooks.empty.fire();
					 }
				  },
				  // Not public - generate a queueHooks object, or return the current one
				  _queueHooks: function(elem2, type2) {
					 var key = type2 + "queueHooks";
					 return dataPriv.get(elem2, key) || dataPriv.access(elem2, key, {
						empty: jQuery.Callbacks("once memory").add(function() {
						  dataPriv.remove(elem2, [type2 + "queue", key]);
						})
					 });
				  }
				});
				jQuery.fn.extend({
				  queue: function(type2, data) {
					 var setter = 2;
					 if (typeof type2 !== "string") {
						data = type2;
						type2 = "fx";
						setter--;
					 }
					 if (arguments.length < setter) {
						return jQuery.queue(this[0], type2);
					 }
					 return data === void 0 ? this : this.each(function() {
						var queue = jQuery.queue(this, type2, data);
						jQuery._queueHooks(this, type2);
						if (type2 === "fx" && queue[0] !== "inprogress") {
						  jQuery.dequeue(this, type2);
						}
					 });
				  },
				  dequeue: function(type2) {
					 return this.each(function() {
						jQuery.dequeue(this, type2);
					 });
				  },
				  clearQueue: function(type2) {
					 return this.queue(type2 || "fx", []);
				  },
				  // Get a promise resolved when queues of a certain type
				  // are emptied (fx is the type by default)
				  promise: function(type2, obj) {
					 var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function() {
						if (!--count) {
						  defer.resolveWith(elements, [elements]);
						}
					 };
					 if (typeof type2 !== "string") {
						obj = type2;
						type2 = void 0;
					 }
					 type2 = type2 || "fx";
					 while (i--) {
						tmp = dataPriv.get(elements[i], type2 + "queueHooks");
						if (tmp && tmp.empty) {
						  count++;
						  tmp.empty.add(resolve);
						}
					 }
					 resolve();
					 return defer.promise(obj);
				  }
				});
				var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
				var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
				var cssExpand = ["Top", "Right", "Bottom", "Left"];
				var documentElement = document2.documentElement;
				var isAttached = function(elem2) {
				  return jQuery.contains(elem2.ownerDocument, elem2);
				}, composed = { composed: true };
				if (documentElement.getRootNode) {
				  isAttached = function(elem2) {
					 return jQuery.contains(elem2.ownerDocument, elem2) || elem2.getRootNode(composed) === elem2.ownerDocument;
				  };
				}
				var isHiddenWithinTree = function(elem2, el) {
				  elem2 = el || elem2;
				  return elem2.style.display === "none" || elem2.style.display === "" && // Otherwise, check computed style
				  // Support: Firefox <=43 - 45
				  // Disconnected elements can have computed display: none, so first confirm that elem is
				  // in the document.
				  isAttached(elem2) && jQuery.css(elem2, "display") === "none";
				};
				function adjustCSS(elem2, prop, valueParts, tween) {
				  var adjusted, scale, maxIterations = 20, currentValue = tween ? function() {
					 return tween.cur();
				  } : function() {
					 return jQuery.css(elem2, prop, "");
				  }, initial = currentValue(), unit2 = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"), initialInUnit = elem2.nodeType && (jQuery.cssNumber[prop] || unit2 !== "px" && +initial) && rcssNum.exec(jQuery.css(elem2, prop));
				  if (initialInUnit && initialInUnit[3] !== unit2) {
					 initial = initial / 2;
					 unit2 = unit2 || initialInUnit[3];
					 initialInUnit = +initial || 1;
					 while (maxIterations--) {
						jQuery.style(elem2, prop, initialInUnit + unit2);
						if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {
						  maxIterations = 0;
						}
						initialInUnit = initialInUnit / scale;
					 }
					 initialInUnit = initialInUnit * 2;
					 jQuery.style(elem2, prop, initialInUnit + unit2);
					 valueParts = valueParts || [];
				  }
				  if (valueParts) {
					 initialInUnit = +initialInUnit || +initial || 0;
					 adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
					 if (tween) {
						tween.unit = unit2;
						tween.start = initialInUnit;
						tween.end = adjusted;
					 }
				  }
				  return adjusted;
				}
				var defaultDisplayMap = {};
				function getDefaultDisplay(elem2) {
				  var temp, doc = elem2.ownerDocument, nodeName2 = elem2.nodeName, display = defaultDisplayMap[nodeName2];
				  if (display) {
					 return display;
				  }
				  temp = doc.body.appendChild(doc.createElement(nodeName2));
				  display = jQuery.css(temp, "display");
				  temp.parentNode.removeChild(temp);
				  if (display === "none") {
					 display = "block";
				  }
				  defaultDisplayMap[nodeName2] = display;
				  return display;
				}
				function showHide(elements, show) {
				  var display, elem2, values = [], index = 0, length = elements.length;
				  for (; index < length; index++) {
					 elem2 = elements[index];
					 if (!elem2.style) {
						continue;
					 }
					 display = elem2.style.display;
					 if (show) {
						if (display === "none") {
						  values[index] = dataPriv.get(elem2, "display") || null;
						  if (!values[index]) {
							 elem2.style.display = "";
						  }
						}
						if (elem2.style.display === "" && isHiddenWithinTree(elem2)) {
						  values[index] = getDefaultDisplay(elem2);
						}
					 } else {
						if (display !== "none") {
						  values[index] = "none";
						  dataPriv.set(elem2, "display", display);
						}
					 }
				  }
				  for (index = 0; index < length; index++) {
					 if (values[index] != null) {
						elements[index].style.display = values[index];
					 }
				  }
				  return elements;
				}
				jQuery.fn.extend({
				  show: function() {
					 return showHide(this, true);
				  },
				  hide: function() {
					 return showHide(this);
				  },
				  toggle: function(state) {
					 if (typeof state === "boolean") {
						return state ? this.show() : this.hide();
					 }
					 return this.each(function() {
						if (isHiddenWithinTree(this)) {
						  jQuery(this).show();
						} else {
						  jQuery(this).hide();
						}
					 });
				  }
				});
				var rcheckableType = /^(?:checkbox|radio)$/i;
				var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i;
				var rscriptType = /^$|^module$|\/(?:java|ecma)script/i;
				(function() {
				  var fragment = document2.createDocumentFragment(), div = fragment.appendChild(document2.createElement("div")), input2 = document2.createElement("input");
				  input2.setAttribute("type", "radio");
				  input2.setAttribute("checked", "checked");
				  input2.setAttribute("name", "t");
				  div.appendChild(input2);
				  support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
				  div.innerHTML = "<textarea>x</textarea>";
				  support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
				  div.innerHTML = "<option></option>";
				  support.option = !!div.lastChild;
				})();
				var wrapMap = {
				  // XHTML parsers do not magically insert elements in the
				  // same way that tag soup parsers do. So we cannot shorten
				  // this by omitting <tbody> or other required elements.
				  thead: [1, "<table>", "</table>"],
				  col: [2, "<table><colgroup>", "</colgroup></table>"],
				  tr: [2, "<table><tbody>", "</tbody></table>"],
				  td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
				  _default: [0, "", ""]
				};
				wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
				wrapMap.th = wrapMap.td;
				if (!support.option) {
				  wrapMap.optgroup = wrapMap.option = [1, "<select multiple='multiple'>", "</select>"];
				}
				function getAll(context2, tag) {
				  var ret;
				  if (typeof context2.getElementsByTagName !== "undefined") {
					 ret = context2.getElementsByTagName(tag || "*");
				  } else if (typeof context2.querySelectorAll !== "undefined") {
					 ret = context2.querySelectorAll(tag || "*");
				  } else {
					 ret = [];
				  }
				  if (tag === void 0 || tag && nodeName(context2, tag)) {
					 return jQuery.merge([context2], ret);
				  }
				  return ret;
				}
				function setGlobalEval(elems, refElements) {
				  var i = 0, l = elems.length;
				  for (; i < l; i++) {
					 dataPriv.set(
						elems[i],
						"globalEval",
						!refElements || dataPriv.get(refElements[i], "globalEval")
					 );
				  }
				}
				var rhtml = /<|&#?\w+;/;
				function buildFragment(elems, context2, scripts, selection2, ignored) {
				  var elem2, tmp, tag, wrap, attached, j, fragment = context2.createDocumentFragment(), nodes = [], i = 0, l = elems.length;
				  for (; i < l; i++) {
					 elem2 = elems[i];
					 if (elem2 || elem2 === 0) {
						if (toType(elem2) === "object") {
						  jQuery.merge(nodes, elem2.nodeType ? [elem2] : elem2);
						} else if (!rhtml.test(elem2)) {
						  nodes.push(context2.createTextNode(elem2));
						} else {
						  tmp = tmp || fragment.appendChild(context2.createElement("div"));
						  tag = (rtagName.exec(elem2) || ["", ""])[1].toLowerCase();
						  wrap = wrapMap[tag] || wrapMap._default;
						  tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem2) + wrap[2];
						  j = wrap[0];
						  while (j--) {
							 tmp = tmp.lastChild;
						  }
						  jQuery.merge(nodes, tmp.childNodes);
						  tmp = fragment.firstChild;
						  tmp.textContent = "";
						}
					 }
				  }
				  fragment.textContent = "";
				  i = 0;
				  while (elem2 = nodes[i++]) {
					 if (selection2 && jQuery.inArray(elem2, selection2) > -1) {
						if (ignored) {
						  ignored.push(elem2);
						}
						continue;
					 }
					 attached = isAttached(elem2);
					 tmp = getAll(fragment.appendChild(elem2), "script");
					 if (attached) {
						setGlobalEval(tmp);
					 }
					 if (scripts) {
						j = 0;
						while (elem2 = tmp[j++]) {
						  if (rscriptType.test(elem2.type || "")) {
							 scripts.push(elem2);
						  }
						}
					 }
				  }
				  return fragment;
				}
				var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
				function returnTrue() {
				  return true;
				}
				function returnFalse() {
				  return false;
				}
				function on(elem2, types, selector, data, fn, one2) {
				  var origFn, type2;
				  if (typeof types === "object") {
					 if (typeof selector !== "string") {
						data = data || selector;
						selector = void 0;
					 }
					 for (type2 in types) {
						on(elem2, type2, selector, data, types[type2], one2);
					 }
					 return elem2;
				  }
				  if (data == null && fn == null) {
					 fn = selector;
					 data = selector = void 0;
				  } else if (fn == null) {
					 if (typeof selector === "string") {
						fn = data;
						data = void 0;
					 } else {
						fn = data;
						data = selector;
						selector = void 0;
					 }
				  }
				  if (fn === false) {
					 fn = returnFalse;
				  } else if (!fn) {
					 return elem2;
				  }
				  if (one2 === 1) {
					 origFn = fn;
					 fn = function(event) {
						jQuery().off(event);
						return origFn.apply(this, arguments);
					 };
					 fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
				  }
				  return elem2.each(function() {
					 jQuery.event.add(this, types, fn, data, selector);
				  });
				}
				jQuery.event = {
				  copyGlobalForElem: {},
				  add: function(elem2, types, handler, data, selector) {
					 var handleObjIn, eventHandle, tmp, events, t, handleObj, special2, handlers, type2, namespaces, origType, elemData = dataPriv.get(elem2);
					 if (!acceptData(elem2)) {
						return;
					 }
					 if (handler.handler) {
						handleObjIn = handler;
						handler = handleObjIn.handler;
						selector = handleObjIn.selector;
					 }
					 if (selector) {
						jQuery.find.matchesSelector(documentElement, selector);
					 }
					 if (!handler.guid) {
						handler.guid = jQuery.guid++;
					 }
					 if (!(events = elemData.events)) {
						events = elemData.events = /* @__PURE__ */ Object.create(null);
					 }
					 if (!(eventHandle = elemData.handle)) {
						eventHandle = elemData.handle = function(e) {
						  return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem2, arguments) : void 0;
						};
					 }
					 types = (types || "").match(rnothtmlwhite) || [""];
					 t = types.length;
					 while (t--) {
						tmp = rtypenamespace.exec(types[t]) || [];
						type2 = origType = tmp[1];
						namespaces = (tmp[2] || "").split(".").sort();
						if (!type2) {
						  continue;
						}
						special2 = jQuery.event.special[type2] || {};
						type2 = (selector ? special2.delegateType : special2.bindType) || type2;
						special2 = jQuery.event.special[type2] || {};
						handleObj = jQuery.extend({
						  type: type2,
						  origType,
						  data,
						  handler,
						  guid: handler.guid,
						  selector,
						  needsContext: selector && jQuery.expr.match.needsContext.test(selector),
						  namespace: namespaces.join(".")
						}, handleObjIn);
						if (!(handlers = events[type2])) {
						  handlers = events[type2] = [];
						  handlers.delegateCount = 0;
						  if (!special2.setup || special2.setup.call(elem2, data, namespaces, eventHandle) === false) {
							 if (elem2.addEventListener) {
								elem2.addEventListener(type2, eventHandle);
							 }
						  }
						}
						if (special2.add) {
						  special2.add.call(elem2, handleObj);
						  if (!handleObj.handler.guid) {
							 handleObj.handler.guid = handler.guid;
						  }
						}
						if (selector) {
						  handlers.splice(handlers.delegateCount++, 0, handleObj);
						} else {
						  handlers.push(handleObj);
						}
						jQuery.event.copyGlobalForElem[type2] = true;
					 }
				  },
				  // Detach an event or set of events from an element
				  remove: function(elem2, types, handler, selector, mappedTypes) {
					 var j, origCount, tmp, events, t, handleObj, special2, handlers, type2, namespaces, origType, elemData = dataPriv.hasData(elem2) && dataPriv.get(elem2);
					 if (!elemData || !(events = elemData.events)) {
						return;
					 }
					 types = (types || "").match(rnothtmlwhite) || [""];
					 t = types.length;
					 while (t--) {
						tmp = rtypenamespace.exec(types[t]) || [];
						type2 = origType = tmp[1];
						namespaces = (tmp[2] || "").split(".").sort();
						if (!type2) {
						  for (type2 in events) {
							 jQuery.event.remove(elem2, type2 + types[t], handler, selector, true);
						  }
						  continue;
						}
						special2 = jQuery.event.special[type2] || {};
						type2 = (selector ? special2.delegateType : special2.bindType) || type2;
						handlers = events[type2] || [];
						tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
						origCount = j = handlers.length;
						while (j--) {
						  handleObj = handlers[j];
						  if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
							 handlers.splice(j, 1);
							 if (handleObj.selector) {
								handlers.delegateCount--;
							 }
							 if (special2.remove) {
								special2.remove.call(elem2, handleObj);
							 }
						  }
						}
						if (origCount && !handlers.length) {
						  if (!special2.teardown || special2.teardown.call(elem2, namespaces, elemData.handle) === false) {
							 jQuery.removeEvent(elem2, type2, elemData.handle);
						  }
						  delete events[type2];
						}
					 }
					 if (jQuery.isEmptyObject(events)) {
						dataPriv.remove(elem2, "handle events");
					 }
				  },
				  dispatch: function(nativeEvent) {
					 var i, j, ret, matched, handleObj, handlerQueue, args = new Array(arguments.length), event = jQuery.event.fix(nativeEvent), handlers = (dataPriv.get(this, "events") || /* @__PURE__ */ Object.create(null))[event.type] || [], special2 = jQuery.event.special[event.type] || {};
					 args[0] = event;
					 for (i = 1; i < arguments.length; i++) {
						args[i] = arguments[i];
					 }
					 event.delegateTarget = this;
					 if (special2.preDispatch && special2.preDispatch.call(this, event) === false) {
						return;
					 }
					 handlerQueue = jQuery.event.handlers.call(this, event, handlers);
					 i = 0;
					 while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
						event.currentTarget = matched.elem;
						j = 0;
						while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
						  if (!event.rnamespace || handleObj.namespace === false || event.rnamespace.test(handleObj.namespace)) {
							 event.handleObj = handleObj;
							 event.data = handleObj.data;
							 ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
							 if (ret !== void 0) {
								if ((event.result = ret) === false) {
								  event.preventDefault();
								  event.stopPropagation();
								}
							 }
						  }
						}
					 }
					 if (special2.postDispatch) {
						special2.postDispatch.call(this, event);
					 }
					 return event.result;
				  },
				  handlers: function(event, handlers) {
					 var i, handleObj, sel, matchedHandlers, matchedSelectors, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
					 if (delegateCount && // Support: IE <=9
					 // Black-hole SVG <use> instance trees (trac-13180)
					 cur.nodeType && // Support: Firefox <=42
					 // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
					 // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
					 // Support: IE 11 only
					 // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
					 !(event.type === "click" && event.button >= 1)) {
						for (; cur !== this; cur = cur.parentNode || this) {
						  if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
							 matchedHandlers = [];
							 matchedSelectors = {};
							 for (i = 0; i < delegateCount; i++) {
								handleObj = handlers[i];
								sel = handleObj.selector + " ";
								if (matchedSelectors[sel] === void 0) {
								  matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
								}
								if (matchedSelectors[sel]) {
								  matchedHandlers.push(handleObj);
								}
							 }
							 if (matchedHandlers.length) {
								handlerQueue.push({ elem: cur, handlers: matchedHandlers });
							 }
						  }
						}
					 }
					 cur = this;
					 if (delegateCount < handlers.length) {
						handlerQueue.push({ elem: cur, handlers: handlers.slice(delegateCount) });
					 }
					 return handlerQueue;
				  },
				  addProp: function(name, hook) {
					 Object.defineProperty(jQuery.Event.prototype, name, {
						enumerable: true,
						configurable: true,
						get: isFunction5(hook) ? function() {
						  if (this.originalEvent) {
							 return hook(this.originalEvent);
						  }
						} : function() {
						  if (this.originalEvent) {
							 return this.originalEvent[name];
						  }
						},
						set: function(value) {
						  Object.defineProperty(this, name, {
							 enumerable: true,
							 configurable: true,
							 writable: true,
							 value
						  });
						}
					 });
				  },
				  fix: function(originalEvent) {
					 return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);
				  },
				  special: {
					 load: {
						// Prevent triggered image.load events from bubbling to window.load
						noBubble: true
					 },
					 click: {
						// Utilize native event to ensure correct state for checkable inputs
						setup: function(data) {
						  var el = this || data;
						  if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
							 leverageNative(el, "click", true);
						  }
						  return false;
						},
						trigger: function(data) {
						  var el = this || data;
						  if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
							 leverageNative(el, "click");
						  }
						  return true;
						},
						// For cross-browser consistency, suppress native .click() on links
						// Also prevent it if we're currently inside a leveraged native-event stack
						_default: function(event) {
						  var target = event.target;
						  return rcheckableType.test(target.type) && target.click && nodeName(target, "input") && dataPriv.get(target, "click") || nodeName(target, "a");
						}
					 },
					 beforeunload: {
						postDispatch: function(event) {
						  if (event.result !== void 0 && event.originalEvent) {
							 event.originalEvent.returnValue = event.result;
						  }
						}
					 }
				  }
				};
				function leverageNative(el, type2, isSetup) {
				  if (!isSetup) {
					 if (dataPriv.get(el, type2) === void 0) {
						jQuery.event.add(el, type2, returnTrue);
					 }
					 return;
				  }
				  dataPriv.set(el, type2, false);
				  jQuery.event.add(el, type2, {
					 namespace: false,
					 handler: function(event) {
						var result, saved = dataPriv.get(this, type2);
						if (event.isTrigger & 1 && this[type2]) {
						  if (!saved) {
							 saved = slice.call(arguments);
							 dataPriv.set(this, type2, saved);
							 this[type2]();
							 result = dataPriv.get(this, type2);
							 dataPriv.set(this, type2, false);
							 if (saved !== result) {
								event.stopImmediatePropagation();
								event.preventDefault();
								return result;
							 }
						  } else if ((jQuery.event.special[type2] || {}).delegateType) {
							 event.stopPropagation();
						  }
						} else if (saved) {
						  dataPriv.set(this, type2, jQuery.event.trigger(
							 saved[0],
							 saved.slice(1),
							 this
						  ));
						  event.stopPropagation();
						  event.isImmediatePropagationStopped = returnTrue;
						}
					 }
				  });
				}
				jQuery.removeEvent = function(elem2, type2, handle) {
				  if (elem2.removeEventListener) {
					 elem2.removeEventListener(type2, handle);
				  }
				};
				jQuery.Event = function(src, props) {
				  if (!(this instanceof jQuery.Event)) {
					 return new jQuery.Event(src, props);
				  }
				  if (src && src.type) {
					 this.originalEvent = src;
					 this.type = src.type;
					 this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === void 0 && // Support: Android <=2.3 only
					 src.returnValue === false ? returnTrue : returnFalse;
					 this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
					 this.currentTarget = src.currentTarget;
					 this.relatedTarget = src.relatedTarget;
				  } else {
					 this.type = src;
				  }
				  if (props) {
					 jQuery.extend(this, props);
				  }
				  this.timeStamp = src && src.timeStamp || Date.now();
				  this[jQuery.expando] = true;
				};
				jQuery.Event.prototype = {
				  constructor: jQuery.Event,
				  isDefaultPrevented: returnFalse,
				  isPropagationStopped: returnFalse,
				  isImmediatePropagationStopped: returnFalse,
				  isSimulated: false,
				  preventDefault: function() {
					 var e = this.originalEvent;
					 this.isDefaultPrevented = returnTrue;
					 if (e && !this.isSimulated) {
						e.preventDefault();
					 }
				  },
				  stopPropagation: function() {
					 var e = this.originalEvent;
					 this.isPropagationStopped = returnTrue;
					 if (e && !this.isSimulated) {
						e.stopPropagation();
					 }
				  },
				  stopImmediatePropagation: function() {
					 var e = this.originalEvent;
					 this.isImmediatePropagationStopped = returnTrue;
					 if (e && !this.isSimulated) {
						e.stopImmediatePropagation();
					 }
					 this.stopPropagation();
				  }
				};
				jQuery.each({
				  altKey: true,
				  bubbles: true,
				  cancelable: true,
				  changedTouches: true,
				  ctrlKey: true,
				  detail: true,
				  eventPhase: true,
				  metaKey: true,
				  pageX: true,
				  pageY: true,
				  shiftKey: true,
				  view: true,
				  "char": true,
				  code: true,
				  charCode: true,
				  key: true,
				  keyCode: true,
				  button: true,
				  buttons: true,
				  clientX: true,
				  clientY: true,
				  offsetX: true,
				  offsetY: true,
				  pointerId: true,
				  pointerType: true,
				  screenX: true,
				  screenY: true,
				  targetTouches: true,
				  toElement: true,
				  touches: true,
				  which: true
				}, jQuery.event.addProp);
				jQuery.each({ focus: "focusin", blur: "focusout" }, function(type2, delegateType) {
				  function focusMappedHandler(nativeEvent) {
					 if (document2.documentMode) {
						var handle = dataPriv.get(this, "handle"), event = jQuery.event.fix(nativeEvent);
						event.type = nativeEvent.type === "focusin" ? "focus" : "blur";
						event.isSimulated = true;
						handle(nativeEvent);
						if (event.target === event.currentTarget) {
						  handle(event);
						}
					 } else {
						jQuery.event.simulate(
						  delegateType,
						  nativeEvent.target,
						  jQuery.event.fix(nativeEvent)
						);
					 }
				  }
				  jQuery.event.special[type2] = {
					 // Utilize native event if possible so blur/focus sequence is correct
					 setup: function() {
						var attaches;
						leverageNative(this, type2, true);
						if (document2.documentMode) {
						  attaches = dataPriv.get(this, delegateType);
						  if (!attaches) {
							 this.addEventListener(delegateType, focusMappedHandler);
						  }
						  dataPriv.set(this, delegateType, (attaches || 0) + 1);
						} else {
						  return false;
						}
					 },
					 trigger: function() {
						leverageNative(this, type2);
						return true;
					 },
					 teardown: function() {
						var attaches;
						if (document2.documentMode) {
						  attaches = dataPriv.get(this, delegateType) - 1;
						  if (!attaches) {
							 this.removeEventListener(delegateType, focusMappedHandler);
							 dataPriv.remove(this, delegateType);
						  } else {
							 dataPriv.set(this, delegateType, attaches);
						  }
						} else {
						  return false;
						}
					 },
					 // Suppress native focus or blur if we're currently inside
					 // a leveraged native-event stack
					 _default: function(event) {
						return dataPriv.get(event.target, type2);
					 },
					 delegateType
				  };
				  jQuery.event.special[delegateType] = {
					 setup: function() {
						var doc = this.ownerDocument || this.document || this, dataHolder = document2.documentMode ? this : doc, attaches = dataPriv.get(dataHolder, delegateType);
						if (!attaches) {
						  if (document2.documentMode) {
							 this.addEventListener(delegateType, focusMappedHandler);
						  } else {
							 doc.addEventListener(type2, focusMappedHandler, true);
						  }
						}
						dataPriv.set(dataHolder, delegateType, (attaches || 0) + 1);
					 },
					 teardown: function() {
						var doc = this.ownerDocument || this.document || this, dataHolder = document2.documentMode ? this : doc, attaches = dataPriv.get(dataHolder, delegateType) - 1;
						if (!attaches) {
						  if (document2.documentMode) {
							 this.removeEventListener(delegateType, focusMappedHandler);
						  } else {
							 doc.removeEventListener(type2, focusMappedHandler, true);
						  }
						  dataPriv.remove(dataHolder, delegateType);
						} else {
						  dataPriv.set(dataHolder, delegateType, attaches);
						}
					 }
				  };
				});
				jQuery.each({
				  mouseenter: "mouseover",
				  mouseleave: "mouseout",
				  pointerenter: "pointerover",
				  pointerleave: "pointerout"
				}, function(orig, fix) {
				  jQuery.event.special[orig] = {
					 delegateType: fix,
					 bindType: fix,
					 handle: function(event) {
						var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
						if (!related || related !== target && !jQuery.contains(target, related)) {
						  event.type = handleObj.origType;
						  ret = handleObj.handler.apply(this, arguments);
						  event.type = fix;
						}
						return ret;
					 }
				  };
				});
				jQuery.fn.extend({
				  on: function(types, selector, data, fn) {
					 return on(this, types, selector, data, fn);
				  },
				  one: function(types, selector, data, fn) {
					 return on(this, types, selector, data, fn, 1);
				  },
				  off: function(types, selector, fn) {
					 var handleObj, type2;
					 if (types && types.preventDefault && types.handleObj) {
						handleObj = types.handleObj;
						jQuery(types.delegateTarget).off(
						  handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
						  handleObj.selector,
						  handleObj.handler
						);
						return this;
					 }
					 if (typeof types === "object") {
						for (type2 in types) {
						  this.off(type2, selector, types[type2]);
						}
						return this;
					 }
					 if (selector === false || typeof selector === "function") {
						fn = selector;
						selector = void 0;
					 }
					 if (fn === false) {
						fn = returnFalse;
					 }
					 return this.each(function() {
						jQuery.event.remove(this, types, fn, selector);
					 });
				  }
				});
				var rnoInnerhtml = /<script|<style|<link/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rcleanScript = /^\s*<!\[CDATA\[|\]\]>\s*$/g;
				function manipulationTarget(elem2, content) {
				  if (nodeName(elem2, "table") && nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {
					 return jQuery(elem2).children("tbody")[0] || elem2;
				  }
				  return elem2;
				}
				function disableScript(elem2) {
				  elem2.type = (elem2.getAttribute("type") !== null) + "/" + elem2.type;
				  return elem2;
				}
				function restoreScript(elem2) {
				  if ((elem2.type || "").slice(0, 5) === "true/") {
					 elem2.type = elem2.type.slice(5);
				  } else {
					 elem2.removeAttribute("type");
				  }
				  return elem2;
				}
				function cloneCopyEvent(src, dest) {
				  var i, l, type2, pdataOld, udataOld, udataCur, events;
				  if (dest.nodeType !== 1) {
					 return;
				  }
				  if (dataPriv.hasData(src)) {
					 pdataOld = dataPriv.get(src);
					 events = pdataOld.events;
					 if (events) {
						dataPriv.remove(dest, "handle events");
						for (type2 in events) {
						  for (i = 0, l = events[type2].length; i < l; i++) {
							 jQuery.event.add(dest, type2, events[type2][i]);
						  }
						}
					 }
				  }
				  if (dataUser.hasData(src)) {
					 udataOld = dataUser.access(src);
					 udataCur = jQuery.extend({}, udataOld);
					 dataUser.set(dest, udataCur);
				  }
				}
				function fixInput(src, dest) {
				  var nodeName2 = dest.nodeName.toLowerCase();
				  if (nodeName2 === "input" && rcheckableType.test(src.type)) {
					 dest.checked = src.checked;
				  } else if (nodeName2 === "input" || nodeName2 === "textarea") {
					 dest.defaultValue = src.defaultValue;
				  }
				}
				function domManip(collection, args, callback, ignored) {
				  args = flat(args);
				  var fragment, first2, scripts, hasScripts, node, doc, i = 0, l = collection.length, iNoClone = l - 1, value = args[0], valueIsFunction = isFunction5(value);
				  if (valueIsFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
					 return collection.each(function(index) {
						var self2 = collection.eq(index);
						if (valueIsFunction) {
						  args[0] = value.call(this, index, self2.html());
						}
						domManip(self2, args, callback, ignored);
					 });
				  }
				  if (l) {
					 fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
					 first2 = fragment.firstChild;
					 if (fragment.childNodes.length === 1) {
						fragment = first2;
					 }
					 if (first2 || ignored) {
						scripts = jQuery.map(getAll(fragment, "script"), disableScript);
						hasScripts = scripts.length;
						for (; i < l; i++) {
						  node = fragment;
						  if (i !== iNoClone) {
							 node = jQuery.clone(node, true, true);
							 if (hasScripts) {
								jQuery.merge(scripts, getAll(node, "script"));
							 }
						  }
						  callback.call(collection[i], node, i);
						}
						if (hasScripts) {
						  doc = scripts[scripts.length - 1].ownerDocument;
						  jQuery.map(scripts, restoreScript);
						  for (i = 0; i < hasScripts; i++) {
							 node = scripts[i];
							 if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node)) {
								if (node.src && (node.type || "").toLowerCase() !== "module") {
								  if (jQuery._evalUrl && !node.noModule) {
									 jQuery._evalUrl(node.src, {
										nonce: node.nonce || node.getAttribute("nonce")
									 }, doc);
								  }
								} else {
								  DOMEval(node.textContent.replace(rcleanScript, ""), node, doc);
								}
							 }
						  }
						}
					 }
				  }
				  return collection;
				}
				function remove4(elem2, selector, keepData) {
				  var node, nodes = selector ? jQuery.filter(selector, elem2) : elem2, i = 0;
				  for (; (node = nodes[i]) != null; i++) {
					 if (!keepData && node.nodeType === 1) {
						jQuery.cleanData(getAll(node));
					 }
					 if (node.parentNode) {
						if (keepData && isAttached(node)) {
						  setGlobalEval(getAll(node, "script"));
						}
						node.parentNode.removeChild(node);
					 }
				  }
				  return elem2;
				}
				jQuery.extend({
				  htmlPrefilter: function(html) {
					 return html;
				  },
				  clone: function(elem2, dataAndEvents, deepDataAndEvents) {
					 var i, l, srcElements, destElements, clone2 = elem2.cloneNode(true), inPage = isAttached(elem2);
					 if (!support.noCloneChecked && (elem2.nodeType === 1 || elem2.nodeType === 11) && !jQuery.isXMLDoc(elem2)) {
						destElements = getAll(clone2);
						srcElements = getAll(elem2);
						for (i = 0, l = srcElements.length; i < l; i++) {
						  fixInput(srcElements[i], destElements[i]);
						}
					 }
					 if (dataAndEvents) {
						if (deepDataAndEvents) {
						  srcElements = srcElements || getAll(elem2);
						  destElements = destElements || getAll(clone2);
						  for (i = 0, l = srcElements.length; i < l; i++) {
							 cloneCopyEvent(srcElements[i], destElements[i]);
						  }
						} else {
						  cloneCopyEvent(elem2, clone2);
						}
					 }
					 destElements = getAll(clone2, "script");
					 if (destElements.length > 0) {
						setGlobalEval(destElements, !inPage && getAll(elem2, "script"));
					 }
					 return clone2;
				  },
				  cleanData: function(elems) {
					 var data, elem2, type2, special2 = jQuery.event.special, i = 0;
					 for (; (elem2 = elems[i]) !== void 0; i++) {
						if (acceptData(elem2)) {
						  if (data = elem2[dataPriv.expando]) {
							 if (data.events) {
								for (type2 in data.events) {
								  if (special2[type2]) {
									 jQuery.event.remove(elem2, type2);
								  } else {
									 jQuery.removeEvent(elem2, type2, data.handle);
								  }
								}
							 }
							 elem2[dataPriv.expando] = void 0;
						  }
						  if (elem2[dataUser.expando]) {
							 elem2[dataUser.expando] = void 0;
						  }
						}
					 }
				  }
				});
				jQuery.fn.extend({
				  detach: function(selector) {
					 return remove4(this, selector, true);
				  },
				  remove: function(selector) {
					 return remove4(this, selector);
				  },
				  text: function(value) {
					 return access(this, function(value2) {
						return value2 === void 0 ? jQuery.text(this) : this.empty().each(function() {
						  if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
							 this.textContent = value2;
						  }
						});
					 }, null, value, arguments.length);
				  },
				  append: function() {
					 return domManip(this, arguments, function(elem2) {
						if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
						  var target = manipulationTarget(this, elem2);
						  target.appendChild(elem2);
						}
					 });
				  },
				  prepend: function() {
					 return domManip(this, arguments, function(elem2) {
						if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
						  var target = manipulationTarget(this, elem2);
						  target.insertBefore(elem2, target.firstChild);
						}
					 });
				  },
				  before: function() {
					 return domManip(this, arguments, function(elem2) {
						if (this.parentNode) {
						  this.parentNode.insertBefore(elem2, this);
						}
					 });
				  },
				  after: function() {
					 return domManip(this, arguments, function(elem2) {
						if (this.parentNode) {
						  this.parentNode.insertBefore(elem2, this.nextSibling);
						}
					 });
				  },
				  empty: function() {
					 var elem2, i = 0;
					 for (; (elem2 = this[i]) != null; i++) {
						if (elem2.nodeType === 1) {
						  jQuery.cleanData(getAll(elem2, false));
						  elem2.textContent = "";
						}
					 }
					 return this;
				  },
				  clone: function(dataAndEvents, deepDataAndEvents) {
					 dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
					 deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
					 return this.map(function() {
						return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
					 });
				  },
				  html: function(value) {
					 return access(this, function(value2) {
						var elem2 = this[0] || {}, i = 0, l = this.length;
						if (value2 === void 0 && elem2.nodeType === 1) {
						  return elem2.innerHTML;
						}
						if (typeof value2 === "string" && !rnoInnerhtml.test(value2) && !wrapMap[(rtagName.exec(value2) || ["", ""])[1].toLowerCase()]) {
						  value2 = jQuery.htmlPrefilter(value2);
						  try {
							 for (; i < l; i++) {
								elem2 = this[i] || {};
								if (elem2.nodeType === 1) {
								  jQuery.cleanData(getAll(elem2, false));
								  elem2.innerHTML = value2;
								}
							 }
							 elem2 = 0;
						  } catch (e) {
						  }
						}
						if (elem2) {
						  this.empty().append(value2);
						}
					 }, null, value, arguments.length);
				  },
				  replaceWith: function() {
					 var ignored = [];
					 return domManip(this, arguments, function(elem2) {
						var parent = this.parentNode;
						if (jQuery.inArray(this, ignored) < 0) {
						  jQuery.cleanData(getAll(this));
						  if (parent) {
							 parent.replaceChild(elem2, this);
						  }
						}
					 }, ignored);
				  }
				});
				jQuery.each({
				  appendTo: "append",
				  prependTo: "prepend",
				  insertBefore: "before",
				  insertAfter: "after",
				  replaceAll: "replaceWith"
				}, function(name, original) {
				  jQuery.fn[name] = function(selector) {
					 var elems, ret = [], insert = jQuery(selector), last2 = insert.length - 1, i = 0;
					 for (; i <= last2; i++) {
						elems = i === last2 ? this : this.clone(true);
						jQuery(insert[i])[original](elems);
						push.apply(ret, elems.get());
					 }
					 return this.pushStack(ret);
				  };
				});
				var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
				var rcustomProp = /^--/;
				var getStyles = function(elem2) {
				  var view = elem2.ownerDocument.defaultView;
				  if (!view || !view.opener) {
					 view = window2;
				  }
				  return view.getComputedStyle(elem2);
				};
				var swap = function(elem2, options, callback) {
				  var ret, name, old = {};
				  for (name in options) {
					 old[name] = elem2.style[name];
					 elem2.style[name] = options[name];
				  }
				  ret = callback.call(elem2);
				  for (name in options) {
					 elem2.style[name] = old[name];
				  }
				  return ret;
				};
				var rboxStyle = new RegExp(cssExpand.join("|"), "i");
				(function() {
				  function computeStyleTests() {
					 if (!div) {
						return;
					 }
					 container.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0";
					 div.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%";
					 documentElement.appendChild(container).appendChild(div);
					 var divStyle = window2.getComputedStyle(div);
					 pixelPositionVal = divStyle.top !== "1%";
					 reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;
					 div.style.right = "60%";
					 pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;
					 boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36;
					 div.style.position = "absolute";
					 scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12;
					 documentElement.removeChild(container);
					 div = null;
				  }
				  function roundPixelMeasures(measure) {
					 return Math.round(parseFloat(measure));
				  }
				  var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal, reliableTrDimensionsVal, reliableMarginLeftVal, container = document2.createElement("div"), div = document2.createElement("div");
				  if (!div.style) {
					 return;
				  }
				  div.style.backgroundClip = "content-box";
				  div.cloneNode(true).style.backgroundClip = "";
				  support.clearCloneStyle = div.style.backgroundClip === "content-box";
				  jQuery.extend(support, {
					 boxSizingReliable: function() {
						computeStyleTests();
						return boxSizingReliableVal;
					 },
					 pixelBoxStyles: function() {
						computeStyleTests();
						return pixelBoxStylesVal;
					 },
					 pixelPosition: function() {
						computeStyleTests();
						return pixelPositionVal;
					 },
					 reliableMarginLeft: function() {
						computeStyleTests();
						return reliableMarginLeftVal;
					 },
					 scrollboxSize: function() {
						computeStyleTests();
						return scrollboxSizeVal;
					 },
					 // Support: IE 9 - 11+, Edge 15 - 18+
					 // IE/Edge misreport `getComputedStyle` of table rows with width/height
					 // set in CSS while `offset*` properties report correct values.
					 // Behavior in IE 9 is more subtle than in newer versions & it passes
					 // some versions of this test; make sure not to make it pass there!
					 //
					 // Support: Firefox 70+
					 // Only Firefox includes border widths
					 // in computed dimensions. (gh-4529)
					 reliableTrDimensions: function() {
						var table, tr, trChild, trStyle;
						if (reliableTrDimensionsVal == null) {
						  table = document2.createElement("table");
						  tr = document2.createElement("tr");
						  trChild = document2.createElement("div");
						  table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
						  tr.style.cssText = "box-sizing:content-box;border:1px solid";
						  tr.style.height = "1px";
						  trChild.style.height = "9px";
						  trChild.style.display = "block";
						  documentElement.appendChild(table).appendChild(tr).appendChild(trChild);
						  trStyle = window2.getComputedStyle(tr);
						  reliableTrDimensionsVal = parseInt(trStyle.height, 10) + parseInt(trStyle.borderTopWidth, 10) + parseInt(trStyle.borderBottomWidth, 10) === tr.offsetHeight;
						  documentElement.removeChild(table);
						}
						return reliableTrDimensionsVal;
					 }
				  });
				})();
				function curCSS(elem2, name, computed) {
				  var width, minWidth, maxWidth, ret, isCustomProp = rcustomProp.test(name), style = elem2.style;
				  computed = computed || getStyles(elem2);
				  if (computed) {
					 ret = computed.getPropertyValue(name) || computed[name];
					 if (isCustomProp && ret) {
						ret = ret.replace(rtrimCSS, "$1") || void 0;
					 }
					 if (ret === "" && !isAttached(elem2)) {
						ret = jQuery.style(elem2, name);
					 }
					 if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {
						width = style.width;
						minWidth = style.minWidth;
						maxWidth = style.maxWidth;
						style.minWidth = style.maxWidth = style.width = ret;
						ret = computed.width;
						style.width = width;
						style.minWidth = minWidth;
						style.maxWidth = maxWidth;
					 }
				  }
				  return ret !== void 0 ? (
					 // Support: IE <=9 - 11 only
					 // IE returns zIndex value as an integer.
					 ret + ""
				  ) : ret;
				}
				function addGetHookIf(conditionFn, hookFn) {
				  return {
					 get: function() {
						if (conditionFn()) {
						  delete this.get;
						  return;
						}
						return (this.get = hookFn).apply(this, arguments);
					 }
				  };
				}
				var cssPrefixes = ["Webkit", "Moz", "ms"], emptyStyle = document2.createElement("div").style, vendorProps = {};
				function vendorPropName(name) {
				  var capName = name[0].toUpperCase() + name.slice(1), i = cssPrefixes.length;
				  while (i--) {
					 name = cssPrefixes[i] + capName;
					 if (name in emptyStyle) {
						return name;
					 }
				  }
				}
				function finalPropName(name) {
				  var final = jQuery.cssProps[name] || vendorProps[name];
				  if (final) {
					 return final;
				  }
				  if (name in emptyStyle) {
					 return name;
				  }
				  return vendorProps[name] = vendorPropName(name) || name;
				}
				var rdisplayswap = /^(none|table(?!-c[ea]).+)/, cssShow = { position: "absolute", visibility: "hidden", display: "block" }, cssNormalTransform = {
				  letterSpacing: "0",
				  fontWeight: "400"
				};
				function setPositiveNumber(_elem, value, subtract) {
				  var matches = rcssNum.exec(value);
				  return matches ? (
					 // Guard against undefined "subtract", e.g., when used as in cssHooks
					 Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px")
				  ) : value;
				}
				function boxModelAdjustment(elem2, dimension, box, isBorderBox, styles, computedVal) {
				  var i = dimension === "width" ? 1 : 0, extra = 0, delta = 0, marginDelta = 0;
				  if (box === (isBorderBox ? "border" : "content")) {
					 return 0;
				  }
				  for (; i < 4; i += 2) {
					 if (box === "margin") {
						marginDelta += jQuery.css(elem2, box + cssExpand[i], true, styles);
					 }
					 if (!isBorderBox) {
						delta += jQuery.css(elem2, "padding" + cssExpand[i], true, styles);
						if (box !== "padding") {
						  delta += jQuery.css(elem2, "border" + cssExpand[i] + "Width", true, styles);
						} else {
						  extra += jQuery.css(elem2, "border" + cssExpand[i] + "Width", true, styles);
						}
					 } else {
						if (box === "content") {
						  delta -= jQuery.css(elem2, "padding" + cssExpand[i], true, styles);
						}
						if (box !== "margin") {
						  delta -= jQuery.css(elem2, "border" + cssExpand[i] + "Width", true, styles);
						}
					 }
				  }
				  if (!isBorderBox && computedVal >= 0) {
					 delta += Math.max(0, Math.ceil(
						elem2["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5
						// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
						// Use an explicit zero to avoid NaN (gh-3964)
					 )) || 0;
				  }
				  return delta + marginDelta;
				}
				function getWidthOrHeight(elem2, dimension, extra) {
				  var styles = getStyles(elem2), boxSizingNeeded = !support.boxSizingReliable() || extra, isBorderBox = boxSizingNeeded && jQuery.css(elem2, "boxSizing", false, styles) === "border-box", valueIsBorderBox = isBorderBox, val = curCSS(elem2, dimension, styles), offsetProp = "offset" + dimension[0].toUpperCase() + dimension.slice(1);
				  if (rnumnonpx.test(val)) {
					 if (!extra) {
						return val;
					 }
					 val = "auto";
				  }
				  if ((!support.boxSizingReliable() && isBorderBox || // Support: IE 10 - 11+, Edge 15 - 18+
				  // IE/Edge misreport `getComputedStyle` of table rows with width/height
				  // set in CSS while `offset*` properties report correct values.
				  // Interestingly, in some cases IE 9 doesn't suffer from this issue.
				  !support.reliableTrDimensions() && nodeName(elem2, "tr") || // Fall back to offsetWidth/offsetHeight when value is "auto"
				  // This happens for inline elements with no explicit setting (gh-3571)
				  val === "auto" || // Support: Android <=4.1 - 4.3 only
				  // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
				  !parseFloat(val) && jQuery.css(elem2, "display", false, styles) === "inline") && // Make sure the element is visible & connected
				  elem2.getClientRects().length) {
					 isBorderBox = jQuery.css(elem2, "boxSizing", false, styles) === "border-box";
					 valueIsBorderBox = offsetProp in elem2;
					 if (valueIsBorderBox) {
						val = elem2[offsetProp];
					 }
				  }
				  val = parseFloat(val) || 0;
				  return val + boxModelAdjustment(
					 elem2,
					 dimension,
					 extra || (isBorderBox ? "border" : "content"),
					 valueIsBorderBox,
					 styles,
					 // Provide the current computed size to request scroll gutter calculation (gh-3589)
					 val
				  ) + "px";
				}
				jQuery.extend({
				  // Add in style property hooks for overriding the default
				  // behavior of getting and setting a style property
				  cssHooks: {
					 opacity: {
						get: function(elem2, computed) {
						  if (computed) {
							 var ret = curCSS(elem2, "opacity");
							 return ret === "" ? "1" : ret;
						  }
						}
					 }
				  },
				  // Don't automatically add "px" to these possibly-unitless properties
				  cssNumber: {
					 animationIterationCount: true,
					 aspectRatio: true,
					 borderImageSlice: true,
					 columnCount: true,
					 flexGrow: true,
					 flexShrink: true,
					 fontWeight: true,
					 gridArea: true,
					 gridColumn: true,
					 gridColumnEnd: true,
					 gridColumnStart: true,
					 gridRow: true,
					 gridRowEnd: true,
					 gridRowStart: true,
					 lineHeight: true,
					 opacity: true,
					 order: true,
					 orphans: true,
					 scale: true,
					 widows: true,
					 zIndex: true,
					 zoom: true,
					 // SVG-related
					 fillOpacity: true,
					 floodOpacity: true,
					 stopOpacity: true,
					 strokeMiterlimit: true,
					 strokeOpacity: true
				  },
				  // Add in properties whose names you wish to fix before
				  // setting or getting the value
				  cssProps: {},
				  // Get and set the style property on a DOM Node
				  style: function(elem2, name, value, extra) {
					 if (!elem2 || elem2.nodeType === 3 || elem2.nodeType === 8 || !elem2.style) {
						return;
					 }
					 var ret, type2, hooks, origName = camelCase(name), isCustomProp = rcustomProp.test(name), style = elem2.style;
					 if (!isCustomProp) {
						name = finalPropName(origName);
					 }
					 hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
					 if (value !== void 0) {
						type2 = typeof value;
						if (type2 === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
						  value = adjustCSS(elem2, name, ret);
						  type2 = "number";
						}
						if (value == null || value !== value) {
						  return;
						}
						if (type2 === "number" && !isCustomProp) {
						  value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
						}
						if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
						  style[name] = "inherit";
						}
						if (!hooks || !("set" in hooks) || (value = hooks.set(elem2, value, extra)) !== void 0) {
						  if (isCustomProp) {
							 style.setProperty(name, value);
						  } else {
							 style[name] = value;
						  }
						}
					 } else {
						if (hooks && "get" in hooks && (ret = hooks.get(elem2, false, extra)) !== void 0) {
						  return ret;
						}
						return style[name];
					 }
				  },
				  css: function(elem2, name, extra, styles) {
					 var val, num, hooks, origName = camelCase(name), isCustomProp = rcustomProp.test(name);
					 if (!isCustomProp) {
						name = finalPropName(origName);
					 }
					 hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
					 if (hooks && "get" in hooks) {
						val = hooks.get(elem2, true, extra);
					 }
					 if (val === void 0) {
						val = curCSS(elem2, name, styles);
					 }
					 if (val === "normal" && name in cssNormalTransform) {
						val = cssNormalTransform[name];
					 }
					 if (extra === "" || extra) {
						num = parseFloat(val);
						return extra === true || isFinite(num) ? num || 0 : val;
					 }
					 return val;
				  }
				});
				jQuery.each(["height", "width"], function(_i, dimension) {
				  jQuery.cssHooks[dimension] = {
					 get: function(elem2, computed, extra) {
						if (computed) {
						  return rdisplayswap.test(jQuery.css(elem2, "display")) && // Support: Safari 8+
						  // Table columns in Safari have non-zero offsetWidth & zero
						  // getBoundingClientRect().width unless display is changed.
						  // Support: IE <=11 only
						  // Running getBoundingClientRect on a disconnected node
						  // in IE throws an error.
						  (!elem2.getClientRects().length || !elem2.getBoundingClientRect().width) ? swap(elem2, cssShow, function() {
							 return getWidthOrHeight(elem2, dimension, extra);
						  }) : getWidthOrHeight(elem2, dimension, extra);
						}
					 },
					 set: function(elem2, value, extra) {
						var matches, styles = getStyles(elem2), scrollboxSizeBuggy = !support.scrollboxSize() && styles.position === "absolute", boxSizingNeeded = scrollboxSizeBuggy || extra, isBorderBox = boxSizingNeeded && jQuery.css(elem2, "boxSizing", false, styles) === "border-box", subtract = extra ? boxModelAdjustment(
						  elem2,
						  dimension,
						  extra,
						  isBorderBox,
						  styles
						) : 0;
						if (isBorderBox && scrollboxSizeBuggy) {
						  subtract -= Math.ceil(
							 elem2["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem2, dimension, "border", false, styles) - 0.5
						  );
						}
						if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
						  elem2.style[dimension] = value;
						  value = jQuery.css(elem2, dimension);
						}
						return setPositiveNumber(elem2, value, subtract);
					 }
				  };
				});
				jQuery.cssHooks.marginLeft = addGetHookIf(
				  support.reliableMarginLeft,
				  function(elem2, computed) {
					 if (computed) {
						return (parseFloat(curCSS(elem2, "marginLeft")) || elem2.getBoundingClientRect().left - swap(elem2, { marginLeft: 0 }, function() {
						  return elem2.getBoundingClientRect().left;
						})) + "px";
					 }
				  }
				);
				jQuery.each({
				  margin: "",
				  padding: "",
				  border: "Width"
				}, function(prefix, suffix) {
				  jQuery.cssHooks[prefix + suffix] = {
					 expand: function(value) {
						var i = 0, expanded = {}, parts = typeof value === "string" ? value.split(" ") : [value];
						for (; i < 4; i++) {
						  expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
						}
						return expanded;
					 }
				  };
				  if (prefix !== "margin") {
					 jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
				  }
				});
				jQuery.fn.extend({
				  css: function(name, value) {
					 return access(this, function(elem2, name2, value2) {
						var styles, len, map3 = {}, i = 0;
						if (Array.isArray(name2)) {
						  styles = getStyles(elem2);
						  len = name2.length;
						  for (; i < len; i++) {
							 map3[name2[i]] = jQuery.css(elem2, name2[i], false, styles);
						  }
						  return map3;
						}
						return value2 !== void 0 ? jQuery.style(elem2, name2, value2) : jQuery.css(elem2, name2);
					 }, name, value, arguments.length > 1);
				  }
				});
				function Tween(elem2, options, prop, end, easing) {
				  return new Tween.prototype.init(elem2, options, prop, end, easing);
				}
				jQuery.Tween = Tween;
				Tween.prototype = {
				  constructor: Tween,
				  init: function(elem2, options, prop, end, easing, unit2) {
					 this.elem = elem2;
					 this.prop = prop;
					 this.easing = easing || jQuery.easing._default;
					 this.options = options;
					 this.start = this.now = this.cur();
					 this.end = end;
					 this.unit = unit2 || (jQuery.cssNumber[prop] ? "" : "px");
				  },
				  cur: function() {
					 var hooks = Tween.propHooks[this.prop];
					 return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
				  },
				  run: function(percent) {
					 var eased, hooks = Tween.propHooks[this.prop];
					 if (this.options.duration) {
						this.pos = eased = jQuery.easing[this.easing](
						  percent,
						  this.options.duration * percent,
						  0,
						  1,
						  this.options.duration
						);
					 } else {
						this.pos = eased = percent;
					 }
					 this.now = (this.end - this.start) * eased + this.start;
					 if (this.options.step) {
						this.options.step.call(this.elem, this.now, this);
					 }
					 if (hooks && hooks.set) {
						hooks.set(this);
					 } else {
						Tween.propHooks._default.set(this);
					 }
					 return this;
				  }
				};
				Tween.prototype.init.prototype = Tween.prototype;
				Tween.propHooks = {
				  _default: {
					 get: function(tween) {
						var result;
						if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
						  return tween.elem[tween.prop];
						}
						result = jQuery.css(tween.elem, tween.prop, "");
						return !result || result === "auto" ? 0 : result;
					 },
					 set: function(tween) {
						if (jQuery.fx.step[tween.prop]) {
						  jQuery.fx.step[tween.prop](tween);
						} else if (tween.elem.nodeType === 1 && (jQuery.cssHooks[tween.prop] || tween.elem.style[finalPropName(tween.prop)] != null)) {
						  jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
						} else {
						  tween.elem[tween.prop] = tween.now;
						}
					 }
				  }
				};
				Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
				  set: function(tween) {
					 if (tween.elem.nodeType && tween.elem.parentNode) {
						tween.elem[tween.prop] = tween.now;
					 }
				  }
				};
				jQuery.easing = {
				  linear: function(p) {
					 return p;
				  },
				  swing: function(p) {
					 return 0.5 - Math.cos(p * Math.PI) / 2;
				  },
				  _default: "swing"
				};
				jQuery.fx = Tween.prototype.init;
				jQuery.fx.step = {};
				var fxNow, inProgress, rfxtypes = /^(?:toggle|show|hide)$/, rrun = /queueHooks$/;
				function schedule() {
				  if (inProgress) {
					 if (document2.hidden === false && window2.requestAnimationFrame) {
						window2.requestAnimationFrame(schedule);
					 } else {
						window2.setTimeout(schedule, jQuery.fx.interval);
					 }
					 jQuery.fx.tick();
				  }
				}
				function createFxNow() {
				  window2.setTimeout(function() {
					 fxNow = void 0;
				  });
				  return fxNow = Date.now();
				}
				function genFx(type2, includeWidth) {
				  var which, i = 0, attrs = { height: type2 };
				  includeWidth = includeWidth ? 1 : 0;
				  for (; i < 4; i += 2 - includeWidth) {
					 which = cssExpand[i];
					 attrs["margin" + which] = attrs["padding" + which] = type2;
				  }
				  if (includeWidth) {
					 attrs.opacity = attrs.width = type2;
				  }
				  return attrs;
				}
				function createTween(value, prop, animation) {
				  var tween, collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]), index = 0, length = collection.length;
				  for (; index < length; index++) {
					 if (tween = collection[index].call(animation, prop, value)) {
						return tween;
					 }
				  }
				}
				function defaultPrefilter(elem2, props, opts) {
				  var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display, isBox = "width" in props || "height" in props, anim = this, orig = {}, style = elem2.style, hidden = elem2.nodeType && isHiddenWithinTree(elem2), dataShow = dataPriv.get(elem2, "fxshow");
				  if (!opts.queue) {
					 hooks = jQuery._queueHooks(elem2, "fx");
					 if (hooks.unqueued == null) {
						hooks.unqueued = 0;
						oldfire = hooks.empty.fire;
						hooks.empty.fire = function() {
						  if (!hooks.unqueued) {
							 oldfire();
						  }
						};
					 }
					 hooks.unqueued++;
					 anim.always(function() {
						anim.always(function() {
						  hooks.unqueued--;
						  if (!jQuery.queue(elem2, "fx").length) {
							 hooks.empty.fire();
						  }
						});
					 });
				  }
				  for (prop in props) {
					 value = props[prop];
					 if (rfxtypes.test(value)) {
						delete props[prop];
						toggle = toggle || value === "toggle";
						if (value === (hidden ? "hide" : "show")) {
						  if (value === "show" && dataShow && dataShow[prop] !== void 0) {
							 hidden = true;
						  } else {
							 continue;
						  }
						}
						orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem2, prop);
					 }
				  }
				  propTween = !jQuery.isEmptyObject(props);
				  if (!propTween && jQuery.isEmptyObject(orig)) {
					 return;
				  }
				  if (isBox && elem2.nodeType === 1) {
					 opts.overflow = [style.overflow, style.overflowX, style.overflowY];
					 restoreDisplay = dataShow && dataShow.display;
					 if (restoreDisplay == null) {
						restoreDisplay = dataPriv.get(elem2, "display");
					 }
					 display = jQuery.css(elem2, "display");
					 if (display === "none") {
						if (restoreDisplay) {
						  display = restoreDisplay;
						} else {
						  showHide([elem2], true);
						  restoreDisplay = elem2.style.display || restoreDisplay;
						  display = jQuery.css(elem2, "display");
						  showHide([elem2]);
						}
					 }
					 if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
						if (jQuery.css(elem2, "float") === "none") {
						  if (!propTween) {
							 anim.done(function() {
								style.display = restoreDisplay;
							 });
							 if (restoreDisplay == null) {
								display = style.display;
								restoreDisplay = display === "none" ? "" : display;
							 }
						  }
						  style.display = "inline-block";
						}
					 }
				  }
				  if (opts.overflow) {
					 style.overflow = "hidden";
					 anim.always(function() {
						style.overflow = opts.overflow[0];
						style.overflowX = opts.overflow[1];
						style.overflowY = opts.overflow[2];
					 });
				  }
				  propTween = false;
				  for (prop in orig) {
					 if (!propTween) {
						if (dataShow) {
						  if ("hidden" in dataShow) {
							 hidden = dataShow.hidden;
						  }
						} else {
						  dataShow = dataPriv.access(elem2, "fxshow", { display: restoreDisplay });
						}
						if (toggle) {
						  dataShow.hidden = !hidden;
						}
						if (hidden) {
						  showHide([elem2], true);
						}
						anim.done(function() {
						  if (!hidden) {
							 showHide([elem2]);
						  }
						  dataPriv.remove(elem2, "fxshow");
						  for (prop in orig) {
							 jQuery.style(elem2, prop, orig[prop]);
						  }
						});
					 }
					 propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
					 if (!(prop in dataShow)) {
						dataShow[prop] = propTween.start;
						if (hidden) {
						  propTween.end = propTween.start;
						  propTween.start = 0;
						}
					 }
				  }
				}
				function propFilter(props, specialEasing) {
				  var index, name, easing, value, hooks;
				  for (index in props) {
					 name = camelCase(index);
					 easing = specialEasing[name];
					 value = props[index];
					 if (Array.isArray(value)) {
						easing = value[1];
						value = props[index] = value[0];
					 }
					 if (index !== name) {
						props[name] = value;
						delete props[index];
					 }
					 hooks = jQuery.cssHooks[name];
					 if (hooks && "expand" in hooks) {
						value = hooks.expand(value);
						delete props[name];
						for (index in value) {
						  if (!(index in props)) {
							 props[index] = value[index];
							 specialEasing[index] = easing;
						  }
						}
					 } else {
						specialEasing[name] = easing;
					 }
				  }
				}
				function Animation(elem2, properties, options) {
				  var result, stopped, index = 0, length = Animation.prefilters.length, deferred = jQuery.Deferred().always(function() {
					 delete tick.elem;
				  }), tick = function() {
					 if (stopped) {
						return false;
					 }
					 var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index2 = 0, length2 = animation.tweens.length;
					 for (; index2 < length2; index2++) {
						animation.tweens[index2].run(percent);
					 }
					 deferred.notifyWith(elem2, [animation, percent, remaining]);
					 if (percent < 1 && length2) {
						return remaining;
					 }
					 if (!length2) {
						deferred.notifyWith(elem2, [animation, 1, 0]);
					 }
					 deferred.resolveWith(elem2, [animation]);
					 return false;
				  }, animation = deferred.promise({
					 elem: elem2,
					 props: jQuery.extend({}, properties),
					 opts: jQuery.extend(true, {
						specialEasing: {},
						easing: jQuery.easing._default
					 }, options),
					 originalProperties: properties,
					 originalOptions: options,
					 startTime: fxNow || createFxNow(),
					 duration: options.duration,
					 tweens: [],
					 createTween: function(prop, end) {
						var tween = jQuery.Tween(
						  elem2,
						  animation.opts,
						  prop,
						  end,
						  animation.opts.specialEasing[prop] || animation.opts.easing
						);
						animation.tweens.push(tween);
						return tween;
					 },
					 stop: function(gotoEnd) {
						var index2 = 0, length2 = gotoEnd ? animation.tweens.length : 0;
						if (stopped) {
						  return this;
						}
						stopped = true;
						for (; index2 < length2; index2++) {
						  animation.tweens[index2].run(1);
						}
						if (gotoEnd) {
						  deferred.notifyWith(elem2, [animation, 1, 0]);
						  deferred.resolveWith(elem2, [animation, gotoEnd]);
						} else {
						  deferred.rejectWith(elem2, [animation, gotoEnd]);
						}
						return this;
					 }
				  }), props = animation.props;
				  propFilter(props, animation.opts.specialEasing);
				  for (; index < length; index++) {
					 result = Animation.prefilters[index].call(animation, elem2, props, animation.opts);
					 if (result) {
						if (isFunction5(result.stop)) {
						  jQuery._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);
						}
						return result;
					 }
				  }
				  jQuery.map(props, createTween, animation);
				  if (isFunction5(animation.opts.start)) {
					 animation.opts.start.call(elem2, animation);
				  }
				  animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
				  jQuery.fx.timer(
					 jQuery.extend(tick, {
						elem: elem2,
						anim: animation,
						queue: animation.opts.queue
					 })
				  );
				  return animation;
				}
				jQuery.Animation = jQuery.extend(Animation, {
				  tweeners: {
					 "*": [function(prop, value) {
						var tween = this.createTween(prop, value);
						adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
						return tween;
					 }]
				  },
				  tweener: function(props, callback) {
					 if (isFunction5(props)) {
						callback = props;
						props = ["*"];
					 } else {
						props = props.match(rnothtmlwhite);
					 }
					 var prop, index = 0, length = props.length;
					 for (; index < length; index++) {
						prop = props[index];
						Animation.tweeners[prop] = Animation.tweeners[prop] || [];
						Animation.tweeners[prop].unshift(callback);
					 }
				  },
				  prefilters: [defaultPrefilter],
				  prefilter: function(callback, prepend) {
					 if (prepend) {
						Animation.prefilters.unshift(callback);
					 } else {
						Animation.prefilters.push(callback);
					 }
				  }
				});
				jQuery.speed = function(speed, easing, fn) {
				  var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
					 complete: fn || !fn && easing || isFunction5(speed) && speed,
					 duration: speed,
					 easing: fn && easing || easing && !isFunction5(easing) && easing
				  };
				  if (jQuery.fx.off) {
					 opt.duration = 0;
				  } else {
					 if (typeof opt.duration !== "number") {
						if (opt.duration in jQuery.fx.speeds) {
						  opt.duration = jQuery.fx.speeds[opt.duration];
						} else {
						  opt.duration = jQuery.fx.speeds._default;
						}
					 }
				  }
				  if (opt.queue == null || opt.queue === true) {
					 opt.queue = "fx";
				  }
				  opt.old = opt.complete;
				  opt.complete = function() {
					 if (isFunction5(opt.old)) {
						opt.old.call(this);
					 }
					 if (opt.queue) {
						jQuery.dequeue(this, opt.queue);
					 }
				  };
				  return opt;
				};
				jQuery.fn.extend({
				  fadeTo: function(speed, to, easing, callback) {
					 return this.filter(isHiddenWithinTree).css("opacity", 0).show().end().animate({ opacity: to }, speed, easing, callback);
				  },
				  animate: function(prop, speed, easing, callback) {
					 var empty2 = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function() {
						var anim = Animation(this, jQuery.extend({}, prop), optall);
						if (empty2 || dataPriv.get(this, "finish")) {
						  anim.stop(true);
						}
					 };
					 doAnimation.finish = doAnimation;
					 return empty2 || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
				  },
				  stop: function(type2, clearQueue, gotoEnd) {
					 var stopQueue = function(hooks) {
						var stop = hooks.stop;
						delete hooks.stop;
						stop(gotoEnd);
					 };
					 if (typeof type2 !== "string") {
						gotoEnd = clearQueue;
						clearQueue = type2;
						type2 = void 0;
					 }
					 if (clearQueue) {
						this.queue(type2 || "fx", []);
					 }
					 return this.each(function() {
						var dequeue = true, index = type2 != null && type2 + "queueHooks", timers = jQuery.timers, data = dataPriv.get(this);
						if (index) {
						  if (data[index] && data[index].stop) {
							 stopQueue(data[index]);
						  }
						} else {
						  for (index in data) {
							 if (data[index] && data[index].stop && rrun.test(index)) {
								stopQueue(data[index]);
							 }
						  }
						}
						for (index = timers.length; index--; ) {
						  if (timers[index].elem === this && (type2 == null || timers[index].queue === type2)) {
							 timers[index].anim.stop(gotoEnd);
							 dequeue = false;
							 timers.splice(index, 1);
						  }
						}
						if (dequeue || !gotoEnd) {
						  jQuery.dequeue(this, type2);
						}
					 });
				  },
				  finish: function(type2) {
					 if (type2 !== false) {
						type2 = type2 || "fx";
					 }
					 return this.each(function() {
						var index, data = dataPriv.get(this), queue = data[type2 + "queue"], hooks = data[type2 + "queueHooks"], timers = jQuery.timers, length = queue ? queue.length : 0;
						data.finish = true;
						jQuery.queue(this, type2, []);
						if (hooks && hooks.stop) {
						  hooks.stop.call(this, true);
						}
						for (index = timers.length; index--; ) {
						  if (timers[index].elem === this && timers[index].queue === type2) {
							 timers[index].anim.stop(true);
							 timers.splice(index, 1);
						  }
						}
						for (index = 0; index < length; index++) {
						  if (queue[index] && queue[index].finish) {
							 queue[index].finish.call(this);
						  }
						}
						delete data.finish;
					 });
				  }
				});
				jQuery.each(["toggle", "show", "hide"], function(_i, name) {
				  var cssFn = jQuery.fn[name];
				  jQuery.fn[name] = function(speed, easing, callback) {
					 return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
				  };
				});
				jQuery.each({
				  slideDown: genFx("show"),
				  slideUp: genFx("hide"),
				  slideToggle: genFx("toggle"),
				  fadeIn: { opacity: "show" },
				  fadeOut: { opacity: "hide" },
				  fadeToggle: { opacity: "toggle" }
				}, function(name, props) {
				  jQuery.fn[name] = function(speed, easing, callback) {
					 return this.animate(props, speed, easing, callback);
				  };
				});
				jQuery.timers = [];
				jQuery.fx.tick = function() {
				  var timer2, i = 0, timers = jQuery.timers;
				  fxNow = Date.now();
				  for (; i < timers.length; i++) {
					 timer2 = timers[i];
					 if (!timer2() && timers[i] === timer2) {
						timers.splice(i--, 1);
					 }
				  }
				  if (!timers.length) {
					 jQuery.fx.stop();
				  }
				  fxNow = void 0;
				};
				jQuery.fx.timer = function(timer2) {
				  jQuery.timers.push(timer2);
				  jQuery.fx.start();
				};
				jQuery.fx.interval = 13;
				jQuery.fx.start = function() {
				  if (inProgress) {
					 return;
				  }
				  inProgress = true;
				  schedule();
				};
				jQuery.fx.stop = function() {
				  inProgress = null;
				};
				jQuery.fx.speeds = {
				  slow: 600,
				  fast: 200,
				  // Default speed
				  _default: 400
				};
				jQuery.fn.delay = function(time, type2) {
				  time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
				  type2 = type2 || "fx";
				  return this.queue(type2, function(next, hooks) {
					 var timeout2 = window2.setTimeout(next, time);
					 hooks.stop = function() {
						window2.clearTimeout(timeout2);
					 };
				  });
				};
				(function() {
				  var input2 = document2.createElement("input"), select = document2.createElement("select"), opt = select.appendChild(document2.createElement("option"));
				  input2.type = "checkbox";
				  support.checkOn = input2.value !== "";
				  support.optSelected = opt.selected;
				  input2 = document2.createElement("input");
				  input2.value = "t";
				  input2.type = "radio";
				  support.radioValue = input2.value === "t";
				})();
				var boolHook, attrHandle = jQuery.expr.attrHandle;
				jQuery.fn.extend({
				  attr: function(name, value) {
					 return access(this, jQuery.attr, name, value, arguments.length > 1);
				  },
				  removeAttr: function(name) {
					 return this.each(function() {
						jQuery.removeAttr(this, name);
					 });
				  }
				});
				jQuery.extend({
				  attr: function(elem2, name, value) {
					 var ret, hooks, nType = elem2.nodeType;
					 if (nType === 3 || nType === 8 || nType === 2) {
						return;
					 }
					 if (typeof elem2.getAttribute === "undefined") {
						return jQuery.prop(elem2, name, value);
					 }
					 if (nType !== 1 || !jQuery.isXMLDoc(elem2)) {
						hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : void 0);
					 }
					 if (value !== void 0) {
						if (value === null) {
						  jQuery.removeAttr(elem2, name);
						  return;
						}
						if (hooks && "set" in hooks && (ret = hooks.set(elem2, value, name)) !== void 0) {
						  return ret;
						}
						elem2.setAttribute(name, value + "");
						return value;
					 }
					 if (hooks && "get" in hooks && (ret = hooks.get(elem2, name)) !== null) {
						return ret;
					 }
					 ret = jQuery.find.attr(elem2, name);
					 return ret == null ? void 0 : ret;
				  },
				  attrHooks: {
					 type: {
						set: function(elem2, value) {
						  if (!support.radioValue && value === "radio" && nodeName(elem2, "input")) {
							 var val = elem2.value;
							 elem2.setAttribute("type", value);
							 if (val) {
								elem2.value = val;
							 }
							 return value;
						  }
						}
					 }
				  },
				  removeAttr: function(elem2, value) {
					 var name, i = 0, attrNames = value && value.match(rnothtmlwhite);
					 if (attrNames && elem2.nodeType === 1) {
						while (name = attrNames[i++]) {
						  elem2.removeAttribute(name);
						}
					 }
				  }
				});
				boolHook = {
				  set: function(elem2, value, name) {
					 if (value === false) {
						jQuery.removeAttr(elem2, name);
					 } else {
						elem2.setAttribute(name, name);
					 }
					 return name;
				  }
				};
				jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(_i, name) {
				  var getter = attrHandle[name] || jQuery.find.attr;
				  attrHandle[name] = function(elem2, name2, isXML) {
					 var ret, handle, lowercaseName = name2.toLowerCase();
					 if (!isXML) {
						handle = attrHandle[lowercaseName];
						attrHandle[lowercaseName] = ret;
						ret = getter(elem2, name2, isXML) != null ? lowercaseName : null;
						attrHandle[lowercaseName] = handle;
					 }
					 return ret;
				  };
				});
				var rfocusable = /^(?:input|select|textarea|button)$/i, rclickable = /^(?:a|area)$/i;
				jQuery.fn.extend({
				  prop: function(name, value) {
					 return access(this, jQuery.prop, name, value, arguments.length > 1);
				  },
				  removeProp: function(name) {
					 return this.each(function() {
						delete this[jQuery.propFix[name] || name];
					 });
				  }
				});
				jQuery.extend({
				  prop: function(elem2, name, value) {
					 var ret, hooks, nType = elem2.nodeType;
					 if (nType === 3 || nType === 8 || nType === 2) {
						return;
					 }
					 if (nType !== 1 || !jQuery.isXMLDoc(elem2)) {
						name = jQuery.propFix[name] || name;
						hooks = jQuery.propHooks[name];
					 }
					 if (value !== void 0) {
						if (hooks && "set" in hooks && (ret = hooks.set(elem2, value, name)) !== void 0) {
						  return ret;
						}
						return elem2[name] = value;
					 }
					 if (hooks && "get" in hooks && (ret = hooks.get(elem2, name)) !== null) {
						return ret;
					 }
					 return elem2[name];
				  },
				  propHooks: {
					 tabIndex: {
						get: function(elem2) {
						  var tabindex = jQuery.find.attr(elem2, "tabindex");
						  if (tabindex) {
							 return parseInt(tabindex, 10);
						  }
						  if (rfocusable.test(elem2.nodeName) || rclickable.test(elem2.nodeName) && elem2.href) {
							 return 0;
						  }
						  return -1;
						}
					 }
				  },
				  propFix: {
					 "for": "htmlFor",
					 "class": "className"
				  }
				});
				if (!support.optSelected) {
				  jQuery.propHooks.selected = {
					 get: function(elem2) {
						var parent = elem2.parentNode;
						if (parent && parent.parentNode) {
						  parent.parentNode.selectedIndex;
						}
						return null;
					 },
					 set: function(elem2) {
						var parent = elem2.parentNode;
						if (parent) {
						  parent.selectedIndex;
						  if (parent.parentNode) {
							 parent.parentNode.selectedIndex;
						  }
						}
					 }
				  };
				}
				jQuery.each([
				  "tabIndex",
				  "readOnly",
				  "maxLength",
				  "cellSpacing",
				  "cellPadding",
				  "rowSpan",
				  "colSpan",
				  "useMap",
				  "frameBorder",
				  "contentEditable"
				], function() {
				  jQuery.propFix[this.toLowerCase()] = this;
				});
				function stripAndCollapse(value) {
				  var tokens = value.match(rnothtmlwhite) || [];
				  return tokens.join(" ");
				}
				function getClass(elem2) {
				  return elem2.getAttribute && elem2.getAttribute("class") || "";
				}
				function classesToArray(value) {
				  if (Array.isArray(value)) {
					 return value;
				  }
				  if (typeof value === "string") {
					 return value.match(rnothtmlwhite) || [];
				  }
				  return [];
				}
				jQuery.fn.extend({
				  addClass: function(value) {
					 var classNames, cur, curValue, className, i, finalValue;
					 if (isFunction5(value)) {
						return this.each(function(j) {
						  jQuery(this).addClass(value.call(this, j, getClass(this)));
						});
					 }
					 classNames = classesToArray(value);
					 if (classNames.length) {
						return this.each(function() {
						  curValue = getClass(this);
						  cur = this.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
						  if (cur) {
							 for (i = 0; i < classNames.length; i++) {
								className = classNames[i];
								if (cur.indexOf(" " + className + " ") < 0) {
								  cur += className + " ";
								}
							 }
							 finalValue = stripAndCollapse(cur);
							 if (curValue !== finalValue) {
								this.setAttribute("class", finalValue);
							 }
						  }
						});
					 }
					 return this;
				  },
				  removeClass: function(value) {
					 var classNames, cur, curValue, className, i, finalValue;
					 if (isFunction5(value)) {
						return this.each(function(j) {
						  jQuery(this).removeClass(value.call(this, j, getClass(this)));
						});
					 }
					 if (!arguments.length) {
						return this.attr("class", "");
					 }
					 classNames = classesToArray(value);
					 if (classNames.length) {
						return this.each(function() {
						  curValue = getClass(this);
						  cur = this.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
						  if (cur) {
							 for (i = 0; i < classNames.length; i++) {
								className = classNames[i];
								while (cur.indexOf(" " + className + " ") > -1) {
								  cur = cur.replace(" " + className + " ", " ");
								}
							 }
							 finalValue = stripAndCollapse(cur);
							 if (curValue !== finalValue) {
								this.setAttribute("class", finalValue);
							 }
						  }
						});
					 }
					 return this;
				  },
				  toggleClass: function(value, stateVal) {
					 var classNames, className, i, self2, type2 = typeof value, isValidValue = type2 === "string" || Array.isArray(value);
					 if (isFunction5(value)) {
						return this.each(function(i2) {
						  jQuery(this).toggleClass(
							 value.call(this, i2, getClass(this), stateVal),
							 stateVal
						  );
						});
					 }
					 if (typeof stateVal === "boolean" && isValidValue) {
						return stateVal ? this.addClass(value) : this.removeClass(value);
					 }
					 classNames = classesToArray(value);
					 return this.each(function() {
						if (isValidValue) {
						  self2 = jQuery(this);
						  for (i = 0; i < classNames.length; i++) {
							 className = classNames[i];
							 if (self2.hasClass(className)) {
								self2.removeClass(className);
							 } else {
								self2.addClass(className);
							 }
						  }
						} else if (value === void 0 || type2 === "boolean") {
						  className = getClass(this);
						  if (className) {
							 dataPriv.set(this, "__className__", className);
						  }
						  if (this.setAttribute) {
							 this.setAttribute(
								"class",
								className || value === false ? "" : dataPriv.get(this, "__className__") || ""
							 );
						  }
						}
					 });
				  },
				  hasClass: function(selector) {
					 var className, elem2, i = 0;
					 className = " " + selector + " ";
					 while (elem2 = this[i++]) {
						if (elem2.nodeType === 1 && (" " + stripAndCollapse(getClass(elem2)) + " ").indexOf(className) > -1) {
						  return true;
						}
					 }
					 return false;
				  }
				});
				var rreturn = /\r/g;
				jQuery.fn.extend({
				  val: function(value) {
					 var hooks, ret, valueIsFunction, elem2 = this[0];
					 if (!arguments.length) {
						if (elem2) {
						  hooks = jQuery.valHooks[elem2.type] || jQuery.valHooks[elem2.nodeName.toLowerCase()];
						  if (hooks && "get" in hooks && (ret = hooks.get(elem2, "value")) !== void 0) {
							 return ret;
						  }
						  ret = elem2.value;
						  if (typeof ret === "string") {
							 return ret.replace(rreturn, "");
						  }
						  return ret == null ? "" : ret;
						}
						return;
					 }
					 valueIsFunction = isFunction5(value);
					 return this.each(function(i) {
						var val;
						if (this.nodeType !== 1) {
						  return;
						}
						if (valueIsFunction) {
						  val = value.call(this, i, jQuery(this).val());
						} else {
						  val = value;
						}
						if (val == null) {
						  val = "";
						} else if (typeof val === "number") {
						  val += "";
						} else if (Array.isArray(val)) {
						  val = jQuery.map(val, function(value2) {
							 return value2 == null ? "" : value2 + "";
						  });
						}
						hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
						if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === void 0) {
						  this.value = val;
						}
					 });
				  }
				});
				jQuery.extend({
				  valHooks: {
					 option: {
						get: function(elem2) {
						  var val = jQuery.find.attr(elem2, "value");
						  return val != null ? val : (
							 // Support: IE <=10 - 11 only
							 // option.text throws exceptions (trac-14686, trac-14858)
							 // Strip and collapse whitespace
							 // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
							 stripAndCollapse(jQuery.text(elem2))
						  );
						}
					 },
					 select: {
						get: function(elem2) {
						  var value, option, i, options = elem2.options, index = elem2.selectedIndex, one2 = elem2.type === "select-one", values = one2 ? null : [], max3 = one2 ? index + 1 : options.length;
						  if (index < 0) {
							 i = max3;
						  } else {
							 i = one2 ? index : 0;
						  }
						  for (; i < max3; i++) {
							 option = options[i];
							 if ((option.selected || i === index) && // Don't return options that are disabled or in a disabled optgroup
							 !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {
								value = jQuery(option).val();
								if (one2) {
								  return value;
								}
								values.push(value);
							 }
						  }
						  return values;
						},
						set: function(elem2, value) {
						  var optionSet, option, options = elem2.options, values = jQuery.makeArray(value), i = options.length;
						  while (i--) {
							 option = options[i];
							 if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
								optionSet = true;
							 }
						  }
						  if (!optionSet) {
							 elem2.selectedIndex = -1;
						  }
						  return values;
						}
					 }
				  }
				});
				jQuery.each(["radio", "checkbox"], function() {
				  jQuery.valHooks[this] = {
					 set: function(elem2, value) {
						if (Array.isArray(value)) {
						  return elem2.checked = jQuery.inArray(jQuery(elem2).val(), value) > -1;
						}
					 }
				  };
				  if (!support.checkOn) {
					 jQuery.valHooks[this].get = function(elem2) {
						return elem2.getAttribute("value") === null ? "on" : elem2.value;
					 };
				  }
				});
				var location2 = window2.location;
				var nonce = { guid: Date.now() };
				var rquery = /\?/;
				jQuery.parseXML = function(data) {
				  var xml, parserErrorElem;
				  if (!data || typeof data !== "string") {
					 return null;
				  }
				  try {
					 xml = new window2.DOMParser().parseFromString(data, "text/xml");
				  } catch (e) {
				  }
				  parserErrorElem = xml && xml.getElementsByTagName("parsererror")[0];
				  if (!xml || parserErrorElem) {
					 jQuery.error("Invalid XML: " + (parserErrorElem ? jQuery.map(parserErrorElem.childNodes, function(el) {
						return el.textContent;
					 }).join("\n") : data));
				  }
				  return xml;
				};
				var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, stopPropagationCallback = function(e) {
				  e.stopPropagation();
				};
				jQuery.extend(jQuery.event, {
				  trigger: function(event, data, elem2, onlyHandlers) {
					 var i, cur, tmp, bubbleType, ontype, handle, special2, lastElement, eventPath = [elem2 || document2], type2 = hasOwn.call(event, "type") ? event.type : event, namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
					 cur = lastElement = tmp = elem2 = elem2 || document2;
					 if (elem2.nodeType === 3 || elem2.nodeType === 8) {
						return;
					 }
					 if (rfocusMorph.test(type2 + jQuery.event.triggered)) {
						return;
					 }
					 if (type2.indexOf(".") > -1) {
						namespaces = type2.split(".");
						type2 = namespaces.shift();
						namespaces.sort();
					 }
					 ontype = type2.indexOf(":") < 0 && "on" + type2;
					 event = event[jQuery.expando] ? event : new jQuery.Event(type2, typeof event === "object" && event);
					 event.isTrigger = onlyHandlers ? 2 : 3;
					 event.namespace = namespaces.join(".");
					 event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
					 event.result = void 0;
					 if (!event.target) {
						event.target = elem2;
					 }
					 data = data == null ? [event] : jQuery.makeArray(data, [event]);
					 special2 = jQuery.event.special[type2] || {};
					 if (!onlyHandlers && special2.trigger && special2.trigger.apply(elem2, data) === false) {
						return;
					 }
					 if (!onlyHandlers && !special2.noBubble && !isWindow(elem2)) {
						bubbleType = special2.delegateType || type2;
						if (!rfocusMorph.test(bubbleType + type2)) {
						  cur = cur.parentNode;
						}
						for (; cur; cur = cur.parentNode) {
						  eventPath.push(cur);
						  tmp = cur;
						}
						if (tmp === (elem2.ownerDocument || document2)) {
						  eventPath.push(tmp.defaultView || tmp.parentWindow || window2);
						}
					 }
					 i = 0;
					 while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
						lastElement = cur;
						event.type = i > 1 ? bubbleType : special2.bindType || type2;
						handle = (dataPriv.get(cur, "events") || /* @__PURE__ */ Object.create(null))[event.type] && dataPriv.get(cur, "handle");
						if (handle) {
						  handle.apply(cur, data);
						}
						handle = ontype && cur[ontype];
						if (handle && handle.apply && acceptData(cur)) {
						  event.result = handle.apply(cur, data);
						  if (event.result === false) {
							 event.preventDefault();
						  }
						}
					 }
					 event.type = type2;
					 if (!onlyHandlers && !event.isDefaultPrevented()) {
						if ((!special2._default || special2._default.apply(eventPath.pop(), data) === false) && acceptData(elem2)) {
						  if (ontype && isFunction5(elem2[type2]) && !isWindow(elem2)) {
							 tmp = elem2[ontype];
							 if (tmp) {
								elem2[ontype] = null;
							 }
							 jQuery.event.triggered = type2;
							 if (event.isPropagationStopped()) {
								lastElement.addEventListener(type2, stopPropagationCallback);
							 }
							 elem2[type2]();
							 if (event.isPropagationStopped()) {
								lastElement.removeEventListener(type2, stopPropagationCallback);
							 }
							 jQuery.event.triggered = void 0;
							 if (tmp) {
								elem2[ontype] = tmp;
							 }
						  }
						}
					 }
					 return event.result;
				  },
				  // Piggyback on a donor event to simulate a different one
				  // Used only for `focus(in | out)` events
				  simulate: function(type2, elem2, event) {
					 var e = jQuery.extend(
						new jQuery.Event(),
						event,
						{
						  type: type2,
						  isSimulated: true
						}
					 );
					 jQuery.event.trigger(e, null, elem2);
				  }
				});
				jQuery.fn.extend({
				  trigger: function(type2, data) {
					 return this.each(function() {
						jQuery.event.trigger(type2, data, this);
					 });
				  },
				  triggerHandler: function(type2, data) {
					 var elem2 = this[0];
					 if (elem2) {
						return jQuery.event.trigger(type2, data, elem2, true);
					 }
				  }
				});
				var rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
				function buildParams(prefix, obj, traditional, add2) {
				  var name;
				  if (Array.isArray(obj)) {
					 jQuery.each(obj, function(i, v) {
						if (traditional || rbracket.test(prefix)) {
						  add2(prefix, v);
						} else {
						  buildParams(
							 prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]",
							 v,
							 traditional,
							 add2
						  );
						}
					 });
				  } else if (!traditional && toType(obj) === "object") {
					 for (name in obj) {
						buildParams(prefix + "[" + name + "]", obj[name], traditional, add2);
					 }
				  } else {
					 add2(prefix, obj);
				  }
				}
				jQuery.param = function(a, traditional) {
				  var prefix, s = [], add2 = function(key, valueOrFunction) {
					 var value = isFunction5(valueOrFunction) ? valueOrFunction() : valueOrFunction;
					 s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
				  };
				  if (a == null) {
					 return "";
				  }
				  if (Array.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
					 jQuery.each(a, function() {
						add2(this.name, this.value);
					 });
				  } else {
					 for (prefix in a) {
						buildParams(prefix, a[prefix], traditional, add2);
					 }
				  }
				  return s.join("&");
				};
				jQuery.fn.extend({
				  serialize: function() {
					 return jQuery.param(this.serializeArray());
				  },
				  serializeArray: function() {
					 return this.map(function() {
						var elements = jQuery.prop(this, "elements");
						return elements ? jQuery.makeArray(elements) : this;
					 }).filter(function() {
						var type2 = this.type;
						return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type2) && (this.checked || !rcheckableType.test(type2));
					 }).map(function(_i, elem2) {
						var val = jQuery(this).val();
						if (val == null) {
						  return null;
						}
						if (Array.isArray(val)) {
						  return jQuery.map(val, function(val2) {
							 return { name: elem2.name, value: val2.replace(rCRLF, "\r\n") };
						  });
						}
						return { name: elem2.name, value: val.replace(rCRLF, "\r\n") };
					 }).get();
				  }
				});
				var r20 = /%20/g, rhash = /#.*$/, rantiCache = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, prefilters = {}, transports = {}, allTypes = "*/".concat("*"), originAnchor = document2.createElement("a");
				originAnchor.href = location2.href;
				function addToPrefiltersOrTransports(structure) {
				  return function(dataTypeExpression, func) {
					 if (typeof dataTypeExpression !== "string") {
						func = dataTypeExpression;
						dataTypeExpression = "*";
					 }
					 var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];
					 if (isFunction5(func)) {
						while (dataType = dataTypes[i++]) {
						  if (dataType[0] === "+") {
							 dataType = dataType.slice(1) || "*";
							 (structure[dataType] = structure[dataType] || []).unshift(func);
						  } else {
							 (structure[dataType] = structure[dataType] || []).push(func);
						  }
						}
					 }
				  };
				}
				function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
				  var inspected = {}, seekingTransport = structure === transports;
				  function inspect(dataType) {
					 var selected;
					 inspected[dataType] = true;
					 jQuery.each(structure[dataType] || [], function(_2, prefilterOrFactory) {
						var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
						if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
						  options.dataTypes.unshift(dataTypeOrTransport);
						  inspect(dataTypeOrTransport);
						  return false;
						} else if (seekingTransport) {
						  return !(selected = dataTypeOrTransport);
						}
					 });
					 return selected;
				  }
				  return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
				}
				function ajaxExtend(target, src) {
				  var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
				  for (key in src) {
					 if (src[key] !== void 0) {
						(flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
					 }
				  }
				  if (deep) {
					 jQuery.extend(true, target, deep);
				  }
				  return target;
				}
				function ajaxHandleResponses(s, jqXHR, responses) {
				  var ct, type2, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes;
				  while (dataTypes[0] === "*") {
					 dataTypes.shift();
					 if (ct === void 0) {
						ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
					 }
				  }
				  if (ct) {
					 for (type2 in contents) {
						if (contents[type2] && contents[type2].test(ct)) {
						  dataTypes.unshift(type2);
						  break;
						}
					 }
				  }
				  if (dataTypes[0] in responses) {
					 finalDataType = dataTypes[0];
				  } else {
					 for (type2 in responses) {
						if (!dataTypes[0] || s.converters[type2 + " " + dataTypes[0]]) {
						  finalDataType = type2;
						  break;
						}
						if (!firstDataType) {
						  firstDataType = type2;
						}
					 }
					 finalDataType = finalDataType || firstDataType;
				  }
				  if (finalDataType) {
					 if (finalDataType !== dataTypes[0]) {
						dataTypes.unshift(finalDataType);
					 }
					 return responses[finalDataType];
				  }
				}
				function ajaxConvert(s, response, jqXHR, isSuccess) {
				  var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s.dataTypes.slice();
				  if (dataTypes[1]) {
					 for (conv in s.converters) {
						converters[conv.toLowerCase()] = s.converters[conv];
					 }
				  }
				  current = dataTypes.shift();
				  while (current) {
					 if (s.responseFields[current]) {
						jqXHR[s.responseFields[current]] = response;
					 }
					 if (!prev && isSuccess && s.dataFilter) {
						response = s.dataFilter(response, s.dataType);
					 }
					 prev = current;
					 current = dataTypes.shift();
					 if (current) {
						if (current === "*") {
						  current = prev;
						} else if (prev !== "*" && prev !== current) {
						  conv = converters[prev + " " + current] || converters["* " + current];
						  if (!conv) {
							 for (conv2 in converters) {
								tmp = conv2.split(" ");
								if (tmp[1] === current) {
								  conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
								  if (conv) {
									 if (conv === true) {
										conv = converters[conv2];
									 } else if (converters[conv2] !== true) {
										current = tmp[0];
										dataTypes.unshift(tmp[1]);
									 }
									 break;
								  }
								}
							 }
						  }
						  if (conv !== true) {
							 if (conv && s.throws) {
								response = conv(response);
							 } else {
								try {
								  response = conv(response);
								} catch (e) {
								  return {
									 state: "parsererror",
									 error: conv ? e : "No conversion from " + prev + " to " + current
								  };
								}
							 }
						  }
						}
					 }
				  }
				  return { state: "success", data: response };
				}
				jQuery.extend({
				  // Counter for holding the number of active queries
				  active: 0,
				  // Last-Modified header cache for next request
				  lastModified: {},
				  etag: {},
				  ajaxSettings: {
					 url: location2.href,
					 type: "GET",
					 isLocal: rlocalProtocol.test(location2.protocol),
					 copyGlobalForElem: true,
					 processData: true,
					 async: true,
					 contentType: "application/x-www-form-urlencoded; charset=UTF-8",
					 /*
					 timeout: 0,
					 data: null,
					 dataType: null,
					 username: null,
					 password: null,
					 cache: null,
					 throws: false,
					 traditional: false,
					 headers: {},
					 */
					 accepts: {
						"*": allTypes,
						text: "text/plain",
						html: "text/html",
						xml: "application/xml, text/xml",
						json: "application/json, text/javascript"
					 },
					 contents: {
						xml: /\bxml\b/,
						html: /\bhtml/,
						json: /\bjson\b/
					 },
					 responseFields: {
						xml: "responseXML",
						text: "responseText",
						json: "responseJSON"
					 },
					 // Data converters
					 // Keys separate source (or catchall "*") and destination types with a single space
					 converters: {
						// Convert anything to text
						"* text": String,
						// Text to html (true = no transformation)
						"text html": true,
						// Evaluate text as a json expression
						"text json": JSON.parse,
						// Parse text as xml
						"text xml": jQuery.parseXML
					 },
					 // For options that shouldn't be deep extended:
					 // you can add your own custom options here if
					 // and when you create one that shouldn't be
					 // deep extended (see ajaxExtend)
					 flatOptions: {
						url: true,
						context: true
					 }
				  },
				  // Creates a full fledged settings object into target
				  // with both ajaxSettings and settings fields.
				  // If target is omitted, writes into ajaxSettings.
				  ajaxSetup: function(target, settings) {
					 return settings ? (
						// Building a settings object
						ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings)
					 ) : (
						// Extending ajaxSettings
						ajaxExtend(jQuery.ajaxSettings, target)
					 );
				  },
				  ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
				  ajaxTransport: addToPrefiltersOrTransports(transports),
				  // Main method
				  ajax: function(url, options) {
					 if (typeof url === "object") {
						options = url;
						url = void 0;
					 }
					 options = options || {};
					 var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, urlAnchor, completed2, fireGlobals, i, uncached, s = jQuery.ajaxSetup({}, options), callbackContext = s.context || s, globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks("once memory"), statusCode = s.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, strAbort = "canceled", jqXHR = {
						readyState: 0,
						// Builds headers hashtable if needed
						getResponseHeader: function(key) {
						  var match23;
						  if (completed2) {
							 if (!responseHeaders) {
								responseHeaders = {};
								while (match23 = rheaders.exec(responseHeadersString)) {
								  responseHeaders[match23[1].toLowerCase() + " "] = (responseHeaders[match23[1].toLowerCase() + " "] || []).concat(match23[2]);
								}
							 }
							 match23 = responseHeaders[key.toLowerCase() + " "];
						  }
						  return match23 == null ? null : match23.join(", ");
						},
						// Raw string
						getAllResponseHeaders: function() {
						  return completed2 ? responseHeadersString : null;
						},
						// Caches the header
						setRequestHeader: function(name, value) {
						  if (completed2 == null) {
							 name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;
							 requestHeaders[name] = value;
						  }
						  return this;
						},
						// Overrides response content-type header
						overrideMimeType: function(type2) {
						  if (completed2 == null) {
							 s.mimeType = type2;
						  }
						  return this;
						},
						// Status-dependent callbacks
						statusCode: function(map3) {
						  var code;
						  if (map3) {
							 if (completed2) {
								jqXHR.always(map3[jqXHR.status]);
							 } else {
								for (code in map3) {
								  statusCode[code] = [statusCode[code], map3[code]];
								}
							 }
						  }
						  return this;
						},
						// Cancel the request
						abort: function(statusText) {
						  var finalText = statusText || strAbort;
						  if (transport) {
							 transport.abort(finalText);
						  }
						  done(0, finalText);
						  return this;
						}
					 };
					 deferred.promise(jqXHR);
					 s.url = ((url || s.url || location2.href) + "").replace(rprotocol, location2.protocol + "//");
					 s.type = options.method || options.type || s.method || s.type;
					 s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""];
					 if (s.crossDomain == null) {
						urlAnchor = document2.createElement("a");
						try {
						  urlAnchor.href = s.url;
						  urlAnchor.href = urlAnchor.href;
						  s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
						} catch (e) {
						  s.crossDomain = true;
						}
					 }
					 if (s.data && s.processData && typeof s.data !== "string") {
						s.data = jQuery.param(s.data, s.traditional);
					 }
					 inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
					 if (completed2) {
						return jqXHR;
					 }
					 fireGlobals = jQuery.event && s.copyGlobalForElem;
					 if (fireGlobals && jQuery.active++ === 0) {
						jQuery.event.trigger("ajaxStart");
					 }
					 s.type = s.type.toUpperCase();
					 s.hasContent = !rnoContent.test(s.type);
					 cacheURL = s.url.replace(rhash, "");
					 if (!s.hasContent) {
						uncached = s.url.slice(cacheURL.length);
						if (s.data && (s.processData || typeof s.data === "string")) {
						  cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data;
						  delete s.data;
						}
						if (s.cache === false) {
						  cacheURL = cacheURL.replace(rantiCache, "$1");
						  uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce.guid++ + uncached;
						}
						s.url = cacheURL + uncached;
					 } else if (s.data && s.processData && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
						s.data = s.data.replace(r20, "+");
					 }
					 if (s.ifModified) {
						if (jQuery.lastModified[cacheURL]) {
						  jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
						}
						if (jQuery.etag[cacheURL]) {
						  jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
						}
					 }
					 if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
						jqXHR.setRequestHeader("Content-Type", s.contentType);
					 }
					 jqXHR.setRequestHeader(
						"Accept",
						s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]
					 );
					 for (i in s.headers) {
						jqXHR.setRequestHeader(i, s.headers[i]);
					 }
					 if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed2)) {
						return jqXHR.abort();
					 }
					 strAbort = "abort";
					 completeDeferred.add(s.complete);
					 jqXHR.done(s.success);
					 jqXHR.fail(s.error);
					 transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
					 if (!transport) {
						done(-1, "No Transport");
					 } else {
						jqXHR.readyState = 1;
						if (fireGlobals) {
						  globalEventContext.trigger("ajaxSend", [jqXHR, s]);
						}
						if (completed2) {
						  return jqXHR;
						}
						if (s.async && s.timeout > 0) {
						  timeoutTimer = window2.setTimeout(function() {
							 jqXHR.abort("timeout");
						  }, s.timeout);
						}
						try {
						  completed2 = false;
						  transport.send(requestHeaders, done);
						} catch (e) {
						  if (completed2) {
							 throw e;
						  }
						  done(-1, e);
						}
					 }
					 function done(status, nativeStatusText, responses, headers) {
						var isSuccess, success, error, response, modified, statusText = nativeStatusText;
						if (completed2) {
						  return;
						}
						completed2 = true;
						if (timeoutTimer) {
						  window2.clearTimeout(timeoutTimer);
						}
						transport = void 0;
						responseHeadersString = headers || "";
						jqXHR.readyState = status > 0 ? 4 : 0;
						isSuccess = status >= 200 && status < 300 || status === 304;
						if (responses) {
						  response = ajaxHandleResponses(s, jqXHR, responses);
						}
						if (!isSuccess && jQuery.inArray("script", s.dataTypes) > -1 && jQuery.inArray("json", s.dataTypes) < 0) {
						  s.converters["text script"] = function() {
						  };
						}
						response = ajaxConvert(s, response, jqXHR, isSuccess);
						if (isSuccess) {
						  if (s.ifModified) {
							 modified = jqXHR.getResponseHeader("Last-Modified");
							 if (modified) {
								jQuery.lastModified[cacheURL] = modified;
							 }
							 modified = jqXHR.getResponseHeader("etag");
							 if (modified) {
								jQuery.etag[cacheURL] = modified;
							 }
						  }
						  if (status === 204 || s.type === "HEAD") {
							 statusText = "nocontent";
						  } else if (status === 304) {
							 statusText = "notmodified";
						  } else {
							 statusText = response.state;
							 success = response.data;
							 error = response.error;
							 isSuccess = !error;
						  }
						} else {
						  error = statusText;
						  if (status || !statusText) {
							 statusText = "error";
							 if (status < 0) {
								status = 0;
							 }
						  }
						}
						jqXHR.status = status;
						jqXHR.statusText = (nativeStatusText || statusText) + "";
						if (isSuccess) {
						  deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
						} else {
						  deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
						}
						jqXHR.statusCode(statusCode);
						statusCode = void 0;
						if (fireGlobals) {
						  globalEventContext.trigger(
							 isSuccess ? "ajaxSuccess" : "ajaxError",
							 [jqXHR, s, isSuccess ? success : error]
						  );
						}
						completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
						if (fireGlobals) {
						  globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
						  if (!--jQuery.active) {
							 jQuery.event.trigger("ajaxStop");
						  }
						}
					 }
					 return jqXHR;
				  },
				  getJSON: function(url, data, callback) {
					 return jQuery.get(url, data, callback, "json");
				  },
				  getScript: function(url, callback) {
					 return jQuery.get(url, void 0, callback, "script");
				  }
				});
				jQuery.each(["get", "post"], function(_i, method) {
				  jQuery[method] = function(url, data, callback, type2) {
					 if (isFunction5(data)) {
						type2 = type2 || callback;
						callback = data;
						data = void 0;
					 }
					 return jQuery.ajax(jQuery.extend({
						url,
						type: method,
						dataType: type2,
						data,
						success: callback
					 }, jQuery.isPlainObject(url) && url));
				  };
				});
				jQuery.ajaxPrefilter(function(s) {
				  var i;
				  for (i in s.headers) {
					 if (i.toLowerCase() === "content-type") {
						s.contentType = s.headers[i] || "";
					 }
				  }
				});
				jQuery._evalUrl = function(url, options, doc) {
				  return jQuery.ajax({
					 url,
					 // Make this explicit, since user can override this through ajaxSetup (trac-11264)
					 type: "GET",
					 dataType: "script",
					 cache: true,
					 async: false,
					 copyGlobalForElem: false,
					 // Only evaluate the response if it is successful (gh-4126)
					 // dataFilter is not invoked for failure responses, so using it instead
					 // of the default converter is kludgy but it works.
					 converters: {
						"text script": function() {
						}
					 },
					 dataFilter: function(response) {
						jQuery.globalEval(response, options, doc);
					 }
				  });
				};
				jQuery.fn.extend({
				  wrapAll: function(html) {
					 var wrap;
					 if (this[0]) {
						if (isFunction5(html)) {
						  html = html.call(this[0]);
						}
						wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
						if (this[0].parentNode) {
						  wrap.insertBefore(this[0]);
						}
						wrap.map(function() {
						  var elem2 = this;
						  while (elem2.firstElementChild) {
							 elem2 = elem2.firstElementChild;
						  }
						  return elem2;
						}).append(this);
					 }
					 return this;
				  },
				  wrapInner: function(html) {
					 if (isFunction5(html)) {
						return this.each(function(i) {
						  jQuery(this).wrapInner(html.call(this, i));
						});
					 }
					 return this.each(function() {
						var self2 = jQuery(this), contents = self2.contents();
						if (contents.length) {
						  contents.wrapAll(html);
						} else {
						  self2.append(html);
						}
					 });
				  },
				  wrap: function(html) {
					 var htmlIsFunction = isFunction5(html);
					 return this.each(function(i) {
						jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);
					 });
				  },
				  unwrap: function(selector) {
					 this.parent(selector).not("body").each(function() {
						jQuery(this).replaceWith(this.childNodes);
					 });
					 return this;
				  }
				});
				jQuery.expr.pseudos.hidden = function(elem2) {
				  return !jQuery.expr.pseudos.visible(elem2);
				};
				jQuery.expr.pseudos.visible = function(elem2) {
				  return !!(elem2.offsetWidth || elem2.offsetHeight || elem2.getClientRects().length);
				};
				jQuery.ajaxSettings.xhr = function() {
				  try {
					 return new window2.XMLHttpRequest();
				  } catch (e) {
				  }
				};
				var xhrSuccessStatus = {
				  // File protocol always yields status code 0, assume 200
				  0: 200,
				  // Support: IE <=9 only
				  // trac-1450: sometimes IE returns 1223 when it should be 204
				  1223: 204
				}, xhrSupported = jQuery.ajaxSettings.xhr();
				support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
				support.ajax = xhrSupported = !!xhrSupported;
				jQuery.ajaxTransport(function(options) {
				  var callback, errorCallback;
				  if (support.cors || xhrSupported && !options.crossDomain) {
					 return {
						send: function(headers, complete) {
						  var i, xhr = options.xhr();
						  xhr.open(
							 options.type,
							 options.url,
							 options.async,
							 options.username,
							 options.password
						  );
						  if (options.xhrFields) {
							 for (i in options.xhrFields) {
								xhr[i] = options.xhrFields[i];
							 }
						  }
						  if (options.mimeType && xhr.overrideMimeType) {
							 xhr.overrideMimeType(options.mimeType);
						  }
						  if (!options.crossDomain && !headers["X-Requested-With"]) {
							 headers["X-Requested-With"] = "XMLHttpRequest";
						  }
						  for (i in headers) {
							 xhr.setRequestHeader(i, headers[i]);
						  }
						  callback = function(type2) {
							 return function() {
								if (callback) {
								  callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;
								  if (type2 === "abort") {
									 xhr.abort();
								  } else if (type2 === "error") {
									 if (typeof xhr.status !== "number") {
										complete(0, "error");
									 } else {
										complete(
										  // File: protocol always yields status 0; see trac-8605, trac-14207
										  xhr.status,
										  xhr.statusText
										);
									 }
								  } else {
									 complete(
										xhrSuccessStatus[xhr.status] || xhr.status,
										xhr.statusText,
										// Support: IE <=9 only
										// IE9 has no XHR2 but throws on binary (trac-11426)
										// For XHR2 non-text, let the caller handle it (gh-2498)
										(xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? { binary: xhr.response } : { text: xhr.responseText },
										xhr.getAllResponseHeaders()
									 );
								  }
								}
							 };
						  };
						  xhr.onload = callback();
						  errorCallback = xhr.onerror = xhr.ontimeout = callback("error");
						  if (xhr.onabort !== void 0) {
							 xhr.onabort = errorCallback;
						  } else {
							 xhr.onreadystatechange = function() {
								if (xhr.readyState === 4) {
								  window2.setTimeout(function() {
									 if (callback) {
										errorCallback();
									 }
								  });
								}
							 };
						  }
						  callback = callback("abort");
						  try {
							 xhr.send(options.hasContent && options.data || null);
						  } catch (e) {
							 if (callback) {
								throw e;
							 }
						  }
						},
						abort: function() {
						  if (callback) {
							 callback();
						  }
						}
					 };
				  }
				});
				jQuery.ajaxPrefilter(function(s) {
				  if (s.crossDomain) {
					 s.contents.script = false;
				  }
				});
				jQuery.ajaxSetup({
				  accepts: {
					 script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
				  },
				  contents: {
					 script: /\b(?:java|ecma)script\b/
				  },
				  converters: {
					 "text script": function(text) {
						jQuery.globalEval(text);
						return text;
					 }
				  }
				});
				jQuery.ajaxPrefilter("script", function(s) {
				  if (s.cache === void 0) {
					 s.cache = false;
				  }
				  if (s.crossDomain) {
					 s.type = "GET";
				  }
				});
				jQuery.ajaxTransport("script", function(s) {
				  if (s.crossDomain || s.scriptAttrs) {
					 var script, callback;
					 return {
						send: function(_2, complete) {
						  script = jQuery("<script>").attr(s.scriptAttrs || {}).prop({ charset: s.scriptCharset, src: s.url }).on("load error", callback = function(evt) {
							 script.remove();
							 callback = null;
							 if (evt) {
								complete(evt.type === "error" ? 404 : 200, evt.type);
							 }
						  });
						  document2.head.appendChild(script[0]);
						},
						abort: function() {
						  if (callback) {
							 callback();
						  }
						}
					 };
				  }
				});
				var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
				jQuery.ajaxSetup({
				  jsonp: "callback",
				  jsonpCallback: function() {
					 var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce.guid++;
					 this[callback] = true;
					 return callback;
				  }
				});
				jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
				  var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data");
				  if (jsonProp || s.dataTypes[0] === "jsonp") {
					 callbackName = s.jsonpCallback = isFunction5(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
					 if (jsonProp) {
						s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
					 } else if (s.jsonp !== false) {
						s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
					 }
					 s.converters["script json"] = function() {
						if (!responseContainer) {
						  jQuery.error(callbackName + " was not called");
						}
						return responseContainer[0];
					 };
					 s.dataTypes[0] = "json";
					 overwritten = window2[callbackName];
					 window2[callbackName] = function() {
						responseContainer = arguments;
					 };
					 jqXHR.always(function() {
						if (overwritten === void 0) {
						  jQuery(window2).removeProp(callbackName);
						} else {
						  window2[callbackName] = overwritten;
						}
						if (s[callbackName]) {
						  s.jsonpCallback = originalSettings.jsonpCallback;
						  oldCallbacks.push(callbackName);
						}
						if (responseContainer && isFunction5(overwritten)) {
						  overwritten(responseContainer[0]);
						}
						responseContainer = overwritten = void 0;
					 });
					 return "script";
				  }
				});
				support.createHTMLDocument = function() {
				  var body = document2.implementation.createHTMLDocument("").body;
				  body.innerHTML = "<form></form><form></form>";
				  return body.childNodes.length === 2;
				}();
				jQuery.parseHTML = function(data, context2, keepScripts) {
				  if (typeof data !== "string") {
					 return [];
				  }
				  if (typeof context2 === "boolean") {
					 keepScripts = context2;
					 context2 = false;
				  }
				  var base, parsed, scripts;
				  if (!context2) {
					 if (support.createHTMLDocument) {
						context2 = document2.implementation.createHTMLDocument("");
						base = context2.createElement("base");
						base.href = document2.location.href;
						context2.head.appendChild(base);
					 } else {
						context2 = document2;
					 }
				  }
				  parsed = rsingleTag.exec(data);
				  scripts = !keepScripts && [];
				  if (parsed) {
					 return [context2.createElement(parsed[1])];
				  }
				  parsed = buildFragment([data], context2, scripts);
				  if (scripts && scripts.length) {
					 jQuery(scripts).remove();
				  }
				  return jQuery.merge([], parsed.childNodes);
				};
				jQuery.fn.load = function(url, params, callback) {
				  var selector, type2, response, self2 = this, off = url.indexOf(" ");
				  if (off > -1) {
					 selector = stripAndCollapse(url.slice(off));
					 url = url.slice(0, off);
				  }
				  if (isFunction5(params)) {
					 callback = params;
					 params = void 0;
				  } else if (params && typeof params === "object") {
					 type2 = "POST";
				  }
				  if (self2.length > 0) {
					 jQuery.ajax({
						url,
						// If "type" variable is undefined, then "GET" method will be used.
						// Make value of this field explicit since
						// user can override it through ajaxSetup method
						type: type2 || "GET",
						dataType: "html",
						data: params
					 }).done(function(responseText) {
						response = arguments;
						self2.html(selector ? (
						  // If a selector was specified, locate the right elements in a dummy div
						  // Exclude scripts to avoid IE 'Permission Denied' errors
						  jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector)
						) : (
						  // Otherwise use the full result
						  responseText
						));
					 }).always(callback && function(jqXHR, status) {
						self2.each(function() {
						  callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
						});
					 });
				  }
				  return this;
				};
				jQuery.expr.pseudos.animated = function(elem2) {
				  return jQuery.grep(jQuery.timers, function(fn) {
					 return elem2 === fn.elem;
				  }).length;
				};
				jQuery.offset = {
				  setOffset: function(elem2, options, i) {
					 var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem2, "position"), curElem = jQuery(elem2), props = {};
					 if (position === "static") {
						elem2.style.position = "relative";
					 }
					 curOffset = curElem.offset();
					 curCSSTop = jQuery.css(elem2, "top");
					 curCSSLeft = jQuery.css(elem2, "left");
					 calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
					 if (calculatePosition) {
						curPosition = curElem.position();
						curTop = curPosition.top;
						curLeft = curPosition.left;
					 } else {
						curTop = parseFloat(curCSSTop) || 0;
						curLeft = parseFloat(curCSSLeft) || 0;
					 }
					 if (isFunction5(options)) {
						options = options.call(elem2, i, jQuery.extend({}, curOffset));
					 }
					 if (options.top != null) {
						props.top = options.top - curOffset.top + curTop;
					 }
					 if (options.left != null) {
						props.left = options.left - curOffset.left + curLeft;
					 }
					 if ("using" in options) {
						options.using.call(elem2, props);
					 } else {
						curElem.css(props);
					 }
				  }
				};
				jQuery.fn.extend({
				  // offset() relates an element's border box to the document origin
				  offset: function(options) {
					 if (arguments.length) {
						return options === void 0 ? this : this.each(function(i) {
						  jQuery.offset.setOffset(this, options, i);
						});
					 }
					 var rect, win, elem2 = this[0];
					 if (!elem2) {
						return;
					 }
					 if (!elem2.getClientRects().length) {
						return { top: 0, left: 0 };
					 }
					 rect = elem2.getBoundingClientRect();
					 win = elem2.ownerDocument.defaultView;
					 return {
						top: rect.top + win.pageYOffset,
						left: rect.left + win.pageXOffset
					 };
				  },
				  // position() relates an element's margin box to its offset parent's padding box
				  // This corresponds to the behavior of CSS absolute positioning
				  position: function() {
					 if (!this[0]) {
						return;
					 }
					 var offsetParent, offset, doc, elem2 = this[0], parentOffset = { top: 0, left: 0 };
					 if (jQuery.css(elem2, "position") === "fixed") {
						offset = elem2.getBoundingClientRect();
					 } else {
						offset = this.offset();
						doc = elem2.ownerDocument;
						offsetParent = elem2.offsetParent || doc.documentElement;
						while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery.css(offsetParent, "position") === "static") {
						  offsetParent = offsetParent.parentNode;
						}
						if (offsetParent && offsetParent !== elem2 && offsetParent.nodeType === 1) {
						  parentOffset = jQuery(offsetParent).offset();
						  parentOffset.top += jQuery.css(offsetParent, "borderTopWidth", true);
						  parentOffset.left += jQuery.css(offsetParent, "borderLeftWidth", true);
						}
					 }
					 return {
						top: offset.top - parentOffset.top - jQuery.css(elem2, "marginTop", true),
						left: offset.left - parentOffset.left - jQuery.css(elem2, "marginLeft", true)
					 };
				  },
				  // This method will return documentElement in the following cases:
				  // 1) For the element inside the iframe without offsetParent, this method will return
				  //    documentElement of the parent window
				  // 2) For the hidden or detached element
				  // 3) For body or html element, i.e. in case of the html node - it will return itself
				  //
				  // but those exceptions were never presented as a real life use-cases
				  // and might be considered as more preferable results.
				  //
				  // This logic, however, is not guaranteed and can change at any point in the future
				  offsetParent: function() {
					 return this.map(function() {
						var offsetParent = this.offsetParent;
						while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
						  offsetParent = offsetParent.offsetParent;
						}
						return offsetParent || documentElement;
					 });
				  }
				});
				jQuery.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function(method, prop) {
				  var top2 = "pageYOffset" === prop;
				  jQuery.fn[method] = function(val) {
					 return access(this, function(elem2, method2, val2) {
						var win;
						if (isWindow(elem2)) {
						  win = elem2;
						} else if (elem2.nodeType === 9) {
						  win = elem2.defaultView;
						}
						if (val2 === void 0) {
						  return win ? win[prop] : elem2[method2];
						}
						if (win) {
						  win.scrollTo(
							 !top2 ? val2 : win.pageXOffset,
							 top2 ? val2 : win.pageYOffset
						  );
						} else {
						  elem2[method2] = val2;
						}
					 }, method, val, arguments.length);
				  };
				});
				jQuery.each(["top", "left"], function(_i, prop) {
				  jQuery.cssHooks[prop] = addGetHookIf(
					 support.pixelPosition,
					 function(elem2, computed) {
						if (computed) {
						  computed = curCSS(elem2, prop);
						  return rnumnonpx.test(computed) ? jQuery(elem2).position()[prop] + "px" : computed;
						}
					 }
				  );
				});
				jQuery.each({ Height: "height", Width: "width" }, function(name, type2) {
				  jQuery.each({
					 padding: "inner" + name,
					 content: type2,
					 "": "outer" + name
				  }, function(defaultExtra, funcName) {
					 jQuery.fn[funcName] = function(margin, value) {
						var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"), extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
						return access(this, function(elem2, type3, value2) {
						  var doc;
						  if (isWindow(elem2)) {
							 return funcName.indexOf("outer") === 0 ? elem2["inner" + name] : elem2.document.documentElement["client" + name];
						  }
						  if (elem2.nodeType === 9) {
							 doc = elem2.documentElement;
							 return Math.max(
								elem2.body["scroll" + name],
								doc["scroll" + name],
								elem2.body["offset" + name],
								doc["offset" + name],
								doc["client" + name]
							 );
						  }
						  return value2 === void 0 ? (
							 // Get width or height on the element, requesting but not forcing parseFloat
							 jQuery.css(elem2, type3, extra)
						  ) : (
							 // Set width or height on the element
							 jQuery.style(elem2, type3, value2, extra)
						  );
						}, type2, chainable ? margin : void 0, chainable);
					 };
				  });
				});
				jQuery.each([
				  "ajaxStart",
				  "ajaxStop",
				  "ajaxComplete",
				  "ajaxError",
				  "ajaxSuccess",
				  "ajaxSend"
				], function(_i, type2) {
				  jQuery.fn[type2] = function(fn) {
					 return this.on(type2, fn);
				  };
				});
				jQuery.fn.extend({
				  bind: function(types, data, fn) {
					 return this.on(types, null, data, fn);
				  },
				  unbind: function(types, fn) {
					 return this.off(types, null, fn);
				  },
				  delegate: function(selector, types, data, fn) {
					 return this.on(types, selector, data, fn);
				  },
				  undelegate: function(selector, types, fn) {
					 return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
				  },
				  hover: function(fnOver, fnOut) {
					 return this.on("mouseenter", fnOver).on("mouseleave", fnOut || fnOver);
				  }
				});
				jQuery.each(
				  "blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),
				  function(_i, name) {
					 jQuery.fn[name] = function(data, fn) {
						return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
					 };
				  }
				);
				var rtrim = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;
				jQuery.proxy = function(fn, context2) {
				  var tmp, args, proxy;
				  if (typeof context2 === "string") {
					 tmp = fn[context2];
					 context2 = fn;
					 fn = tmp;
				  }
				  if (!isFunction5(fn)) {
					 return void 0;
				  }
				  args = slice.call(arguments, 2);
				  proxy = function() {
					 return fn.apply(context2 || this, args.concat(slice.call(arguments)));
				  };
				  proxy.guid = fn.guid = fn.guid || jQuery.guid++;
				  return proxy;
				};
				jQuery.holdReady = function(hold) {
				  if (hold) {
					 jQuery.readyWait++;
				  } else {
					 jQuery.ready(true);
				  }
				};
				jQuery.isArray = Array.isArray;
				jQuery.parseJSON = JSON.parse;
				jQuery.nodeName = nodeName;
				jQuery.isFunction = isFunction5;
				jQuery.isWindow = isWindow;
				jQuery.camelCase = camelCase;
				jQuery.type = toType;
				jQuery.now = Date.now;
				jQuery.isNumeric = function(obj) {
				  var type2 = jQuery.type(obj);
				  return (type2 === "number" || type2 === "string") && // parseFloat NaNs numeric-cast false positives ("")
				  // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
				  // subtraction forces infinities to NaN
				  !isNaN(obj - parseFloat(obj));
				};
				jQuery.trim = function(text) {
				  return text == null ? "" : (text + "").replace(rtrim, "$1");
				};
				if (typeof define === "function" && define.amd) {
				  define("jquery", [], function() {
					 return jQuery;
				  });
				}
				var _jQuery = window2.jQuery, _$ = window2.$;
				jQuery.noConflict = function(deep) {
				  if (window2.$ === jQuery) {
					 window2.$ = _$;
				  }
				  if (deep && window2.jQuery === jQuery) {
					 window2.jQuery = _jQuery;
				  }
				  return jQuery;
				};
				if (typeof noGlobal === "undefined") {
				  window2.jQuery = window2.$ = jQuery;
				}
				return jQuery;
			 });
		  }
		});

		// node_modules/@angular/core/fesm2022/primitives/signals.mjs
		function defaultEquals(a, b) {
		  return Object.is(a, b);
		}
		var activeConsumer = null;
		var inNotificationPhase = false;
		var epoch = 1;
		var SIGNAL = /* @__PURE__ */ Symbol("SIGNAL");
		function setActiveConsumer(consumer) {
		  const prev = activeConsumer;
		  activeConsumer = consumer;
		  return prev;
		}
		function getActiveConsumer() {
		  return activeConsumer;
		}
		var REACTIVE_NODE = {
		  version: 0,
		  lastCleanEpoch: 0,
		  dirty: false,
		  producerNode: void 0,
		  producerLastReadVersion: void 0,
		  producerIndexOfThis: void 0,
		  nextProducerIndex: 0,
		  liveConsumerNode: void 0,
		  liveConsumerIndexOfThis: void 0,
		  consumerAllowSignalWrites: false,
		  consumerIsAlwaysLive: false,
		  producerMustRecompute: () => false,
		  producerRecomputeValue: () => {
		  },
		  consumerMarkedDirty: () => {
		  },
		  consumerOnSignalRead: () => {
		  }
		};
		function producerAccessed(node) {
		  if (inNotificationPhase) {
			 throw new Error(typeof ngDevMode !== "undefined" && ngDevMode ? `Assertion error: signal read during notification phase` : "");
		  }
		  if (activeConsumer === null) {
			 return;
		  }
		  activeConsumer.consumerOnSignalRead(node);
		  const idx = activeConsumer.nextProducerIndex++;
		  assertConsumerNode(activeConsumer);
		  if (idx < activeConsumer.producerNode.length && activeConsumer.producerNode[idx] !== node) {
			 if (consumerIsLive(activeConsumer)) {
				const staleProducer = activeConsumer.producerNode[idx];
				producerRemoveLiveConsumerAtIndex(staleProducer, activeConsumer.producerIndexOfThis[idx]);
			 }
		  }
		  if (activeConsumer.producerNode[idx] !== node) {
			 activeConsumer.producerNode[idx] = node;
			 activeConsumer.producerIndexOfThis[idx] = consumerIsLive(activeConsumer) ? producerAddLiveConsumer(node, activeConsumer, idx) : 0;
		  }
		  activeConsumer.producerLastReadVersion[idx] = node.version;
		}
		function producerIncrementEpoch() {
		  epoch++;
		}
		function producerUpdateValueVersion(node) {
		  if (consumerIsLive(node) && !node.dirty) {
			 return;
		  }
		  if (!node.dirty && node.lastCleanEpoch === epoch) {
			 return;
		  }
		  if (!node.producerMustRecompute(node) && !consumerPollProducersForChange(node)) {
			 node.dirty = false;
			 node.lastCleanEpoch = epoch;
			 return;
		  }
		  node.producerRecomputeValue(node);
		  node.dirty = false;
		  node.lastCleanEpoch = epoch;
		}
		function producerNotifyConsumers(node) {
		  if (node.liveConsumerNode === void 0) {
			 return;
		  }
		  const prev = inNotificationPhase;
		  inNotificationPhase = true;
		  try {
			 for (const consumer of node.liveConsumerNode) {
				if (!consumer.dirty) {
				  consumerMarkDirty(consumer);
				}
			 }
		  } finally {
			 inNotificationPhase = prev;
		  }
		}
		function producerUpdatesAllowed() {
		  return activeConsumer?.consumerAllowSignalWrites !== false;
		}
		function consumerMarkDirty(node) {
		  node.dirty = true;
		  producerNotifyConsumers(node);
		  node.consumerMarkedDirty?.(node);
		}
		function consumerBeforeComputation(node) {
		  node && (node.nextProducerIndex = 0);
		  return setActiveConsumer(node);
		}
		function consumerAfterComputation(node, prevConsumer) {
		  setActiveConsumer(prevConsumer);
		  if (!node || node.producerNode === void 0 || node.producerIndexOfThis === void 0 || node.producerLastReadVersion === void 0) {
			 return;
		  }
		  if (consumerIsLive(node)) {
			 for (let i = node.nextProducerIndex; i < node.producerNode.length; i++) {
				producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);
			 }
		  }
		  while (node.producerNode.length > node.nextProducerIndex) {
			 node.producerNode.pop();
			 node.producerLastReadVersion.pop();
			 node.producerIndexOfThis.pop();
		  }
		}
		function consumerPollProducersForChange(node) {
		  assertConsumerNode(node);
		  for (let i = 0; i < node.producerNode.length; i++) {
			 const producer = node.producerNode[i];
			 const seenVersion = node.producerLastReadVersion[i];
			 if (seenVersion !== producer.version) {
				return true;
			 }
			 producerUpdateValueVersion(producer);
			 if (seenVersion !== producer.version) {
				return true;
			 }
		  }
		  return false;
		}
		function consumerDestroy(node) {
		  assertConsumerNode(node);
		  if (consumerIsLive(node)) {
			 for (let i = 0; i < node.producerNode.length; i++) {
				producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);
			 }
		  }
		  node.producerNode.length = node.producerLastReadVersion.length = node.producerIndexOfThis.length = 0;
		  if (node.liveConsumerNode) {
			 node.liveConsumerNode.length = node.liveConsumerIndexOfThis.length = 0;
		  }
		}
		function producerAddLiveConsumer(node, consumer, indexOfThis) {
		  assertProducerNode(node);
		  assertConsumerNode(node);
		  if (node.liveConsumerNode.length === 0) {
			 for (let i = 0; i < node.producerNode.length; i++) {
				node.producerIndexOfThis[i] = producerAddLiveConsumer(node.producerNode[i], node, i);
			 }
		  }
		  node.liveConsumerIndexOfThis.push(indexOfThis);
		  return node.liveConsumerNode.push(consumer) - 1;
		}
		function producerRemoveLiveConsumerAtIndex(node, idx) {
		  assertProducerNode(node);
		  assertConsumerNode(node);
		  if (typeof ngDevMode !== "undefined" && ngDevMode && idx >= node.liveConsumerNode.length) {
			 throw new Error(`Assertion error: active consumer index ${idx} is out of bounds of ${node.liveConsumerNode.length} consumers)`);
		  }
		  if (node.liveConsumerNode.length === 1) {
			 for (let i = 0; i < node.producerNode.length; i++) {
				producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);
			 }
		  }
		  const lastIdx = node.liveConsumerNode.length - 1;
		  node.liveConsumerNode[idx] = node.liveConsumerNode[lastIdx];
		  node.liveConsumerIndexOfThis[idx] = node.liveConsumerIndexOfThis[lastIdx];
		  node.liveConsumerNode.length--;
		  node.liveConsumerIndexOfThis.length--;
		  if (idx < node.liveConsumerNode.length) {
			 const idxProducer = node.liveConsumerIndexOfThis[idx];
			 const consumer = node.liveConsumerNode[idx];
			 assertConsumerNode(consumer);
			 consumer.producerIndexOfThis[idxProducer] = idx;
		  }
		}
		function consumerIsLive(node) {
		  return node.consumerIsAlwaysLive || (node?.liveConsumerNode?.length ?? 0) > 0;
		}
		function assertConsumerNode(node) {
		  node.producerNode ??= [];
		  node.producerIndexOfThis ??= [];
		  node.producerLastReadVersion ??= [];
		}
		function assertProducerNode(node) {
		  node.liveConsumerNode ??= [];
		  node.liveConsumerIndexOfThis ??= [];
		}
		function createComputed(computation) {
		  const node = Object.create(COMPUTED_NODE);
		  node.computation = computation;
		  const computed = () => {
			 producerUpdateValueVersion(node);
			 producerAccessed(node);
			 if (node.value === ERRORED) {
				throw node.error;
			 }
			 return node.value;
		  };
		  computed[SIGNAL] = node;
		  return computed;
		}
		var UNSET = /* @__PURE__ */ Symbol("UNSET");
		var COMPUTING = /* @__PURE__ */ Symbol("COMPUTING");
		var ERRORED = /* @__PURE__ */ Symbol("ERRORED");
		var COMPUTED_NODE = /* @__PURE__ */ (() => {
		  return __spreadProps(__spreadValues({}, REACTIVE_NODE), {
			 value: UNSET,
			 dirty: true,
			 error: null,
			 equal: defaultEquals,
			 producerMustRecompute(node) {
				return node.value === UNSET || node.value === COMPUTING;
			 },
			 producerRecomputeValue(node) {
				if (node.value === COMPUTING) {
				  throw new Error("Detected cycle in computations.");
				}
				const oldValue = node.value;
				node.value = COMPUTING;
				const prevConsumer = consumerBeforeComputation(node);
				let newValue;
				try {
				  newValue = node.computation();
				} catch (err) {
				  newValue = ERRORED;
				  node.error = err;
				} finally {
				  consumerAfterComputation(node, prevConsumer);
				}
				if (oldValue !== UNSET && oldValue !== ERRORED && newValue !== ERRORED && node.equal(oldValue, newValue)) {
				  node.value = oldValue;
				  return;
				}
				node.value = newValue;
				node.version++;
			 }
		  });
		})();
		function defaultThrowError() {
		  throw new Error();
		}
		var throwInvalidWriteToSignalErrorFn = defaultThrowError;
		function throwInvalidWriteToSignalError() {
		  throwInvalidWriteToSignalErrorFn();
		}
		function setThrowInvalidWriteToSignalError(fn) {
		  throwInvalidWriteToSignalErrorFn = fn;
		}
		var postSignalSetFn = null;
		function createSignal(initialValue) {
		  const node = Object.create(SIGNAL_NODE);
		  node.value = initialValue;
		  const getter = () => {
			 producerAccessed(node);
			 return node.value;
		  };
		  getter[SIGNAL] = node;
		  return getter;
		}
		function signalSetFn(node, newValue) {
		  if (!producerUpdatesAllowed()) {
			 throwInvalidWriteToSignalError();
		  }
		  if (!node.equal(node.value, newValue)) {
			 node.value = newValue;
			 signalValueChanged(node);
		  }
		}
		function signalUpdateFn(node, updater) {
		  if (!producerUpdatesAllowed()) {
			 throwInvalidWriteToSignalError();
		  }
		  signalSetFn(node, updater(node.value));
		}
		var SIGNAL_NODE = /* @__PURE__ */ (() => {
		  return __spreadProps(__spreadValues({}, REACTIVE_NODE), {
			 equal: defaultEquals,
			 value: void 0
		  });
		})();
		function signalValueChanged(node) {
		  node.version++;
		  producerIncrementEpoch();
		  producerNotifyConsumers(node);
		  postSignalSetFn?.();
		}

		// node_modules/rxjs/dist/esm/internal/util/isFunction.js
		function isFunction(value) {
		  return typeof value === "function";
		}

		// node_modules/rxjs/dist/esm/internal/util/createErrorClass.js
		function createErrorClass(createImpl) {
		  const _super = (instance) => {
			 Error.call(instance);
			 instance.stack = new Error().stack;
		  };
		  const ctorFunc = createImpl(_super);
		  ctorFunc.prototype = Object.create(Error.prototype);
		  ctorFunc.prototype.constructor = ctorFunc;
		  return ctorFunc;
		}

		// node_modules/rxjs/dist/esm/internal/util/UnsubscriptionError.js
		var UnsubscriptionError = createErrorClass((_super) => function UnsubscriptionErrorImpl(errors) {
		  _super(this);
		  this.message = errors ? `${errors.length} errors occurred during unsubscription:
		${errors.map((err, i) => `${i + 1}) ${err.toString()}`).join("\n  ")}` : "";
		  this.name = "UnsubscriptionError";
		  this.errors = errors;
		});

		// node_modules/rxjs/dist/esm/internal/util/arrRemove.js
		function arrRemove(arr, item) {
		  if (arr) {
			 const index = arr.indexOf(item);
			 0 <= index && arr.splice(index, 1);
		  }
		}

		// node_modules/rxjs/dist/esm/internal/Subscription.js
		var Subscription = class _Subscription {
		  constructor(initialTeardown) {
			 this.initialTeardown = initialTeardown;
			 this.closed = false;
			 this._parentage = null;
			 this._finalizers = null;
		  }
		  unsubscribe() {
			 let errors;
			 if (!this.closed) {
				this.closed = true;
				const { _parentage } = this;
				if (_parentage) {
				  this._parentage = null;
				  if (Array.isArray(_parentage)) {
					 for (const parent of _parentage) {
						parent.remove(this);
					 }
				  } else {
					 _parentage.remove(this);
				  }
				}
				const { initialTeardown: initialFinalizer } = this;
				if (isFunction(initialFinalizer)) {
				  try {
					 initialFinalizer();
				  } catch (e) {
					 errors = e instanceof UnsubscriptionError ? e.errors : [e];
				  }
				}
				const { _finalizers } = this;
				if (_finalizers) {
				  this._finalizers = null;
				  for (const finalizer of _finalizers) {
					 try {
						execFinalizer(finalizer);
					 } catch (err) {
						errors = errors !== null && errors !== void 0 ? errors : [];
						if (err instanceof UnsubscriptionError) {
						  errors = [...errors, ...err.errors];
						} else {
						  errors.push(err);
						}
					 }
				  }
				}
				if (errors) {
				  throw new UnsubscriptionError(errors);
				}
			 }
		  }
		  add(teardown) {
			 var _a;
			 if (teardown && teardown !== this) {
				if (this.closed) {
				  execFinalizer(teardown);
				} else {
				  if (teardown instanceof _Subscription) {
					 if (teardown.closed || teardown._hasParent(this)) {
						return;
					 }
					 teardown._addParent(this);
				  }
				  (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
				}
			 }
		  }
		  _hasParent(parent) {
			 const { _parentage } = this;
			 return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
		  }
		  _addParent(parent) {
			 const { _parentage } = this;
			 this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
		  }
		  _removeParent(parent) {
			 const { _parentage } = this;
			 if (_parentage === parent) {
				this._parentage = null;
			 } else if (Array.isArray(_parentage)) {
				arrRemove(_parentage, parent);
			 }
		  }
		  remove(teardown) {
			 const { _finalizers } = this;
			 _finalizers && arrRemove(_finalizers, teardown);
			 if (teardown instanceof _Subscription) {
				teardown._removeParent(this);
			 }
		  }
		};
		Subscription.EMPTY = (() => {
		  const empty2 = new Subscription();
		  empty2.closed = true;
		  return empty2;
		})();
		var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
		function isSubscription(value) {
		  return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
		}
		function execFinalizer(finalizer) {
		  if (isFunction(finalizer)) {
			 finalizer();
		  } else {
			 finalizer.unsubscribe();
		  }
		}

		// node_modules/rxjs/dist/esm/internal/config.js
		var config = {
		  onUnhandledError: null,
		  onStoppedNotification: null,
		  Promise: void 0,
		  useDeprecatedSynchronousErrorHandling: false,
		  useDeprecatedNextContext: false
		};

		// node_modules/rxjs/dist/esm/internal/scheduler/timeoutProvider.js
		var timeoutProvider = {
		  setTimeout(handler, timeout2, ...args) {
			 const { delegate } = timeoutProvider;
			 if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
				return delegate.setTimeout(handler, timeout2, ...args);
			 }
			 return setTimeout(handler, timeout2, ...args);
		  },
		  clearTimeout(handle) {
			 const { delegate } = timeoutProvider;
			 return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
		  },
		  delegate: void 0
		};

		// node_modules/rxjs/dist/esm/internal/util/reportUnhandledError.js
		function reportUnhandledError(err) {
		  timeoutProvider.setTimeout(() => {
			 const { onUnhandledError } = config;
			 if (onUnhandledError) {
				onUnhandledError(err);
			 } else {
				throw err;
			 }
		  });
		}

		// node_modules/rxjs/dist/esm/internal/util/noop.js
		function noop() {
		}

		// node_modules/rxjs/dist/esm/internal/NotificationFactories.js
		var COMPLETE_NOTIFICATION = (() => createNotification("C", void 0, void 0))();
		function errorNotification(error) {
		  return createNotification("E", void 0, error);
		}
		function nextNotification(value) {
		  return createNotification("N", value, void 0);
		}
		function createNotification(kind, value, error) {
		  return {
			 kind,
			 value,
			 error
		  };
		}

		// node_modules/rxjs/dist/esm/internal/util/errorContext.js
		var context = null;
		function errorContext(cb) {
		  if (config.useDeprecatedSynchronousErrorHandling) {
			 const isRoot = !context;
			 if (isRoot) {
				context = { errorThrown: false, error: null };
			 }
			 cb();
			 if (isRoot) {
				const { errorThrown, error } = context;
				context = null;
				if (errorThrown) {
				  throw error;
				}
			 }
		  } else {
			 cb();
		  }
		}
		function captureError(err) {
		  if (config.useDeprecatedSynchronousErrorHandling && context) {
			 context.errorThrown = true;
			 context.error = err;
		  }
		}

		// node_modules/rxjs/dist/esm/internal/Subscriber.js
		var Subscriber = class extends Subscription {
		  constructor(destination) {
			 super();
			 this.isStopped = false;
			 if (destination) {
				this.destination = destination;
				if (isSubscription(destination)) {
				  destination.add(this);
				}
			 } else {
				this.destination = EMPTY_OBSERVER;
			 }
		  }
		  static create(next, error, complete) {
			 return new SafeSubscriber(next, error, complete);
		  }
		  next(value) {
			 if (this.isStopped) {
				handleStoppedNotification(nextNotification(value), this);
			 } else {
				this._next(value);
			 }
		  }
		  error(err) {
			 if (this.isStopped) {
				handleStoppedNotification(errorNotification(err), this);
			 } else {
				this.isStopped = true;
				this._error(err);
			 }
		  }
		  complete() {
			 if (this.isStopped) {
				handleStoppedNotification(COMPLETE_NOTIFICATION, this);
			 } else {
				this.isStopped = true;
				this._complete();
			 }
		  }
		  unsubscribe() {
			 if (!this.closed) {
				this.isStopped = true;
				super.unsubscribe();
				this.destination = null;
			 }
		  }
		  _next(value) {
			 this.destination.next(value);
		  }
		  _error(err) {
			 try {
				this.destination.error(err);
			 } finally {
				this.unsubscribe();
			 }
		  }
		  _complete() {
			 try {
				this.destination.complete();
			 } finally {
				this.unsubscribe();
			 }
		  }
		};
		var _bind = Function.prototype.bind;
		function bind(fn, thisArg) {
		  return _bind.call(fn, thisArg);
		}
		var ConsumerObserver = class {
		  constructor(partialObserver) {
			 this.partialObserver = partialObserver;
		  }
		  next(value) {
			 const { partialObserver } = this;
			 if (partialObserver.next) {
				try {
				  partialObserver.next(value);
				} catch (error) {
				  handleUnhandledError(error);
				}
			 }
		  }
		  error(err) {
			 const { partialObserver } = this;
			 if (partialObserver.error) {
				try {
				  partialObserver.error(err);
				} catch (error) {
				  handleUnhandledError(error);
				}
			 } else {
				handleUnhandledError(err);
			 }
		  }
		  complete() {
			 const { partialObserver } = this;
			 if (partialObserver.complete) {
				try {
				  partialObserver.complete();
				} catch (error) {
				  handleUnhandledError(error);
				}
			 }
		  }
		};
		var SafeSubscriber = class extends Subscriber {
		  constructor(observerOrNext, error, complete) {
			 super();
			 let partialObserver;
			 if (isFunction(observerOrNext) || !observerOrNext) {
				partialObserver = {
				  next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
				  error: error !== null && error !== void 0 ? error : void 0,
				  complete: complete !== null && complete !== void 0 ? complete : void 0
				};
			 } else {
				let context2;
				if (this && config.useDeprecatedNextContext) {
				  context2 = Object.create(observerOrNext);
				  context2.unsubscribe = () => this.unsubscribe();
				  partialObserver = {
					 next: observerOrNext.next && bind(observerOrNext.next, context2),
					 error: observerOrNext.error && bind(observerOrNext.error, context2),
					 complete: observerOrNext.complete && bind(observerOrNext.complete, context2)
				  };
				} else {
				  partialObserver = observerOrNext;
				}
			 }
			 this.destination = new ConsumerObserver(partialObserver);
		  }
		};
		function handleUnhandledError(error) {
		  if (config.useDeprecatedSynchronousErrorHandling) {
			 captureError(error);
		  } else {
			 reportUnhandledError(error);
		  }
		}
		function defaultErrorHandler(err) {
		  throw err;
		}
		function handleStoppedNotification(notification, subscriber) {
		  const { onStoppedNotification } = config;
		  onStoppedNotification && timeoutProvider.setTimeout(() => onStoppedNotification(notification, subscriber));
		}
		var EMPTY_OBSERVER = {
		  closed: true,
		  next: noop,
		  error: defaultErrorHandler,
		  complete: noop
		};

		// node_modules/rxjs/dist/esm/internal/symbol/observable.js
		var observable = (() => typeof Symbol === "function" && Symbol.observable || "@@observable")();

		// node_modules/rxjs/dist/esm/internal/util/identity.js
		function identity(x) {
		  return x;
		}

		// node_modules/rxjs/dist/esm/internal/util/pipe.js
		function pipeFromArray(fns) {
		  if (fns.length === 0) {
			 return identity;
		  }
		  if (fns.length === 1) {
			 return fns[0];
		  }
		  return function piped(input2) {
			 return fns.reduce((prev, fn) => fn(prev), input2);
		  };
		}

		// node_modules/rxjs/dist/esm/internal/Observable.js
		var Observable = class _Observable {
		  constructor(subscribe) {
			 if (subscribe) {
				this._subscribe = subscribe;
			 }
		  }
		  lift(operator) {
			 const observable2 = new _Observable();
			 observable2.source = this;
			 observable2.operator = operator;
			 return observable2;
		  }
		  subscribe(observerOrNext, error, complete) {
			 const subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
			 errorContext(() => {
				const { operator, source } = this;
				subscriber.add(operator ? operator.call(subscriber, source) : source ? this._subscribe(subscriber) : this._trySubscribe(subscriber));
			 });
			 return subscriber;
		  }
		  _trySubscribe(sink) {
			 try {
				return this._subscribe(sink);
			 } catch (err) {
				sink.error(err);
			 }
		  }
		  forEach(next, promiseCtor) {
			 promiseCtor = getPromiseCtor(promiseCtor);
			 return new promiseCtor((resolve, reject) => {
				const subscriber = new SafeSubscriber({
				  next: (value) => {
					 try {
						next(value);
					 } catch (err) {
						reject(err);
						subscriber.unsubscribe();
					 }
				  },
				  error: reject,
				  complete: resolve
				});
				this.subscribe(subscriber);
			 });
		  }
		  _subscribe(subscriber) {
			 var _a;
			 return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
		  }
		  [observable]() {
			 return this;
		  }
		  pipe(...operations) {
			 return pipeFromArray(operations)(this);
		  }
		  toPromise(promiseCtor) {
			 promiseCtor = getPromiseCtor(promiseCtor);
			 return new promiseCtor((resolve, reject) => {
				let value;
				this.subscribe((x) => value = x, (err) => reject(err), () => resolve(value));
			 });
		  }
		};
		Observable.create = (subscribe) => {
		  return new Observable(subscribe);
		};
		function getPromiseCtor(promiseCtor) {
		  var _a;
		  return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;
		}
		function isObserver(value) {
		  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
		}
		function isSubscriber(value) {
		  return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
		}

		// node_modules/rxjs/dist/esm/internal/util/lift.js
		function hasLift(source) {
		  return isFunction(source === null || source === void 0 ? void 0 : source.lift);
		}
		function operate(init2) {
		  return (source) => {
			 if (hasLift(source)) {
				return source.lift(function(liftedSource) {
				  try {
					 return init2(liftedSource, this);
				  } catch (err) {
					 this.error(err);
				  }
				});
			 }
			 throw new TypeError("Unable to lift unknown Observable type");
		  };
		}

		// node_modules/rxjs/dist/esm/internal/operators/OperatorSubscriber.js
		function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
		  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
		}
		var OperatorSubscriber = class extends Subscriber {
		  constructor(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
			 super(destination);
			 this.onFinalize = onFinalize;
			 this.shouldUnsubscribe = shouldUnsubscribe;
			 this._next = onNext ? function(value) {
				try {
				  onNext(value);
				} catch (err) {
				  destination.error(err);
				}
			 } : super._next;
			 this._error = onError ? function(err) {
				try {
				  onError(err);
				} catch (err2) {
				  destination.error(err2);
				} finally {
				  this.unsubscribe();
				}
			 } : super._error;
			 this._complete = onComplete ? function() {
				try {
				  onComplete();
				} catch (err) {
				  destination.error(err);
				} finally {
				  this.unsubscribe();
				}
			 } : super._complete;
		  }
		  unsubscribe() {
			 var _a;
			 if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
				const { closed } = this;
				super.unsubscribe();
				!closed && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
			 }
		  }
		};

		// node_modules/rxjs/dist/esm/internal/util/ObjectUnsubscribedError.js
		var ObjectUnsubscribedError = createErrorClass((_super) => function ObjectUnsubscribedErrorImpl() {
		  _super(this);
		  this.name = "ObjectUnsubscribedError";
		  this.message = "object unsubscribed";
		});

		// node_modules/rxjs/dist/esm/internal/Subject.js
		var Subject = class extends Observable {
		  constructor() {
			 super();
			 this.closed = false;
			 this.currentObservers = null;
			 this.observers = [];
			 this.isStopped = false;
			 this.hasError = false;
			 this.thrownError = null;
		  }
		  lift(operator) {
			 const subject = new AnonymousSubject(this, this);
			 subject.operator = operator;
			 return subject;
		  }
		  _throwIfClosed() {
			 if (this.closed) {
				throw new ObjectUnsubscribedError();
			 }
		  }
		  next(value) {
			 errorContext(() => {
				this._throwIfClosed();
				if (!this.isStopped) {
				  if (!this.currentObservers) {
					 this.currentObservers = Array.from(this.observers);
				  }
				  for (const observer of this.currentObservers) {
					 observer.next(value);
				  }
				}
			 });
		  }
		  error(err) {
			 errorContext(() => {
				this._throwIfClosed();
				if (!this.isStopped) {
				  this.hasError = this.isStopped = true;
				  this.thrownError = err;
				  const { observers } = this;
				  while (observers.length) {
					 observers.shift().error(err);
				  }
				}
			 });
		  }
		  complete() {
			 errorContext(() => {
				this._throwIfClosed();
				if (!this.isStopped) {
				  this.isStopped = true;
				  const { observers } = this;
				  while (observers.length) {
					 observers.shift().complete();
				  }
				}
			 });
		  }
		  unsubscribe() {
			 this.isStopped = this.closed = true;
			 this.observers = this.currentObservers = null;
		  }
		  get observed() {
			 var _a;
			 return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
		  }
		  _trySubscribe(subscriber) {
			 this._throwIfClosed();
			 return super._trySubscribe(subscriber);
		  }
		  _subscribe(subscriber) {
			 this._throwIfClosed();
			 this._checkFinalizedStatuses(subscriber);
			 return this._innerSubscribe(subscriber);
		  }
		  _innerSubscribe(subscriber) {
			 const { hasError, isStopped, observers } = this;
			 if (hasError || isStopped) {
				return EMPTY_SUBSCRIPTION;
			 }
			 this.currentObservers = null;
			 observers.push(subscriber);
			 return new Subscription(() => {
				this.currentObservers = null;
				arrRemove(observers, subscriber);
			 });
		  }
		  _checkFinalizedStatuses(subscriber) {
			 const { hasError, thrownError, isStopped } = this;
			 if (hasError) {
				subscriber.error(thrownError);
			 } else if (isStopped) {
				subscriber.complete();
			 }
		  }
		  asObservable() {
			 const observable2 = new Observable();
			 observable2.source = this;
			 return observable2;
		  }
		};
		Subject.create = (destination, source) => {
		  return new AnonymousSubject(destination, source);
		};
		var AnonymousSubject = class extends Subject {
		  constructor(destination, source) {
			 super();
			 this.destination = destination;
			 this.source = source;
		  }
		  next(value) {
			 var _a, _b;
			 (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
		  }
		  error(err) {
			 var _a, _b;
			 (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
		  }
		  complete() {
			 var _a, _b;
			 (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
		  }
		  _subscribe(subscriber) {
			 var _a, _b;
			 return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
		  }
		};

		// node_modules/rxjs/dist/esm/internal/BehaviorSubject.js
		var BehaviorSubject = class extends Subject {
		  constructor(_value) {
			 super();
			 this._value = _value;
		  }
		  get value() {
			 return this.getValue();
		  }
		  _subscribe(subscriber) {
			 const subscription = super._subscribe(subscriber);
			 !subscription.closed && subscriber.next(this._value);
			 return subscription;
		  }
		  getValue() {
			 const { hasError, thrownError, _value } = this;
			 if (hasError) {
				throw thrownError;
			 }
			 this._throwIfClosed();
			 return _value;
		  }
		  next(value) {
			 super.next(this._value = value);
		  }
		};

		// node_modules/rxjs/dist/esm/internal/scheduler/dateTimestampProvider.js
		var dateTimestampProvider = {
		  now() {
			 return (dateTimestampProvider.delegate || Date).now();
		  },
		  delegate: void 0
		};

		// node_modules/rxjs/dist/esm/internal/ReplaySubject.js
		var ReplaySubject = class extends Subject {
		  constructor(_bufferSize = Infinity, _windowTime = Infinity, _timestampProvider = dateTimestampProvider) {
			 super();
			 this._bufferSize = _bufferSize;
			 this._windowTime = _windowTime;
			 this._timestampProvider = _timestampProvider;
			 this._buffer = [];
			 this._infiniteTimeWindow = true;
			 this._infiniteTimeWindow = _windowTime === Infinity;
			 this._bufferSize = Math.max(1, _bufferSize);
			 this._windowTime = Math.max(1, _windowTime);
		  }
		  next(value) {
			 const { isStopped, _buffer, _infiniteTimeWindow, _timestampProvider, _windowTime } = this;
			 if (!isStopped) {
				_buffer.push(value);
				!_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
			 }
			 this._trimBuffer();
			 super.next(value);
		  }
		  _subscribe(subscriber) {
			 this._throwIfClosed();
			 this._trimBuffer();
			 const subscription = this._innerSubscribe(subscriber);
			 const { _infiniteTimeWindow, _buffer } = this;
			 const copy2 = _buffer.slice();
			 for (let i = 0; i < copy2.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {
				subscriber.next(copy2[i]);
			 }
			 this._checkFinalizedStatuses(subscriber);
			 return subscription;
		  }
		  _trimBuffer() {
			 const { _bufferSize, _timestampProvider, _buffer, _infiniteTimeWindow } = this;
			 const adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
			 _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
			 if (!_infiniteTimeWindow) {
				const now2 = _timestampProvider.now();
				let last2 = 0;
				for (let i = 1; i < _buffer.length && _buffer[i] <= now2; i += 2) {
				  last2 = i;
				}
				last2 && _buffer.splice(0, last2 + 1);
			 }
		  }
		};

		// node_modules/rxjs/dist/esm/internal/observable/empty.js
		var EMPTY = new Observable((subscriber) => subscriber.complete());

		// node_modules/rxjs/dist/esm/internal/util/isScheduler.js
		function isScheduler(value) {
		  return value && isFunction(value.schedule);
		}

		// node_modules/rxjs/dist/esm/internal/util/args.js
		function last(arr) {
		  return arr[arr.length - 1];
		}
		function popScheduler(args) {
		  return isScheduler(last(args)) ? args.pop() : void 0;
		}
		function popNumber(args, defaultValue) {
		  return typeof last(args) === "number" ? args.pop() : defaultValue;
		}

		// node_modules/tslib/tslib.es6.mjs
		function __decorate(decorators, target, key, desc) {
		  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
		  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
			 r = Reflect.decorate(decorators, target, key, desc);
		  else
			 for (var i = decorators.length - 1; i >= 0; i--)
				if (d = decorators[i])
				  r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
		  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
		}
		function __param(paramIndex, decorator) {
		  return function(target, key) {
			 decorator(target, key, paramIndex);
		  };
		}
		function __awaiter(thisArg, _arguments, P, generator) {
		  function adopt(value) {
			 return value instanceof P ? value : new P(function(resolve) {
				resolve(value);
			 });
		  }
		  return new (P || (P = Promise))(function(resolve, reject) {
			 function fulfilled(value) {
				try {
				  step(generator.next(value));
				} catch (e) {
				  reject(e);
				}
			 }
			 function rejected(value) {
				try {
				  step(generator["throw"](value));
				} catch (e) {
				  reject(e);
				}
			 }
			 function step(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			 }
			 step((generator = generator.apply(thisArg, _arguments || [])).next());
		  });
		}
		function __values(o) {
		  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
		  if (m)
			 return m.call(o);
		  if (o && typeof o.length === "number")
			 return {
				next: function() {
				  if (o && i >= o.length)
					 o = void 0;
				  return { value: o && o[i++], done: !o };
				}
			 };
		  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
		}
		function __await(v) {
		  return this instanceof __await ? (this.v = v, this) : new __await(v);
		}
		function __asyncGenerator(thisArg, _arguments, generator) {
		  if (!Symbol.asyncIterator)
			 throw new TypeError("Symbol.asyncIterator is not defined.");
		  var g = generator.apply(thisArg, _arguments || []), i, q = [];
		  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
			 return this;
		  }, i;
		  function awaitReturn(f) {
			 return function(v) {
				return Promise.resolve(v).then(f, reject);
			 };
		  }
		  function verb(n, f) {
			 if (g[n]) {
				i[n] = function(v) {
				  return new Promise(function(a, b) {
					 q.push([n, v, a, b]) > 1 || resume(n, v);
				  });
				};
				if (f)
				  i[n] = f(i[n]);
			 }
		  }
		  function resume(n, v) {
			 try {
				step(g[n](v));
			 } catch (e) {
				settle(q[0][3], e);
			 }
		  }
		  function step(r) {
			 r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
		  }
		  function fulfill(value) {
			 resume("next", value);
		  }
		  function reject(value) {
			 resume("throw", value);
		  }
		  function settle(f, v) {
			 if (f(v), q.shift(), q.length)
				resume(q[0][0], q[0][1]);
		  }
		}
		function __asyncValues(o) {
		  if (!Symbol.asyncIterator)
			 throw new TypeError("Symbol.asyncIterator is not defined.");
		  var m = o[Symbol.asyncIterator], i;
		  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
			 return this;
		  }, i);
		  function verb(n) {
			 i[n] = o[n] && function(v) {
				return new Promise(function(resolve, reject) {
				  v = o[n](v), settle(resolve, reject, v.done, v.value);
				});
			 };
		  }
		  function settle(resolve, reject, d, v) {
			 Promise.resolve(v).then(function(v2) {
				resolve({ value: v2, done: d });
			 }, reject);
		  }
		}

		// node_modules/rxjs/dist/esm/internal/util/isArrayLike.js
		var isArrayLike = (x) => x && typeof x.length === "number" && typeof x !== "function";

		// node_modules/rxjs/dist/esm/internal/util/isPromise.js
		function isPromise(value) {
		  return isFunction(value === null || value === void 0 ? void 0 : value.then);
		}

		// node_modules/rxjs/dist/esm/internal/util/isInteropObservable.js
		function isInteropObservable(input2) {
		  return isFunction(input2[observable]);
		}

		// node_modules/rxjs/dist/esm/internal/util/isAsyncIterable.js
		function isAsyncIterable(obj) {
		  return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
		}

		// node_modules/rxjs/dist/esm/internal/util/throwUnobservableError.js
		function createInvalidObservableTypeError(input2) {
		  return new TypeError(`You provided ${input2 !== null && typeof input2 === "object" ? "an invalid object" : `'${input2}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`);
		}

		// node_modules/rxjs/dist/esm/internal/symbol/iterator.js
		function getSymbolIterator() {
		  if (typeof Symbol !== "function" || !Symbol.iterator) {
			 return "@@iterator";
		  }
		  return Symbol.iterator;
		}
		var iterator = getSymbolIterator();

		// node_modules/rxjs/dist/esm/internal/util/isIterable.js
		function isIterable(input2) {
		  return isFunction(input2 === null || input2 === void 0 ? void 0 : input2[iterator]);
		}

		// node_modules/rxjs/dist/esm/internal/util/isReadableStreamLike.js
		function readableStreamLikeToAsyncGenerator(readableStream) {
		  return __asyncGenerator(this, arguments, function* readableStreamLikeToAsyncGenerator_1() {
			 const reader = readableStream.getReader();
			 try {
				while (true) {
				  const { value, done } = yield __await(reader.read());
				  if (done) {
					 return yield __await(void 0);
				  }
				  yield yield __await(value);
				}
			 } finally {
				reader.releaseLock();
			 }
		  });
		}
		function isReadableStreamLike(obj) {
		  return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
		}

		// node_modules/rxjs/dist/esm/internal/observable/innerFrom.js
		function innerFrom(input2) {
		  if (input2 instanceof Observable) {
			 return input2;
		  }
		  if (input2 != null) {
			 if (isInteropObservable(input2)) {
				return fromInteropObservable(input2);
			 }
			 if (isArrayLike(input2)) {
				return fromArrayLike(input2);
			 }
			 if (isPromise(input2)) {
				return fromPromise(input2);
			 }
			 if (isAsyncIterable(input2)) {
				return fromAsyncIterable(input2);
			 }
			 if (isIterable(input2)) {
				return fromIterable(input2);
			 }
			 if (isReadableStreamLike(input2)) {
				return fromReadableStreamLike(input2);
			 }
		  }
		  throw createInvalidObservableTypeError(input2);
		}
		function fromInteropObservable(obj) {
		  return new Observable((subscriber) => {
			 const obs = obj[observable]();
			 if (isFunction(obs.subscribe)) {
				return obs.subscribe(subscriber);
			 }
			 throw new TypeError("Provided object does not correctly implement Symbol.observable");
		  });
		}
		function fromArrayLike(array2) {
		  return new Observable((subscriber) => {
			 for (let i = 0; i < array2.length && !subscriber.closed; i++) {
				subscriber.next(array2[i]);
			 }
			 subscriber.complete();
		  });
		}
		function fromPromise(promise) {
		  return new Observable((subscriber) => {
			 promise.then((value) => {
				if (!subscriber.closed) {
				  subscriber.next(value);
				  subscriber.complete();
				}
			 }, (err) => subscriber.error(err)).then(null, reportUnhandledError);
		  });
		}
		function fromIterable(iterable) {
		  return new Observable((subscriber) => {
			 for (const value of iterable) {
				subscriber.next(value);
				if (subscriber.closed) {
				  return;
				}
			 }
			 subscriber.complete();
		  });
		}
		function fromAsyncIterable(asyncIterable) {
		  return new Observable((subscriber) => {
			 process(asyncIterable, subscriber).catch((err) => subscriber.error(err));
		  });
		}
		function fromReadableStreamLike(readableStream) {
		  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
		}
		function process(asyncIterable, subscriber) {
		  var asyncIterable_1, asyncIterable_1_1;
		  var e_1, _a;
		  return __awaiter(this, void 0, void 0, function* () {
			 try {
				for (asyncIterable_1 = __asyncValues(asyncIterable); asyncIterable_1_1 = yield asyncIterable_1.next(), !asyncIterable_1_1.done; ) {
				  const value = asyncIterable_1_1.value;
				  subscriber.next(value);
				  if (subscriber.closed) {
					 return;
				  }
				}
			 } catch (e_1_1) {
				e_1 = { error: e_1_1 };
			 } finally {
				try {
				  if (asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return))
					 yield _a.call(asyncIterable_1);
				} finally {
				  if (e_1)
					 throw e_1.error;
				}
			 }
			 subscriber.complete();
		  });
		}

		// node_modules/rxjs/dist/esm/internal/util/executeSchedule.js
		function executeSchedule(parentSubscription, scheduler2, work, delay = 0, repeat = false) {
		  const scheduleSubscription = scheduler2.schedule(function() {
			 work();
			 if (repeat) {
				parentSubscription.add(this.schedule(null, delay));
			 } else {
				this.unsubscribe();
			 }
		  }, delay);
		  parentSubscription.add(scheduleSubscription);
		  if (!repeat) {
			 return scheduleSubscription;
		  }
		}

		// node_modules/rxjs/dist/esm/internal/operators/observeOn.js
		function observeOn(scheduler2, delay = 0) {
		  return operate((source, subscriber) => {
			 source.subscribe(createOperatorSubscriber(subscriber, (value) => executeSchedule(subscriber, scheduler2, () => subscriber.next(value), delay), () => executeSchedule(subscriber, scheduler2, () => subscriber.complete(), delay), (err) => executeSchedule(subscriber, scheduler2, () => subscriber.error(err), delay)));
		  });
		}

		// node_modules/rxjs/dist/esm/internal/operators/subscribeOn.js
		function subscribeOn(scheduler2, delay = 0) {
		  return operate((source, subscriber) => {
			 subscriber.add(scheduler2.schedule(() => source.subscribe(subscriber), delay));
		  });
		}

		// node_modules/rxjs/dist/esm/internal/scheduled/scheduleObservable.js
		function scheduleObservable(input2, scheduler2) {
		  return innerFrom(input2).pipe(subscribeOn(scheduler2), observeOn(scheduler2));
		}

		// node_modules/rxjs/dist/esm/internal/scheduled/schedulePromise.js
		function schedulePromise(input2, scheduler2) {
		  return innerFrom(input2).pipe(subscribeOn(scheduler2), observeOn(scheduler2));
		}

		// node_modules/rxjs/dist/esm/internal/scheduled/scheduleArray.js
		function scheduleArray(input2, scheduler2) {
		  return new Observable((subscriber) => {
			 let i = 0;
			 return scheduler2.schedule(function() {
				if (i === input2.length) {
				  subscriber.complete();
				} else {
				  subscriber.next(input2[i++]);
				  if (!subscriber.closed) {
					 this.schedule();
				  }
				}
			 });
		  });
		}

		// node_modules/rxjs/dist/esm/internal/scheduled/scheduleIterable.js
		function scheduleIterable(input2, scheduler2) {
		  return new Observable((subscriber) => {
			 let iterator2;
			 executeSchedule(subscriber, scheduler2, () => {
				iterator2 = input2[iterator]();
				executeSchedule(subscriber, scheduler2, () => {
				  let value;
				  let done;
				  try {
					 ({ value, done } = iterator2.next());
				  } catch (err) {
					 subscriber.error(err);
					 return;
				  }
				  if (done) {
					 subscriber.complete();
				  } else {
					 subscriber.next(value);
				  }
				}, 0, true);
			 });
			 return () => isFunction(iterator2 === null || iterator2 === void 0 ? void 0 : iterator2.return) && iterator2.return();
		  });
		}

		// node_modules/rxjs/dist/esm/internal/scheduled/scheduleAsyncIterable.js
		function scheduleAsyncIterable(input2, scheduler2) {
		  if (!input2) {
			 throw new Error("Iterable cannot be null");
		  }
		  return new Observable((subscriber) => {
			 executeSchedule(subscriber, scheduler2, () => {
				const iterator2 = input2[Symbol.asyncIterator]();
				executeSchedule(subscriber, scheduler2, () => {
				  iterator2.next().then((result) => {
					 if (result.done) {
						subscriber.complete();
					 } else {
						subscriber.next(result.value);
					 }
				  });
				}, 0, true);
			 });
		  });
		}

		// node_modules/rxjs/dist/esm/internal/scheduled/scheduleReadableStreamLike.js
		function scheduleReadableStreamLike(input2, scheduler2) {
		  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input2), scheduler2);
		}

		// node_modules/rxjs/dist/esm/internal/scheduled/scheduled.js
		function scheduled(input2, scheduler2) {
		  if (input2 != null) {
			 if (isInteropObservable(input2)) {
				return scheduleObservable(input2, scheduler2);
			 }
			 if (isArrayLike(input2)) {
				return scheduleArray(input2, scheduler2);
			 }
			 if (isPromise(input2)) {
				return schedulePromise(input2, scheduler2);
			 }
			 if (isAsyncIterable(input2)) {
				return scheduleAsyncIterable(input2, scheduler2);
			 }
			 if (isIterable(input2)) {
				return scheduleIterable(input2, scheduler2);
			 }
			 if (isReadableStreamLike(input2)) {
				return scheduleReadableStreamLike(input2, scheduler2);
			 }
		  }
		  throw createInvalidObservableTypeError(input2);
		}

		// node_modules/rxjs/dist/esm/internal/observable/from.js
		function from(input2, scheduler2) {
		  return scheduler2 ? scheduled(input2, scheduler2) : innerFrom(input2);
		}

		// node_modules/rxjs/dist/esm/internal/operators/map.js
		function map(project, thisArg) {
		  return operate((source, subscriber) => {
			 let index = 0;
			 source.subscribe(createOperatorSubscriber(subscriber, (value) => {
				subscriber.next(project.call(thisArg, value, index++));
			 }));
		  });
		}

		// node_modules/rxjs/dist/esm/internal/operators/mergeInternals.js
		function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
		  const buffer = [];
		  let active = 0;
		  let index = 0;
		  let isComplete = false;
		  const checkComplete = () => {
			 if (isComplete && !buffer.length && !active) {
				subscriber.complete();
			 }
		  };
		  const outerNext = (value) => active < concurrent ? doInnerSub(value) : buffer.push(value);
		  const doInnerSub = (value) => {
			 expand && subscriber.next(value);
			 active++;
			 let innerComplete = false;
			 innerFrom(project(value, index++)).subscribe(createOperatorSubscriber(subscriber, (innerValue) => {
				onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
				if (expand) {
				  outerNext(innerValue);
				} else {
				  subscriber.next(innerValue);
				}
			 }, () => {
				innerComplete = true;
			 }, void 0, () => {
				if (innerComplete) {
				  try {
					 active--;
					 while (buffer.length && active < concurrent) {
						const bufferedValue = buffer.shift();
						if (innerSubScheduler) {
						  executeSchedule(subscriber, innerSubScheduler, () => doInnerSub(bufferedValue));
						} else {
						  doInnerSub(bufferedValue);
						}
					 }
					 checkComplete();
				  } catch (err) {
					 subscriber.error(err);
				  }
				}
			 }));
		  };
		  source.subscribe(createOperatorSubscriber(subscriber, outerNext, () => {
			 isComplete = true;
			 checkComplete();
		  }));
		  return () => {
			 additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
		  };
		}

		// node_modules/rxjs/dist/esm/internal/operators/mergeMap.js
		function mergeMap(project, resultSelector, concurrent = Infinity) {
		  if (isFunction(resultSelector)) {
			 return mergeMap((a, i) => map((b, ii) => resultSelector(a, b, i, ii))(innerFrom(project(a, i))), concurrent);
		  } else if (typeof resultSelector === "number") {
			 concurrent = resultSelector;
		  }
		  return operate((source, subscriber) => mergeInternals(source, subscriber, project, concurrent));
		}

		// node_modules/rxjs/dist/esm/internal/operators/mergeAll.js
		function mergeAll(concurrent = Infinity) {
		  return mergeMap(identity, concurrent);
		}

		// node_modules/rxjs/dist/esm/internal/observable/merge.js
		function merge(...args) {
		  const scheduler2 = popScheduler(args);
		  const concurrent = popNumber(args, Infinity);
		  const sources = args;
		  return !sources.length ? EMPTY : sources.length === 1 ? innerFrom(sources[0]) : mergeAll(concurrent)(from(sources, scheduler2));
		}

		// node_modules/rxjs/dist/esm/internal/operators/switchMap.js
		function switchMap(project, resultSelector) {
		  return operate((source, subscriber) => {
			 let innerSubscriber = null;
			 let index = 0;
			 let isComplete = false;
			 const checkComplete = () => isComplete && !innerSubscriber && subscriber.complete();
			 source.subscribe(createOperatorSubscriber(subscriber, (value) => {
				innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
				let innerIndex = 0;
				const outerIndex = index++;
				innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = createOperatorSubscriber(subscriber, (innerValue) => subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue), () => {
				  innerSubscriber = null;
				  checkComplete();
				}));
			 }, () => {
				isComplete = true;
				checkComplete();
			 }));
		  });
		}

		// node_modules/@angular/core/fesm2022/core.mjs
		var ERROR_DETAILS_PAGE_BASE_URL = "https://angular.io/errors";
		var XSS_SECURITY_URL = "https://g.co/ng/security#xss";
		var RuntimeError = class extends Error {
		  constructor(code, message2) {
			 super(formatRuntimeError(code, message2));
			 this.code = code;
		  }
		};
		function formatRuntimeError(code, message2) {
		  const fullCode = `NG0${Math.abs(code)}`;
		  let errorMessage = `${fullCode}${message2 ? ": " + message2 : ""}`;
		  if (ngDevMode && code < 0) {
			 const addPeriodSeparator = !errorMessage.match(/[.,;!?\n]$/);
			 const separator = addPeriodSeparator ? "." : "";
			 errorMessage = `${errorMessage}${separator} Find more at ${ERROR_DETAILS_PAGE_BASE_URL}/${fullCode}`;
		  }
		  return errorMessage;
		}
		var REQUIRED_UNSET_VALUE = /* @__PURE__ */ Symbol("InputSignalNode#UNSET");
		var INPUT_SIGNAL_NODE = /* @__PURE__ */ (() => {
		  return __spreadProps(__spreadValues({}, SIGNAL_NODE), {
			 transformFn: void 0,
			 applyValueToInputSignal(node, value) {
				signalSetFn(node, value);
			 }
		  });
		})();
		function createInputSignal(initialValue, options) {
		  const node = Object.create(INPUT_SIGNAL_NODE);
		  node.value = initialValue;
		  node.transformFn = options?.transform;
		  function inputValueFn() {
			 producerAccessed(node);
			 if (node.value === REQUIRED_UNSET_VALUE) {
				throw new RuntimeError(-950, ngDevMode && "Input is required but no value is available yet.");
			 }
			 return node.value;
		  }
		  inputValueFn[SIGNAL] = node;
		  if (ngDevMode) {
			 inputValueFn.toString = () => `[Input Signal: ${inputValueFn()}]`;
		  }
		  return inputValueFn;
		}
		function noSideEffects(fn) {
		  return { toString: fn }.toString();
		}
		var ANNOTATIONS = "__annotations__";
		var PARAMETERS = "__parameters__";
		var PROP_METADATA = "__prop__metadata__";
		function makeDecorator(name, props, parentClass, additionalProcessing, typeFn) {
		  return noSideEffects(() => {
			 const metaCtor = makeMetadataCtor(props);
			 function DecoratorFactory(...args) {
				if (this instanceof DecoratorFactory) {
				  metaCtor.call(this, ...args);
				  return this;
				}
				const annotationInstance = new DecoratorFactory(...args);
				return function TypeDecorator(cls) {
				  if (typeFn)
					 typeFn(cls, ...args);
				  const annotations = cls.hasOwnProperty(ANNOTATIONS) ? cls[ANNOTATIONS] : Object.defineProperty(cls, ANNOTATIONS, { value: [] })[ANNOTATIONS];
				  annotations.push(annotationInstance);
				  if (additionalProcessing)
					 additionalProcessing(cls);
				  return cls;
				};
			 }
			 if (parentClass) {
				DecoratorFactory.prototype = Object.create(parentClass.prototype);
			 }
			 DecoratorFactory.prototype.ngMetadataName = name;
			 DecoratorFactory.annotationCls = DecoratorFactory;
			 return DecoratorFactory;
		  });
		}
		function makeMetadataCtor(props) {
		  return function ctor(...args) {
			 if (props) {
				const values = props(...args);
				for (const propName in values) {
				  this[propName] = values[propName];
				}
			 }
		  };
		}
		function makeParamDecorator(name, props, parentClass) {
		  return noSideEffects(() => {
			 const metaCtor = makeMetadataCtor(props);
			 function ParamDecoratorFactory(...args) {
				if (this instanceof ParamDecoratorFactory) {
				  metaCtor.apply(this, args);
				  return this;
				}
				const annotationInstance = new ParamDecoratorFactory(...args);
				ParamDecorator.annotation = annotationInstance;
				return ParamDecorator;
				function ParamDecorator(cls, unusedKey, index) {
				  const parameters = cls.hasOwnProperty(PARAMETERS) ? cls[PARAMETERS] : Object.defineProperty(cls, PARAMETERS, { value: [] })[PARAMETERS];
				  while (parameters.length <= index) {
					 parameters.push(null);
				  }
				  (parameters[index] = parameters[index] || []).push(annotationInstance);
				  return cls;
				}
			 }
			 if (parentClass) {
				ParamDecoratorFactory.prototype = Object.create(parentClass.prototype);
			 }
			 ParamDecoratorFactory.prototype.ngMetadataName = name;
			 ParamDecoratorFactory.annotationCls = ParamDecoratorFactory;
			 return ParamDecoratorFactory;
		  });
		}
		function makePropDecorator(name, props, parentClass, additionalProcessing) {
		  return noSideEffects(() => {
			 const metaCtor = makeMetadataCtor(props);
			 function PropDecoratorFactory(...args) {
				if (this instanceof PropDecoratorFactory) {
				  metaCtor.apply(this, args);
				  return this;
				}
				const decoratorInstance = new PropDecoratorFactory(...args);
				function PropDecorator(target, name2) {
				  if (target === void 0) {
					 throw new Error("Standard Angular field decorators are not supported in JIT mode.");
				  }
				  const constructor = target.constructor;
				  const meta = constructor.hasOwnProperty(PROP_METADATA) ? constructor[PROP_METADATA] : Object.defineProperty(constructor, PROP_METADATA, { value: {} })[PROP_METADATA];
				  meta[name2] = meta.hasOwnProperty(name2) && meta[name2] || [];
				  meta[name2].unshift(decoratorInstance);
				  if (additionalProcessing)
					 additionalProcessing(target, name2, ...args);
				}
				return PropDecorator;
			 }
			 if (parentClass) {
				PropDecoratorFactory.prototype = Object.create(parentClass.prototype);
			 }
			 PropDecoratorFactory.prototype.ngMetadataName = name;
			 PropDecoratorFactory.annotationCls = PropDecoratorFactory;
			 return PropDecoratorFactory;
		  });
		}
		var _global = globalThis;
		function ngDevModeResetPerfCounters() {
		  const locationString = typeof location !== "undefined" ? location.toString() : "";
		  const newCounters = {
			 namedConstructors: locationString.indexOf("ngDevMode=namedConstructors") != -1,
			 firstCreatePass: 0,
			 tNode: 0,
			 tView: 0,
			 rendererCreateTextNode: 0,
			 rendererSetText: 0,
			 rendererCreateElement: 0,
			 rendererAddEventListener: 0,
			 rendererSetAttribute: 0,
			 rendererRemoveAttribute: 0,
			 rendererSetProperty: 0,
			 rendererSetClassName: 0,
			 rendererAddClass: 0,
			 rendererRemoveClass: 0,
			 rendererSetStyle: 0,
			 rendererRemoveStyle: 0,
			 rendererDestroy: 0,
			 rendererDestroyNode: 0,
			 rendererMoveNode: 0,
			 rendererRemoveNode: 0,
			 rendererAppendChild: 0,
			 rendererInsertBefore: 0,
			 rendererCreateComment: 0,
			 hydratedNodes: 0,
			 hydratedComponents: 0,
			 dehydratedViewsRemoved: 0,
			 dehydratedViewsCleanupRuns: 0,
			 componentsSkippedHydration: 0
		  };
		  const allowNgDevModeTrue = locationString.indexOf("ngDevMode=false") === -1;
		  if (!allowNgDevModeTrue) {
			 _global["ngDevMode"] = false;
		  } else {
			 if (typeof _global["ngDevMode"] !== "object") {
				_global["ngDevMode"] = {};
			 }
			 Object.assign(_global["ngDevMode"], newCounters);
		  }
		  return newCounters;
		}
		function initNgDevMode() {
		  if (typeof ngDevMode === "undefined" || ngDevMode) {
			 if (typeof ngDevMode !== "object" || Object.keys(ngDevMode).length === 0) {
				ngDevModeResetPerfCounters();
			 }
			 return typeof ngDevMode !== "undefined" && !!ngDevMode;
		  }
		  return false;
		}
		function getClosureSafeProperty(objWithPropertyToExtract) {
		  for (let key in objWithPropertyToExtract) {
			 if (objWithPropertyToExtract[key] === getClosureSafeProperty) {
				return key;
			 }
		  }
		  throw Error("Could not find renamed property on target object.");
		}
		function fillProperties(target, source) {
		  for (const key in source) {
			 if (source.hasOwnProperty(key) && !target.hasOwnProperty(key)) {
				target[key] = source[key];
			 }
		  }
		}
		function stringify(token) {
		  if (typeof token === "string") {
			 return token;
		  }
		  if (Array.isArray(token)) {
			 return "[" + token.map(stringify).join(", ") + "]";
		  }
		  if (token == null) {
			 return "" + token;
		  }
		  if (token.overriddenName) {
			 return `${token.overriddenName}`;
		  }
		  if (token.name) {
			 return `${token.name}`;
		  }
		  const res = token.toString();
		  if (res == null) {
			 return "" + res;
		  }
		  const newLineIndex = res.indexOf("\n");
		  return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
		}
		function concatStringsWithSpace(before, after) {
		  return before == null || before === "" ? after === null ? "" : after : after == null || after === "" ? before : before + " " + after;
		}
		var __forward_ref__ = getClosureSafeProperty({ __forward_ref__: getClosureSafeProperty });
		function forwardRef(forwardRefFn) {
		  forwardRefFn.__forward_ref__ = forwardRef;
		  forwardRefFn.toString = function() {
			 return stringify(this());
		  };
		  return forwardRefFn;
		}
		function resolveForwardRef(type2) {
		  return isForwardRef(type2) ? type2() : type2;
		}
		function isForwardRef(fn) {
		  return typeof fn === "function" && fn.hasOwnProperty(__forward_ref__) && fn.__forward_ref__ === forwardRef;
		}
		function assertNumber(actual, msg) {
		  if (!(typeof actual === "number")) {
			 throwError(msg, typeof actual, "number", "===");
		  }
		}
		function assertNumberInRange(actual, minInclusive, maxInclusive) {
		  assertNumber(actual, "Expected a number");
		  assertLessThanOrEqual(actual, maxInclusive, "Expected number to be less than or equal to");
		  assertGreaterThanOrEqual(actual, minInclusive, "Expected number to be greater than or equal to");
		}
		function assertString(actual, msg) {
		  if (!(typeof actual === "string")) {
			 throwError(msg, actual === null ? "null" : typeof actual, "string", "===");
		  }
		}
		function assertFunction(actual, msg) {
		  if (!(typeof actual === "function")) {
			 throwError(msg, actual === null ? "null" : typeof actual, "function", "===");
		  }
		}
		function assertEqual(actual, expected, msg) {
		  if (!(actual == expected)) {
			 throwError(msg, actual, expected, "==");
		  }
		}
		function assertNotEqual(actual, expected, msg) {
		  if (!(actual != expected)) {
			 throwError(msg, actual, expected, "!=");
		  }
		}
		function assertSame(actual, expected, msg) {
		  if (!(actual === expected)) {
			 throwError(msg, actual, expected, "===");
		  }
		}
		function assertNotSame(actual, expected, msg) {
		  if (!(actual !== expected)) {
			 throwError(msg, actual, expected, "!==");
		  }
		}
		function assertLessThan(actual, expected, msg) {
		  if (!(actual < expected)) {
			 throwError(msg, actual, expected, "<");
		  }
		}
		function assertLessThanOrEqual(actual, expected, msg) {
		  if (!(actual <= expected)) {
			 throwError(msg, actual, expected, "<=");
		  }
		}
		function assertGreaterThan(actual, expected, msg) {
		  if (!(actual > expected)) {
			 throwError(msg, actual, expected, ">");
		  }
		}
		function assertGreaterThanOrEqual(actual, expected, msg) {
		  if (!(actual >= expected)) {
			 throwError(msg, actual, expected, ">=");
		  }
		}
		function assertDefined(actual, msg) {
		  if (actual == null) {
			 throwError(msg, actual, null, "!=");
		  }
		}
		function throwError(msg, actual, expected, comparison) {
		  throw new Error(`ASSERTION ERROR: ${msg}` + (comparison == null ? "" : ` [Expected=> ${expected} ${comparison} ${actual} <=Actual]`));
		}
		function assertDomNode(node) {
		  if (!(node instanceof Node)) {
			 throwError(`The provided value must be an instance of a DOM Node but got ${stringify(node)}`);
		  }
		}
		function assertElement(node) {
		  if (!(node instanceof Element)) {
			 throwError(`The provided value must be an element but got ${stringify(node)}`);
		  }
		}
		function assertIndexInRange(arr, index) {
		  assertDefined(arr, "Array must be defined.");
		  const maxLen = arr.length;
		  if (index < 0 || index >= maxLen) {
			 throwError(`Index expected to be less than ${maxLen} but got ${index}`);
		  }
		}
		function assertOneOf(value, ...validValues) {
		  if (validValues.indexOf(value) !== -1)
			 return true;
		  throwError(`Expected value to be one of ${JSON.stringify(validValues)} but was ${JSON.stringify(value)}.`);
		}
		function assertNotReactive(fn) {
		  if (getActiveConsumer() !== null) {
			 throwError(`${fn}() should never be called in a reactive context.`);
		  }
		}
		function \u0275\u0275defineInjectable(opts) {
		  return {
			 token: opts.token,
			 providedIn: opts.providedIn || null,
			 factory: opts.factory,
			 value: void 0
		  };
		}
		function \u0275\u0275defineInjector(options) {
		  return { providers: options.providers || [], imports: options.imports || [] };
		}
		function getInjectableDef(type2) {
		  return getOwnDefinition(type2, NG_PROV_DEF) || getOwnDefinition(type2, NG_INJECTABLE_DEF);
		}
		function getOwnDefinition(type2, field) {
		  return type2.hasOwnProperty(field) ? type2[field] : null;
		}
		function getInheritedInjectableDef(type2) {
		  const def = type2 && (type2[NG_PROV_DEF] || type2[NG_INJECTABLE_DEF]);
		  if (def) {
			 ngDevMode && console.warn(`DEPRECATED: DI is instantiating a token "${type2.name}" that inherits its @Injectable decorator but does not provide one itself.
		This will become an error in a future version of Angular. Please add @Injectable() to the "${type2.name}" class.`);
			 return def;
		  } else {
			 return null;
		  }
		}
		function getInjectorDef(type2) {
		  return type2 && (type2.hasOwnProperty(NG_INJ_DEF) || type2.hasOwnProperty(NG_INJECTOR_DEF)) ? type2[NG_INJ_DEF] : null;
		}
		var NG_PROV_DEF = getClosureSafeProperty({ \u0275prov: getClosureSafeProperty });
		var NG_INJ_DEF = getClosureSafeProperty({ \u0275inj: getClosureSafeProperty });
		var NG_INJECTABLE_DEF = getClosureSafeProperty({ ngInjectableDef: getClosureSafeProperty });
		var NG_INJECTOR_DEF = getClosureSafeProperty({ ngInjectorDef: getClosureSafeProperty });
		var InjectionToken = class {
		  /**
			* @param _desc   Description for the token,
			*                used only for debugging purposes,
			*                it should but does not need to be unique
			* @param options Options for the token's usage, as described above
			*/
		  constructor(_desc, options) {
			 this._desc = _desc;
			 this.ngMetadataName = "InjectionToken";
			 this.\u0275prov = void 0;
			 if (typeof options == "number") {
				(typeof ngDevMode === "undefined" || ngDevMode) && assertLessThan(options, 0, "Only negative numbers are supported here");
				this.__NG_ELEMENT_ID__ = options;
			 } else if (options !== void 0) {
				this.\u0275prov = \u0275\u0275defineInjectable({
				  token: this,
				  providedIn: options.providedIn || "root",
				  factory: options.factory
				});
			 }
		  }
		  /**
			* @internal
			*/
		  get multi() {
			 return this;
		  }
		  toString() {
			 return `InjectionToken ${this._desc}`;
		  }
		};
		var _injectorProfilerContext;
		function getInjectorProfilerContext() {
		  !ngDevMode && throwError("getInjectorProfilerContext should never be called in production mode");
		  return _injectorProfilerContext;
		}
		function setInjectorProfilerContext(context2) {
		  !ngDevMode && throwError("setInjectorProfilerContext should never be called in production mode");
		  const previous = _injectorProfilerContext;
		  _injectorProfilerContext = context2;
		  return previous;
		}
		var injectorProfilerCallback = null;
		var setInjectorProfiler = (injectorProfiler2) => {
		  !ngDevMode && throwError("setInjectorProfiler should never be called in production mode");
		  injectorProfilerCallback = injectorProfiler2;
		};
		function injectorProfiler(event) {
		  !ngDevMode && throwError("Injector profiler should never be called in production mode");
		  if (injectorProfilerCallback != null) {
			 injectorProfilerCallback(event);
		  }
		}
		function emitProviderConfiguredEvent(eventProvider, isViewProvider = false) {
		  !ngDevMode && throwError("Injector profiler should never be called in production mode");
		  let token;
		  if (typeof eventProvider === "function") {
			 token = eventProvider;
		  } else if (eventProvider instanceof InjectionToken) {
			 token = eventProvider;
		  } else {
			 token = resolveForwardRef(eventProvider.provide);
		  }
		  let provider = eventProvider;
		  if (eventProvider instanceof InjectionToken) {
			 provider = eventProvider.\u0275prov || eventProvider;
		  }
		  injectorProfiler({
			 type: 2,
			 context: getInjectorProfilerContext(),
			 providerRecord: { token, provider, isViewProvider }
		  });
		}
		function emitInstanceCreatedByInjectorEvent(instance) {
		  !ngDevMode && throwError("Injector profiler should never be called in production mode");
		  injectorProfiler({
			 type: 1,
			 context: getInjectorProfilerContext(),
			 instance: { value: instance }
		  });
		}
		function emitInjectEvent(token, value, flags) {
		  !ngDevMode && throwError("Injector profiler should never be called in production mode");
		  injectorProfiler({
			 type: 0,
			 context: getInjectorProfilerContext(),
			 service: { token, value, flags }
		  });
		}
		function runInInjectorProfilerContext(injector, token, callback) {
		  !ngDevMode && throwError("runInInjectorProfilerContext should never be called in production mode");
		  const prevInjectContext = setInjectorProfilerContext({ injector, token });
		  try {
			 callback();
		  } finally {
			 setInjectorProfilerContext(prevInjectContext);
		  }
		}
		function isEnvironmentProviders(value) {
		  return value && !!value.\u0275providers;
		}
		var NG_COMP_DEF = getClosureSafeProperty({ \u0275cmp: getClosureSafeProperty });
		var NG_DIR_DEF = getClosureSafeProperty({ \u0275dir: getClosureSafeProperty });
		var NG_PIPE_DEF = getClosureSafeProperty({ \u0275pipe: getClosureSafeProperty });
		var NG_MOD_DEF = getClosureSafeProperty({ \u0275mod: getClosureSafeProperty });
		var NG_FACTORY_DEF = getClosureSafeProperty({ \u0275fac: getClosureSafeProperty });
		var NG_ELEMENT_ID = getClosureSafeProperty({ __NG_ELEMENT_ID__: getClosureSafeProperty });
		var NG_ENV_ID = getClosureSafeProperty({ __NG_ENV_ID__: getClosureSafeProperty });
		function renderStringify(value) {
		  if (typeof value === "string")
			 return value;
		  if (value == null)
			 return "";
		  return String(value);
		}
		function stringifyForError(value) {
		  if (typeof value === "function")
			 return value.name || value.toString();
		  if (typeof value === "object" && value != null && typeof value.type === "function") {
			 return value.type.name || value.type.toString();
		  }
		  return renderStringify(value);
		}
		function throwCyclicDependencyError(token, path) {
		  const depPath = path ? `. Dependency path: ${path.join(" > ")} > ${token}` : "";
		  throw new RuntimeError(-200, ngDevMode ? `Circular dependency in DI detected for ${token}${depPath}` : token);
		}
		function throwMixedMultiProviderError() {
		  throw new Error(`Cannot mix multi providers and regular providers`);
		}
		function throwInvalidProviderError(ngModuleType, providers, provider) {
		  if (ngModuleType && providers) {
			 const providerDetail = providers.map((v) => v == provider ? "?" + provider + "?" : "...");
			 throw new Error(`Invalid provider for the NgModule '${stringify(ngModuleType)}' - only instances of Provider and Type are allowed, got: [${providerDetail.join(", ")}]`);
		  } else if (isEnvironmentProviders(provider)) {
			 if (provider.\u0275fromNgModule) {
				throw new RuntimeError(207, `Invalid providers from 'importProvidersFrom' present in a non-environment injector. 'importProvidersFrom' can't be used for component providers.`);
			 } else {
				throw new RuntimeError(207, `Invalid providers present in a non-environment injector. 'EnvironmentProviders' can't be used for component providers.`);
			 }
		  } else {
			 throw new Error("Invalid provider");
		  }
		}
		function throwProviderNotFoundError(token, injectorName) {
		  const errorMessage = ngDevMode && `No provider for ${stringifyForError(token)} found${injectorName ? ` in ${injectorName}` : ""}`;
		  throw new RuntimeError(-201, errorMessage);
		}
		var InjectFlags;
		(function(InjectFlags2) {
		  InjectFlags2[InjectFlags2["Default"] = 0] = "Default";
		  InjectFlags2[InjectFlags2["Host"] = 1] = "Host";
		  InjectFlags2[InjectFlags2["Self"] = 2] = "Self";
		  InjectFlags2[InjectFlags2["SkipSelf"] = 4] = "SkipSelf";
		  InjectFlags2[InjectFlags2["Optional"] = 8] = "Optional";
		})(InjectFlags || (InjectFlags = {}));
		var _injectImplementation;
		function getInjectImplementation() {
		  return _injectImplementation;
		}
		function setInjectImplementation(impl) {
		  const previous = _injectImplementation;
		  _injectImplementation = impl;
		  return previous;
		}
		function injectRootLimpMode(token, notFoundValue, flags) {
		  const injectableDef = getInjectableDef(token);
		  if (injectableDef && injectableDef.providedIn == "root") {
			 return injectableDef.value === void 0 ? injectableDef.value = injectableDef.factory() : injectableDef.value;
		  }
		  if (flags & InjectFlags.Optional)
			 return null;
		  if (notFoundValue !== void 0)
			 return notFoundValue;
		  throwProviderNotFoundError(token, "Injector");
		}
		function assertInjectImplementationNotEqual(fn) {
		  ngDevMode && assertNotEqual(_injectImplementation, fn, "Calling \u0275\u0275inject would cause infinite recursion");
		}
		var _THROW_IF_NOT_FOUND = {};
		var THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;
		var DI_DECORATOR_FLAG = "__NG_DI_FLAG__";
		var NG_TEMP_TOKEN_PATH = "ngTempTokenPath";
		var NG_TOKEN_PATH = "ngTokenPath";
		var NEW_LINE = /\n/gm;
		var NO_NEW_LINE = "\u0275";
		var SOURCE = "__source";
		var _currentInjector = void 0;
		function getCurrentInjector() {
		  return _currentInjector;
		}
		function setCurrentInjector(injector) {
		  const former = _currentInjector;
		  _currentInjector = injector;
		  return former;
		}
		function injectInjectorOnly(token, flags = InjectFlags.Default) {
		  if (_currentInjector === void 0) {
			 throw new RuntimeError(-203, ngDevMode && `inject() must be called from an injection context such as a constructor, a factory function, a field initializer, or a function used with \`runInInjectionContext\`.`);
		  } else if (_currentInjector === null) {
			 return injectRootLimpMode(token, void 0, flags);
		  } else {
			 const value = _currentInjector.get(token, flags & InjectFlags.Optional ? null : void 0, flags);
			 ngDevMode && emitInjectEvent(token, value, flags);
			 return value;
		  }
		}
		function \u0275\u0275inject(token, flags = InjectFlags.Default) {
		  return (getInjectImplementation() || injectInjectorOnly)(resolveForwardRef(token), flags);
		}
		function \u0275\u0275invalidFactoryDep(index) {
		  throw new RuntimeError(202, ngDevMode && `This constructor is not compatible with Angular Dependency Injection because its dependency at index ${index} of the parameter list is invalid.
		This can happen if the dependency type is a primitive like a string or if an ancestor of this class is missing an Angular decorator.

		Please check that 1) the type for the parameter at index ${index} is correct and 2) the correct Angular decorators are defined for this class and its ancestors.`);
		}
		function inject(token, flags = InjectFlags.Default) {
		  return \u0275\u0275inject(token, convertToBitFlags(flags));
		}
		function convertToBitFlags(flags) {
		  if (typeof flags === "undefined" || typeof flags === "number") {
			 return flags;
		  }
		  return 0 | // comment to force a line break in the formatter
		  (flags.optional && 8) | (flags.host && 1) | (flags.self && 2) | (flags.skipSelf && 4);
		}
		function injectArgs(types) {
		  const args = [];
		  for (let i = 0; i < types.length; i++) {
			 const arg = resolveForwardRef(types[i]);
			 if (Array.isArray(arg)) {
				if (arg.length === 0) {
				  throw new RuntimeError(900, ngDevMode && "Arguments array must have arguments.");
				}
				let type2 = void 0;
				let flags = InjectFlags.Default;
				for (let j = 0; j < arg.length; j++) {
				  const meta = arg[j];
				  const flag = getInjectFlag(meta);
				  if (typeof flag === "number") {
					 if (flag === -1) {
						type2 = meta.token;
					 } else {
						flags |= flag;
					 }
				  } else {
					 type2 = meta;
				  }
				}
				args.push(\u0275\u0275inject(type2, flags));
			 } else {
				args.push(\u0275\u0275inject(arg));
			 }
		  }
		  return args;
		}
		function attachInjectFlag(decorator, flag) {
		  decorator[DI_DECORATOR_FLAG] = flag;
		  decorator.prototype[DI_DECORATOR_FLAG] = flag;
		  return decorator;
		}
		function getInjectFlag(token) {
		  return token[DI_DECORATOR_FLAG];
		}
		function catchInjectorError(e, token, injectorErrorName, source) {
		  const tokenPath = e[NG_TEMP_TOKEN_PATH];
		  if (token[SOURCE]) {
			 tokenPath.unshift(token[SOURCE]);
		  }
		  e.message = formatError("\n" + e.message, tokenPath, injectorErrorName, source);
		  e[NG_TOKEN_PATH] = tokenPath;
		  e[NG_TEMP_TOKEN_PATH] = null;
		  throw e;
		}
		function formatError(text, obj, injectorErrorName, source = null) {
		  text = text && text.charAt(0) === "\n" && text.charAt(1) == NO_NEW_LINE ? text.slice(2) : text;
		  let context2 = stringify(obj);
		  if (Array.isArray(obj)) {
			 context2 = obj.map(stringify).join(" -> ");
		  } else if (typeof obj === "object") {
			 let parts = [];
			 for (let key in obj) {
				if (obj.hasOwnProperty(key)) {
				  let value = obj[key];
				  parts.push(key + ":" + (typeof value === "string" ? JSON.stringify(value) : stringify(value)));
				}
			 }
			 context2 = `{${parts.join(", ")}}`;
		  }
		  return `${injectorErrorName}${source ? "(" + source + ")" : ""}[${context2}]: ${text.replace(NEW_LINE, "\n  ")}`;
		}
		var Inject = attachInjectFlag(
		  // Disable tslint because `DecoratorFlags` is a const enum which gets inlined.
		  // tslint:disable-next-line: no-toplevel-property-access
		  makeParamDecorator("Inject", (token) => ({ token })),
		  -1
		  /* DecoratorFlags.Inject */
		);
		var Optional = (
		  // Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.
		  // tslint:disable-next-line: no-toplevel-property-access
		  attachInjectFlag(
			 makeParamDecorator("Optional"),
			 8
			 /* InternalInjectFlags.Optional */
		  )
		);
		var Self = (
		  // Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.
		  // tslint:disable-next-line: no-toplevel-property-access
		  attachInjectFlag(
			 makeParamDecorator("Self"),
			 2
			 /* InternalInjectFlags.Self */
		  )
		);
		var SkipSelf = (
		  // Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.
		  // tslint:disable-next-line: no-toplevel-property-access
		  attachInjectFlag(
			 makeParamDecorator("SkipSelf"),
			 4
			 /* InternalInjectFlags.SkipSelf */
		  )
		);
		var Host = (
		  // Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.
		  // tslint:disable-next-line: no-toplevel-property-access
		  attachInjectFlag(
			 makeParamDecorator("Host"),
			 1
			 /* InternalInjectFlags.Host */
		  )
		);
		function getFactoryDef(type2, throwNotFound) {
		  const hasFactoryDef = type2.hasOwnProperty(NG_FACTORY_DEF);
		  if (!hasFactoryDef && throwNotFound === true && ngDevMode) {
			 throw new Error(`Type ${stringify(type2)} does not have '\u0275fac' property.`);
		  }
		  return hasFactoryDef ? type2[NG_FACTORY_DEF] : null;
		}
		function arrayEquals(a, b, identityAccessor) {
		  if (a.length !== b.length)
			 return false;
		  for (let i = 0; i < a.length; i++) {
			 let valueA = a[i];
			 let valueB = b[i];
			 if (identityAccessor) {
				valueA = identityAccessor(valueA);
				valueB = identityAccessor(valueB);
			 }
			 if (valueB !== valueA) {
				return false;
			 }
		  }
		  return true;
		}
		function flatten(list) {
		  return list.flat(Number.POSITIVE_INFINITY);
		}
		function deepForEach(input2, fn) {
		  input2.forEach((value) => Array.isArray(value) ? deepForEach(value, fn) : fn(value));
		}
		function addToArray(arr, index, value) {
		  if (index >= arr.length) {
			 arr.push(value);
		  } else {
			 arr.splice(index, 0, value);
		  }
		}
		function removeFromArray(arr, index) {
		  if (index >= arr.length - 1) {
			 return arr.pop();
		  } else {
			 return arr.splice(index, 1)[0];
		  }
		}
		function newArray(size, value) {
		  const list = [];
		  for (let i = 0; i < size; i++) {
			 list.push(value);
		  }
		  return list;
		}
		function arraySplice(array2, index, count) {
		  const length = array2.length - count;
		  while (index < length) {
			 array2[index] = array2[index + count];
			 index++;
		  }
		  while (count--) {
			 array2.pop();
		  }
		}
		function arrayInsert2(array2, index, value1, value2) {
		  ngDevMode && assertLessThanOrEqual(index, array2.length, "Can't insert past array end.");
		  let end = array2.length;
		  if (end == index) {
			 array2.push(value1, value2);
		  } else if (end === 1) {
			 array2.push(value2, array2[0]);
			 array2[0] = value1;
		  } else {
			 end--;
			 array2.push(array2[end - 1], array2[end]);
			 while (end > index) {
				const previousEnd = end - 2;
				array2[end] = array2[previousEnd];
				end--;
			 }
			 array2[index] = value1;
			 array2[index + 1] = value2;
		  }
		}
		function keyValueArraySet(keyValueArray, key, value) {
		  let index = keyValueArrayIndexOf(keyValueArray, key);
		  if (index >= 0) {
			 keyValueArray[index | 1] = value;
		  } else {
			 index = ~index;
			 arrayInsert2(keyValueArray, index, key, value);
		  }
		  return index;
		}
		function keyValueArrayGet(keyValueArray, key) {
		  const index = keyValueArrayIndexOf(keyValueArray, key);
		  if (index >= 0) {
			 return keyValueArray[index | 1];
		  }
		  return void 0;
		}
		function keyValueArrayIndexOf(keyValueArray, key) {
		  return _arrayIndexOfSorted(keyValueArray, key, 1);
		}
		function _arrayIndexOfSorted(array2, value, shift) {
		  ngDevMode && assertEqual(Array.isArray(array2), true, "Expecting an array");
		  let start2 = 0;
		  let end = array2.length >> shift;
		  while (end !== start2) {
			 const middle = start2 + (end - start2 >> 1);
			 const current = array2[middle << shift];
			 if (value === current) {
				return middle << shift;
			 } else if (current > value) {
				end = middle;
			 } else {
				start2 = middle + 1;
			 }
		  }
		  return ~(end << shift);
		}
		var EMPTY_OBJ = {};
		var EMPTY_ARRAY = [];
		if ((typeof ngDevMode === "undefined" || ngDevMode) && initNgDevMode()) {
		  Object.freeze(EMPTY_OBJ);
		  Object.freeze(EMPTY_ARRAY);
		}
		var ENVIRONMENT_INITIALIZER = new InjectionToken(ngDevMode ? "ENVIRONMENT_INITIALIZER" : "");
		var INJECTOR$1 = new InjectionToken(
		  ngDevMode ? "INJECTOR" : "",
		  // Disable tslint because this is const enum which gets inlined not top level prop access.
		  // tslint:disable-next-line: no-toplevel-property-access
		  -1
		  /* InjectorMarkers.Injector */
		);
		var INJECTOR_DEF_TYPES = new InjectionToken(ngDevMode ? "INJECTOR_DEF_TYPES" : "");
		var NullInjector = class {
		  get(token, notFoundValue = THROW_IF_NOT_FOUND) {
			 if (notFoundValue === THROW_IF_NOT_FOUND) {
				const error = new Error(`NullInjectorError: No provider for ${stringify(token)}!`);
				error.name = "NullInjectorError";
				throw error;
			 }
			 return notFoundValue;
		  }
		};
		var ChangeDetectionStrategy;
		(function(ChangeDetectionStrategy2) {
		  ChangeDetectionStrategy2[ChangeDetectionStrategy2["OnPush"] = 0] = "OnPush";
		  ChangeDetectionStrategy2[ChangeDetectionStrategy2["Default"] = 1] = "Default";
		})(ChangeDetectionStrategy || (ChangeDetectionStrategy = {}));
		var ViewEncapsulation$1;
		(function(ViewEncapsulation2) {
		  ViewEncapsulation2[ViewEncapsulation2["Emulated"] = 0] = "Emulated";
		  ViewEncapsulation2[ViewEncapsulation2["None"] = 2] = "None";
		  ViewEncapsulation2[ViewEncapsulation2["ShadowDom"] = 3] = "ShadowDom";
		})(ViewEncapsulation$1 || (ViewEncapsulation$1 = {}));
		var InputFlags;
		(function(InputFlags2) {
		  InputFlags2[InputFlags2["None"] = 0] = "None";
		  InputFlags2[InputFlags2["SignalBased"] = 1] = "SignalBased";
		  InputFlags2[InputFlags2["HasDecoratorInputTransform"] = 2] = "HasDecoratorInputTransform";
		})(InputFlags || (InputFlags = {}));
		function classIndexOf(className, classToSearch, startingIndex) {
		  ngDevMode && assertNotEqual(classToSearch, "", 'can not look for "" string.');
		  let end = className.length;
		  while (true) {
			 const foundIndex = className.indexOf(classToSearch, startingIndex);
			 if (foundIndex === -1)
				return foundIndex;
			 if (foundIndex === 0 || className.charCodeAt(foundIndex - 1) <= 32) {
				const length = classToSearch.length;
				if (foundIndex + length === end || className.charCodeAt(foundIndex + length) <= 32) {
				  return foundIndex;
				}
			 }
			 startingIndex = foundIndex + 1;
		  }
		}
		function setUpAttributes(renderer, native, attrs) {
		  let i = 0;
		  while (i < attrs.length) {
			 const value = attrs[i];
			 if (typeof value === "number") {
				if (value !== 0) {
				  break;
				}
				i++;
				const namespaceURI = attrs[i++];
				const attrName = attrs[i++];
				const attrVal = attrs[i++];
				ngDevMode && ngDevMode.rendererSetAttribute++;
				renderer.setAttribute(native, attrName, attrVal, namespaceURI);
			 } else {
				const attrName = value;
				const attrVal = attrs[++i];
				ngDevMode && ngDevMode.rendererSetAttribute++;
				if (isAnimationProp(attrName)) {
				  renderer.setProperty(native, attrName, attrVal);
				} else {
				  renderer.setAttribute(native, attrName, attrVal);
				}
				i++;
			 }
		  }
		  return i;
		}
		function isNameOnlyAttributeMarker(marker) {
		  return marker === 3 || marker === 4 || marker === 6;
		}
		function isAnimationProp(name) {
		  return name.charCodeAt(0) === 64;
		}
		function mergeHostAttrs(dst, src) {
		  if (src === null || src.length === 0) {
		  } else if (dst === null || dst.length === 0) {
			 dst = src.slice();
		  } else {
			 let srcMarker = -1;
			 for (let i = 0; i < src.length; i++) {
				const item = src[i];
				if (typeof item === "number") {
				  srcMarker = item;
				} else {
				  if (srcMarker === 0) {
				  } else if (srcMarker === -1 || srcMarker === 2) {
					 mergeHostAttribute(dst, srcMarker, item, null, src[++i]);
				  } else {
					 mergeHostAttribute(dst, srcMarker, item, null, null);
				  }
				}
			 }
		  }
		  return dst;
		}
		function mergeHostAttribute(dst, marker, key1, key2, value) {
		  let i = 0;
		  let markerInsertPosition = dst.length;
		  if (marker === -1) {
			 markerInsertPosition = -1;
		  } else {
			 while (i < dst.length) {
				const dstValue = dst[i++];
				if (typeof dstValue === "number") {
				  if (dstValue === marker) {
					 markerInsertPosition = -1;
					 break;
				  } else if (dstValue > marker) {
					 markerInsertPosition = i - 1;
					 break;
				  }
				}
			 }
		  }
		  while (i < dst.length) {
			 const item = dst[i];
			 if (typeof item === "number") {
				break;
			 } else if (item === key1) {
				if (key2 === null) {
				  if (value !== null) {
					 dst[i + 1] = value;
				  }
				  return;
				} else if (key2 === dst[i + 1]) {
				  dst[i + 2] = value;
				  return;
				}
			 }
			 i++;
			 if (key2 !== null)
				i++;
			 if (value !== null)
				i++;
		  }
		  if (markerInsertPosition !== -1) {
			 dst.splice(markerInsertPosition, 0, marker);
			 i = markerInsertPosition + 1;
		  }
		  dst.splice(i++, 0, key1);
		  if (key2 !== null) {
			 dst.splice(i++, 0, key2);
		  }
		  if (value !== null) {
			 dst.splice(i++, 0, value);
		  }
		}
		var NG_TEMPLATE_SELECTOR = "ng-template";
		function isCssClassMatching(tNode, attrs, cssClassToMatch, isProjectionMode) {
		  ngDevMode && assertEqual(cssClassToMatch, cssClassToMatch.toLowerCase(), "Class name expected to be lowercase.");
		  let i = 0;
		  if (isProjectionMode) {
			 for (; i < attrs.length && typeof attrs[i] === "string"; i += 2) {
				if (attrs[i] === "class" && classIndexOf(attrs[i + 1].toLowerCase(), cssClassToMatch, 0) !== -1) {
				  return true;
				}
			 }
		  } else if (isInlineTemplate(tNode)) {
			 return false;
		  }
		  i = attrs.indexOf(1, i);
		  if (i > -1) {
			 let item;
			 while (++i < attrs.length && typeof (item = attrs[i]) === "string") {
				if (item.toLowerCase() === cssClassToMatch) {
				  return true;
				}
			 }
		  }
		  return false;
		}
		function isInlineTemplate(tNode) {
		  return tNode.type === 4 && tNode.value !== NG_TEMPLATE_SELECTOR;
		}
		function hasTagAndTypeMatch(tNode, currentSelector, isProjectionMode) {
		  const tagNameToCompare = tNode.type === 4 && !isProjectionMode ? NG_TEMPLATE_SELECTOR : tNode.value;
		  return currentSelector === tagNameToCompare;
		}
		function isNodeMatchingSelector(tNode, selector, isProjectionMode) {
		  ngDevMode && assertDefined(selector[0], "Selector should have a tag name");
		  let mode = 4;
		  const nodeAttrs = tNode.attrs;
		  const nameOnlyMarkerIdx = nodeAttrs !== null ? getNameOnlyMarkerIndex(nodeAttrs) : 0;
		  let skipToNextSelector = false;
		  for (let i = 0; i < selector.length; i++) {
			 const current = selector[i];
			 if (typeof current === "number") {
				if (!skipToNextSelector && !isPositive(mode) && !isPositive(current)) {
				  return false;
				}
				if (skipToNextSelector && isPositive(current))
				  continue;
				skipToNextSelector = false;
				mode = current | mode & 1;
				continue;
			 }
			 if (skipToNextSelector)
				continue;
			 if (mode & 4) {
				mode = 2 | mode & 1;
				if (current !== "" && !hasTagAndTypeMatch(tNode, current, isProjectionMode) || current === "" && selector.length === 1) {
				  if (isPositive(mode))
					 return false;
				  skipToNextSelector = true;
				}
			 } else if (mode & 8) {
				if (nodeAttrs === null || !isCssClassMatching(tNode, nodeAttrs, current, isProjectionMode)) {
				  if (isPositive(mode))
					 return false;
				  skipToNextSelector = true;
				}
			 } else {
				const selectorAttrValue = selector[++i];
				const attrIndexInNode = findAttrIndexInNode(current, nodeAttrs, isInlineTemplate(tNode), isProjectionMode);
				if (attrIndexInNode === -1) {
				  if (isPositive(mode))
					 return false;
				  skipToNextSelector = true;
				  continue;
				}
				if (selectorAttrValue !== "") {
				  let nodeAttrValue;
				  if (attrIndexInNode > nameOnlyMarkerIdx) {
					 nodeAttrValue = "";
				  } else {
					 ngDevMode && assertNotEqual(nodeAttrs[attrIndexInNode], 0, "We do not match directives on namespaced attributes");
					 nodeAttrValue = nodeAttrs[attrIndexInNode + 1].toLowerCase();
				  }
				  if (mode & 2 && selectorAttrValue !== nodeAttrValue) {
					 if (isPositive(mode))
						return false;
					 skipToNextSelector = true;
				  }
				}
			 }
		  }
		  return isPositive(mode) || skipToNextSelector;
		}
		function isPositive(mode) {
		  return (mode & 1) === 0;
		}
		function findAttrIndexInNode(name, attrs, isInlineTemplate2, isProjectionMode) {
		  if (attrs === null)
			 return -1;
		  let i = 0;
		  if (isProjectionMode || !isInlineTemplate2) {
			 let bindingsMode = false;
			 while (i < attrs.length) {
				const maybeAttrName = attrs[i];
				if (maybeAttrName === name) {
				  return i;
				} else if (maybeAttrName === 3 || maybeAttrName === 6) {
				  bindingsMode = true;
				} else if (maybeAttrName === 1 || maybeAttrName === 2) {
				  let value = attrs[++i];
				  while (typeof value === "string") {
					 value = attrs[++i];
				  }
				  continue;
				} else if (maybeAttrName === 4) {
				  break;
				} else if (maybeAttrName === 0) {
				  i += 4;
				  continue;
				}
				i += bindingsMode ? 1 : 2;
			 }
			 return -1;
		  } else {
			 return matchTemplateAttribute(attrs, name);
		  }
		}
		function isNodeMatchingSelectorList(tNode, selector, isProjectionMode = false) {
		  for (let i = 0; i < selector.length; i++) {
			 if (isNodeMatchingSelector(tNode, selector[i], isProjectionMode)) {
				return true;
			 }
		  }
		  return false;
		}
		function getProjectAsAttrValue(tNode) {
		  const nodeAttrs = tNode.attrs;
		  if (nodeAttrs != null) {
			 const ngProjectAsAttrIdx = nodeAttrs.indexOf(
				5
				/* AttributeMarker.ProjectAs */
			 );
			 if ((ngProjectAsAttrIdx & 1) === 0) {
				return nodeAttrs[ngProjectAsAttrIdx + 1];
			 }
		  }
		  return null;
		}
		function getNameOnlyMarkerIndex(nodeAttrs) {
		  for (let i = 0; i < nodeAttrs.length; i++) {
			 const nodeAttr = nodeAttrs[i];
			 if (isNameOnlyAttributeMarker(nodeAttr)) {
				return i;
			 }
		  }
		  return nodeAttrs.length;
		}
		function matchTemplateAttribute(attrs, name) {
		  let i = attrs.indexOf(
			 4
			 /* AttributeMarker.Template */
		  );
		  if (i > -1) {
			 i++;
			 while (i < attrs.length) {
				const attr = attrs[i];
				if (typeof attr === "number")
				  return -1;
				if (attr === name)
				  return i;
				i++;
			 }
		  }
		  return -1;
		}
		function isSelectorInSelectorList(selector, list) {
		  selectorListLoop:
			 for (let i = 0; i < list.length; i++) {
				const currentSelectorInList = list[i];
				if (selector.length !== currentSelectorInList.length) {
				  continue;
				}
				for (let j = 0; j < selector.length; j++) {
				  if (selector[j] !== currentSelectorInList[j]) {
					 continue selectorListLoop;
				  }
				}
				return true;
			 }
		  return false;
		}
		function maybeWrapInNotSelector(isNegativeMode, chunk) {
		  return isNegativeMode ? ":not(" + chunk.trim() + ")" : chunk;
		}
		function stringifyCSSSelector(selector) {
		  let result = selector[0];
		  let i = 1;
		  let mode = 2;
		  let currentChunk = "";
		  let isNegativeMode = false;
		  while (i < selector.length) {
			 let valueOrMarker = selector[i];
			 if (typeof valueOrMarker === "string") {
				if (mode & 2) {
				  const attrValue = selector[++i];
				  currentChunk += "[" + valueOrMarker + (attrValue.length > 0 ? '="' + attrValue + '"' : "") + "]";
				} else if (mode & 8) {
				  currentChunk += "." + valueOrMarker;
				} else if (mode & 4) {
				  currentChunk += " " + valueOrMarker;
				}
			 } else {
				if (currentChunk !== "" && !isPositive(valueOrMarker)) {
				  result += maybeWrapInNotSelector(isNegativeMode, currentChunk);
				  currentChunk = "";
				}
				mode = valueOrMarker;
				isNegativeMode = isNegativeMode || !isPositive(mode);
			 }
			 i++;
		  }
		  if (currentChunk !== "") {
			 result += maybeWrapInNotSelector(isNegativeMode, currentChunk);
		  }
		  return result;
		}
		function stringifyCSSSelectorList(selectorList) {
		  return selectorList.map(stringifyCSSSelector).join(",");
		}
		function extractAttrsAndClassesFromSelector(selector) {
		  const attrs = [];
		  const classes = [];
		  let i = 1;
		  let mode = 2;
		  while (i < selector.length) {
			 let valueOrMarker = selector[i];
			 if (typeof valueOrMarker === "string") {
				if (mode === 2) {
				  if (valueOrMarker !== "") {
					 attrs.push(valueOrMarker, selector[++i]);
				  }
				} else if (mode === 8) {
				  classes.push(valueOrMarker);
				}
			 } else {
				if (!isPositive(mode))
				  break;
				mode = valueOrMarker;
			 }
			 i++;
		  }
		  return { attrs, classes };
		}
		function \u0275\u0275defineComponent(componentDefinition) {
		  return noSideEffects(() => {
			 (typeof ngDevMode === "undefined" || ngDevMode) && initNgDevMode();
			 const baseDef = getNgDirectiveDef(componentDefinition);
			 const def = __spreadProps(__spreadValues({}, baseDef), {
				decls: componentDefinition.decls,
				vars: componentDefinition.vars,
				template: componentDefinition.template,
				consts: componentDefinition.consts || null,
				ngContentSelectors: componentDefinition.ngContentSelectors,
				onPush: componentDefinition.changeDetection === ChangeDetectionStrategy.OnPush,
				directiveDefs: null,
				// assigned in noSideEffects
				pipeDefs: null,
				// assigned in noSideEffects
				dependencies: baseDef.standalone && componentDefinition.dependencies || null,
				getStandaloneInjector: null,
				signals: componentDefinition.signals ?? false,
				data: componentDefinition.data || {},
				encapsulation: componentDefinition.encapsulation || ViewEncapsulation$1.Emulated,
				styles: componentDefinition.styles || EMPTY_ARRAY,
				_: null,
				schemas: componentDefinition.schemas || null,
				tView: null,
				id: ""
			 });
			 initFeatures(def);
			 const dependencies = componentDefinition.dependencies;
			 def.directiveDefs = extractDefListOrFactory(
				dependencies,
				/* pipeDef */
				false
			 );
			 def.pipeDefs = extractDefListOrFactory(
				dependencies,
				/* pipeDef */
				true
			 );
			 def.id = getComponentId(def);
			 return def;
		  });
		}
		function extractDirectiveDef(type2) {
		  return getComponentDef(type2) || getDirectiveDef(type2);
		}
		function nonNull(value) {
		  return value !== null;
		}
		function \u0275\u0275defineNgModule(def) {
		  return noSideEffects(() => {
			 const res = {
				type: def.type,
				bootstrap: def.bootstrap || EMPTY_ARRAY,
				declarations: def.declarations || EMPTY_ARRAY,
				imports: def.imports || EMPTY_ARRAY,
				exports: def.exports || EMPTY_ARRAY,
				transitiveCompileScopes: null,
				schemas: def.schemas || null,
				id: def.id || null
			 };
			 return res;
		  });
		}
		function parseAndConvertBindingsForDefinition(obj, declaredInputs) {
		  if (obj == null)
			 return EMPTY_OBJ;
		  const newLookup = {};
		  for (const minifiedKey in obj) {
			 if (obj.hasOwnProperty(minifiedKey)) {
				const value = obj[minifiedKey];
				let publicName;
				let declaredName;
				let inputFlags = InputFlags.None;
				if (Array.isArray(value)) {
				  inputFlags = value[0];
				  publicName = value[1];
				  declaredName = value[2] ?? publicName;
				} else {
				  publicName = value;
				  declaredName = value;
				}
				if (declaredInputs) {
				  newLookup[publicName] = inputFlags !== InputFlags.None ? [minifiedKey, inputFlags] : minifiedKey;
				  declaredInputs[publicName] = declaredName;
				} else {
				  newLookup[publicName] = minifiedKey;
				}
			 }
		  }
		  return newLookup;
		}
		function \u0275\u0275defineDirective(directiveDefinition) {
		  return noSideEffects(() => {
			 const def = getNgDirectiveDef(directiveDefinition);
			 initFeatures(def);
			 return def;
		  });
		}
		function \u0275\u0275definePipe(pipeDef) {
		  return {
			 type: pipeDef.type,
			 name: pipeDef.name,
			 factory: null,
			 pure: pipeDef.pure !== false,
			 standalone: pipeDef.standalone === true,
			 onDestroy: pipeDef.type.prototype.ngOnDestroy || null
		  };
		}
		function getComponentDef(type2) {
		  return type2[NG_COMP_DEF] || null;
		}
		function getDirectiveDef(type2) {
		  return type2[NG_DIR_DEF] || null;
		}
		function getPipeDef$1(type2) {
		  return type2[NG_PIPE_DEF] || null;
		}
		function isStandalone(type2) {
		  const def = getComponentDef(type2) || getDirectiveDef(type2) || getPipeDef$1(type2);
		  return def !== null ? def.standalone : false;
		}
		function getNgModuleDef(type2, throwNotFound) {
		  const ngModuleDef = type2[NG_MOD_DEF] || null;
		  if (!ngModuleDef && throwNotFound === true) {
			 throw new Error(`Type ${stringify(type2)} does not have '\u0275mod' property.`);
		  }
		  return ngModuleDef;
		}
		function getNgDirectiveDef(directiveDefinition) {
		  const declaredInputs = {};
		  return {
			 type: directiveDefinition.type,
			 providersResolver: null,
			 factory: null,
			 hostBindings: directiveDefinition.hostBindings || null,
			 hostVars: directiveDefinition.hostVars || 0,
			 hostAttrs: directiveDefinition.hostAttrs || null,
			 contentQueries: directiveDefinition.contentQueries || null,
			 declaredInputs,
			 inputTransforms: null,
			 inputConfig: directiveDefinition.inputs || EMPTY_OBJ,
			 exportAs: directiveDefinition.exportAs || null,
			 standalone: directiveDefinition.standalone === true,
			 signals: directiveDefinition.signals === true,
			 selectors: directiveDefinition.selectors || EMPTY_ARRAY,
			 viewQuery: directiveDefinition.viewQuery || null,
			 features: directiveDefinition.features || null,
			 setInput: null,
			 findHostDirectiveDefs: null,
			 hostDirectives: null,
			 inputs: parseAndConvertBindingsForDefinition(directiveDefinition.inputs, declaredInputs),
			 outputs: parseAndConvertBindingsForDefinition(directiveDefinition.outputs),
			 debugInfo: null
		  };
		}
		function initFeatures(definition) {
		  definition.features?.forEach((fn) => fn(definition));
		}
		function extractDefListOrFactory(dependencies, pipeDef) {
		  if (!dependencies) {
			 return null;
		  }
		  const defExtractor = pipeDef ? getPipeDef$1 : extractDirectiveDef;
		  return () => (typeof dependencies === "function" ? dependencies() : dependencies).map((dep) => defExtractor(dep)).filter(nonNull);
		}
		var GENERATED_COMP_IDS = /* @__PURE__ */ new Map();
		function getComponentId(componentDef) {
		  let hash = 0;
		  const hashSelectors = [
			 componentDef.selectors,
			 componentDef.ngContentSelectors,
			 componentDef.hostVars,
			 componentDef.hostAttrs,
			 componentDef.consts,
			 componentDef.vars,
			 componentDef.decls,
			 componentDef.encapsulation,
			 componentDef.standalone,
			 componentDef.signals,
			 componentDef.exportAs,
			 JSON.stringify(componentDef.inputs),
			 JSON.stringify(componentDef.outputs),
			 // We cannot use 'componentDef.type.name' as the name of the symbol will change and will not
			 // match in the server and browser bundles.
			 Object.getOwnPropertyNames(componentDef.type.prototype),
			 !!componentDef.contentQueries,
			 !!componentDef.viewQuery
		  ].join("|");
		  for (const char of hashSelectors) {
			 hash = Math.imul(31, hash) + char.charCodeAt(0) << 0;
		  }
		  hash += 2147483647 + 1;
		  const compId = "c" + hash;
		  if (typeof ngDevMode === "undefined" || ngDevMode) {
			 if (GENERATED_COMP_IDS.has(compId)) {
				const previousCompDefType = GENERATED_COMP_IDS.get(compId);
				if (previousCompDefType !== componentDef.type) {
				  console.warn(formatRuntimeError(-912, `Component ID generation collision detected. Components '${previousCompDefType.name}' and '${componentDef.type.name}' with selector '${stringifyCSSSelectorList(componentDef.selectors)}' generated the same component ID. To fix this, you can change the selector of one of those components or add an extra host attribute to force a different ID.`));
				}
			 } else {
				GENERATED_COMP_IDS.set(compId, componentDef.type);
			 }
		  }
		  return compId;
		}
		function makeEnvironmentProviders(providers) {
		  return {
			 \u0275providers: providers
		  };
		}
		function importProvidersFrom(...sources) {
		  return {
			 \u0275providers: internalImportProvidersFrom(true, sources),
			 \u0275fromNgModule: true
		  };
		}
		function internalImportProvidersFrom(checkForStandaloneCmp, ...sources) {
		  const providersOut = [];
		  const dedup = /* @__PURE__ */ new Set();
		  let injectorTypesWithProviders;
		  const collectProviders = (provider) => {
			 providersOut.push(provider);
		  };
		  deepForEach(sources, (source) => {
			 if ((typeof ngDevMode === "undefined" || ngDevMode) && checkForStandaloneCmp) {
				const cmpDef = getComponentDef(source);
				if (cmpDef?.standalone) {
				  throw new RuntimeError(800, `Importing providers supports NgModule or ModuleWithProviders but got a standalone component "${stringifyForError(source)}"`);
				}
			 }
			 const internalSource = source;
			 if (walkProviderTree(internalSource, collectProviders, [], dedup)) {
				injectorTypesWithProviders ||= [];
				injectorTypesWithProviders.push(internalSource);
			 }
		  });
		  if (injectorTypesWithProviders !== void 0) {
			 processInjectorTypesWithProviders(injectorTypesWithProviders, collectProviders);
		  }
		  return providersOut;
		}
		function processInjectorTypesWithProviders(typesWithProviders, visitor) {
		  for (let i = 0; i < typesWithProviders.length; i++) {
			 const { ngModule, providers } = typesWithProviders[i];
			 deepForEachProvider(providers, (provider) => {
				ngDevMode && validateProvider(provider, providers || EMPTY_ARRAY, ngModule);
				visitor(provider, ngModule);
			 });
		  }
		}
		function walkProviderTree(container, visitor, parents, dedup) {
		  container = resolveForwardRef(container);
		  if (!container)
			 return false;
		  let defType = null;
		  let injDef = getInjectorDef(container);
		  const cmpDef = !injDef && getComponentDef(container);
		  if (!injDef && !cmpDef) {
			 const ngModule = container.ngModule;
			 injDef = getInjectorDef(ngModule);
			 if (injDef) {
				defType = ngModule;
			 } else {
				return false;
			 }
		  } else if (cmpDef && !cmpDef.standalone) {
			 return false;
		  } else {
			 defType = container;
		  }
		  if (ngDevMode && parents.indexOf(defType) !== -1) {
			 const defName = stringify(defType);
			 const path = parents.map(stringify);
			 throwCyclicDependencyError(defName, path);
		  }
		  const isDuplicate = dedup.has(defType);
		  if (cmpDef) {
			 if (isDuplicate) {
				return false;
			 }
			 dedup.add(defType);
			 if (cmpDef.dependencies) {
				const deps = typeof cmpDef.dependencies === "function" ? cmpDef.dependencies() : cmpDef.dependencies;
				for (const dep of deps) {
				  walkProviderTree(dep, visitor, parents, dedup);
				}
			 }
		  } else if (injDef) {
			 if (injDef.imports != null && !isDuplicate) {
				ngDevMode && parents.push(defType);
				dedup.add(defType);
				let importTypesWithProviders;
				try {
				  deepForEach(injDef.imports, (imported) => {
					 if (walkProviderTree(imported, visitor, parents, dedup)) {
						importTypesWithProviders ||= [];
						importTypesWithProviders.push(imported);
					 }
				  });
				} finally {
				  ngDevMode && parents.pop();
				}
				if (importTypesWithProviders !== void 0) {
				  processInjectorTypesWithProviders(importTypesWithProviders, visitor);
				}
			 }
			 if (!isDuplicate) {
				const factory = getFactoryDef(defType) || (() => new defType());
				visitor({ provide: defType, useFactory: factory, deps: EMPTY_ARRAY }, defType);
				visitor({ provide: INJECTOR_DEF_TYPES, useValue: defType, multi: true }, defType);
				visitor({ provide: ENVIRONMENT_INITIALIZER, useValue: () => \u0275\u0275inject(defType), multi: true }, defType);
			 }
			 const defProviders = injDef.providers;
			 if (defProviders != null && !isDuplicate) {
				const injectorType = container;
				deepForEachProvider(defProviders, (provider) => {
				  ngDevMode && validateProvider(provider, defProviders, injectorType);
				  visitor(provider, injectorType);
				});
			 }
		  } else {
			 return false;
		  }
		  return defType !== container && container.providers !== void 0;
		}
		function validateProvider(provider, providers, containerType) {
		  if (isTypeProvider(provider) || isValueProvider(provider) || isFactoryProvider(provider) || isExistingProvider(provider)) {
			 return;
		  }
		  const classRef = resolveForwardRef(provider && (provider.useClass || provider.provide));
		  if (!classRef) {
			 throwInvalidProviderError(containerType, providers, provider);
		  }
		}
		function deepForEachProvider(providers, fn) {
		  for (let provider of providers) {
			 if (isEnvironmentProviders(provider)) {
				provider = provider.\u0275providers;
			 }
			 if (Array.isArray(provider)) {
				deepForEachProvider(provider, fn);
			 } else {
				fn(provider);
			 }
		  }
		}
		var USE_VALUE$1 = getClosureSafeProperty({ provide: String, useValue: getClosureSafeProperty });
		function isValueProvider(value) {
		  return value !== null && typeof value == "object" && USE_VALUE$1 in value;
		}
		function isExistingProvider(value) {
		  return !!(value && value.useExisting);
		}
		function isFactoryProvider(value) {
		  return !!(value && value.useFactory);
		}
		function isTypeProvider(value) {
		  return typeof value === "function";
		}
		function isClassProvider(value) {
		  return !!value.useClass;
		}
		var INJECTOR_SCOPE = new InjectionToken(ngDevMode ? "Set Injector scope." : "");
		var NOT_YET = {};
		var CIRCULAR = {};
		var NULL_INJECTOR = void 0;
		function getNullInjector() {
		  if (NULL_INJECTOR === void 0) {
			 NULL_INJECTOR = new NullInjector();
		  }
		  return NULL_INJECTOR;
		}
		var EnvironmentInjector = class {
		};
		var R3Injector = class extends EnvironmentInjector {
		  /**
			* Flag indicating that this injector was previously destroyed.
			*/
		  get destroyed() {
			 return this._destroyed;
		  }
		  constructor(providers, parent, source, scopes) {
			 super();
			 this.parent = parent;
			 this.source = source;
			 this.scopes = scopes;
			 this.records = /* @__PURE__ */ new Map();
			 this._ngOnDestroyHooks = /* @__PURE__ */ new Set();
			 this._onDestroyHooks = [];
			 this._destroyed = false;
			 forEachSingleProvider(providers, (provider) => this.processProvider(provider));
			 this.records.set(INJECTOR$1, makeRecord(void 0, this));
			 if (scopes.has("environment")) {
				this.records.set(EnvironmentInjector, makeRecord(void 0, this));
			 }
			 const record = this.records.get(INJECTOR_SCOPE);
			 if (record != null && typeof record.value === "string") {
				this.scopes.add(record.value);
			 }
			 this.injectorDefTypes = new Set(this.get(INJECTOR_DEF_TYPES, EMPTY_ARRAY, InjectFlags.Self));
		  }
		  /**
			* Destroy the injector and release references to every instance or provider associated with it.
			*
			* Also calls the `OnDestroy` lifecycle hooks of every instance that was created for which a
			* hook was found.
			*/
		  destroy() {
			 this.assertNotDestroyed();
			 this._destroyed = true;
			 const prevConsumer = setActiveConsumer(null);
			 try {
				for (const service of this._ngOnDestroyHooks) {
				  service.ngOnDestroy();
				}
				const onDestroyHooks = this._onDestroyHooks;
				this._onDestroyHooks = [];
				for (const hook of onDestroyHooks) {
				  hook();
				}
			 } finally {
				this.records.clear();
				this._ngOnDestroyHooks.clear();
				this.injectorDefTypes.clear();
				setActiveConsumer(prevConsumer);
			 }
		  }
		  onDestroy(callback) {
			 this.assertNotDestroyed();
			 this._onDestroyHooks.push(callback);
			 return () => this.removeOnDestroy(callback);
		  }
		  runInContext(fn) {
			 this.assertNotDestroyed();
			 const previousInjector = setCurrentInjector(this);
			 const previousInjectImplementation = setInjectImplementation(void 0);
			 let prevInjectContext;
			 if (ngDevMode) {
				prevInjectContext = setInjectorProfilerContext({ injector: this, token: null });
			 }
			 try {
				return fn();
			 } finally {
				setCurrentInjector(previousInjector);
				setInjectImplementation(previousInjectImplementation);
				ngDevMode && setInjectorProfilerContext(prevInjectContext);
			 }
		  }
		  get(token, notFoundValue = THROW_IF_NOT_FOUND, flags = InjectFlags.Default) {
			 this.assertNotDestroyed();
			 if (token.hasOwnProperty(NG_ENV_ID)) {
				return token[NG_ENV_ID](this);
			 }
			 flags = convertToBitFlags(flags);
			 let prevInjectContext;
			 if (ngDevMode) {
				prevInjectContext = setInjectorProfilerContext({ injector: this, token });
			 }
			 const previousInjector = setCurrentInjector(this);
			 const previousInjectImplementation = setInjectImplementation(void 0);
			 try {
				if (!(flags & InjectFlags.SkipSelf)) {
				  let record = this.records.get(token);
				  if (record === void 0) {
					 const def = couldBeInjectableType(token) && getInjectableDef(token);
					 if (def && this.injectableDefInScope(def)) {
						if (ngDevMode) {
						  runInInjectorProfilerContext(this, token, () => {
							 emitProviderConfiguredEvent(token);
						  });
						}
						record = makeRecord(injectableDefOrInjectorDefFactory(token), NOT_YET);
					 } else {
						record = null;
					 }
					 this.records.set(token, record);
				  }
				  if (record != null) {
					 return this.hydrate(token, record);
				  }
				}
				const nextInjector = !(flags & InjectFlags.Self) ? this.parent : getNullInjector();
				notFoundValue = flags & InjectFlags.Optional && notFoundValue === THROW_IF_NOT_FOUND ? null : notFoundValue;
				return nextInjector.get(token, notFoundValue);
			 } catch (e) {
				if (e.name === "NullInjectorError") {
				  const path = e[NG_TEMP_TOKEN_PATH] = e[NG_TEMP_TOKEN_PATH] || [];
				  path.unshift(stringify(token));
				  if (previousInjector) {
					 throw e;
				  } else {
					 return catchInjectorError(e, token, "R3InjectorError", this.source);
				  }
				} else {
				  throw e;
				}
			 } finally {
				setInjectImplementation(previousInjectImplementation);
				setCurrentInjector(previousInjector);
				ngDevMode && setInjectorProfilerContext(prevInjectContext);
			 }
		  }
		  /** @internal */
		  resolveInjectorInitializers() {
			 const prevConsumer = setActiveConsumer(null);
			 const previousInjector = setCurrentInjector(this);
			 const previousInjectImplementation = setInjectImplementation(void 0);
			 let prevInjectContext;
			 if (ngDevMode) {
				prevInjectContext = setInjectorProfilerContext({ injector: this, token: null });
			 }
			 try {
				const initializers = this.get(ENVIRONMENT_INITIALIZER, EMPTY_ARRAY, InjectFlags.Self);
				if (ngDevMode && !Array.isArray(initializers)) {
				  throw new RuntimeError(-209, `Unexpected type of the \`ENVIRONMENT_INITIALIZER\` token value (expected an array, but got ${typeof initializers}). Please check that the \`ENVIRONMENT_INITIALIZER\` token is configured as a \`multi: true\` provider.`);
				}
				for (const initializer of initializers) {
				  initializer();
				}
			 } finally {
				setCurrentInjector(previousInjector);
				setInjectImplementation(previousInjectImplementation);
				ngDevMode && setInjectorProfilerContext(prevInjectContext);
				setActiveConsumer(prevConsumer);
			 }
		  }
		  toString() {
			 const tokens = [];
			 const records = this.records;
			 for (const token of records.keys()) {
				tokens.push(stringify(token));
			 }
			 return `R3Injector[${tokens.join(", ")}]`;
		  }
		  assertNotDestroyed() {
			 if (this._destroyed) {
				throw new RuntimeError(205, ngDevMode && "Injector has already been destroyed.");
			 }
		  }
		  /**
			* Process a `SingleProvider` and add it.
			*/
		  processProvider(provider) {
			 provider = resolveForwardRef(provider);
			 let token = isTypeProvider(provider) ? provider : resolveForwardRef(provider && provider.provide);
			 const record = providerToRecord(provider);
			 if (ngDevMode) {
				runInInjectorProfilerContext(this, token, () => {
				  if (isValueProvider(provider)) {
					 emitInstanceCreatedByInjectorEvent(provider.useValue);
				  }
				  emitProviderConfiguredEvent(provider);
				});
			 }
			 if (!isTypeProvider(provider) && provider.multi === true) {
				let multiRecord = this.records.get(token);
				if (multiRecord) {
				  if (ngDevMode && multiRecord.multi === void 0) {
					 throwMixedMultiProviderError();
				  }
				} else {
				  multiRecord = makeRecord(void 0, NOT_YET, true);
				  multiRecord.factory = () => injectArgs(multiRecord.multi);
				  this.records.set(token, multiRecord);
				}
				token = provider;
				multiRecord.multi.push(provider);
			 } else {
				if (ngDevMode) {
				  const existing = this.records.get(token);
				  if (existing && existing.multi !== void 0) {
					 throwMixedMultiProviderError();
				  }
				}
			 }
			 this.records.set(token, record);
		  }
		  hydrate(token, record) {
			 const prevConsumer = setActiveConsumer(null);
			 try {
				if (ngDevMode && record.value === CIRCULAR) {
				  throwCyclicDependencyError(stringify(token));
				} else if (record.value === NOT_YET) {
				  record.value = CIRCULAR;
				  if (ngDevMode) {
					 runInInjectorProfilerContext(this, token, () => {
						record.value = record.factory();
						emitInstanceCreatedByInjectorEvent(record.value);
					 });
				  } else {
					 record.value = record.factory();
				  }
				}
				if (typeof record.value === "object" && record.value && hasOnDestroy(record.value)) {
				  this._ngOnDestroyHooks.add(record.value);
				}
				return record.value;
			 } finally {
				setActiveConsumer(prevConsumer);
			 }
		  }
		  injectableDefInScope(def) {
			 if (!def.providedIn) {
				return false;
			 }
			 const providedIn = resolveForwardRef(def.providedIn);
			 if (typeof providedIn === "string") {
				return providedIn === "any" || this.scopes.has(providedIn);
			 } else {
				return this.injectorDefTypes.has(providedIn);
			 }
		  }
		  removeOnDestroy(callback) {
			 const destroyCBIdx = this._onDestroyHooks.indexOf(callback);
			 if (destroyCBIdx !== -1) {
				this._onDestroyHooks.splice(destroyCBIdx, 1);
			 }
		  }
		};
		function injectableDefOrInjectorDefFactory(token) {
		  const injectableDef = getInjectableDef(token);
		  const factory = injectableDef !== null ? injectableDef.factory : getFactoryDef(token);
		  if (factory !== null) {
			 return factory;
		  }
		  if (token instanceof InjectionToken) {
			 throw new RuntimeError(204, ngDevMode && `Token ${stringify(token)} is missing a \u0275prov definition.`);
		  }
		  if (token instanceof Function) {
			 return getUndecoratedInjectableFactory(token);
		  }
		  throw new RuntimeError(204, ngDevMode && "unreachable");
		}
		function getUndecoratedInjectableFactory(token) {
		  const paramLength = token.length;
		  if (paramLength > 0) {
			 throw new RuntimeError(204, ngDevMode && `Can't resolve all parameters for ${stringify(token)}: (${newArray(paramLength, "?").join(", ")}).`);
		  }
		  const inheritedInjectableDef = getInheritedInjectableDef(token);
		  if (inheritedInjectableDef !== null) {
			 return () => inheritedInjectableDef.factory(token);
		  } else {
			 return () => new token();
		  }
		}
		function providerToRecord(provider) {
		  if (isValueProvider(provider)) {
			 return makeRecord(void 0, provider.useValue);
		  } else {
			 const factory = providerToFactory(provider);
			 return makeRecord(factory, NOT_YET);
		  }
		}
		function providerToFactory(provider, ngModuleType, providers) {
		  let factory = void 0;
		  if (ngDevMode && isEnvironmentProviders(provider)) {
			 throwInvalidProviderError(void 0, providers, provider);
		  }
		  if (isTypeProvider(provider)) {
			 const unwrappedProvider = resolveForwardRef(provider);
			 return getFactoryDef(unwrappedProvider) || injectableDefOrInjectorDefFactory(unwrappedProvider);
		  } else {
			 if (isValueProvider(provider)) {
				factory = () => resolveForwardRef(provider.useValue);
			 } else if (isFactoryProvider(provider)) {
				factory = () => provider.useFactory(...injectArgs(provider.deps || []));
			 } else if (isExistingProvider(provider)) {
				factory = () => \u0275\u0275inject(resolveForwardRef(provider.useExisting));
			 } else {
				const classRef = resolveForwardRef(provider && (provider.useClass || provider.provide));
				if (ngDevMode && !classRef) {
				  throwInvalidProviderError(ngModuleType, providers, provider);
				}
				if (hasDeps(provider)) {
				  factory = () => new classRef(...injectArgs(provider.deps));
				} else {
				  return getFactoryDef(classRef) || injectableDefOrInjectorDefFactory(classRef);
				}
			 }
		  }
		  return factory;
		}
		function makeRecord(factory, value, multi = false) {
		  return {
			 factory,
			 value,
			 multi: multi ? [] : void 0
		  };
		}
		function hasDeps(value) {
		  return !!value.deps;
		}
		function hasOnDestroy(value) {
		  return value !== null && typeof value === "object" && typeof value.ngOnDestroy === "function";
		}
		function couldBeInjectableType(value) {
		  return typeof value === "function" || typeof value === "object" && value instanceof InjectionToken;
		}
		function forEachSingleProvider(providers, fn) {
		  for (const provider of providers) {
			 if (Array.isArray(provider)) {
				forEachSingleProvider(provider, fn);
			 } else if (provider && isEnvironmentProviders(provider)) {
				forEachSingleProvider(provider.\u0275providers, fn);
			 } else {
				fn(provider);
			 }
		  }
		}
		function isInInjectionContext() {
		  return getInjectImplementation() !== void 0 || getCurrentInjector() != null;
		}
		function assertInInjectionContext(debugFn) {
		  if (!isInInjectionContext()) {
			 throw new RuntimeError(-203, ngDevMode && debugFn.name + "() can only be used within an injection context such as a constructor, a factory function, a field initializer, or a function used with `runInInjectionContext`");
		  }
		}
		var FactoryTarget;
		(function(FactoryTarget2) {
		  FactoryTarget2[FactoryTarget2["Directive"] = 0] = "Directive";
		  FactoryTarget2[FactoryTarget2["Component"] = 1] = "Component";
		  FactoryTarget2[FactoryTarget2["Injectable"] = 2] = "Injectable";
		  FactoryTarget2[FactoryTarget2["Pipe"] = 3] = "Pipe";
		  FactoryTarget2[FactoryTarget2["NgModule"] = 4] = "NgModule";
		})(FactoryTarget || (FactoryTarget = {}));
		var R3TemplateDependencyKind;
		(function(R3TemplateDependencyKind2) {
		  R3TemplateDependencyKind2[R3TemplateDependencyKind2["Directive"] = 0] = "Directive";
		  R3TemplateDependencyKind2[R3TemplateDependencyKind2["Pipe"] = 1] = "Pipe";
		  R3TemplateDependencyKind2[R3TemplateDependencyKind2["NgModule"] = 2] = "NgModule";
		})(R3TemplateDependencyKind || (R3TemplateDependencyKind = {}));
		var ViewEncapsulation;
		(function(ViewEncapsulation2) {
		  ViewEncapsulation2[ViewEncapsulation2["Emulated"] = 0] = "Emulated";
		  ViewEncapsulation2[ViewEncapsulation2["None"] = 2] = "None";
		  ViewEncapsulation2[ViewEncapsulation2["ShadowDom"] = 3] = "ShadowDom";
		})(ViewEncapsulation || (ViewEncapsulation = {}));
		function getCompilerFacade(request) {
		  const globalNg = _global["ng"];
		  if (globalNg && globalNg.\u0275compilerFacade) {
			 return globalNg.\u0275compilerFacade;
		  }
		  if (typeof ngDevMode === "undefined" || ngDevMode) {
			 console.error(`JIT compilation failed for ${request.kind}`, request.type);
			 let message2 = `The ${request.kind} '${request.type.name}' needs to be compiled using the JIT compiler, but '@angular/compiler' is not available.

		`;
			 if (request.usage === 1) {
				message2 += `The ${request.kind} is part of a library that has been partially compiled.
		`;
				message2 += `However, the Angular Linker has not processed the library such that JIT compilation is used as fallback.
		`;
				message2 += "\n";
				message2 += `Ideally, the library is processed using the Angular Linker to become fully AOT compiled.
		`;
			 } else {
				message2 += `JIT compilation is discouraged for production use-cases! Consider using AOT mode instead.
		`;
			 }
			 message2 += `Alternatively, the JIT compiler should be loaded by bootstrapping using '@angular/platform-browser-dynamic' or '@angular/platform-server',
		`;
			 message2 += `or manually provide the compiler with 'import "@angular/compiler";' before bootstrapping.`;
			 throw new Error(message2);
		  } else {
			 throw new Error("JIT compiler unavailable");
		  }
		}
		var angularCoreDiEnv = {
		  "\u0275\u0275defineInjectable": \u0275\u0275defineInjectable,
		  "\u0275\u0275defineInjector": \u0275\u0275defineInjector,
		  "\u0275\u0275inject": \u0275\u0275inject,
		  "\u0275\u0275invalidFactoryDep": \u0275\u0275invalidFactoryDep,
		  "resolveForwardRef": resolveForwardRef
		};
		var Type = Function;
		function isType(v) {
		  return typeof v === "function";
		}
		var ES5_DELEGATE_CTOR = /^function\s+\S+\(\)\s*{[\s\S]+\.apply\(this,\s*(arguments|(?:[^()]+\(\[\],)?[^()]+\(arguments\).*)\)/;
		var ES2015_INHERITED_CLASS = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{/;
		var ES2015_INHERITED_CLASS_WITH_CTOR = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{[\s\S]*constructor\s*\(/;
		var ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{[\s\S]*constructor\s*\(\)\s*{[^}]*super\(\.\.\.arguments\)/;
		function isDelegateCtor(typeStr) {
		  return ES5_DELEGATE_CTOR.test(typeStr) || ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR.test(typeStr) || ES2015_INHERITED_CLASS.test(typeStr) && !ES2015_INHERITED_CLASS_WITH_CTOR.test(typeStr);
		}
		var ReflectionCapabilities = class {
		  constructor(reflect) {
			 this._reflect = reflect || _global["Reflect"];
		  }
		  factory(t) {
			 return (...args) => new t(...args);
		  }
		  /** @internal */
		  _zipTypesAndAnnotations(paramTypes, paramAnnotations) {
			 let result;
			 if (typeof paramTypes === "undefined") {
				result = newArray(paramAnnotations.length);
			 } else {
				result = newArray(paramTypes.length);
			 }
			 for (let i = 0; i < result.length; i++) {
				if (typeof paramTypes === "undefined") {
				  result[i] = [];
				} else if (paramTypes[i] && paramTypes[i] != Object) {
				  result[i] = [paramTypes[i]];
				} else {
				  result[i] = [];
				}
				if (paramAnnotations && paramAnnotations[i] != null) {
				  result[i] = result[i].concat(paramAnnotations[i]);
				}
			 }
			 return result;
		  }
		  _ownParameters(type2, parentCtor) {
			 const typeStr = type2.toString();
			 if (isDelegateCtor(typeStr)) {
				return null;
			 }
			 if (type2.parameters && type2.parameters !== parentCtor.parameters) {
				return type2.parameters;
			 }
			 const tsickleCtorParams = type2.ctorParameters;
			 if (tsickleCtorParams && tsickleCtorParams !== parentCtor.ctorParameters) {
				const ctorParameters = typeof tsickleCtorParams === "function" ? tsickleCtorParams() : tsickleCtorParams;
				const paramTypes2 = ctorParameters.map((ctorParam) => ctorParam && ctorParam.type);
				const paramAnnotations2 = ctorParameters.map((ctorParam) => ctorParam && convertTsickleDecoratorIntoMetadata(ctorParam.decorators));
				return this._zipTypesAndAnnotations(paramTypes2, paramAnnotations2);
			 }
			 const paramAnnotations = type2.hasOwnProperty(PARAMETERS) && type2[PARAMETERS];
			 const paramTypes = this._reflect && this._reflect.getOwnMetadata && this._reflect.getOwnMetadata("design:paramtypes", type2);
			 if (paramTypes || paramAnnotations) {
				return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);
			 }
			 return newArray(type2.length);
		  }
		  parameters(type2) {
			 if (!isType(type2)) {
				return [];
			 }
			 const parentCtor = getParentCtor(type2);
			 let parameters = this._ownParameters(type2, parentCtor);
			 if (!parameters && parentCtor !== Object) {
				parameters = this.parameters(parentCtor);
			 }
			 return parameters || [];
		  }
		  _ownAnnotations(typeOrFunc, parentCtor) {
			 if (typeOrFunc.annotations && typeOrFunc.annotations !== parentCtor.annotations) {
				let annotations = typeOrFunc.annotations;
				if (typeof annotations === "function" && annotations.annotations) {
				  annotations = annotations.annotations;
				}
				return annotations;
			 }
			 if (typeOrFunc.decorators && typeOrFunc.decorators !== parentCtor.decorators) {
				return convertTsickleDecoratorIntoMetadata(typeOrFunc.decorators);
			 }
			 if (typeOrFunc.hasOwnProperty(ANNOTATIONS)) {
				return typeOrFunc[ANNOTATIONS];
			 }
			 return null;
		  }
		  annotations(typeOrFunc) {
			 if (!isType(typeOrFunc)) {
				return [];
			 }
			 const parentCtor = getParentCtor(typeOrFunc);
			 const ownAnnotations = this._ownAnnotations(typeOrFunc, parentCtor) || [];
			 const parentAnnotations = parentCtor !== Object ? this.annotations(parentCtor) : [];
			 return parentAnnotations.concat(ownAnnotations);
		  }
		  _ownPropMetadata(typeOrFunc, parentCtor) {
			 if (typeOrFunc.propMetadata && typeOrFunc.propMetadata !== parentCtor.propMetadata) {
				let propMetadata = typeOrFunc.propMetadata;
				if (typeof propMetadata === "function" && propMetadata.propMetadata) {
				  propMetadata = propMetadata.propMetadata;
				}
				return propMetadata;
			 }
			 if (typeOrFunc.propDecorators && typeOrFunc.propDecorators !== parentCtor.propDecorators) {
				const propDecorators = typeOrFunc.propDecorators;
				const propMetadata = {};
				Object.keys(propDecorators).forEach((prop) => {
				  propMetadata[prop] = convertTsickleDecoratorIntoMetadata(propDecorators[prop]);
				});
				return propMetadata;
			 }
			 if (typeOrFunc.hasOwnProperty(PROP_METADATA)) {
				return typeOrFunc[PROP_METADATA];
			 }
			 return null;
		  }
		  propMetadata(typeOrFunc) {
			 if (!isType(typeOrFunc)) {
				return {};
			 }
			 const parentCtor = getParentCtor(typeOrFunc);
			 const propMetadata = {};
			 if (parentCtor !== Object) {
				const parentPropMetadata = this.propMetadata(parentCtor);
				Object.keys(parentPropMetadata).forEach((propName) => {
				  propMetadata[propName] = parentPropMetadata[propName];
				});
			 }
			 const ownPropMetadata = this._ownPropMetadata(typeOrFunc, parentCtor);
			 if (ownPropMetadata) {
				Object.keys(ownPropMetadata).forEach((propName) => {
				  const decorators = [];
				  if (propMetadata.hasOwnProperty(propName)) {
					 decorators.push(...propMetadata[propName]);
				  }
				  decorators.push(...ownPropMetadata[propName]);
				  propMetadata[propName] = decorators;
				});
			 }
			 return propMetadata;
		  }
		  ownPropMetadata(typeOrFunc) {
			 if (!isType(typeOrFunc)) {
				return {};
			 }
			 return this._ownPropMetadata(typeOrFunc, getParentCtor(typeOrFunc)) || {};
		  }
		  hasLifecycleHook(type2, lcProperty) {
			 return type2 instanceof Type && lcProperty in type2.prototype;
		  }
		};
		function convertTsickleDecoratorIntoMetadata(decoratorInvocations) {
		  if (!decoratorInvocations) {
			 return [];
		  }
		  return decoratorInvocations.map((decoratorInvocation) => {
			 const decoratorType = decoratorInvocation.type;
			 const annotationCls = decoratorType.annotationCls;
			 const annotationArgs = decoratorInvocation.args ? decoratorInvocation.args : [];
			 return new annotationCls(...annotationArgs);
		  });
		}
		function getParentCtor(ctor) {
		  const parentProto = ctor.prototype ? Object.getPrototypeOf(ctor.prototype) : null;
		  const parentCtor = parentProto ? parentProto.constructor : null;
		  return parentCtor || Object;
		}
		var HOST = 0;
		var TVIEW = 1;
		var FLAGS = 2;
		var PARENT = 3;
		var NEXT = 4;
		var T_HOST = 5;
		var HYDRATION = 6;
		var CLEANUP = 7;
		var CONTEXT = 8;
		var INJECTOR = 9;
		var ENVIRONMENT = 10;
		var RENDERER = 11;
		var CHILD_HEAD = 12;
		var CHILD_TAIL = 13;
		var DECLARATION_VIEW = 14;
		var DECLARATION_COMPONENT_VIEW = 15;
		var DECLARATION_LCONTAINER = 16;
		var PREORDER_HOOK_FLAGS = 17;
		var QUERIES = 18;
		var ID = 19;
		var EMBEDDED_VIEW_INJECTOR = 20;
		var ON_DESTROY_HOOKS = 21;
		var EFFECTS_TO_SCHEDULE = 22;
		var REACTIVE_TEMPLATE_CONSUMER = 23;
		var HEADER_OFFSET = 25;
		var TYPE = 1;
		var NATIVE = 7;
		var VIEW_REFS = 8;
		var MOVED_VIEWS = 9;
		var CONTAINER_HEADER_OFFSET = 10;
		var LContainerFlags;
		(function(LContainerFlags2) {
		  LContainerFlags2[LContainerFlags2["None"] = 0] = "None";
		  LContainerFlags2[LContainerFlags2["HasTransplantedViews"] = 2] = "HasTransplantedViews";
		})(LContainerFlags || (LContainerFlags = {}));
		function isLView(value) {
		  return Array.isArray(value) && typeof value[TYPE] === "object";
		}
		function isLContainer(value) {
		  return Array.isArray(value) && value[TYPE] === true;
		}
		function isContentQueryHost(tNode) {
		  return (tNode.flags & 4) !== 0;
		}
		function isComponentHost(tNode) {
		  return tNode.componentOffset > -1;
		}
		function isDirectiveHost(tNode) {
		  return (tNode.flags & 1) === 1;
		}
		function isComponentDef(def) {
		  return !!def.template;
		}
		function isRootView(target) {
		  return (target[FLAGS] & 512) !== 0;
		}
		function isDestroyed(lView) {
		  return (lView[FLAGS] & 256) === 256;
		}
		function assertTNodeForLView(tNode, lView) {
		  assertTNodeForTView(tNode, lView[TVIEW]);
		}
		function assertTNodeForTView(tNode, tView) {
		  assertTNode(tNode);
		  const tData = tView.data;
		  for (let i = HEADER_OFFSET; i < tData.length; i++) {
			 if (tData[i] === tNode) {
				return;
			 }
		  }
		  throwError("This TNode does not belong to this TView.");
		}
		function assertTNode(tNode) {
		  assertDefined(tNode, "TNode must be defined");
		  if (!(tNode && typeof tNode === "object" && tNode.hasOwnProperty("directiveStylingLast"))) {
			 throwError("Not of type TNode, got: " + tNode);
		  }
		}
		function assertTIcu(tIcu) {
		  assertDefined(tIcu, "Expected TIcu to be defined");
		  if (!(typeof tIcu.currentCaseLViewIndex === "number")) {
			 throwError("Object is not of TIcu type.");
		  }
		}
		function assertComponentType(actual, msg = "Type passed in is not ComponentType, it does not have '\u0275cmp' property.") {
		  if (!getComponentDef(actual)) {
			 throwError(msg);
		  }
		}
		function assertNgModuleType(actual, msg = "Type passed in is not NgModuleType, it does not have '\u0275mod' property.") {
		  if (!getNgModuleDef(actual)) {
			 throwError(msg);
		  }
		}
		function assertHasParent(tNode) {
		  assertDefined(tNode, "currentTNode should exist!");
		  assertDefined(tNode.parent, "currentTNode should have a parent");
		}
		function assertLContainer(value) {
		  assertDefined(value, "LContainer must be defined");
		  assertEqual(isLContainer(value), true, "Expecting LContainer");
		}
		function assertLViewOrUndefined(value) {
		  value && assertEqual(isLView(value), true, "Expecting LView or undefined or null");
		}
		function assertLView(value) {
		  assertDefined(value, "LView must be defined");
		  assertEqual(isLView(value), true, "Expecting LView");
		}
		function assertFirstCreatePass(tView, errMessage) {
		  assertEqual(tView.firstCreatePass, true, errMessage || "Should only be called in first create pass.");
		}
		function assertFirstUpdatePass(tView, errMessage) {
		  assertEqual(tView.firstUpdatePass, true, errMessage || "Should only be called in first update pass.");
		}
		function assertDirectiveDef(obj) {
		  if (obj.type === void 0 || obj.selectors == void 0 || obj.inputs === void 0) {
			 throwError(`Expected a DirectiveDef/ComponentDef and this object does not seem to have the expected shape.`);
		  }
		}
		function assertIndexInDeclRange(tView, index) {
		  assertBetween(HEADER_OFFSET, tView.bindingStartIndex, index);
		}
		function assertIndexInExpandoRange(lView, index) {
		  const tView = lView[1];
		  assertBetween(tView.expandoStartIndex, lView.length, index);
		}
		function assertBetween(lower2, upper, index) {
		  if (!(lower2 <= index && index < upper)) {
			 throwError(`Index out of range (expecting ${lower2} <= ${index} < ${upper})`);
		  }
		}
		function assertProjectionSlots(lView, errMessage) {
		  assertDefined(lView[DECLARATION_COMPONENT_VIEW], "Component views should exist.");
		  assertDefined(lView[DECLARATION_COMPONENT_VIEW][T_HOST].projection, errMessage || "Components with projection nodes (<ng-content>) must have projection slots defined.");
		}
		function assertParentView(lView, errMessage) {
		  assertDefined(lView, errMessage || "Component views should always have a parent view (component's host view)");
		}
		function assertNoDuplicateDirectives(directives) {
		  if (directives.length < 2) {
			 return;
		  }
		  const seenDirectives = /* @__PURE__ */ new Set();
		  for (const current of directives) {
			 if (seenDirectives.has(current)) {
				throw new RuntimeError(309, `Directive ${current.type.name} matches multiple times on the same element. Directives can only match an element once.`);
			 }
			 seenDirectives.add(current);
		  }
		}
		function assertNodeInjector(lView, injectorIndex) {
		  assertIndexInExpandoRange(lView, injectorIndex);
		  assertIndexInExpandoRange(
			 lView,
			 injectorIndex + 8
			 /* NodeInjectorOffset.PARENT */
		  );
		  assertNumber(lView[injectorIndex + 0], "injectorIndex should point to a bloom filter");
		  assertNumber(lView[injectorIndex + 1], "injectorIndex should point to a bloom filter");
		  assertNumber(lView[injectorIndex + 2], "injectorIndex should point to a bloom filter");
		  assertNumber(lView[injectorIndex + 3], "injectorIndex should point to a bloom filter");
		  assertNumber(lView[injectorIndex + 4], "injectorIndex should point to a bloom filter");
		  assertNumber(lView[injectorIndex + 5], "injectorIndex should point to a bloom filter");
		  assertNumber(lView[injectorIndex + 6], "injectorIndex should point to a bloom filter");
		  assertNumber(lView[injectorIndex + 7], "injectorIndex should point to a bloom filter");
		  assertNumber(lView[
			 injectorIndex + 8
			 /* NodeInjectorOffset.PARENT */
		  ], "injectorIndex should point to parent injector");
		}
		var SimpleChange = class {
		  constructor(previousValue, currentValue, firstChange) {
			 this.previousValue = previousValue;
			 this.currentValue = currentValue;
			 this.firstChange = firstChange;
		  }
		  /**
			* Check whether the new value is the first value assigned.
			*/
		  isFirstChange() {
			 return this.firstChange;
		  }
		};
		function applyValueToInputField(instance, inputSignalNode, privateName, value) {
		  if (inputSignalNode !== null) {
			 inputSignalNode.applyValueToInputSignal(inputSignalNode, value);
		  } else {
			 instance[privateName] = value;
		  }
		}
		function \u0275\u0275NgOnChangesFeature() {
		  return NgOnChangesFeatureImpl;
		}
		function NgOnChangesFeatureImpl(definition) {
		  if (definition.type.prototype.ngOnChanges) {
			 definition.setInput = ngOnChangesSetInput;
		  }
		  return rememberChangeHistoryAndInvokeOnChangesHook;
		}
		\u0275\u0275NgOnChangesFeature.ngInherit = true;
		function rememberChangeHistoryAndInvokeOnChangesHook() {
		  const simpleChangesStore = getSimpleChangesStore(this);
		  const current = simpleChangesStore?.current;
		  if (current) {
			 const previous = simpleChangesStore.previous;
			 if (previous === EMPTY_OBJ) {
				simpleChangesStore.previous = current;
			 } else {
				for (let key in current) {
				  previous[key] = current[key];
				}
			 }
			 simpleChangesStore.current = null;
			 this.ngOnChanges(current);
		  }
		}
		function ngOnChangesSetInput(instance, inputSignalNode, value, publicName, privateName) {
		  const declaredName = this.declaredInputs[publicName];
		  ngDevMode && assertString(declaredName, "Name of input in ngOnChanges has to be a string");
		  const simpleChangesStore = getSimpleChangesStore(instance) || setSimpleChangesStore(instance, { previous: EMPTY_OBJ, current: null });
		  const current = simpleChangesStore.current || (simpleChangesStore.current = {});
		  const previous = simpleChangesStore.previous;
		  const previousChange = previous[declaredName];
		  current[declaredName] = new SimpleChange(previousChange && previousChange.currentValue, value, previous === EMPTY_OBJ);
		  applyValueToInputField(instance, inputSignalNode, privateName, value);
		}
		var SIMPLE_CHANGES_STORE = "__ngSimpleChanges__";
		function getSimpleChangesStore(instance) {
		  return instance[SIMPLE_CHANGES_STORE] || null;
		}
		function setSimpleChangesStore(instance, store2) {
		  return instance[SIMPLE_CHANGES_STORE] = store2;
		}
		var profilerCallback = null;
		var setProfiler = (profiler2) => {
		  profilerCallback = profiler2;
		};
		var profiler = function(event, instance, hookOrListener) {
		  if (profilerCallback != null) {
			 profilerCallback(event, instance, hookOrListener);
		  }
		};
		var SVG_NAMESPACE = "svg";
		var MATH_ML_NAMESPACE = "math";
		var _ensureDirtyViewsAreAlwaysReachable = false;
		function getEnsureDirtyViewsAreAlwaysReachable() {
		  return _ensureDirtyViewsAreAlwaysReachable;
		}
		function unwrapRNode(value) {
		  while (Array.isArray(value)) {
			 value = value[HOST];
		  }
		  return value;
		}
		function unwrapLView(value) {
		  while (Array.isArray(value)) {
			 if (typeof value[TYPE] === "object")
				return value;
			 value = value[HOST];
		  }
		  return null;
		}
		function getNativeByIndex(index, lView) {
		  ngDevMode && assertIndexInRange(lView, index);
		  ngDevMode && assertGreaterThanOrEqual(index, HEADER_OFFSET, "Expected to be past HEADER_OFFSET");
		  return unwrapRNode(lView[index]);
		}
		function getNativeByTNode(tNode, lView) {
		  ngDevMode && assertTNodeForLView(tNode, lView);
		  ngDevMode && assertIndexInRange(lView, tNode.index);
		  const node = unwrapRNode(lView[tNode.index]);
		  return node;
		}
		function getTNode(tView, index) {
		  ngDevMode && assertGreaterThan(index, -1, "wrong index for TNode");
		  ngDevMode && assertLessThan(index, tView.data.length, "wrong index for TNode");
		  const tNode = tView.data[index];
		  ngDevMode && tNode !== null && assertTNode(tNode);
		  return tNode;
		}
		function load(view, index) {
		  ngDevMode && assertIndexInRange(view, index);
		  return view[index];
		}
		function getComponentLViewByIndex(nodeIndex, hostView) {
		  ngDevMode && assertIndexInRange(hostView, nodeIndex);
		  const slotValue = hostView[nodeIndex];
		  const lView = isLView(slotValue) ? slotValue : slotValue[HOST];
		  return lView;
		}
		function isCreationMode(view) {
		  return (view[FLAGS] & 4) === 4;
		}
		function viewAttachedToChangeDetector(view) {
		  return (view[FLAGS] & 128) === 128;
		}
		function viewAttachedToContainer(view) {
		  return isLContainer(view[PARENT]);
		}
		function getConstant(consts, index) {
		  if (index === null || index === void 0)
			 return null;
		  ngDevMode && assertIndexInRange(consts, index);
		  return consts[index];
		}
		function resetPreOrderHookFlags(lView) {
		  lView[PREORDER_HOOK_FLAGS] = 0;
		}
		function markViewForRefresh(lView) {
		  if (lView[FLAGS] & 1024) {
			 return;
		  }
		  lView[FLAGS] |= 1024;
		  if (viewAttachedToChangeDetector(lView)) {
			 markAncestorsForTraversal(lView);
		  }
		}
		function walkUpViews(nestingLevel, currentView) {
		  while (nestingLevel > 0) {
			 ngDevMode && assertDefined(currentView[DECLARATION_VIEW], "Declaration view should be defined if nesting level is greater than 0.");
			 currentView = currentView[DECLARATION_VIEW];
			 nestingLevel--;
		  }
		  return currentView;
		}
		function requiresRefreshOrTraversal(lView) {
		  return !!(lView[FLAGS] & (1024 | 8192) || lView[REACTIVE_TEMPLATE_CONSUMER]?.dirty);
		}
		function updateAncestorTraversalFlagsOnAttach(lView) {
		  lView[ENVIRONMENT].changeDetectionScheduler?.notify(
			 1
			 /* NotificationType.AfterRenderHooks */
		  );
		  if (requiresRefreshOrTraversal(lView)) {
			 markAncestorsForTraversal(lView);
		  } else if (lView[FLAGS] & 64) {
			 if (getEnsureDirtyViewsAreAlwaysReachable()) {
				lView[FLAGS] |= 1024;
				markAncestorsForTraversal(lView);
			 } else {
				lView[ENVIRONMENT].changeDetectionScheduler?.notify();
			 }
		  }
		}
		function markAncestorsForTraversal(lView) {
		  lView[ENVIRONMENT].changeDetectionScheduler?.notify();
		  let parent = getLViewParent(lView);
		  while (parent !== null) {
			 if (parent[FLAGS] & 8192) {
				break;
			 }
			 parent[FLAGS] |= 8192;
			 if (!viewAttachedToChangeDetector(parent)) {
				break;
			 }
			 parent = getLViewParent(parent);
		  }
		}
		function storeLViewOnDestroy(lView, onDestroyCallback) {
		  if ((lView[FLAGS] & 256) === 256) {
			 throw new RuntimeError(911, ngDevMode && "View has already been destroyed.");
		  }
		  if (lView[ON_DESTROY_HOOKS] === null) {
			 lView[ON_DESTROY_HOOKS] = [];
		  }
		  lView[ON_DESTROY_HOOKS].push(onDestroyCallback);
		}
		function removeLViewOnDestroy(lView, onDestroyCallback) {
		  if (lView[ON_DESTROY_HOOKS] === null)
			 return;
		  const destroyCBIdx = lView[ON_DESTROY_HOOKS].indexOf(onDestroyCallback);
		  if (destroyCBIdx !== -1) {
			 lView[ON_DESTROY_HOOKS].splice(destroyCBIdx, 1);
		  }
		}
		function getLViewParent(lView) {
		  ngDevMode && assertLView(lView);
		  const parent = lView[PARENT];
		  return isLContainer(parent) ? parent[PARENT] : parent;
		}
		var instructionState = {
		  lFrame: createLFrame(null),
		  bindingsEnabled: true,
		  skipHydrationRootTNode: null
		};
		var _isInCheckNoChangesMode = false;
		function getElementDepthCount() {
		  return instructionState.lFrame.elementDepthCount;
		}
		function increaseElementDepthCount() {
		  instructionState.lFrame.elementDepthCount++;
		}
		function decreaseElementDepthCount() {
		  instructionState.lFrame.elementDepthCount--;
		}
		function getBindingsEnabled() {
		  return instructionState.bindingsEnabled;
		}
		function isInSkipHydrationBlock$1() {
		  return instructionState.skipHydrationRootTNode !== null;
		}
		function isSkipHydrationRootTNode(tNode) {
		  return instructionState.skipHydrationRootTNode === tNode;
		}
		function \u0275\u0275enableBindings() {
		  instructionState.bindingsEnabled = true;
		}
		function \u0275\u0275disableBindings() {
		  instructionState.bindingsEnabled = false;
		}
		function leaveSkipHydrationBlock() {
		  instructionState.skipHydrationRootTNode = null;
		}
		function getLView() {
		  return instructionState.lFrame.lView;
		}
		function getTView() {
		  return instructionState.lFrame.tView;
		}
		function \u0275\u0275restoreView(viewToRestore) {
		  instructionState.lFrame.contextLView = viewToRestore;
		  return viewToRestore[CONTEXT];
		}
		function \u0275\u0275resetView(value) {
		  instructionState.lFrame.contextLView = null;
		  return value;
		}
		function getCurrentTNode() {
		  let currentTNode = getCurrentTNodePlaceholderOk();
		  while (currentTNode !== null && currentTNode.type === 64) {
			 currentTNode = currentTNode.parent;
		  }
		  return currentTNode;
		}
		function getCurrentTNodePlaceholderOk() {
		  return instructionState.lFrame.currentTNode;
		}
		function getCurrentParentTNode() {
		  const lFrame = instructionState.lFrame;
		  const currentTNode = lFrame.currentTNode;
		  return lFrame.isParent ? currentTNode : currentTNode.parent;
		}
		function setCurrentTNode(tNode, isParent) {
		  ngDevMode && tNode && assertTNodeForTView(tNode, instructionState.lFrame.tView);
		  const lFrame = instructionState.lFrame;
		  lFrame.currentTNode = tNode;
		  lFrame.isParent = isParent;
		}
		function isCurrentTNodeParent() {
		  return instructionState.lFrame.isParent;
		}
		function setCurrentTNodeAsNotParent() {
		  instructionState.lFrame.isParent = false;
		}
		function getContextLView() {
		  const contextLView = instructionState.lFrame.contextLView;
		  ngDevMode && assertDefined(contextLView, "contextLView must be defined.");
		  return contextLView;
		}
		function isInCheckNoChangesMode() {
		  !ngDevMode && throwError("Must never be called in production mode");
		  return _isInCheckNoChangesMode;
		}
		function setIsInCheckNoChangesMode(mode) {
		  !ngDevMode && throwError("Must never be called in production mode");
		  _isInCheckNoChangesMode = mode;
		}
		function getBindingRoot() {
		  const lFrame = instructionState.lFrame;
		  let index = lFrame.bindingRootIndex;
		  if (index === -1) {
			 index = lFrame.bindingRootIndex = lFrame.tView.bindingStartIndex;
		  }
		  return index;
		}
		function getBindingIndex() {
		  return instructionState.lFrame.bindingIndex;
		}
		function setBindingIndex(value) {
		  return instructionState.lFrame.bindingIndex = value;
		}
		function nextBindingIndex() {
		  return instructionState.lFrame.bindingIndex++;
		}
		function incrementBindingIndex(count) {
		  const lFrame = instructionState.lFrame;
		  const index = lFrame.bindingIndex;
		  lFrame.bindingIndex = lFrame.bindingIndex + count;
		  return index;
		}
		function isInI18nBlock() {
		  return instructionState.lFrame.inI18n;
		}
		function setInI18nBlock(isInI18nBlock2) {
		  instructionState.lFrame.inI18n = isInI18nBlock2;
		}
		function setBindingRootForHostBindings(bindingRootIndex, currentDirectiveIndex) {
		  const lFrame = instructionState.lFrame;
		  lFrame.bindingIndex = lFrame.bindingRootIndex = bindingRootIndex;
		  setCurrentDirectiveIndex(currentDirectiveIndex);
		}
		function getCurrentDirectiveIndex() {
		  return instructionState.lFrame.currentDirectiveIndex;
		}
		function setCurrentDirectiveIndex(currentDirectiveIndex) {
		  instructionState.lFrame.currentDirectiveIndex = currentDirectiveIndex;
		}
		function getCurrentDirectiveDef(tData) {
		  const currentDirectiveIndex = instructionState.lFrame.currentDirectiveIndex;
		  return currentDirectiveIndex === -1 ? null : tData[currentDirectiveIndex];
		}
		function getCurrentQueryIndex() {
		  return instructionState.lFrame.currentQueryIndex;
		}
		function setCurrentQueryIndex(value) {
		  instructionState.lFrame.currentQueryIndex = value;
		}
		function getDeclarationTNode(lView) {
		  const tView = lView[TVIEW];
		  if (tView.type === 2) {
			 ngDevMode && assertDefined(tView.declTNode, "Embedded TNodes should have declaration parents.");
			 return tView.declTNode;
		  }
		  if (tView.type === 1) {
			 return lView[T_HOST];
		  }
		  return null;
		}
		function enterDI(lView, tNode, flags) {
		  ngDevMode && assertLViewOrUndefined(lView);
		  if (flags & InjectFlags.SkipSelf) {
			 ngDevMode && assertTNodeForTView(tNode, lView[TVIEW]);
			 let parentTNode = tNode;
			 let parentLView = lView;
			 while (true) {
				ngDevMode && assertDefined(parentTNode, "Parent TNode should be defined");
				parentTNode = parentTNode.parent;
				if (parentTNode === null && !(flags & InjectFlags.Host)) {
				  parentTNode = getDeclarationTNode(parentLView);
				  if (parentTNode === null)
					 break;
				  ngDevMode && assertDefined(parentLView, "Parent LView should be defined");
				  parentLView = parentLView[DECLARATION_VIEW];
				  if (parentTNode.type & (2 | 8)) {
					 break;
				  }
				} else {
				  break;
				}
			 }
			 if (parentTNode === null) {
				return false;
			 } else {
				tNode = parentTNode;
				lView = parentLView;
			 }
		  }
		  ngDevMode && assertTNodeForLView(tNode, lView);
		  const lFrame = instructionState.lFrame = allocLFrame();
		  lFrame.currentTNode = tNode;
		  lFrame.lView = lView;
		  return true;
		}
		function enterView(newView) {
		  ngDevMode && assertNotEqual(newView[0], newView[1], "????");
		  ngDevMode && assertLViewOrUndefined(newView);
		  const newLFrame = allocLFrame();
		  if (ngDevMode) {
			 assertEqual(newLFrame.isParent, true, "Expected clean LFrame");
			 assertEqual(newLFrame.lView, null, "Expected clean LFrame");
			 assertEqual(newLFrame.tView, null, "Expected clean LFrame");
			 assertEqual(newLFrame.selectedIndex, -1, "Expected clean LFrame");
			 assertEqual(newLFrame.elementDepthCount, 0, "Expected clean LFrame");
			 assertEqual(newLFrame.currentDirectiveIndex, -1, "Expected clean LFrame");
			 assertEqual(newLFrame.currentNamespace, null, "Expected clean LFrame");
			 assertEqual(newLFrame.bindingRootIndex, -1, "Expected clean LFrame");
			 assertEqual(newLFrame.currentQueryIndex, 0, "Expected clean LFrame");
		  }
		  const tView = newView[TVIEW];
		  instructionState.lFrame = newLFrame;
		  ngDevMode && tView.firstChild && assertTNodeForTView(tView.firstChild, tView);
		  newLFrame.currentTNode = tView.firstChild;
		  newLFrame.lView = newView;
		  newLFrame.tView = tView;
		  newLFrame.contextLView = newView;
		  newLFrame.bindingIndex = tView.bindingStartIndex;
		  newLFrame.inI18n = false;
		}
		function allocLFrame() {
		  const currentLFrame = instructionState.lFrame;
		  const childLFrame = currentLFrame === null ? null : currentLFrame.child;
		  const newLFrame = childLFrame === null ? createLFrame(currentLFrame) : childLFrame;
		  return newLFrame;
		}
		function createLFrame(parent) {
		  const lFrame = {
			 currentTNode: null,
			 isParent: true,
			 lView: null,
			 tView: null,
			 selectedIndex: -1,
			 contextLView: null,
			 elementDepthCount: 0,
			 currentNamespace: null,
			 currentDirectiveIndex: -1,
			 bindingRootIndex: -1,
			 bindingIndex: -1,
			 currentQueryIndex: 0,
			 parent,
			 child: null,
			 inI18n: false
		  };
		  parent !== null && (parent.child = lFrame);
		  return lFrame;
		}
		function leaveViewLight() {
		  const oldLFrame = instructionState.lFrame;
		  instructionState.lFrame = oldLFrame.parent;
		  oldLFrame.currentTNode = null;
		  oldLFrame.lView = null;
		  return oldLFrame;
		}
		var leaveDI = leaveViewLight;
		function leaveView() {
		  const oldLFrame = leaveViewLight();
		  oldLFrame.isParent = true;
		  oldLFrame.tView = null;
		  oldLFrame.selectedIndex = -1;
		  oldLFrame.contextLView = null;
		  oldLFrame.elementDepthCount = 0;
		  oldLFrame.currentDirectiveIndex = -1;
		  oldLFrame.currentNamespace = null;
		  oldLFrame.bindingRootIndex = -1;
		  oldLFrame.bindingIndex = -1;
		  oldLFrame.currentQueryIndex = 0;
		}
		function nextContextImpl(level) {
		  const contextLView = instructionState.lFrame.contextLView = walkUpViews(level, instructionState.lFrame.contextLView);
		  return contextLView[CONTEXT];
		}
		function getSelectedIndex() {
		  return instructionState.lFrame.selectedIndex;
		}
		function setSelectedIndex(index) {
		  ngDevMode && index !== -1 && assertGreaterThanOrEqual(index, HEADER_OFFSET, "Index must be past HEADER_OFFSET (or -1).");
		  ngDevMode && assertLessThan(index, instructionState.lFrame.lView.length, "Can't set index passed end of LView");
		  instructionState.lFrame.selectedIndex = index;
		}
		function getSelectedTNode() {
		  const lFrame = instructionState.lFrame;
		  return getTNode(lFrame.tView, lFrame.selectedIndex);
		}
		function \u0275\u0275namespaceSVG() {
		  instructionState.lFrame.currentNamespace = SVG_NAMESPACE;
		}
		function \u0275\u0275namespaceMathML() {
		  instructionState.lFrame.currentNamespace = MATH_ML_NAMESPACE;
		}
		function \u0275\u0275namespaceHTML() {
		  namespaceHTMLInternal();
		}
		function namespaceHTMLInternal() {
		  instructionState.lFrame.currentNamespace = null;
		}
		function getNamespace$1() {
		  return instructionState.lFrame.currentNamespace;
		}
		var _wasLastNodeCreated = true;
		function wasLastNodeCreated() {
		  return _wasLastNodeCreated;
		}
		function lastNodeWasCreated(flag) {
		  _wasLastNodeCreated = flag;
		}
		function registerPreOrderHooks(directiveIndex, directiveDef, tView) {
		  ngDevMode && assertFirstCreatePass(tView);
		  const { ngOnChanges, ngOnInit, ngDoCheck } = directiveDef.type.prototype;
		  if (ngOnChanges) {
			 const wrappedOnChanges = NgOnChangesFeatureImpl(directiveDef);
			 (tView.preOrderHooks ??= []).push(directiveIndex, wrappedOnChanges);
			 (tView.preOrderCheckHooks ??= []).push(directiveIndex, wrappedOnChanges);
		  }
		  if (ngOnInit) {
			 (tView.preOrderHooks ??= []).push(0 - directiveIndex, ngOnInit);
		  }
		  if (ngDoCheck) {
			 (tView.preOrderHooks ??= []).push(directiveIndex, ngDoCheck);
			 (tView.preOrderCheckHooks ??= []).push(directiveIndex, ngDoCheck);
		  }
		}
		function registerPostOrderHooks(tView, tNode) {
		  ngDevMode && assertFirstCreatePass(tView);
		  for (let i = tNode.directiveStart, end = tNode.directiveEnd; i < end; i++) {
			 const directiveDef = tView.data[i];
			 ngDevMode && assertDefined(directiveDef, "Expecting DirectiveDef");
			 const lifecycleHooks = directiveDef.type.prototype;
			 const { ngAfterContentInit, ngAfterContentChecked, ngAfterViewInit, ngAfterViewChecked, ngOnDestroy } = lifecycleHooks;
			 if (ngAfterContentInit) {
				(tView.contentHooks ??= []).push(-i, ngAfterContentInit);
			 }
			 if (ngAfterContentChecked) {
				(tView.contentHooks ??= []).push(i, ngAfterContentChecked);
				(tView.contentCheckHooks ??= []).push(i, ngAfterContentChecked);
			 }
			 if (ngAfterViewInit) {
				(tView.viewHooks ??= []).push(-i, ngAfterViewInit);
			 }
			 if (ngAfterViewChecked) {
				(tView.viewHooks ??= []).push(i, ngAfterViewChecked);
				(tView.viewCheckHooks ??= []).push(i, ngAfterViewChecked);
			 }
			 if (ngOnDestroy != null) {
				(tView.destroyHooks ??= []).push(i, ngOnDestroy);
			 }
		  }
		}
		function executeCheckHooks(lView, hooks, nodeIndex) {
		  callHooks(lView, hooks, 3, nodeIndex);
		}
		function executeInitAndCheckHooks(lView, hooks, initPhase, nodeIndex) {
		  ngDevMode && assertNotEqual(initPhase, 3, "Init pre-order hooks should not be called more than once");
		  if ((lView[FLAGS] & 3) === initPhase) {
			 callHooks(lView, hooks, initPhase, nodeIndex);
		  }
		}
		function incrementInitPhaseFlags(lView, initPhase) {
		  ngDevMode && assertNotEqual(initPhase, 3, "Init hooks phase should not be incremented after all init hooks have been run.");
		  let flags = lView[FLAGS];
		  if ((flags & 3) === initPhase) {
			 flags &= 16383;
			 flags += 1;
			 lView[FLAGS] = flags;
		  }
		}
		function callHooks(currentView, arr, initPhase, currentNodeIndex) {
		  ngDevMode && assertEqual(isInCheckNoChangesMode(), false, "Hooks should never be run when in check no changes mode.");
		  const startIndex = currentNodeIndex !== void 0 ? currentView[PREORDER_HOOK_FLAGS] & 65535 : 0;
		  const nodeIndexLimit = currentNodeIndex != null ? currentNodeIndex : -1;
		  const max3 = arr.length - 1;
		  let lastNodeIndexFound = 0;
		  for (let i = startIndex; i < max3; i++) {
			 const hook = arr[i + 1];
			 if (typeof hook === "number") {
				lastNodeIndexFound = arr[i];
				if (currentNodeIndex != null && lastNodeIndexFound >= currentNodeIndex) {
				  break;
				}
			 } else {
				const isInitHook = arr[i] < 0;
				if (isInitHook) {
				  currentView[PREORDER_HOOK_FLAGS] += 65536;
				}
				if (lastNodeIndexFound < nodeIndexLimit || nodeIndexLimit == -1) {
				  callHook(currentView, initPhase, arr, i);
				  currentView[PREORDER_HOOK_FLAGS] = (currentView[PREORDER_HOOK_FLAGS] & 4294901760) + i + 2;
				}
				i++;
			 }
		  }
		}
		function callHookInternal(directive, hook) {
		  profiler(4, directive, hook);
		  const prevConsumer = setActiveConsumer(null);
		  try {
			 hook.call(directive);
		  } finally {
			 setActiveConsumer(prevConsumer);
			 profiler(5, directive, hook);
		  }
		}
		function callHook(currentView, initPhase, arr, i) {
		  const isInitHook = arr[i] < 0;
		  const hook = arr[i + 1];
		  const directiveIndex = isInitHook ? -arr[i] : arr[i];
		  const directive = currentView[directiveIndex];
		  if (isInitHook) {
			 const indexWithintInitPhase = currentView[FLAGS] >> 14;
			 if (indexWithintInitPhase < currentView[PREORDER_HOOK_FLAGS] >> 16 && (currentView[FLAGS] & 3) === initPhase) {
				currentView[FLAGS] += 16384;
				callHookInternal(directive, hook);
			 }
		  } else {
			 callHookInternal(directive, hook);
		  }
		}
		var NO_PARENT_INJECTOR = -1;
		var NodeInjectorFactory = class {
		  constructor(factory, isViewProvider, injectImplementation) {
			 this.factory = factory;
			 this.resolving = false;
			 ngDevMode && assertDefined(factory, "Factory not specified");
			 ngDevMode && assertEqual(typeof factory, "function", "Expected factory function.");
			 this.canSeeViewProviders = isViewProvider;
			 this.injectImpl = injectImplementation;
		  }
		};
		function isFactory(obj) {
		  return obj instanceof NodeInjectorFactory;
		}
		function toTNodeTypeAsString(tNodeType) {
		  let text = "";
		  tNodeType & 1 && (text += "|Text");
		  tNodeType & 2 && (text += "|Element");
		  tNodeType & 4 && (text += "|Container");
		  tNodeType & 8 && (text += "|ElementContainer");
		  tNodeType & 16 && (text += "|Projection");
		  tNodeType & 32 && (text += "|IcuContainer");
		  tNodeType & 64 && (text += "|Placeholder");
		  return text.length > 0 ? text.substring(1) : text;
		}
		function hasClassInput(tNode) {
		  return (tNode.flags & 8) !== 0;
		}
		function hasStyleInput(tNode) {
		  return (tNode.flags & 16) !== 0;
		}
		function assertTNodeType(tNode, expectedTypes, message2) {
		  assertDefined(tNode, "should be called with a TNode");
		  if ((tNode.type & expectedTypes) === 0) {
			 throwError(message2 || `Expected [${toTNodeTypeAsString(expectedTypes)}] but got ${toTNodeTypeAsString(tNode.type)}.`);
		  }
		}
		function assertPureTNodeType(type2) {
		  if (!(type2 === 2 || //
		  type2 === 1 || //
		  type2 === 4 || //
		  type2 === 8 || //
		  type2 === 32 || //
		  type2 === 16 || //
		  type2 === 64)) {
			 throwError(`Expected TNodeType to have only a single type selected, but got ${toTNodeTypeAsString(type2)}.`);
		  }
		}
		function hasParentInjector(parentLocation) {
		  return parentLocation !== NO_PARENT_INJECTOR;
		}
		function getParentInjectorIndex(parentLocation) {
		  if (ngDevMode) {
			 assertNumber(parentLocation, "Number expected");
			 assertNotEqual(parentLocation, -1, "Not a valid state.");
			 const parentInjectorIndex = parentLocation & 32767;
			 assertGreaterThan(parentInjectorIndex, HEADER_OFFSET, "Parent injector must be pointing past HEADER_OFFSET.");
		  }
		  return parentLocation & 32767;
		}
		function getParentInjectorViewOffset(parentLocation) {
		  return parentLocation >> 16;
		}
		function getParentInjectorView(location2, startView) {
		  let viewOffset = getParentInjectorViewOffset(location2);
		  let parentView = startView;
		  while (viewOffset > 0) {
			 parentView = parentView[DECLARATION_VIEW];
			 viewOffset--;
		  }
		  return parentView;
		}
		var includeViewProviders = true;
		function setIncludeViewProviders(v) {
		  const oldValue = includeViewProviders;
		  includeViewProviders = v;
		  return oldValue;
		}
		var BLOOM_SIZE = 256;
		var BLOOM_MASK = BLOOM_SIZE - 1;
		var BLOOM_BUCKET_BITS = 5;
		var nextNgElementId = 0;
		var NOT_FOUND = {};
		function bloomAdd(injectorIndex, tView, type2) {
		  ngDevMode && assertEqual(tView.firstCreatePass, true, "expected firstCreatePass to be true");
		  let id3;
		  if (typeof type2 === "string") {
			 id3 = type2.charCodeAt(0) || 0;
		  } else if (type2.hasOwnProperty(NG_ELEMENT_ID)) {
			 id3 = type2[NG_ELEMENT_ID];
		  }
		  if (id3 == null) {
			 id3 = type2[NG_ELEMENT_ID] = nextNgElementId++;
		  }
		  const bloomHash = id3 & BLOOM_MASK;
		  const mask = 1 << bloomHash;
		  tView.data[injectorIndex + (bloomHash >> BLOOM_BUCKET_BITS)] |= mask;
		}
		function getOrCreateNodeInjectorForNode(tNode, lView) {
		  const existingInjectorIndex = getInjectorIndex(tNode, lView);
		  if (existingInjectorIndex !== -1) {
			 return existingInjectorIndex;
		  }
		  const tView = lView[TVIEW];
		  if (tView.firstCreatePass) {
			 tNode.injectorIndex = lView.length;
			 insertBloom(tView.data, tNode);
			 insertBloom(lView, null);
			 insertBloom(tView.blueprint, null);
		  }
		  const parentLoc = getParentInjectorLocation(tNode, lView);
		  const injectorIndex = tNode.injectorIndex;
		  if (hasParentInjector(parentLoc)) {
			 const parentIndex = getParentInjectorIndex(parentLoc);
			 const parentLView = getParentInjectorView(parentLoc, lView);
			 const parentData = parentLView[TVIEW].data;
			 for (let i = 0; i < 8; i++) {
				lView[injectorIndex + i] = parentLView[parentIndex + i] | parentData[parentIndex + i];
			 }
		  }
		  lView[
			 injectorIndex + 8
			 /* NodeInjectorOffset.PARENT */
		  ] = parentLoc;
		  return injectorIndex;
		}
		function insertBloom(arr, footer) {
		  arr.push(0, 0, 0, 0, 0, 0, 0, 0, footer);
		}
		function getInjectorIndex(tNode, lView) {
		  if (tNode.injectorIndex === -1 || // If the injector index is the same as its parent's injector index, then the index has been
		  // copied down from the parent node. No injector has been created yet on this node.
		  tNode.parent && tNode.parent.injectorIndex === tNode.injectorIndex || // After the first template pass, the injector index might exist but the parent values
		  // might not have been calculated yet for this instance
		  lView[
			 tNode.injectorIndex + 8
			 /* NodeInjectorOffset.PARENT */
		  ] === null) {
			 return -1;
		  } else {
			 ngDevMode && assertIndexInRange(lView, tNode.injectorIndex);
			 return tNode.injectorIndex;
		  }
		}
		function getParentInjectorLocation(tNode, lView) {
		  if (tNode.parent && tNode.parent.injectorIndex !== -1) {
			 return tNode.parent.injectorIndex;
		  }
		  let declarationViewOffset = 0;
		  let parentTNode = null;
		  let lViewCursor = lView;
		  while (lViewCursor !== null) {
			 parentTNode = getTNodeFromLView(lViewCursor);
			 if (parentTNode === null) {
				return NO_PARENT_INJECTOR;
			 }
			 ngDevMode && parentTNode && assertTNodeForLView(parentTNode, lViewCursor[DECLARATION_VIEW]);
			 declarationViewOffset++;
			 lViewCursor = lViewCursor[DECLARATION_VIEW];
			 if (parentTNode.injectorIndex !== -1) {
				return parentTNode.injectorIndex | declarationViewOffset << 16;
			 }
		  }
		  return NO_PARENT_INJECTOR;
		}
		function diPublicInInjector(injectorIndex, tView, token) {
		  bloomAdd(injectorIndex, tView, token);
		}
		function injectAttributeImpl(tNode, attrNameToInject) {
		  ngDevMode && assertTNodeType(
			 tNode,
			 12 | 3
			 /* TNodeType.AnyRNode */
		  );
		  ngDevMode && assertDefined(tNode, "expecting tNode");
		  if (attrNameToInject === "class") {
			 return tNode.classes;
		  }
		  if (attrNameToInject === "style") {
			 return tNode.styles;
		  }
		  const attrs = tNode.attrs;
		  if (attrs) {
			 const attrsLength = attrs.length;
			 let i = 0;
			 while (i < attrsLength) {
				const value = attrs[i];
				if (isNameOnlyAttributeMarker(value))
				  break;
				if (value === 0) {
				  i = i + 2;
				} else if (typeof value === "number") {
				  i++;
				  while (i < attrsLength && typeof attrs[i] === "string") {
					 i++;
				  }
				} else if (value === attrNameToInject) {
				  return attrs[i + 1];
				} else {
				  i = i + 2;
				}
			 }
		  }
		  return null;
		}
		function notFoundValueOrThrow(notFoundValue, token, flags) {
		  if (flags & InjectFlags.Optional || notFoundValue !== void 0) {
			 return notFoundValue;
		  } else {
			 throwProviderNotFoundError(token, "NodeInjector");
		  }
		}
		function lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue) {
		  if (flags & InjectFlags.Optional && notFoundValue === void 0) {
			 notFoundValue = null;
		  }
		  if ((flags & (InjectFlags.Self | InjectFlags.Host)) === 0) {
			 const moduleInjector = lView[INJECTOR];
			 const previousInjectImplementation = setInjectImplementation(void 0);
			 try {
				if (moduleInjector) {
				  return moduleInjector.get(token, notFoundValue, flags & InjectFlags.Optional);
				} else {
				  return injectRootLimpMode(token, notFoundValue, flags & InjectFlags.Optional);
				}
			 } finally {
				setInjectImplementation(previousInjectImplementation);
			 }
		  }
		  return notFoundValueOrThrow(notFoundValue, token, flags);
		}
		function getOrCreateInjectable(tNode, lView, token, flags = InjectFlags.Default, notFoundValue) {
		  if (tNode !== null) {
			 if (lView[FLAGS] & 2048 && // The token must be present on the current node injector when the `Self`
			 // flag is set, so the lookup on embedded view injector(s) can be skipped.
			 !(flags & InjectFlags.Self)) {
				const embeddedInjectorValue = lookupTokenUsingEmbeddedInjector(tNode, lView, token, flags, NOT_FOUND);
				if (embeddedInjectorValue !== NOT_FOUND) {
				  return embeddedInjectorValue;
				}
			 }
			 const value = lookupTokenUsingNodeInjector(tNode, lView, token, flags, NOT_FOUND);
			 if (value !== NOT_FOUND) {
				return value;
			 }
		  }
		  return lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue);
		}
		function lookupTokenUsingNodeInjector(tNode, lView, token, flags, notFoundValue) {
		  const bloomHash = bloomHashBitOrFactory(token);
		  if (typeof bloomHash === "function") {
			 if (!enterDI(lView, tNode, flags)) {
				return flags & InjectFlags.Host ? notFoundValueOrThrow(notFoundValue, token, flags) : lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue);
			 }
			 try {
				let value;
				if (ngDevMode) {
				  runInInjectorProfilerContext(new NodeInjector(getCurrentTNode(), getLView()), token, () => {
					 value = bloomHash(flags);
					 if (value != null) {
						emitInstanceCreatedByInjectorEvent(value);
					 }
				  });
				} else {
				  value = bloomHash(flags);
				}
				if (value == null && !(flags & InjectFlags.Optional)) {
				  throwProviderNotFoundError(token);
				} else {
				  return value;
				}
			 } finally {
				leaveDI();
			 }
		  } else if (typeof bloomHash === "number") {
			 let previousTView = null;
			 let injectorIndex = getInjectorIndex(tNode, lView);
			 let parentLocation = NO_PARENT_INJECTOR;
			 let hostTElementNode = flags & InjectFlags.Host ? lView[DECLARATION_COMPONENT_VIEW][T_HOST] : null;
			 if (injectorIndex === -1 || flags & InjectFlags.SkipSelf) {
				parentLocation = injectorIndex === -1 ? getParentInjectorLocation(tNode, lView) : lView[
				  injectorIndex + 8
				  /* NodeInjectorOffset.PARENT */
				];
				if (parentLocation === NO_PARENT_INJECTOR || !shouldSearchParent(flags, false)) {
				  injectorIndex = -1;
				} else {
				  previousTView = lView[TVIEW];
				  injectorIndex = getParentInjectorIndex(parentLocation);
				  lView = getParentInjectorView(parentLocation, lView);
				}
			 }
			 while (injectorIndex !== -1) {
				ngDevMode && assertNodeInjector(lView, injectorIndex);
				const tView = lView[TVIEW];
				ngDevMode && assertTNodeForLView(tView.data[
				  injectorIndex + 8
				  /* NodeInjectorOffset.TNODE */
				], lView);
				if (bloomHasToken(bloomHash, injectorIndex, tView.data)) {
				  const instance = searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode);
				  if (instance !== NOT_FOUND) {
					 return instance;
				  }
				}
				parentLocation = lView[
				  injectorIndex + 8
				  /* NodeInjectorOffset.PARENT */
				];
				if (parentLocation !== NO_PARENT_INJECTOR && shouldSearchParent(flags, lView[TVIEW].data[
				  injectorIndex + 8
				  /* NodeInjectorOffset.TNODE */
				] === hostTElementNode) && bloomHasToken(bloomHash, injectorIndex, lView)) {
				  previousTView = tView;
				  injectorIndex = getParentInjectorIndex(parentLocation);
				  lView = getParentInjectorView(parentLocation, lView);
				} else {
				  injectorIndex = -1;
				}
			 }
		  }
		  return notFoundValue;
		}
		function searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode) {
		  const currentTView = lView[TVIEW];
		  const tNode = currentTView.data[
			 injectorIndex + 8
			 /* NodeInjectorOffset.TNODE */
		  ];
		  const canAccessViewProviders = previousTView == null ? (
			 // 1) This is the first invocation `previousTView == null` which means that we are at the
			 // `TNode` of where injector is starting to look. In such a case the only time we are allowed
			 // to look into the ViewProviders is if:
			 // - we are on a component
			 // - AND the injector set `includeViewProviders` to true (implying that the token can see
			 // ViewProviders because it is the Component or a Service which itself was declared in
			 // ViewProviders)
			 isComponentHost(tNode) && includeViewProviders
		  ) : (
			 // 2) `previousTView != null` which means that we are now walking across the parent nodes.
			 // In such a case we are only allowed to look into the ViewProviders if:
			 // - We just crossed from child View to Parent View `previousTView != currentTView`
			 // - AND the parent TNode is an Element.
			 // This means that we just came from the Component's View and therefore are allowed to see
			 // into the ViewProviders.
			 previousTView != currentTView && (tNode.type & 3) !== 0
		  );
		  const isHostSpecialCase = flags & InjectFlags.Host && hostTElementNode === tNode;
		  const injectableIdx = locateDirectiveOrProvider(tNode, currentTView, token, canAccessViewProviders, isHostSpecialCase);
		  if (injectableIdx !== null) {
			 return getNodeInjectable(lView, currentTView, injectableIdx, tNode);
		  } else {
			 return NOT_FOUND;
		  }
		}
		function locateDirectiveOrProvider(tNode, tView, token, canAccessViewProviders, isHostSpecialCase) {
		  const nodeProviderIndexes = tNode.providerIndexes;
		  const tInjectables = tView.data;
		  const injectablesStart = nodeProviderIndexes & 1048575;
		  const directivesStart = tNode.directiveStart;
		  const directiveEnd = tNode.directiveEnd;
		  const cptViewProvidersCount = nodeProviderIndexes >> 20;
		  const startingIndex = canAccessViewProviders ? injectablesStart : injectablesStart + cptViewProvidersCount;
		  const endIndex = isHostSpecialCase ? injectablesStart + cptViewProvidersCount : directiveEnd;
		  for (let i = startingIndex; i < endIndex; i++) {
			 const providerTokenOrDef = tInjectables[i];
			 if (i < directivesStart && token === providerTokenOrDef || i >= directivesStart && providerTokenOrDef.type === token) {
				return i;
			 }
		  }
		  if (isHostSpecialCase) {
			 const dirDef = tInjectables[directivesStart];
			 if (dirDef && isComponentDef(dirDef) && dirDef.type === token) {
				return directivesStart;
			 }
		  }
		  return null;
		}
		function getNodeInjectable(lView, tView, index, tNode) {
		  let value = lView[index];
		  const tData = tView.data;
		  if (isFactory(value)) {
			 const factory = value;
			 if (factory.resolving) {
				throwCyclicDependencyError(stringifyForError(tData[index]));
			 }
			 const previousIncludeViewProviders = setIncludeViewProviders(factory.canSeeViewProviders);
			 factory.resolving = true;
			 let prevInjectContext;
			 if (ngDevMode) {
				const token = tData[index].type || tData[index];
				const injector = new NodeInjector(tNode, lView);
				prevInjectContext = setInjectorProfilerContext({ injector, token });
			 }
			 const previousInjectImplementation = factory.injectImpl ? setInjectImplementation(factory.injectImpl) : null;
			 const success = enterDI(lView, tNode, InjectFlags.Default);
			 ngDevMode && assertEqual(success, true, "Because flags do not contain `SkipSelf' we expect this to always succeed.");
			 try {
				value = lView[index] = factory.factory(void 0, tData, lView, tNode);
				ngDevMode && emitInstanceCreatedByInjectorEvent(value);
				if (tView.firstCreatePass && index >= tNode.directiveStart) {
				  ngDevMode && assertDirectiveDef(tData[index]);
				  registerPreOrderHooks(index, tData[index], tView);
				}
			 } finally {
				ngDevMode && setInjectorProfilerContext(prevInjectContext);
				previousInjectImplementation !== null && setInjectImplementation(previousInjectImplementation);
				setIncludeViewProviders(previousIncludeViewProviders);
				factory.resolving = false;
				leaveDI();
			 }
		  }
		  return value;
		}
		function bloomHashBitOrFactory(token) {
		  ngDevMode && assertDefined(token, "token must be defined");
		  if (typeof token === "string") {
			 return token.charCodeAt(0) || 0;
		  }
		  const tokenId = (
			 // First check with `hasOwnProperty` so we don't get an inherited ID.
			 token.hasOwnProperty(NG_ELEMENT_ID) ? token[NG_ELEMENT_ID] : void 0
		  );
		  if (typeof tokenId === "number") {
			 if (tokenId >= 0) {
				return tokenId & BLOOM_MASK;
			 } else {
				ngDevMode && assertEqual(tokenId, -1, "Expecting to get Special Injector Id");
				return createNodeInjector;
			 }
		  } else {
			 return tokenId;
		  }
		}
		function bloomHasToken(bloomHash, injectorIndex, injectorView) {
		  const mask = 1 << bloomHash;
		  const value = injectorView[injectorIndex + (bloomHash >> BLOOM_BUCKET_BITS)];
		  return !!(value & mask);
		}
		function shouldSearchParent(flags, isFirstHostTNode) {
		  return !(flags & InjectFlags.Self) && !(flags & InjectFlags.Host && isFirstHostTNode);
		}
		function getNodeInjectorLView(nodeInjector) {
		  return nodeInjector._lView;
		}
		function getNodeInjectorTNode(nodeInjector) {
		  return nodeInjector._tNode;
		}
		var NodeInjector = class {
		  constructor(_tNode, _lView) {
			 this._tNode = _tNode;
			 this._lView = _lView;
		  }
		  get(token, notFoundValue, flags) {
			 return getOrCreateInjectable(this._tNode, this._lView, token, convertToBitFlags(flags), notFoundValue);
		  }
		};
		function createNodeInjector() {
		  return new NodeInjector(getCurrentTNode(), getLView());
		}
		function \u0275\u0275getInheritedFactory(type2) {
		  return noSideEffects(() => {
			 const ownConstructor = type2.prototype.constructor;
			 const ownFactory = ownConstructor[NG_FACTORY_DEF] || getFactoryOf(ownConstructor);
			 const objectPrototype = Object.prototype;
			 let parent = Object.getPrototypeOf(type2.prototype).constructor;
			 while (parent && parent !== objectPrototype) {
				const factory = parent[NG_FACTORY_DEF] || getFactoryOf(parent);
				if (factory && factory !== ownFactory) {
				  return factory;
				}
				parent = Object.getPrototypeOf(parent);
			 }
			 return (t) => new t();
		  });
		}
		function getFactoryOf(type2) {
		  if (isForwardRef(type2)) {
			 return () => {
				const factory = getFactoryOf(resolveForwardRef(type2));
				return factory && factory();
			 };
		  }
		  return getFactoryDef(type2);
		}
		function lookupTokenUsingEmbeddedInjector(tNode, lView, token, flags, notFoundValue) {
		  let currentTNode = tNode;
		  let currentLView = lView;
		  while (currentTNode !== null && currentLView !== null && currentLView[FLAGS] & 2048 && !(currentLView[FLAGS] & 512)) {
			 ngDevMode && assertTNodeForLView(currentTNode, currentLView);
			 const nodeInjectorValue = lookupTokenUsingNodeInjector(currentTNode, currentLView, token, flags | InjectFlags.Self, NOT_FOUND);
			 if (nodeInjectorValue !== NOT_FOUND) {
				return nodeInjectorValue;
			 }
			 let parentTNode = currentTNode.parent;
			 if (!parentTNode) {
				const embeddedViewInjector = currentLView[EMBEDDED_VIEW_INJECTOR];
				if (embeddedViewInjector) {
				  const embeddedViewInjectorValue = embeddedViewInjector.get(token, NOT_FOUND, flags);
				  if (embeddedViewInjectorValue !== NOT_FOUND) {
					 return embeddedViewInjectorValue;
				  }
				}
				parentTNode = getTNodeFromLView(currentLView);
				currentLView = currentLView[DECLARATION_VIEW];
			 }
			 currentTNode = parentTNode;
		  }
		  return notFoundValue;
		}
		function getTNodeFromLView(lView) {
		  const tView = lView[TVIEW];
		  const tViewType = tView.type;
		  if (tViewType === 2) {
			 ngDevMode && assertDefined(tView.declTNode, "Embedded TNodes should have declaration parents.");
			 return tView.declTNode;
		  } else if (tViewType === 1) {
			 return lView[T_HOST];
		  }
		  return null;
		}
		function \u0275\u0275injectAttribute(attrNameToInject) {
		  return injectAttributeImpl(getCurrentTNode(), attrNameToInject);
		}
		var Attribute = makeParamDecorator("Attribute", (attributeName) => ({ attributeName, __NG_ELEMENT_ID__: () => \u0275\u0275injectAttribute(attributeName) }));
		var _reflect = null;
		function getReflect() {
		  return _reflect = _reflect || new ReflectionCapabilities();
		}
		function reflectDependencies(type2) {
		  return convertDependencies(getReflect().parameters(type2));
		}
		function convertDependencies(deps) {
		  return deps.map((dep) => reflectDependency(dep));
		}
		function reflectDependency(dep) {
		  const meta = {
			 token: null,
			 attribute: null,
			 host: false,
			 optional: false,
			 self: false,
			 skipSelf: false
		  };
		  if (Array.isArray(dep) && dep.length > 0) {
			 for (let j = 0; j < dep.length; j++) {
				const param = dep[j];
				if (param === void 0) {
				  continue;
				}
				const proto = Object.getPrototypeOf(param);
				if (param instanceof Optional || proto.ngMetadataName === "Optional") {
				  meta.optional = true;
				} else if (param instanceof SkipSelf || proto.ngMetadataName === "SkipSelf") {
				  meta.skipSelf = true;
				} else if (param instanceof Self || proto.ngMetadataName === "Self") {
				  meta.self = true;
				} else if (param instanceof Host || proto.ngMetadataName === "Host") {
				  meta.host = true;
				} else if (param instanceof Inject) {
				  meta.token = param.token;
				} else if (param instanceof Attribute) {
				  if (param.attributeName === void 0) {
					 throw new RuntimeError(204, ngDevMode && `Attribute name must be defined.`);
				  }
				  meta.attribute = param.attributeName;
				} else {
				  meta.token = param;
				}
			 }
		  } else if (dep === void 0 || Array.isArray(dep) && dep.length === 0) {
			 meta.token = null;
		  } else {
			 meta.token = dep;
		  }
		  return meta;
		}
		function compileInjectable(type2, meta) {
		  let ngInjectableDef = null;
		  let ngFactoryDef = null;
		  if (!type2.hasOwnProperty(NG_PROV_DEF)) {
			 Object.defineProperty(type2, NG_PROV_DEF, {
				get: () => {
				  if (ngInjectableDef === null) {
					 const compiler = getCompilerFacade({ usage: 0, kind: "injectable", type: type2 });
					 ngInjectableDef = compiler.compileInjectable(angularCoreDiEnv, `ng:///${type2.name}/\u0275prov.js`, getInjectableMetadata(type2, meta));
				  }
				  return ngInjectableDef;
				}
			 });
		  }
		  if (!type2.hasOwnProperty(NG_FACTORY_DEF)) {
			 Object.defineProperty(type2, NG_FACTORY_DEF, {
				get: () => {
				  if (ngFactoryDef === null) {
					 const compiler = getCompilerFacade({ usage: 0, kind: "injectable", type: type2 });
					 ngFactoryDef = compiler.compileFactory(angularCoreDiEnv, `ng:///${type2.name}/\u0275fac.js`, {
						name: type2.name,
						type: type2,
						typeArgumentCount: 0,
						// In JIT mode types are not available nor used.
						deps: reflectDependencies(type2),
						target: compiler.FactoryTarget.Injectable
					 });
				  }
				  return ngFactoryDef;
				},
				// Leave this configurable so that the factories from directives or pipes can take precedence.
				configurable: true
			 });
		  }
		}
		var USE_VALUE = getClosureSafeProperty({ provide: String, useValue: getClosureSafeProperty });
		function isUseClassProvider(meta) {
		  return meta.useClass !== void 0;
		}
		function isUseValueProvider(meta) {
		  return USE_VALUE in meta;
		}
		function isUseFactoryProvider(meta) {
		  return meta.useFactory !== void 0;
		}
		function isUseExistingProvider(meta) {
		  return meta.useExisting !== void 0;
		}
		function getInjectableMetadata(type2, srcMeta) {
		  const meta = srcMeta || { providedIn: null };
		  const compilerMeta = {
			 name: type2.name,
			 type: type2,
			 typeArgumentCount: 0,
			 providedIn: meta.providedIn
		  };
		  if ((isUseClassProvider(meta) || isUseFactoryProvider(meta)) && meta.deps !== void 0) {
			 compilerMeta.deps = convertDependencies(meta.deps);
		  }
		  if (isUseClassProvider(meta)) {
			 compilerMeta.useClass = meta.useClass;
		  } else if (isUseValueProvider(meta)) {
			 compilerMeta.useValue = meta.useValue;
		  } else if (isUseFactoryProvider(meta)) {
			 compilerMeta.useFactory = meta.useFactory;
		  } else if (isUseExistingProvider(meta)) {
			 compilerMeta.useExisting = meta.useExisting;
		  }
		  return compilerMeta;
		}
		var Injectable = makeDecorator("Injectable", void 0, void 0, void 0, (type2, meta) => compileInjectable(type2, meta));
		function createInjector(defType, parent = null, additionalProviders = null, name) {
		  const injector = createInjectorWithoutInjectorInstances(defType, parent, additionalProviders, name);
		  injector.resolveInjectorInitializers();
		  return injector;
		}
		function createInjectorWithoutInjectorInstances(defType, parent = null, additionalProviders = null, name, scopes = /* @__PURE__ */ new Set()) {
		  const providers = [
			 additionalProviders || EMPTY_ARRAY,
			 importProvidersFrom(defType)
		  ];
		  name = name || (typeof defType === "object" ? void 0 : stringify(defType));
		  return new R3Injector(providers, parent || getNullInjector(), name || null, scopes);
		}
		var Injector = class _Injector {
		  static {
			 this.THROW_IF_NOT_FOUND = THROW_IF_NOT_FOUND;
		  }
		  static {
			 this.NULL = /* @__PURE__ */ new NullInjector();
		  }
		  static create(options, parent) {
			 if (Array.isArray(options)) {
				return createInjector({ name: "" }, parent, options, "");
			 } else {
				const name = options.name ?? "";
				return createInjector({ name }, options.parent, options.providers, name);
			 }
		  }
		  static {
			 this.\u0275prov = \u0275\u0275defineInjectable({
				token: _Injector,
				providedIn: "any",
				factory: () => \u0275\u0275inject(INJECTOR$1)
			 });
		  }
		  static {
			 this.__NG_ELEMENT_ID__ = -1;
		  }
		};
		var ERROR_ORIGINAL_ERROR = "ngOriginalError";
		function getOriginalError(error) {
		  return error[ERROR_ORIGINAL_ERROR];
		}
		var ErrorHandler = class {
		  constructor() {
			 this._console = console;
		  }
		  handleError(error) {
			 const originalError = this._findOriginalError(error);
			 this._console.error("ERROR", error);
			 if (originalError) {
				this._console.error("ORIGINAL ERROR", originalError);
			 }
		  }
		  /** @internal */
		  _findOriginalError(error) {
			 let e = error && getOriginalError(error);
			 while (e && getOriginalError(e)) {
				e = getOriginalError(e);
			 }
			 return e || null;
		  }
		};
		var INTERNAL_APPLICATION_ERROR_HANDLER = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "internal error handler" : "", {
		  providedIn: "root",
		  factory: () => {
			 const userErrorHandler = inject(ErrorHandler);
			 return userErrorHandler.handleError.bind(void 0);
		  }
		});
		var DestroyRef = class {
		  static {
			 this.__NG_ELEMENT_ID__ = injectDestroyRef;
		  }
		  static {
			 this.__NG_ENV_ID__ = (injector) => injector;
		  }
		};
		var NodeInjectorDestroyRef = class extends DestroyRef {
		  constructor(_lView) {
			 super();
			 this._lView = _lView;
		  }
		  onDestroy(callback) {
			 storeLViewOnDestroy(this._lView, callback);
			 return () => removeLViewOnDestroy(this._lView, callback);
		  }
		};
		function injectDestroyRef() {
		  return new NodeInjectorDestroyRef(getLView());
		}
		var OutputEmitterRef = class {
		  constructor() {
			 this.destroyed = false;
			 this.listeners = null;
			 this.errorHandler = inject(ErrorHandler, { optional: true });
			 this.destroyRef = inject(DestroyRef);
			 this.destroyRef.onDestroy(() => {
				this.destroyed = true;
				this.listeners = null;
			 });
		  }
		  subscribe(callback) {
			 if (this.destroyed) {
				throw new RuntimeError(953, ngDevMode && "Unexpected subscription to destroyed `OutputRef`. The owning directive/component is destroyed.");
			 }
			 (this.listeners ??= []).push(callback);
			 return {
				unsubscribe: () => {
				  const idx = this.listeners?.indexOf(callback);
				  if (idx !== void 0 && idx !== -1) {
					 this.listeners?.splice(idx, 1);
				  }
				}
			 };
		  }
		  /** Emits a new value to the output. */
		  emit(value) {
			 if (this.destroyed) {
				throw new RuntimeError(953, ngDevMode && "Unexpected emit for destroyed `OutputRef`. The owning directive/component is destroyed.");
			 }
			 if (this.listeners === null) {
				return;
			 }
			 const previousConsumer = setActiveConsumer(null);
			 try {
				for (const listenerFn of this.listeners) {
				  try {
					 listenerFn(value);
				  } catch (err) {
					 this.errorHandler?.handleError(err);
				  }
				}
			 } finally {
				setActiveConsumer(previousConsumer);
			 }
		  }
		};
		function inputFunction(initialValue, opts) {
		  ngDevMode && assertInInjectionContext(input);
		  return createInputSignal(initialValue, opts);
		}
		function inputRequiredFunction(opts) {
		  ngDevMode && assertInInjectionContext(input);
		  return createInputSignal(REQUIRED_UNSET_VALUE, opts);
		}
		var input = (() => {
		  inputFunction.required = inputRequiredFunction;
		  return inputFunction;
		})();
		function injectElementRef() {
		  return createElementRef(getCurrentTNode(), getLView());
		}
		function createElementRef(tNode, lView) {
		  return new ElementRef(getNativeByTNode(tNode, lView));
		}
		var ElementRef = class {
		  constructor(nativeElement) {
			 this.nativeElement = nativeElement;
		  }
		  static {
			 this.__NG_ELEMENT_ID__ = injectElementRef;
		  }
		};
		function unwrapElementRef(value) {
		  return value instanceof ElementRef ? value.nativeElement : value;
		}
		var EventEmitter_ = class extends Subject {
		  constructor(isAsync = false) {
			 super();
			 this.destroyRef = void 0;
			 this.__isAsync = isAsync;
			 if (isInInjectionContext()) {
				this.destroyRef = inject(DestroyRef, { optional: true }) ?? void 0;
			 }
		  }
		  emit(value) {
			 const prevConsumer = setActiveConsumer(null);
			 try {
				super.next(value);
			 } finally {
				setActiveConsumer(prevConsumer);
			 }
		  }
		  subscribe(observerOrNext, error, complete) {
			 let nextFn = observerOrNext;
			 let errorFn = error || (() => null);
			 let completeFn = complete;
			 if (observerOrNext && typeof observerOrNext === "object") {
				const observer = observerOrNext;
				nextFn = observer.next?.bind(observer);
				errorFn = observer.error?.bind(observer);
				completeFn = observer.complete?.bind(observer);
			 }
			 if (this.__isAsync) {
				errorFn = _wrapInTimeout(errorFn);
				if (nextFn) {
				  nextFn = _wrapInTimeout(nextFn);
				}
				if (completeFn) {
				  completeFn = _wrapInTimeout(completeFn);
				}
			 }
			 const sink = super.subscribe({ next: nextFn, error: errorFn, complete: completeFn });
			 if (observerOrNext instanceof Subscription) {
				observerOrNext.add(sink);
			 }
			 return sink;
		  }
		};
		function _wrapInTimeout(fn) {
		  return (value) => {
			 setTimeout(fn, void 0, value);
		  };
		}
		var EventEmitter = EventEmitter_;
		function symbolIterator() {
		  return this._results[Symbol.iterator]();
		}
		var QueryList = class _QueryList {
		  static {
			 Symbol.iterator;
		  }
		  /**
			* Returns `Observable` of `QueryList` notifying the subscriber of changes.
			*/
		  get changes() {
			 return this._changes ??= new EventEmitter();
		  }
		  /**
			* @param emitDistinctChangesOnly Whether `QueryList.changes` should fire only when actual change
			*     has occurred. Or if it should fire when query is recomputed. (recomputing could resolve in
			*     the same result)
			*/
		  constructor(_emitDistinctChangesOnly = false) {
			 this._emitDistinctChangesOnly = _emitDistinctChangesOnly;
			 this.dirty = true;
			 this._onDirty = void 0;
			 this._results = [];
			 this._changesDetected = false;
			 this._changes = void 0;
			 this.length = 0;
			 this.first = void 0;
			 this.last = void 0;
			 const proto = _QueryList.prototype;
			 if (!proto[Symbol.iterator])
				proto[Symbol.iterator] = symbolIterator;
		  }
		  /**
			* Returns the QueryList entry at `index`.
			*/
		  get(index) {
			 return this._results[index];
		  }
		  /**
			* See
			* [Array.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)
			*/
		  map(fn) {
			 return this._results.map(fn);
		  }
		  filter(fn) {
			 return this._results.filter(fn);
		  }
		  /**
			* See
			* [Array.find](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find)
			*/
		  find(fn) {
			 return this._results.find(fn);
		  }
		  /**
			* See
			* [Array.reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)
			*/
		  reduce(fn, init2) {
			 return this._results.reduce(fn, init2);
		  }
		  /**
			* See
			* [Array.forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)
			*/
		  forEach(fn) {
			 this._results.forEach(fn);
		  }
		  /**
			* See
			* [Array.some](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some)
			*/
		  some(fn) {
			 return this._results.some(fn);
		  }
		  /**
			* Returns a copy of the internal results list as an Array.
			*/
		  toArray() {
			 return this._results.slice();
		  }
		  toString() {
			 return this._results.toString();
		  }
		  /**
			* Updates the stored data of the query list, and resets the `dirty` flag to `false`, so that
			* on change detection, it will not notify of changes to the queries, unless a new change
			* occurs.
			*
			* @param resultsTree The query results to store
			* @param identityAccessor Optional function for extracting stable object identity from a value
			*    in the array. This function is executed for each element of the query result list while
			*    comparing current query list with the new one (provided as a first argument of the `reset`
			*    function) to detect if the lists are different. If the function is not provided, elements
			*    are compared as is (without any pre-processing).
			*/
		  reset(resultsTree, identityAccessor) {
			 this.dirty = false;
			 const newResultFlat = flatten(resultsTree);
			 if (this._changesDetected = !arrayEquals(this._results, newResultFlat, identityAccessor)) {
				this._results = newResultFlat;
				this.length = newResultFlat.length;
				this.last = newResultFlat[this.length - 1];
				this.first = newResultFlat[0];
			 }
		  }
		  /**
			* Triggers a change event by emitting on the `changes` {@link EventEmitter}.
			*/
		  notifyOnChanges() {
			 if (this._changes !== void 0 && (this._changesDetected || !this._emitDistinctChangesOnly))
				this._changes.emit(this);
		  }
		  /** @internal */
		  onDirty(cb) {
			 this._onDirty = cb;
		  }
		  /** internal */
		  setDirty() {
			 this.dirty = true;
			 this._onDirty?.();
		  }
		  /** internal */
		  destroy() {
			 if (this._changes !== void 0) {
				this._changes.complete();
				this._changes.unsubscribe();
			 }
		  }
		};
		function hasInSkipHydrationBlockFlag(tNode) {
		  return (tNode.flags & 128) === 128;
		}
		var TRACKED_LVIEWS = /* @__PURE__ */ new Map();
		var uniqueIdCounter = 0;
		function getUniqueLViewId() {
		  return uniqueIdCounter++;
		}
		function registerLView(lView) {
		  ngDevMode && assertNumber(lView[ID], "LView must have an ID in order to be registered");
		  TRACKED_LVIEWS.set(lView[ID], lView);
		}
		function getLViewById(id3) {
		  ngDevMode && assertNumber(id3, "ID used for LView lookup must be a number");
		  return TRACKED_LVIEWS.get(id3) || null;
		}
		function unregisterLView(lView) {
		  ngDevMode && assertNumber(lView[ID], "Cannot stop tracking an LView that does not have an ID");
		  TRACKED_LVIEWS.delete(lView[ID]);
		}
		var LContext = class {
		  /** Component's parent view data. */
		  get lView() {
			 return getLViewById(this.lViewId);
		  }
		  constructor(lViewId, nodeIndex, native) {
			 this.lViewId = lViewId;
			 this.nodeIndex = nodeIndex;
			 this.native = native;
		  }
		};
		function getLContext(target) {
		  let mpValue = readPatchedData(target);
		  if (mpValue) {
			 if (isLView(mpValue)) {
				const lView = mpValue;
				let nodeIndex;
				let component = void 0;
				let directives = void 0;
				if (isComponentInstance(target)) {
				  nodeIndex = findViaComponent(lView, target);
				  if (nodeIndex == -1) {
					 throw new Error("The provided component was not found in the application");
				  }
				  component = target;
				} else if (isDirectiveInstance(target)) {
				  nodeIndex = findViaDirective(lView, target);
				  if (nodeIndex == -1) {
					 throw new Error("The provided directive was not found in the application");
				  }
				  directives = getDirectivesAtNodeIndex(nodeIndex, lView);
				} else {
				  nodeIndex = findViaNativeElement(lView, target);
				  if (nodeIndex == -1) {
					 return null;
				  }
				}
				const native = unwrapRNode(lView[nodeIndex]);
				const existingCtx = readPatchedData(native);
				const context2 = existingCtx && !Array.isArray(existingCtx) ? existingCtx : createLContext(lView, nodeIndex, native);
				if (component && context2.component === void 0) {
				  context2.component = component;
				  attachPatchData(context2.component, context2);
				}
				if (directives && context2.directives === void 0) {
				  context2.directives = directives;
				  for (let i = 0; i < directives.length; i++) {
					 attachPatchData(directives[i], context2);
				  }
				}
				attachPatchData(context2.native, context2);
				mpValue = context2;
			 }
		  } else {
			 const rElement = target;
			 ngDevMode && assertDomNode(rElement);
			 let parent = rElement;
			 while (parent = parent.parentNode) {
				const parentContext = readPatchedData(parent);
				if (parentContext) {
				  const lView = Array.isArray(parentContext) ? parentContext : parentContext.lView;
				  if (!lView) {
					 return null;
				  }
				  const index = findViaNativeElement(lView, rElement);
				  if (index >= 0) {
					 const native = unwrapRNode(lView[index]);
					 const context2 = createLContext(lView, index, native);
					 attachPatchData(native, context2);
					 mpValue = context2;
					 break;
				  }
				}
			 }
		  }
		  return mpValue || null;
		}
		function createLContext(lView, nodeIndex, native) {
		  return new LContext(lView[ID], nodeIndex, native);
		}
		function getComponentViewByInstance(componentInstance) {
		  let patchedData = readPatchedData(componentInstance);
		  let lView;
		  if (isLView(patchedData)) {
			 const contextLView = patchedData;
			 const nodeIndex = findViaComponent(contextLView, componentInstance);
			 lView = getComponentLViewByIndex(nodeIndex, contextLView);
			 const context2 = createLContext(contextLView, nodeIndex, lView[HOST]);
			 context2.component = componentInstance;
			 attachPatchData(componentInstance, context2);
			 attachPatchData(context2.native, context2);
		  } else {
			 const context2 = patchedData;
			 const contextLView = context2.lView;
			 ngDevMode && assertLView(contextLView);
			 lView = getComponentLViewByIndex(context2.nodeIndex, contextLView);
		  }
		  return lView;
		}
		var MONKEY_PATCH_KEY_NAME = "__ngContext__";
		function attachPatchData(target, data) {
		  ngDevMode && assertDefined(target, "Target expected");
		  if (isLView(data)) {
			 target[MONKEY_PATCH_KEY_NAME] = data[ID];
			 registerLView(data);
		  } else {
			 target[MONKEY_PATCH_KEY_NAME] = data;
		  }
		}
		function readPatchedData(target) {
		  ngDevMode && assertDefined(target, "Target expected");
		  const data = target[MONKEY_PATCH_KEY_NAME];
		  return typeof data === "number" ? getLViewById(data) : data || null;
		}
		function readPatchedLView(target) {
		  const value = readPatchedData(target);
		  if (value) {
			 return isLView(value) ? value : value.lView;
		  }
		  return null;
		}
		function isComponentInstance(instance) {
		  return instance && instance.constructor && instance.constructor.\u0275cmp;
		}
		function isDirectiveInstance(instance) {
		  return instance && instance.constructor && instance.constructor.\u0275dir;
		}
		function findViaNativeElement(lView, target) {
		  const tView = lView[TVIEW];
		  for (let i = HEADER_OFFSET; i < tView.bindingStartIndex; i++) {
			 if (unwrapRNode(lView[i]) === target) {
				return i;
			 }
		  }
		  return -1;
		}
		function traverseNextElement(tNode) {
		  if (tNode.child) {
			 return tNode.child;
		  } else if (tNode.next) {
			 return tNode.next;
		  } else {
			 while (tNode.parent && !tNode.parent.next) {
				tNode = tNode.parent;
			 }
			 return tNode.parent && tNode.parent.next;
		  }
		}
		function findViaComponent(lView, componentInstance) {
		  const componentIndices = lView[TVIEW].components;
		  if (componentIndices) {
			 for (let i = 0; i < componentIndices.length; i++) {
				const elementComponentIndex = componentIndices[i];
				const componentView = getComponentLViewByIndex(elementComponentIndex, lView);
				if (componentView[CONTEXT] === componentInstance) {
				  return elementComponentIndex;
				}
			 }
		  } else {
			 const rootComponentView = getComponentLViewByIndex(HEADER_OFFSET, lView);
			 const rootComponent = rootComponentView[CONTEXT];
			 if (rootComponent === componentInstance) {
				return HEADER_OFFSET;
			 }
		  }
		  return -1;
		}
		function findViaDirective(lView, directiveInstance) {
		  let tNode = lView[TVIEW].firstChild;
		  while (tNode) {
			 const directiveIndexStart = tNode.directiveStart;
			 const directiveIndexEnd = tNode.directiveEnd;
			 for (let i = directiveIndexStart; i < directiveIndexEnd; i++) {
				if (lView[i] === directiveInstance) {
				  return tNode.index;
				}
			 }
			 tNode = traverseNextElement(tNode);
		  }
		  return -1;
		}
		function getDirectivesAtNodeIndex(nodeIndex, lView) {
		  const tNode = lView[TVIEW].data[nodeIndex];
		  if (tNode.directiveStart === 0)
			 return EMPTY_ARRAY;
		  const results = [];
		  for (let i = tNode.directiveStart; i < tNode.directiveEnd; i++) {
			 const directiveInstance = lView[i];
			 if (!isComponentInstance(directiveInstance)) {
				results.push(directiveInstance);
			 }
		  }
		  return results;
		}
		function getComponentAtNodeIndex(nodeIndex, lView) {
		  const tNode = lView[TVIEW].data[nodeIndex];
		  const { directiveStart, componentOffset } = tNode;
		  return componentOffset > -1 ? lView[directiveStart + componentOffset] : null;
		}
		function getRootView(componentOrLView) {
		  ngDevMode && assertDefined(componentOrLView, "component");
		  let lView = isLView(componentOrLView) ? componentOrLView : readPatchedLView(componentOrLView);
		  while (lView && !(lView[FLAGS] & 512)) {
			 lView = getLViewParent(lView);
		  }
		  ngDevMode && assertLView(lView);
		  return lView;
		}
		function getRootContext(viewOrComponent) {
		  const rootView = getRootView(viewOrComponent);
		  ngDevMode && assertDefined(rootView[CONTEXT], "Root view has no context. Perhaps it is disconnected?");
		  return rootView[CONTEXT];
		}
		function getFirstLContainer(lView) {
		  return getNearestLContainer(lView[CHILD_HEAD]);
		}
		function getNextLContainer(container) {
		  return getNearestLContainer(container[NEXT]);
		}
		function getNearestLContainer(viewOrContainer) {
		  while (viewOrContainer !== null && !isLContainer(viewOrContainer)) {
			 viewOrContainer = viewOrContainer[NEXT];
		  }
		  return viewOrContainer;
		}
		function getComponent$1(element) {
		  ngDevMode && assertDomElement(element);
		  const context2 = getLContext(element);
		  if (context2 === null)
			 return null;
		  if (context2.component === void 0) {
			 const lView = context2.lView;
			 if (lView === null) {
				return null;
			 }
			 context2.component = getComponentAtNodeIndex(context2.nodeIndex, lView);
		  }
		  return context2.component;
		}
		function getContext(element) {
		  assertDomElement(element);
		  const context2 = getLContext(element);
		  const lView = context2 ? context2.lView : null;
		  return lView === null ? null : lView[CONTEXT];
		}
		function getOwningComponent(elementOrDir) {
		  const context2 = getLContext(elementOrDir);
		  let lView = context2 ? context2.lView : null;
		  if (lView === null)
			 return null;
		  let parent;
		  while (lView[TVIEW].type === 2 && (parent = getLViewParent(lView))) {
			 lView = parent;
		  }
		  return lView[FLAGS] & 512 ? null : lView[CONTEXT];
		}
		function getRootComponents(elementOrDir) {
		  const lView = readPatchedLView(elementOrDir);
		  return lView !== null ? [getRootContext(lView)] : [];
		}
		function getInjector(elementOrDir) {
		  const context2 = getLContext(elementOrDir);
		  const lView = context2 ? context2.lView : null;
		  if (lView === null)
			 return Injector.NULL;
		  const tNode = lView[TVIEW].data[context2.nodeIndex];
		  return new NodeInjector(tNode, lView);
		}
		function getDirectives(node) {
		  if (node instanceof Text) {
			 return [];
		  }
		  const context2 = getLContext(node);
		  const lView = context2 ? context2.lView : null;
		  if (lView === null) {
			 return [];
		  }
		  const tView = lView[TVIEW];
		  const nodeIndex = context2.nodeIndex;
		  if (!tView?.data[nodeIndex]) {
			 return [];
		  }
		  if (context2.directives === void 0) {
			 context2.directives = getDirectivesAtNodeIndex(nodeIndex, lView);
		  }
		  return context2.directives === null ? [] : [...context2.directives];
		}
		function getDirectiveMetadata$1(directiveOrComponentInstance) {
		  const { constructor } = directiveOrComponentInstance;
		  if (!constructor) {
			 throw new Error("Unable to find the instance constructor");
		  }
		  const componentDef = getComponentDef(constructor);
		  if (componentDef) {
			 const inputs = extractInputDebugMetadata(componentDef.inputs);
			 return {
				inputs,
				outputs: componentDef.outputs,
				encapsulation: componentDef.encapsulation,
				changeDetection: componentDef.onPush ? ChangeDetectionStrategy.OnPush : ChangeDetectionStrategy.Default
			 };
		  }
		  const directiveDef = getDirectiveDef(constructor);
		  if (directiveDef) {
			 const inputs = extractInputDebugMetadata(directiveDef.inputs);
			 return { inputs, outputs: directiveDef.outputs };
		  }
		  return null;
		}
		function getHostElement(componentOrDirective) {
		  return getLContext(componentOrDirective).native;
		}
		function getListeners(element) {
		  ngDevMode && assertDomElement(element);
		  const lContext = getLContext(element);
		  const lView = lContext === null ? null : lContext.lView;
		  if (lView === null)
			 return [];
		  const tView = lView[TVIEW];
		  const lCleanup = lView[CLEANUP];
		  const tCleanup = tView.cleanup;
		  const listeners = [];
		  if (tCleanup && lCleanup) {
			 for (let i = 0; i < tCleanup.length; ) {
				const firstParam = tCleanup[i++];
				const secondParam = tCleanup[i++];
				if (typeof firstParam === "string") {
				  const name = firstParam;
				  const listenerElement = unwrapRNode(lView[secondParam]);
				  const callback = lCleanup[tCleanup[i++]];
				  const useCaptureOrIndx = tCleanup[i++];
				  const type2 = typeof useCaptureOrIndx === "boolean" || useCaptureOrIndx >= 0 ? "dom" : "output";
				  const useCapture = typeof useCaptureOrIndx === "boolean" ? useCaptureOrIndx : false;
				  if (element == listenerElement) {
					 listeners.push({ element, name, callback, useCapture, type: type2 });
				  }
				}
			 }
		  }
		  listeners.sort(sortListeners);
		  return listeners;
		}
		function sortListeners(a, b) {
		  if (a.name == b.name)
			 return 0;
		  return a.name < b.name ? -1 : 1;
		}
		function assertDomElement(value) {
		  if (typeof Element !== "undefined" && !(value instanceof Element)) {
			 throw new Error("Expecting instance of DOM Element");
		  }
		}
		function extractInputDebugMetadata(inputs) {
		  const res = {};
		  for (const key in inputs) {
			 if (!inputs.hasOwnProperty(key)) {
				continue;
			 }
			 const value = inputs[key];
			 if (value === void 0) {
				continue;
			 }
			 let minifiedName;
			 if (Array.isArray(value)) {
				minifiedName = value[0];
			 } else {
				minifiedName = value;
			 }
			 res[key] = minifiedName;
		  }
		  return res;
		}
		var DOCUMENT = void 0;
		function setDocument(document2) {
		  DOCUMENT = document2;
		}
		function getDocument() {
		  if (DOCUMENT !== void 0) {
			 return DOCUMENT;
		  } else if (typeof document !== "undefined") {
			 return document;
		  }
		  throw new RuntimeError(210, (typeof ngDevMode === "undefined" || ngDevMode) && `The document object is not available in this context. Make sure the DOCUMENT injection token is provided.`);
		}
		var APP_ID = new InjectionToken(ngDevMode ? "AppId" : "", {
		  providedIn: "root",
		  factory: () => DEFAULT_APP_ID
		});
		var DEFAULT_APP_ID = "ng";
		var PLATFORM_INITIALIZER = new InjectionToken(ngDevMode ? "Platform Initializer" : "");
		var PLATFORM_ID = new InjectionToken(ngDevMode ? "Platform ID" : "", {
		  providedIn: "platform",
		  factory: () => "unknown"
		  // set a default platform name, when none set explicitly
		});
		var PACKAGE_ROOT_URL = new InjectionToken(ngDevMode ? "Application Packages Root URL" : "");
		var ANIMATION_MODULE_TYPE = new InjectionToken(ngDevMode ? "AnimationModuleType" : "");
		var CSP_NONCE = new InjectionToken(ngDevMode ? "CSP nonce" : "", {
		  providedIn: "root",
		  factory: () => {
			 return getDocument().body?.querySelector("[ngCspNonce]")?.getAttribute("ngCspNonce") || null;
		  }
		});
		var IMAGE_CONFIG_DEFAULTS = {
		  breakpoints: [16, 32, 48, 64, 96, 128, 256, 384, 640, 750, 828, 1080, 1200, 1920, 2048, 3840],
		  placeholderResolution: 30,
		  disableImageSizeWarning: false,
		  disableImageLazyLoadWarning: false
		};
		var IMAGE_CONFIG = new InjectionToken(ngDevMode ? "ImageConfig" : "", { providedIn: "root", factory: () => IMAGE_CONFIG_DEFAULTS });
		function makeStateKey(key) {
		  return key;
		}
		function initTransferState() {
		  const transferState = new TransferState();
		  if (inject(PLATFORM_ID) === "browser") {
			 transferState.store = retrieveTransferredState(getDocument(), inject(APP_ID));
		  }
		  return transferState;
		}
		var TransferState = class _TransferState {
		  constructor() {
			 this.store = {};
			 this.onSerializeCallbacks = {};
		  }
		  static {
			 this.\u0275prov = /** @pureOrBreakMyCode */
			 \u0275\u0275defineInjectable({
				token: _TransferState,
				providedIn: "root",
				factory: initTransferState
			 });
		  }
		  /**
			* Get the value corresponding to a key. Return `defaultValue` if key is not found.
			*/
		  get(key, defaultValue) {
			 return this.store[key] !== void 0 ? this.store[key] : defaultValue;
		  }
		  /**
			* Set the value corresponding to a key.
			*/
		  set(key, value) {
			 this.store[key] = value;
		  }
		  /**
			* Remove a key from the store.
			*/
		  remove(key) {
			 delete this.store[key];
		  }
		  /**
			* Test whether a key exists in the store.
			*/
		  hasKey(key) {
			 return this.store.hasOwnProperty(key);
		  }
		  /**
			* Indicates whether the state is empty.
			*/
		  get isEmpty() {
			 return Object.keys(this.store).length === 0;
		  }
		  /**
			* Register a callback to provide the value for a key when `toJson` is called.
			*/
		  onSerialize(key, callback) {
			 this.onSerializeCallbacks[key] = callback;
		  }
		  /**
			* Serialize the current state of the store to JSON.
			*/
		  toJson() {
			 for (const key in this.onSerializeCallbacks) {
				if (this.onSerializeCallbacks.hasOwnProperty(key)) {
				  try {
					 this.store[key] = this.onSerializeCallbacks[key]();
				  } catch (e) {
					 console.warn("Exception in onSerialize callback: ", e);
				  }
				}
			 }
			 return JSON.stringify(this.store).replace(/</g, "\\u003C");
		  }
		};
		function retrieveTransferredState(doc, appId) {
		  const script = doc.getElementById(appId + "-state");
		  if (script?.textContent) {
			 try {
				return JSON.parse(script.textContent);
			 } catch (e) {
				console.warn("Exception while restoring TransferState for app " + appId, e);
			 }
		  }
		  return {};
		}
		var REFERENCE_NODE_HOST = "h";
		var REFERENCE_NODE_BODY = "b";
		var NodeNavigationStep;
		(function(NodeNavigationStep2) {
		  NodeNavigationStep2["FirstChild"] = "f";
		  NodeNavigationStep2["NextSibling"] = "n";
		})(NodeNavigationStep || (NodeNavigationStep = {}));
		var TRANSFER_STATE_TOKEN_ID = "__nghData__";
		var NGH_DATA_KEY = makeStateKey(TRANSFER_STATE_TOKEN_ID);
		var _retrieveHydrationInfoImpl = () => null;
		function retrieveHydrationInfo(rNode, injector, isRootView2 = false) {
		  return _retrieveHydrationInfoImpl(rNode, injector, isRootView2);
		}
		var HydrationStatus;
		(function(HydrationStatus2) {
		  HydrationStatus2["Hydrated"] = "hydrated";
		  HydrationStatus2["Skipped"] = "skipped";
		  HydrationStatus2["Mismatched"] = "mismatched";
		})(HydrationStatus || (HydrationStatus = {}));
		var IS_HYDRATION_DOM_REUSE_ENABLED = new InjectionToken(typeof ngDevMode === "undefined" || !!ngDevMode ? "IS_HYDRATION_DOM_REUSE_ENABLED" : "");
		var PRESERVE_HOST_CONTENT_DEFAULT = false;
		var PRESERVE_HOST_CONTENT = new InjectionToken(typeof ngDevMode === "undefined" || !!ngDevMode ? "PRESERVE_HOST_CONTENT" : "", {
		  providedIn: "root",
		  factory: () => PRESERVE_HOST_CONTENT_DEFAULT
		});
		var IS_I18N_HYDRATION_ENABLED = new InjectionToken(typeof ngDevMode === "undefined" || !!ngDevMode ? "IS_I18N_HYDRATION_ENABLED" : "");
		var policy$1;
		function getPolicy$1() {
		  if (policy$1 === void 0) {
			 policy$1 = null;
			 if (_global.trustedTypes) {
				try {
				  policy$1 = _global.trustedTypes.createPolicy("angular", {
					 createHTML: (s) => s,
					 createScript: (s) => s,
					 createScriptURL: (s) => s
				  });
				} catch {
				}
			 }
		  }
		  return policy$1;
		}
		function trustedHTMLFromString(html) {
		  return getPolicy$1()?.createHTML(html) || html;
		}
		function trustedScriptURLFromString(url) {
		  return getPolicy$1()?.createScriptURL(url) || url;
		}
		var policy;
		function getPolicy() {
		  if (policy === void 0) {
			 policy = null;
			 if (_global.trustedTypes) {
				try {
				  policy = _global.trustedTypes.createPolicy("angular#unsafe-bypass", {
					 createHTML: (s) => s,
					 createScript: (s) => s,
					 createScriptURL: (s) => s
				  });
				} catch {
				}
			 }
		  }
		  return policy;
		}
		function trustedHTMLFromStringBypass(html) {
		  return getPolicy()?.createHTML(html) || html;
		}
		function trustedScriptFromStringBypass(script) {
		  return getPolicy()?.createScript(script) || script;
		}
		function trustedScriptURLFromStringBypass(url) {
		  return getPolicy()?.createScriptURL(url) || url;
		}
		var SafeValueImpl = class {
		  constructor(changingThisBreaksApplicationSecurity) {
			 this.changingThisBreaksApplicationSecurity = changingThisBreaksApplicationSecurity;
		  }
		  toString() {
			 return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see ${XSS_SECURITY_URL})`;
		  }
		};
		var SafeHtmlImpl = class extends SafeValueImpl {
		  getTypeName() {
			 return "HTML";
		  }
		};
		var SafeStyleImpl = class extends SafeValueImpl {
		  getTypeName() {
			 return "Style";
		  }
		};
		var SafeScriptImpl = class extends SafeValueImpl {
		  getTypeName() {
			 return "Script";
		  }
		};
		var SafeUrlImpl = class extends SafeValueImpl {
		  getTypeName() {
			 return "URL";
		  }
		};
		var SafeResourceUrlImpl = class extends SafeValueImpl {
		  getTypeName() {
			 return "ResourceURL";
		  }
		};
		function unwrapSafeValue(value) {
		  return value instanceof SafeValueImpl ? value.changingThisBreaksApplicationSecurity : value;
		}
		function allowSanitizationBypassAndThrow(value, type2) {
		  const actualType = getSanitizationBypassType(value);
		  if (actualType != null && actualType !== type2) {
			 if (actualType === "ResourceURL" && type2 === "URL")
				return true;
			 throw new Error(`Required a safe ${type2}, got a ${actualType} (see ${XSS_SECURITY_URL})`);
		  }
		  return actualType === type2;
		}
		function getSanitizationBypassType(value) {
		  return value instanceof SafeValueImpl && value.getTypeName() || null;
		}
		function bypassSanitizationTrustHtml(trustedHtml) {
		  return new SafeHtmlImpl(trustedHtml);
		}
		function bypassSanitizationTrustStyle(trustedStyle) {
		  return new SafeStyleImpl(trustedStyle);
		}
		function bypassSanitizationTrustScript(trustedScript) {
		  return new SafeScriptImpl(trustedScript);
		}
		function bypassSanitizationTrustUrl(trustedUrl) {
		  return new SafeUrlImpl(trustedUrl);
		}
		function bypassSanitizationTrustResourceUrl(trustedResourceUrl) {
		  return new SafeResourceUrlImpl(trustedResourceUrl);
		}
		function getInertBodyHelper(defaultDoc) {
		  const inertDocumentHelper = new InertDocumentHelper(defaultDoc);
		  return isDOMParserAvailable() ? new DOMParserHelper(inertDocumentHelper) : inertDocumentHelper;
		}
		var DOMParserHelper = class {
		  constructor(inertDocumentHelper) {
			 this.inertDocumentHelper = inertDocumentHelper;
		  }
		  getInertBodyElement(html) {
			 html = "<body><remove></remove>" + html;
			 try {
				const body = new window.DOMParser().parseFromString(trustedHTMLFromString(html), "text/html").body;
				if (body === null) {
				  return this.inertDocumentHelper.getInertBodyElement(html);
				}
				body.removeChild(body.firstChild);
				return body;
			 } catch {
				return null;
			 }
		  }
		};
		var InertDocumentHelper = class {
		  constructor(defaultDoc) {
			 this.defaultDoc = defaultDoc;
			 this.inertDocument = this.defaultDoc.implementation.createHTMLDocument("sanitization-inert");
		  }
		  getInertBodyElement(html) {
			 const templateEl = this.inertDocument.createElement("template");
			 templateEl.innerHTML = trustedHTMLFromString(html);
			 return templateEl;
		  }
		};
		function isDOMParserAvailable() {
		  try {
			 return !!new window.DOMParser().parseFromString(trustedHTMLFromString(""), "text/html");
		  } catch {
			 return false;
		  }
		}
		var SAFE_URL_PATTERN = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:\/?#]*(?:[\/?#]|$))/i;
		function _sanitizeUrl(url) {
		  url = String(url);
		  if (url.match(SAFE_URL_PATTERN))
			 return url;
		  if (typeof ngDevMode === "undefined" || ngDevMode) {
			 console.warn(`WARNING: sanitizing unsafe URL value ${url} (see ${XSS_SECURITY_URL})`);
		  }
		  return "unsafe:" + url;
		}
		function tagSet(tags) {
		  const res = {};
		  for (const t of tags.split(","))
			 res[t] = true;
		  return res;
		}
		function merge2(...sets) {
		  const res = {};
		  for (const s of sets) {
			 for (const v in s) {
				if (s.hasOwnProperty(v))
				  res[v] = true;
			 }
		  }
		  return res;
		}
		var VOID_ELEMENTS = tagSet("area,br,col,hr,img,wbr");
		var OPTIONAL_END_TAG_BLOCK_ELEMENTS = tagSet("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr");
		var OPTIONAL_END_TAG_INLINE_ELEMENTS = tagSet("rp,rt");
		var OPTIONAL_END_TAG_ELEMENTS = merge2(OPTIONAL_END_TAG_INLINE_ELEMENTS, OPTIONAL_END_TAG_BLOCK_ELEMENTS);
		var BLOCK_ELEMENTS = merge2(OPTIONAL_END_TAG_BLOCK_ELEMENTS, tagSet("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul"));
		var INLINE_ELEMENTS = merge2(OPTIONAL_END_TAG_INLINE_ELEMENTS, tagSet("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video"));
		var VALID_ELEMENTS = merge2(VOID_ELEMENTS, BLOCK_ELEMENTS, INLINE_ELEMENTS, OPTIONAL_END_TAG_ELEMENTS);
		var URI_ATTRS = tagSet("background,cite,href,itemtype,longdesc,poster,src,xlink:href");
		var HTML_ATTRS = tagSet("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,srcset,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width");
		var ARIA_ATTRS = tagSet("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext");
		var VALID_ATTRS = merge2(URI_ATTRS, HTML_ATTRS, ARIA_ATTRS);
		var SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS = tagSet("script,style,template");
		var SanitizingHtmlSerializer = class {
		  constructor() {
			 this.sanitizedSomething = false;
			 this.buf = [];
		  }
		  sanitizeChildren(el) {
			 let current = el.firstChild;
			 let traverseContent = true;
			 let parentNodes = [];
			 while (current) {
				if (current.nodeType === Node.ELEMENT_NODE) {
				  traverseContent = this.startElement(current);
				} else if (current.nodeType === Node.TEXT_NODE) {
				  this.chars(current.nodeValue);
				} else {
				  this.sanitizedSomething = true;
				}
				if (traverseContent && current.firstChild) {
				  parentNodes.push(current);
				  current = getFirstChild(current);
				  continue;
				}
				while (current) {
				  if (current.nodeType === Node.ELEMENT_NODE) {
					 this.endElement(current);
				  }
				  let next = getNextSibling(current);
				  if (next) {
					 current = next;
					 break;
				  }
				  current = parentNodes.pop();
				}
			 }
			 return this.buf.join("");
		  }
		  /**
			* Sanitizes an opening element tag (if valid) and returns whether the element's contents should
			* be traversed. Element content must always be traversed (even if the element itself is not
			* valid/safe), unless the element is one of `SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS`.
			*
			* @param element The element to sanitize.
			* @return True if the element's contents should be traversed.
			*/
		  startElement(element) {
			 const tagName = getNodeName(element).toLowerCase();
			 if (!VALID_ELEMENTS.hasOwnProperty(tagName)) {
				this.sanitizedSomething = true;
				return !SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS.hasOwnProperty(tagName);
			 }
			 this.buf.push("<");
			 this.buf.push(tagName);
			 const elAttrs = element.attributes;
			 for (let i = 0; i < elAttrs.length; i++) {
				const elAttr = elAttrs.item(i);
				const attrName = elAttr.name;
				const lower2 = attrName.toLowerCase();
				if (!VALID_ATTRS.hasOwnProperty(lower2)) {
				  this.sanitizedSomething = true;
				  continue;
				}
				let value = elAttr.value;
				if (URI_ATTRS[lower2])
				  value = _sanitizeUrl(value);
				this.buf.push(" ", attrName, '="', encodeEntities(value), '"');
			 }
			 this.buf.push(">");
			 return true;
		  }
		  endElement(current) {
			 const tagName = getNodeName(current).toLowerCase();
			 if (VALID_ELEMENTS.hasOwnProperty(tagName) && !VOID_ELEMENTS.hasOwnProperty(tagName)) {
				this.buf.push("</");
				this.buf.push(tagName);
				this.buf.push(">");
			 }
		  }
		  chars(chars) {
			 this.buf.push(encodeEntities(chars));
		  }
		};
		function isClobberedElement(parentNode, childNode) {
		  return (parentNode.compareDocumentPosition(childNode) & Node.DOCUMENT_POSITION_CONTAINED_BY) !== Node.DOCUMENT_POSITION_CONTAINED_BY;
		}
		function getNextSibling(node) {
		  const nextSibling = node.nextSibling;
		  if (nextSibling && node !== nextSibling.previousSibling) {
			 throw clobberedElementError(nextSibling);
		  }
		  return nextSibling;
		}
		function getFirstChild(node) {
		  const firstChild = node.firstChild;
		  if (firstChild && isClobberedElement(node, firstChild)) {
			 throw clobberedElementError(firstChild);
		  }
		  return firstChild;
		}
		function getNodeName(node) {
		  const nodeName = node.nodeName;
		  return typeof nodeName === "string" ? nodeName : "FORM";
		}
		function clobberedElementError(node) {
		  return new Error(`Failed to sanitize html because the element is clobbered: ${node.outerHTML}`);
		}
		var SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
		var NON_ALPHANUMERIC_REGEXP = /([^\#-~ |!])/g;
		function encodeEntities(value) {
		  return value.replace(/&/g, "&amp;").replace(SURROGATE_PAIR_REGEXP, function(match23) {
			 const hi = match23.charCodeAt(0);
			 const low = match23.charCodeAt(1);
			 return "&#" + ((hi - 55296) * 1024 + (low - 56320) + 65536) + ";";
		  }).replace(NON_ALPHANUMERIC_REGEXP, function(match23) {
			 return "&#" + match23.charCodeAt(0) + ";";
		  }).replace(/</g, "&lt;").replace(/>/g, "&gt;");
		}
		var inertBodyHelper;
		function _sanitizeHtml(defaultDoc, unsafeHtmlInput) {
		  let inertBodyElement = null;
		  try {
			 inertBodyHelper = inertBodyHelper || getInertBodyHelper(defaultDoc);
			 let unsafeHtml = unsafeHtmlInput ? String(unsafeHtmlInput) : "";
			 inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);
			 let mXSSAttempts = 5;
			 let parsedHtml = unsafeHtml;
			 do {
				if (mXSSAttempts === 0) {
				  throw new Error("Failed to sanitize html because the input is unstable");
				}
				mXSSAttempts--;
				unsafeHtml = parsedHtml;
				parsedHtml = inertBodyElement.innerHTML;
				inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);
			 } while (unsafeHtml !== parsedHtml);
			 const sanitizer = new SanitizingHtmlSerializer();
			 const safeHtml = sanitizer.sanitizeChildren(getTemplateContent(inertBodyElement) || inertBodyElement);
			 if ((typeof ngDevMode === "undefined" || ngDevMode) && sanitizer.sanitizedSomething) {
				console.warn(`WARNING: sanitizing HTML stripped some content, see ${XSS_SECURITY_URL}`);
			 }
			 return trustedHTMLFromString(safeHtml);
		  } finally {
			 if (inertBodyElement) {
				const parent = getTemplateContent(inertBodyElement) || inertBodyElement;
				while (parent.firstChild) {
				  parent.removeChild(parent.firstChild);
				}
			 }
		  }
		}
		function getTemplateContent(el) {
		  return "content" in el && isTemplateElement(el) ? el.content : null;
		}
		function isTemplateElement(el) {
		  return el.nodeType === Node.ELEMENT_NODE && el.nodeName === "TEMPLATE";
		}
		var SecurityContext;
		(function(SecurityContext2) {
		  SecurityContext2[SecurityContext2["NONE"] = 0] = "NONE";
		  SecurityContext2[SecurityContext2["HTML"] = 1] = "HTML";
		  SecurityContext2[SecurityContext2["STYLE"] = 2] = "STYLE";
		  SecurityContext2[SecurityContext2["SCRIPT"] = 3] = "SCRIPT";
		  SecurityContext2[SecurityContext2["URL"] = 4] = "URL";
		  SecurityContext2[SecurityContext2["RESOURCE_URL"] = 5] = "RESOURCE_URL";
		})(SecurityContext || (SecurityContext = {}));
		function \u0275\u0275sanitizeHtml(unsafeHtml) {
		  const sanitizer = getSanitizer();
		  if (sanitizer) {
			 return trustedHTMLFromStringBypass(sanitizer.sanitize(SecurityContext.HTML, unsafeHtml) || "");
		  }
		  if (allowSanitizationBypassAndThrow(
			 unsafeHtml,
			 "HTML"
			 /* BypassType.Html */
		  )) {
			 return trustedHTMLFromStringBypass(unwrapSafeValue(unsafeHtml));
		  }
		  return _sanitizeHtml(getDocument(), renderStringify(unsafeHtml));
		}
		function \u0275\u0275sanitizeStyle(unsafeStyle) {
		  const sanitizer = getSanitizer();
		  if (sanitizer) {
			 return sanitizer.sanitize(SecurityContext.STYLE, unsafeStyle) || "";
		  }
		  if (allowSanitizationBypassAndThrow(
			 unsafeStyle,
			 "Style"
			 /* BypassType.Style */
		  )) {
			 return unwrapSafeValue(unsafeStyle);
		  }
		  return renderStringify(unsafeStyle);
		}
		function \u0275\u0275sanitizeUrl(unsafeUrl) {
		  const sanitizer = getSanitizer();
		  if (sanitizer) {
			 return sanitizer.sanitize(SecurityContext.URL, unsafeUrl) || "";
		  }
		  if (allowSanitizationBypassAndThrow(
			 unsafeUrl,
			 "URL"
			 /* BypassType.Url */
		  )) {
			 return unwrapSafeValue(unsafeUrl);
		  }
		  return _sanitizeUrl(renderStringify(unsafeUrl));
		}
		function \u0275\u0275sanitizeResourceUrl(unsafeResourceUrl) {
		  const sanitizer = getSanitizer();
		  if (sanitizer) {
			 return trustedScriptURLFromStringBypass(sanitizer.sanitize(SecurityContext.RESOURCE_URL, unsafeResourceUrl) || "");
		  }
		  if (allowSanitizationBypassAndThrow(
			 unsafeResourceUrl,
			 "ResourceURL"
			 /* BypassType.ResourceUrl */
		  )) {
			 return trustedScriptURLFromStringBypass(unwrapSafeValue(unsafeResourceUrl));
		  }
		  throw new RuntimeError(904, ngDevMode && `unsafe value used in a resource URL context (see ${XSS_SECURITY_URL})`);
		}
		function \u0275\u0275sanitizeScript(unsafeScript) {
		  const sanitizer = getSanitizer();
		  if (sanitizer) {
			 return trustedScriptFromStringBypass(sanitizer.sanitize(SecurityContext.SCRIPT, unsafeScript) || "");
		  }
		  if (allowSanitizationBypassAndThrow(
			 unsafeScript,
			 "Script"
			 /* BypassType.Script */
		  )) {
			 return trustedScriptFromStringBypass(unwrapSafeValue(unsafeScript));
		  }
		  throw new RuntimeError(905, ngDevMode && "unsafe value used in a script context");
		}
		function \u0275\u0275trustConstantHtml(html) {
		  if (ngDevMode && (!Array.isArray(html) || !Array.isArray(html.raw) || html.length !== 1)) {
			 throw new Error(`Unexpected interpolation in trusted HTML constant: ${html.join("?")}`);
		  }
		  return trustedHTMLFromString(html[0]);
		}
		function \u0275\u0275trustConstantResourceUrl(url) {
		  if (ngDevMode && (!Array.isArray(url) || !Array.isArray(url.raw) || url.length !== 1)) {
			 throw new Error(`Unexpected interpolation in trusted URL constant: ${url.join("?")}`);
		  }
		  return trustedScriptURLFromString(url[0]);
		}
		function getUrlSanitizer(tag, prop) {
		  if (prop === "src" && (tag === "embed" || tag === "frame" || tag === "iframe" || tag === "media" || tag === "script") || prop === "href" && (tag === "base" || tag === "link")) {
			 return \u0275\u0275sanitizeResourceUrl;
		  }
		  return \u0275\u0275sanitizeUrl;
		}
		function \u0275\u0275sanitizeUrlOrResourceUrl(unsafeUrl, tag, prop) {
		  return getUrlSanitizer(tag, prop)(unsafeUrl);
		}
		function validateAgainstEventProperties(name) {
		  if (name.toLowerCase().startsWith("on")) {
			 const errorMessage = `Binding to event property '${name}' is disallowed for security reasons, please use (${name.slice(2)})=...
		If '${name}' is a directive input, make sure the directive is imported by the current module.`;
			 throw new RuntimeError(306, errorMessage);
		  }
		}
		function validateAgainstEventAttributes(name) {
		  if (name.toLowerCase().startsWith("on")) {
			 const errorMessage = `Binding to event attribute '${name}' is disallowed for security reasons, please use (${name.slice(2)})=...`;
			 throw new RuntimeError(306, errorMessage);
		  }
		}
		function getSanitizer() {
		  const lView = getLView();
		  return lView && lView[ENVIRONMENT].sanitizer;
		}
		var COMMENT_DISALLOWED = /^>|^->|<!--|-->|--!>|<!-$/g;
		var COMMENT_DELIMITER = /(<|>)/g;
		var COMMENT_DELIMITER_ESCAPED = "\u200B$1\u200B";
		function escapeCommentText(value) {
		  return value.replace(COMMENT_DISALLOWED, (text) => text.replace(COMMENT_DELIMITER, COMMENT_DELIMITER_ESCAPED));
		}
		function normalizeDebugBindingName(name) {
		  name = camelCaseToDashCase(name.replace(/[$@]/g, "_"));
		  return `ng-reflect-${name}`;
		}
		var CAMEL_CASE_REGEXP = /([A-Z])/g;
		function camelCaseToDashCase(input2) {
		  return input2.replace(CAMEL_CASE_REGEXP, (...m) => "-" + m[1].toLowerCase());
		}
		function normalizeDebugBindingValue(value) {
		  try {
			 return value != null ? value.toString().slice(0, 30) : value;
		  } catch (e) {
			 return "[ERROR] Exception while trying to serialize the value";
		  }
		}
		var CUSTOM_ELEMENTS_SCHEMA = {
		  name: "custom-elements"
		};
		var NO_ERRORS_SCHEMA = {
		  name: "no-errors-schema"
		};
		var shouldThrowErrorOnUnknownElement = false;
		var shouldThrowErrorOnUnknownProperty = false;
		function validateElementIsKnown(element, lView, tagName, schemas, hasDirectives) {
		  if (schemas === null)
			 return;
		  if (!hasDirectives && tagName !== null) {
			 const isUnknown = (
				// Note that we can't check for `typeof HTMLUnknownElement === 'function'` because
				// Domino doesn't expose HTMLUnknownElement globally.
				typeof HTMLUnknownElement !== "undefined" && HTMLUnknownElement && element instanceof HTMLUnknownElement || typeof customElements !== "undefined" && tagName.indexOf("-") > -1 && !customElements.get(tagName)
			 );
			 if (isUnknown && !matchingSchemas(schemas, tagName)) {
				const isHostStandalone = isHostComponentStandalone(lView);
				const templateLocation = getTemplateLocationDetails(lView);
				const schemas2 = `'${isHostStandalone ? "@Component" : "@NgModule"}.schemas'`;
				let message2 = `'${tagName}' is not a known element${templateLocation}:
		`;
				message2 += `1. If '${tagName}' is an Angular component, then verify that it is ${isHostStandalone ? "included in the '@Component.imports' of this component" : "a part of an @NgModule where this component is declared"}.
		`;
				if (tagName && tagName.indexOf("-") > -1) {
				  message2 += `2. If '${tagName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the ${schemas2} of this component to suppress this message.`;
				} else {
				  message2 += `2. To allow any element add 'NO_ERRORS_SCHEMA' to the ${schemas2} of this component.`;
				}
				if (shouldThrowErrorOnUnknownElement) {
				  throw new RuntimeError(304, message2);
				} else {
				  console.error(formatRuntimeError(304, message2));
				}
			 }
		  }
		}
		function isPropertyValid(element, propName, tagName, schemas) {
		  if (schemas === null)
			 return true;
		  if (matchingSchemas(schemas, tagName) || propName in element || isAnimationProp(propName)) {
			 return true;
		  }
		  return typeof Node === "undefined" || Node === null || !(element instanceof Node);
		}
		function handleUnknownPropertyError(propName, tagName, nodeType, lView) {
		  if (!tagName && nodeType === 4) {
			 tagName = "ng-template";
		  }
		  const isHostStandalone = isHostComponentStandalone(lView);
		  const templateLocation = getTemplateLocationDetails(lView);
		  let message2 = `Can't bind to '${propName}' since it isn't a known property of '${tagName}'${templateLocation}.`;
		  const schemas = `'${isHostStandalone ? "@Component" : "@NgModule"}.schemas'`;
		  const importLocation = isHostStandalone ? "included in the '@Component.imports' of this component" : "a part of an @NgModule where this component is declared";
		  if (KNOWN_CONTROL_FLOW_DIRECTIVES.has(propName)) {
			 const correspondingImport = KNOWN_CONTROL_FLOW_DIRECTIVES.get(propName);
			 message2 += `
		If the '${propName}' is an Angular control flow directive, please make sure that either the '${correspondingImport}' directive or the 'CommonModule' is ${importLocation}.`;
		  } else {
			 message2 += `
		1. If '${tagName}' is an Angular component and it has the '${propName}' input, then verify that it is ${importLocation}.`;
			 if (tagName && tagName.indexOf("-") > -1) {
				message2 += `
		2. If '${tagName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the ${schemas} of this component to suppress this message.`;
				message2 += `
		3. To allow any property add 'NO_ERRORS_SCHEMA' to the ${schemas} of this component.`;
			 } else {
				message2 += `
		2. To allow any property add 'NO_ERRORS_SCHEMA' to the ${schemas} of this component.`;
			 }
		  }
		  reportUnknownPropertyError(message2);
		}
		function reportUnknownPropertyError(message2) {
		  if (shouldThrowErrorOnUnknownProperty) {
			 throw new RuntimeError(303, message2);
		  } else {
			 console.error(formatRuntimeError(303, message2));
		  }
		}
		function getDeclarationComponentDef(lView) {
		  !ngDevMode && throwError("Must never be called in production mode");
		  const declarationLView = lView[DECLARATION_COMPONENT_VIEW];
		  const context2 = declarationLView[CONTEXT];
		  if (!context2)
			 return null;
		  return context2.constructor ? getComponentDef(context2.constructor) : null;
		}
		function isHostComponentStandalone(lView) {
		  !ngDevMode && throwError("Must never be called in production mode");
		  const componentDef = getDeclarationComponentDef(lView);
		  return !!componentDef?.standalone;
		}
		function getTemplateLocationDetails(lView) {
		  !ngDevMode && throwError("Must never be called in production mode");
		  const hostComponentDef = getDeclarationComponentDef(lView);
		  const componentClassName = hostComponentDef?.type?.name;
		  return componentClassName ? ` (used in the '${componentClassName}' component template)` : "";
		}
		var KNOWN_CONTROL_FLOW_DIRECTIVES = /* @__PURE__ */ new Map([
		  ["ngIf", "NgIf"],
		  ["ngFor", "NgFor"],
		  ["ngSwitchCase", "NgSwitchCase"],
		  ["ngSwitchDefault", "NgSwitchDefault"]
		]);
		function matchingSchemas(schemas, tagName) {
		  if (schemas !== null) {
			 for (let i = 0; i < schemas.length; i++) {
				const schema = schemas[i];
				if (schema === NO_ERRORS_SCHEMA || schema === CUSTOM_ELEMENTS_SCHEMA && tagName && tagName.indexOf("-") > -1) {
				  return true;
				}
			 }
		  }
		  return false;
		}
		function \u0275\u0275resolveWindow(element) {
		  return element.ownerDocument.defaultView;
		}
		function \u0275\u0275resolveDocument(element) {
		  return element.ownerDocument;
		}
		function \u0275\u0275resolveBody(element) {
		  return element.ownerDocument.body;
		}
		var INTERPOLATION_DELIMITER = `\uFFFD`;
		function maybeUnwrapFn(value) {
		  if (value instanceof Function) {
			 return value();
		  } else {
			 return value;
		  }
		}
		function isPlatformBrowser(injector) {
		  return (injector ?? inject(Injector)).get(PLATFORM_ID) === "browser";
		}
		var VALUE_STRING_LENGTH_LIMIT = 200;
		function assertStandaloneComponentType(type2) {
		  assertComponentDef(type2);
		  const componentDef = getComponentDef(type2);
		  if (!componentDef.standalone) {
			 throw new RuntimeError(907, `The ${stringifyForError(type2)} component is not marked as standalone, but Angular expects to have a standalone component here. Please make sure the ${stringifyForError(type2)} component has the \`standalone: true\` flag in the decorator.`);
		  }
		}
		function assertComponentDef(type2) {
		  if (!getComponentDef(type2)) {
			 throw new RuntimeError(906, `The ${stringifyForError(type2)} is not an Angular component, make sure it has the \`@Component\` decorator.`);
		  }
		}
		function throwMultipleComponentError(tNode, first2, second2) {
		  throw new RuntimeError(-300, `Multiple components match node with tagname ${tNode.value}: ${stringifyForError(first2)} and ${stringifyForError(second2)}`);
		}
		function throwErrorIfNoChangesMode(creationMode, oldValue, currValue, propName, lView) {
		  const hostComponentDef = getDeclarationComponentDef(lView);
		  const componentClassName = hostComponentDef?.type?.name;
		  const field = propName ? ` for '${propName}'` : "";
		  let msg = `ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value${field}: '${formatValue(oldValue)}'. Current value: '${formatValue(currValue)}'.${componentClassName ? ` Expression location: ${componentClassName} component` : ""}`;
		  if (creationMode) {
			 msg += ` It seems like the view has been created after its parent and its children have been dirty checked. Has it been created in a change detection hook?`;
		  }
		  throw new RuntimeError(-100, msg);
		}
		function formatValue(value) {
		  let strValue = String(value);
		  try {
			 if (Array.isArray(value) || strValue === "[object Object]") {
				strValue = JSON.stringify(value);
			 }
		  } catch (error) {
		  }
		  return strValue.length > VALUE_STRING_LENGTH_LIMIT ? strValue.substring(0, VALUE_STRING_LENGTH_LIMIT) + "\u2026" : strValue;
		}
		function constructDetailsForInterpolation(lView, rootIndex, expressionIndex, meta, changedValue) {
		  const [propName, prefix, ...chunks] = meta.split(INTERPOLATION_DELIMITER);
		  let oldValue = prefix, newValue = prefix;
		  for (let i = 0; i < chunks.length; i++) {
			 const slotIdx = rootIndex + i;
			 oldValue += `${lView[slotIdx]}${chunks[i]}`;
			 newValue += `${slotIdx === expressionIndex ? changedValue : lView[slotIdx]}${chunks[i]}`;
		  }
		  return { propName, oldValue, newValue };
		}
		function getExpressionChangedErrorDetails(lView, bindingIndex, oldValue, newValue) {
		  const tData = lView[TVIEW].data;
		  const metadata = tData[bindingIndex];
		  if (typeof metadata === "string") {
			 if (metadata.indexOf(INTERPOLATION_DELIMITER) > -1) {
				return constructDetailsForInterpolation(lView, bindingIndex, bindingIndex, metadata, newValue);
			 }
			 return { propName: metadata, oldValue, newValue };
		  }
		  if (metadata === null) {
			 let idx = bindingIndex - 1;
			 while (typeof tData[idx] !== "string" && tData[idx + 1] === null) {
				idx--;
			 }
			 const meta = tData[idx];
			 if (typeof meta === "string") {
				const matches = meta.match(new RegExp(INTERPOLATION_DELIMITER, "g"));
				if (matches && matches.length - 1 > bindingIndex - idx) {
				  return constructDetailsForInterpolation(lView, idx, bindingIndex, meta, newValue);
				}
			 }
		  }
		  return { propName: void 0, oldValue, newValue };
		}
		var RendererStyleFlags2;
		(function(RendererStyleFlags22) {
		  RendererStyleFlags22[RendererStyleFlags22["Important"] = 1] = "Important";
		  RendererStyleFlags22[RendererStyleFlags22["DashCase"] = 2] = "DashCase";
		})(RendererStyleFlags2 || (RendererStyleFlags2 = {}));
		var _icuContainerIterate;
		function icuContainerIterate(tIcuContainerNode, lView) {
		  return _icuContainerIterate(tIcuContainerNode, lView);
		}
		function ensureIcuContainerVisitorLoaded(loader) {
		  if (_icuContainerIterate === void 0) {
			 _icuContainerIterate = loader();
		  }
		}
		function applyToElementOrContainer(action, renderer, parent, lNodeToHandle, beforeNode) {
		  if (lNodeToHandle != null) {
			 let lContainer;
			 let isComponent2 = false;
			 if (isLContainer(lNodeToHandle)) {
				lContainer = lNodeToHandle;
			 } else if (isLView(lNodeToHandle)) {
				isComponent2 = true;
				ngDevMode && assertDefined(lNodeToHandle[HOST], "HOST must be defined for a component LView");
				lNodeToHandle = lNodeToHandle[HOST];
			 }
			 const rNode = unwrapRNode(lNodeToHandle);
			 if (action === 0 && parent !== null) {
				if (beforeNode == null) {
				  nativeAppendChild(renderer, parent, rNode);
				} else {
				  nativeInsertBefore(renderer, parent, rNode, beforeNode || null, true);
				}
			 } else if (action === 1 && parent !== null) {
				nativeInsertBefore(renderer, parent, rNode, beforeNode || null, true);
			 } else if (action === 2) {
				nativeRemoveNode(renderer, rNode, isComponent2);
			 } else if (action === 3) {
				ngDevMode && ngDevMode.rendererDestroyNode++;
				renderer.destroyNode(rNode);
			 }
			 if (lContainer != null) {
				applyContainer(renderer, action, lContainer, parent, beforeNode);
			 }
		  }
		}
		function createTextNode(renderer, value) {
		  ngDevMode && ngDevMode.rendererCreateTextNode++;
		  ngDevMode && ngDevMode.rendererSetText++;
		  return renderer.createText(value);
		}
		function updateTextNode(renderer, rNode, value) {
		  ngDevMode && ngDevMode.rendererSetText++;
		  renderer.setValue(rNode, value);
		}
		function createCommentNode(renderer, value) {
		  ngDevMode && ngDevMode.rendererCreateComment++;
		  return renderer.createComment(escapeCommentText(value));
		}
		function createElementNode(renderer, name, namespace) {
		  ngDevMode && ngDevMode.rendererCreateElement++;
		  return renderer.createElement(name, namespace);
		}
		function removeViewFromDOM(tView, lView) {
		  detachViewFromDOM(tView, lView);
		  lView[HOST] = null;
		  lView[T_HOST] = null;
		}
		function addViewToDOM(tView, parentTNode, renderer, lView, parentNativeNode, beforeNode) {
		  lView[HOST] = parentNativeNode;
		  lView[T_HOST] = parentTNode;
		  applyView(tView, lView, renderer, 1, parentNativeNode, beforeNode);
		}
		function detachViewFromDOM(tView, lView) {
		  lView[ENVIRONMENT].changeDetectionScheduler?.notify(
			 1
			 /* NotificationType.AfterRenderHooks */
		  );
		  applyView(tView, lView, lView[RENDERER], 2, null, null);
		}
		function destroyViewTree(rootView) {
		  let lViewOrLContainer = rootView[CHILD_HEAD];
		  if (!lViewOrLContainer) {
			 return cleanUpView(rootView[TVIEW], rootView);
		  }
		  while (lViewOrLContainer) {
			 let next = null;
			 if (isLView(lViewOrLContainer)) {
				next = lViewOrLContainer[CHILD_HEAD];
			 } else {
				ngDevMode && assertLContainer(lViewOrLContainer);
				const firstView = lViewOrLContainer[CONTAINER_HEADER_OFFSET];
				if (firstView)
				  next = firstView;
			 }
			 if (!next) {
				while (lViewOrLContainer && !lViewOrLContainer[NEXT] && lViewOrLContainer !== rootView) {
				  if (isLView(lViewOrLContainer)) {
					 cleanUpView(lViewOrLContainer[TVIEW], lViewOrLContainer);
				  }
				  lViewOrLContainer = lViewOrLContainer[PARENT];
				}
				if (lViewOrLContainer === null)
				  lViewOrLContainer = rootView;
				if (isLView(lViewOrLContainer)) {
				  cleanUpView(lViewOrLContainer[TVIEW], lViewOrLContainer);
				}
				next = lViewOrLContainer && lViewOrLContainer[NEXT];
			 }
			 lViewOrLContainer = next;
		  }
		}
		function insertView(tView, lView, lContainer, index) {
		  ngDevMode && assertLView(lView);
		  ngDevMode && assertLContainer(lContainer);
		  const indexInContainer = CONTAINER_HEADER_OFFSET + index;
		  const containerLength = lContainer.length;
		  if (index > 0) {
			 lContainer[indexInContainer - 1][NEXT] = lView;
		  }
		  if (index < containerLength - CONTAINER_HEADER_OFFSET) {
			 lView[NEXT] = lContainer[indexInContainer];
			 addToArray(lContainer, CONTAINER_HEADER_OFFSET + index, lView);
		  } else {
			 lContainer.push(lView);
			 lView[NEXT] = null;
		  }
		  lView[PARENT] = lContainer;
		  const declarationLContainer = lView[DECLARATION_LCONTAINER];
		  if (declarationLContainer !== null && lContainer !== declarationLContainer) {
			 trackMovedView(declarationLContainer, lView);
		  }
		  const lQueries = lView[QUERIES];
		  if (lQueries !== null) {
			 lQueries.insertView(tView);
		  }
		  updateAncestorTraversalFlagsOnAttach(lView);
		  lView[FLAGS] |= 128;
		}
		function trackMovedView(declarationContainer, lView) {
		  ngDevMode && assertDefined(lView, "LView required");
		  ngDevMode && assertLContainer(declarationContainer);
		  const movedViews = declarationContainer[MOVED_VIEWS];
		  const insertedLContainer = lView[PARENT];
		  ngDevMode && assertLContainer(insertedLContainer);
		  const insertedComponentLView = insertedLContainer[PARENT][DECLARATION_COMPONENT_VIEW];
		  ngDevMode && assertDefined(insertedComponentLView, "Missing insertedComponentLView");
		  const declaredComponentLView = lView[DECLARATION_COMPONENT_VIEW];
		  ngDevMode && assertDefined(declaredComponentLView, "Missing declaredComponentLView");
		  if (declaredComponentLView !== insertedComponentLView) {
			 declarationContainer[FLAGS] |= LContainerFlags.HasTransplantedViews;
		  }
		  if (movedViews === null) {
			 declarationContainer[MOVED_VIEWS] = [lView];
		  } else {
			 movedViews.push(lView);
		  }
		}
		function detachMovedView(declarationContainer, lView) {
		  ngDevMode && assertLContainer(declarationContainer);
		  ngDevMode && assertDefined(declarationContainer[MOVED_VIEWS], "A projected view should belong to a non-empty projected views collection");
		  const movedViews = declarationContainer[MOVED_VIEWS];
		  const declarationViewIndex = movedViews.indexOf(lView);
		  ngDevMode && assertLContainer(lView[PARENT]);
		  movedViews.splice(declarationViewIndex, 1);
		}
		function detachView(lContainer, removeIndex) {
		  if (lContainer.length <= CONTAINER_HEADER_OFFSET)
			 return;
		  const indexInContainer = CONTAINER_HEADER_OFFSET + removeIndex;
		  const viewToDetach = lContainer[indexInContainer];
		  if (viewToDetach) {
			 const declarationLContainer = viewToDetach[DECLARATION_LCONTAINER];
			 if (declarationLContainer !== null && declarationLContainer !== lContainer) {
				detachMovedView(declarationLContainer, viewToDetach);
			 }
			 if (removeIndex > 0) {
				lContainer[indexInContainer - 1][NEXT] = viewToDetach[NEXT];
			 }
			 const removedLView = removeFromArray(lContainer, CONTAINER_HEADER_OFFSET + removeIndex);
			 removeViewFromDOM(viewToDetach[TVIEW], viewToDetach);
			 const lQueries = removedLView[QUERIES];
			 if (lQueries !== null) {
				lQueries.detachView(removedLView[TVIEW]);
			 }
			 viewToDetach[PARENT] = null;
			 viewToDetach[NEXT] = null;
			 viewToDetach[FLAGS] &= ~128;
		  }
		  return viewToDetach;
		}
		function destroyLView(tView, lView) {
		  if (!(lView[FLAGS] & 256)) {
			 const renderer = lView[RENDERER];
			 if (renderer.destroyNode) {
				applyView(tView, lView, renderer, 3, null, null);
			 }
			 destroyViewTree(lView);
		  }
		}
		function cleanUpView(tView, lView) {
		  if (lView[FLAGS] & 256) {
			 return;
		  }
		  const prevConsumer = setActiveConsumer(null);
		  try {
			 lView[FLAGS] &= ~128;
			 lView[FLAGS] |= 256;
			 lView[REACTIVE_TEMPLATE_CONSUMER] && consumerDestroy(lView[REACTIVE_TEMPLATE_CONSUMER]);
			 executeOnDestroys(tView, lView);
			 processCleanups(tView, lView);
			 if (lView[TVIEW].type === 1) {
				ngDevMode && ngDevMode.rendererDestroy++;
				lView[RENDERER].destroy();
			 }
			 const declarationContainer = lView[DECLARATION_LCONTAINER];
			 if (declarationContainer !== null && isLContainer(lView[PARENT])) {
				if (declarationContainer !== lView[PARENT]) {
				  detachMovedView(declarationContainer, lView);
				}
				const lQueries = lView[QUERIES];
				if (lQueries !== null) {
				  lQueries.detachView(tView);
				}
			 }
			 unregisterLView(lView);
		  } finally {
			 setActiveConsumer(prevConsumer);
		  }
		}
		function processCleanups(tView, lView) {
		  ngDevMode && assertNotReactive(processCleanups.name);
		  const tCleanup = tView.cleanup;
		  const lCleanup = lView[CLEANUP];
		  if (tCleanup !== null) {
			 for (let i = 0; i < tCleanup.length - 1; i += 2) {
				if (typeof tCleanup[i] === "string") {
				  const targetIdx = tCleanup[i + 3];
				  ngDevMode && assertNumber(targetIdx, "cleanup target must be a number");
				  if (targetIdx >= 0) {
					 lCleanup[targetIdx]();
				  } else {
					 lCleanup[-targetIdx].unsubscribe();
				  }
				  i += 2;
				} else {
				  const context2 = lCleanup[tCleanup[i + 1]];
				  tCleanup[i].call(context2);
				}
			 }
		  }
		  if (lCleanup !== null) {
			 lView[CLEANUP] = null;
		  }
		  const destroyHooks = lView[ON_DESTROY_HOOKS];
		  if (destroyHooks !== null) {
			 lView[ON_DESTROY_HOOKS] = null;
			 for (let i = 0; i < destroyHooks.length; i++) {
				const destroyHooksFn = destroyHooks[i];
				ngDevMode && assertFunction(destroyHooksFn, "Expecting destroy hook to be a function.");
				destroyHooksFn();
			 }
		  }
		}
		function executeOnDestroys(tView, lView) {
		  ngDevMode && assertNotReactive(executeOnDestroys.name);
		  let destroyHooks;
		  if (tView != null && (destroyHooks = tView.destroyHooks) != null) {
			 for (let i = 0; i < destroyHooks.length; i += 2) {
				const context2 = lView[destroyHooks[i]];
				if (!(context2 instanceof NodeInjectorFactory)) {
				  const toCall = destroyHooks[i + 1];
				  if (Array.isArray(toCall)) {
					 for (let j = 0; j < toCall.length; j += 2) {
						const callContext = context2[toCall[j]];
						const hook = toCall[j + 1];
						profiler(4, callContext, hook);
						try {
						  hook.call(callContext);
						} finally {
						  profiler(5, callContext, hook);
						}
					 }
				  } else {
					 profiler(4, context2, toCall);
					 try {
						toCall.call(context2);
					 } finally {
						profiler(5, context2, toCall);
					 }
				  }
				}
			 }
		  }
		}
		function getParentRElement(tView, tNode, lView) {
		  return getClosestRElement(tView, tNode.parent, lView);
		}
		function getClosestRElement(tView, tNode, lView) {
		  let parentTNode = tNode;
		  while (parentTNode !== null && parentTNode.type & (8 | 32)) {
			 tNode = parentTNode;
			 parentTNode = tNode.parent;
		  }
		  if (parentTNode === null) {
			 return lView[HOST];
		  } else {
			 ngDevMode && assertTNodeType(
				parentTNode,
				3 | 4
				/* TNodeType.Container */
			 );
			 const { componentOffset } = parentTNode;
			 if (componentOffset > -1) {
				ngDevMode && assertTNodeForLView(parentTNode, lView);
				const { encapsulation } = tView.data[parentTNode.directiveStart + componentOffset];
				if (encapsulation === ViewEncapsulation$1.None || encapsulation === ViewEncapsulation$1.Emulated) {
				  return null;
				}
			 }
			 return getNativeByTNode(parentTNode, lView);
		  }
		}
		function nativeInsertBefore(renderer, parent, child, beforeNode, isMove) {
		  ngDevMode && ngDevMode.rendererInsertBefore++;
		  renderer.insertBefore(parent, child, beforeNode, isMove);
		}
		function nativeAppendChild(renderer, parent, child) {
		  ngDevMode && ngDevMode.rendererAppendChild++;
		  ngDevMode && assertDefined(parent, "parent node must be defined");
		  renderer.appendChild(parent, child);
		}
		function nativeAppendOrInsertBefore(renderer, parent, child, beforeNode, isMove) {
		  if (beforeNode !== null) {
			 nativeInsertBefore(renderer, parent, child, beforeNode, isMove);
		  } else {
			 nativeAppendChild(renderer, parent, child);
		  }
		}
		function nativeRemoveChild(renderer, parent, child, isHostElement) {
		  renderer.removeChild(parent, child, isHostElement);
		}
		function nativeParentNode(renderer, node) {
		  return renderer.parentNode(node);
		}
		function nativeNextSibling(renderer, node) {
		  return renderer.nextSibling(node);
		}
		function getInsertInFrontOfRNode(parentTNode, currentTNode, lView) {
		  return _getInsertInFrontOfRNodeWithI18n(parentTNode, currentTNode, lView);
		}
		function getInsertInFrontOfRNodeWithNoI18n(parentTNode, currentTNode, lView) {
		  if (parentTNode.type & (8 | 32)) {
			 return getNativeByTNode(parentTNode, lView);
		  }
		  return null;
		}
		var _getInsertInFrontOfRNodeWithI18n = getInsertInFrontOfRNodeWithNoI18n;
		var _processI18nInsertBefore;
		function setI18nHandling(getInsertInFrontOfRNodeWithI18n2, processI18nInsertBefore2) {
		  _getInsertInFrontOfRNodeWithI18n = getInsertInFrontOfRNodeWithI18n2;
		  _processI18nInsertBefore = processI18nInsertBefore2;
		}
		function appendChild(tView, lView, childRNode, childTNode) {
		  const parentRNode = getParentRElement(tView, childTNode, lView);
		  const renderer = lView[RENDERER];
		  const parentTNode = childTNode.parent || lView[T_HOST];
		  const anchorNode = getInsertInFrontOfRNode(parentTNode, childTNode, lView);
		  if (parentRNode != null) {
			 if (Array.isArray(childRNode)) {
				for (let i = 0; i < childRNode.length; i++) {
				  nativeAppendOrInsertBefore(renderer, parentRNode, childRNode[i], anchorNode, false);
				}
			 } else {
				nativeAppendOrInsertBefore(renderer, parentRNode, childRNode, anchorNode, false);
			 }
		  }
		  _processI18nInsertBefore !== void 0 && _processI18nInsertBefore(renderer, childTNode, lView, childRNode, parentRNode);
		}
		function getFirstNativeNode(lView, tNode) {
		  if (tNode !== null) {
			 ngDevMode && assertTNodeType(
				tNode,
				3 | 12 | 32 | 16
				/* TNodeType.Projection */
			 );
			 const tNodeType = tNode.type;
			 if (tNodeType & 3) {
				return getNativeByTNode(tNode, lView);
			 } else if (tNodeType & 4) {
				return getBeforeNodeForView(-1, lView[tNode.index]);
			 } else if (tNodeType & 8) {
				const elIcuContainerChild = tNode.child;
				if (elIcuContainerChild !== null) {
				  return getFirstNativeNode(lView, elIcuContainerChild);
				} else {
				  const rNodeOrLContainer = lView[tNode.index];
				  if (isLContainer(rNodeOrLContainer)) {
					 return getBeforeNodeForView(-1, rNodeOrLContainer);
				  } else {
					 return unwrapRNode(rNodeOrLContainer);
				  }
				}
			 } else if (tNodeType & 32) {
				let nextRNode = icuContainerIterate(tNode, lView);
				let rNode = nextRNode();
				return rNode || unwrapRNode(lView[tNode.index]);
			 } else {
				const projectionNodes = getProjectionNodes(lView, tNode);
				if (projectionNodes !== null) {
				  if (Array.isArray(projectionNodes)) {
					 return projectionNodes[0];
				  }
				  const parentView = getLViewParent(lView[DECLARATION_COMPONENT_VIEW]);
				  ngDevMode && assertParentView(parentView);
				  return getFirstNativeNode(parentView, projectionNodes);
				} else {
				  return getFirstNativeNode(lView, tNode.next);
				}
			 }
		  }
		  return null;
		}
		function getProjectionNodes(lView, tNode) {
		  if (tNode !== null) {
			 const componentView = lView[DECLARATION_COMPONENT_VIEW];
			 const componentHost = componentView[T_HOST];
			 const slotIdx = tNode.projection;
			 ngDevMode && assertProjectionSlots(lView);
			 return componentHost.projection[slotIdx];
		  }
		  return null;
		}
		function getBeforeNodeForView(viewIndexInContainer, lContainer) {
		  const nextViewIndex = CONTAINER_HEADER_OFFSET + viewIndexInContainer + 1;
		  if (nextViewIndex < lContainer.length) {
			 const lView = lContainer[nextViewIndex];
			 const firstTNodeOfView = lView[TVIEW].firstChild;
			 if (firstTNodeOfView !== null) {
				return getFirstNativeNode(lView, firstTNodeOfView);
			 }
		  }
		  return lContainer[NATIVE];
		}
		function nativeRemoveNode(renderer, rNode, isHostElement) {
		  ngDevMode && ngDevMode.rendererRemoveNode++;
		  const nativeParent = nativeParentNode(renderer, rNode);
		  if (nativeParent) {
			 nativeRemoveChild(renderer, nativeParent, rNode, isHostElement);
		  }
		}
		function applyNodes(renderer, action, tNode, lView, parentRElement, beforeNode, isProjection) {
		  while (tNode != null) {
			 ngDevMode && assertTNodeForLView(tNode, lView);
			 ngDevMode && assertTNodeType(
				tNode,
				3 | 12 | 16 | 32
				/* TNodeType.Icu */
			 );
			 const rawSlotValue = lView[tNode.index];
			 const tNodeType = tNode.type;
			 if (isProjection) {
				if (action === 0) {
				  rawSlotValue && attachPatchData(unwrapRNode(rawSlotValue), lView);
				  tNode.flags |= 2;
				}
			 }
			 if ((tNode.flags & 32) !== 32) {
				if (tNodeType & 8) {
				  applyNodes(renderer, action, tNode.child, lView, parentRElement, beforeNode, false);
				  applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);
				} else if (tNodeType & 32) {
				  const nextRNode = icuContainerIterate(tNode, lView);
				  let rNode;
				  while (rNode = nextRNode()) {
					 applyToElementOrContainer(action, renderer, parentRElement, rNode, beforeNode);
				  }
				  applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);
				} else if (tNodeType & 16) {
				  applyProjectionRecursive(renderer, action, lView, tNode, parentRElement, beforeNode);
				} else {
				  ngDevMode && assertTNodeType(
					 tNode,
					 3 | 4
					 /* TNodeType.Container */
				  );
				  applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);
				}
			 }
			 tNode = isProjection ? tNode.projectionNext : tNode.next;
		  }
		}
		function applyView(tView, lView, renderer, action, parentRElement, beforeNode) {
		  applyNodes(renderer, action, tView.firstChild, lView, parentRElement, beforeNode, false);
		}
		function applyProjection(tView, lView, tProjectionNode) {
		  const renderer = lView[RENDERER];
		  const parentRNode = getParentRElement(tView, tProjectionNode, lView);
		  const parentTNode = tProjectionNode.parent || lView[T_HOST];
		  let beforeNode = getInsertInFrontOfRNode(parentTNode, tProjectionNode, lView);
		  applyProjectionRecursive(renderer, 0, lView, tProjectionNode, parentRNode, beforeNode);
		}
		function applyProjectionRecursive(renderer, action, lView, tProjectionNode, parentRElement, beforeNode) {
		  const componentLView = lView[DECLARATION_COMPONENT_VIEW];
		  const componentNode = componentLView[T_HOST];
		  ngDevMode && assertEqual(typeof tProjectionNode.projection, "number", "expecting projection index");
		  const nodeToProjectOrRNodes = componentNode.projection[tProjectionNode.projection];
		  if (Array.isArray(nodeToProjectOrRNodes)) {
			 for (let i = 0; i < nodeToProjectOrRNodes.length; i++) {
				const rNode = nodeToProjectOrRNodes[i];
				applyToElementOrContainer(action, renderer, parentRElement, rNode, beforeNode);
			 }
		  } else {
			 let nodeToProject = nodeToProjectOrRNodes;
			 const projectedComponentLView = componentLView[PARENT];
			 if (hasInSkipHydrationBlockFlag(tProjectionNode)) {
				nodeToProject.flags |= 128;
			 }
			 applyNodes(renderer, action, nodeToProject, projectedComponentLView, parentRElement, beforeNode, true);
		  }
		}
		function applyContainer(renderer, action, lContainer, parentRElement, beforeNode) {
		  ngDevMode && assertLContainer(lContainer);
		  const anchor = lContainer[NATIVE];
		  const native = unwrapRNode(lContainer);
		  if (anchor !== native) {
			 applyToElementOrContainer(action, renderer, parentRElement, anchor, beforeNode);
		  }
		  for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
			 const lView = lContainer[i];
			 applyView(lView[TVIEW], lView, renderer, action, parentRElement, anchor);
		  }
		}
		function applyStyling(renderer, isClassBased, rNode, prop, value) {
		  if (isClassBased) {
			 if (!value) {
				ngDevMode && ngDevMode.rendererRemoveClass++;
				renderer.removeClass(rNode, prop);
			 } else {
				ngDevMode && ngDevMode.rendererAddClass++;
				renderer.addClass(rNode, prop);
			 }
		  } else {
			 let flags = prop.indexOf("-") === -1 ? void 0 : RendererStyleFlags2.DashCase;
			 if (value == null) {
				ngDevMode && ngDevMode.rendererRemoveStyle++;
				renderer.removeStyle(rNode, prop, flags);
			 } else {
				const isImportant = typeof value === "string" ? value.endsWith("!important") : false;
				if (isImportant) {
				  value = value.slice(0, -10);
				  flags |= RendererStyleFlags2.Important;
				}
				ngDevMode && ngDevMode.rendererSetStyle++;
				renderer.setStyle(rNode, prop, value, flags);
			 }
		  }
		}
		function writeDirectStyle(renderer, element, newValue) {
		  ngDevMode && assertString(newValue, "'newValue' should be a string");
		  renderer.setAttribute(element, "style", newValue);
		  ngDevMode && ngDevMode.rendererSetStyle++;
		}
		function writeDirectClass(renderer, element, newValue) {
		  ngDevMode && assertString(newValue, "'newValue' should be a string");
		  if (newValue === "") {
			 renderer.removeAttribute(element, "class");
		  } else {
			 renderer.setAttribute(element, "class", newValue);
		  }
		  ngDevMode && ngDevMode.rendererSetClassName++;
		}
		function setupStaticAttributes(renderer, element, tNode) {
		  const { mergedAttrs, classes, styles } = tNode;
		  if (mergedAttrs !== null) {
			 setUpAttributes(renderer, element, mergedAttrs);
		  }
		  if (classes !== null) {
			 writeDirectClass(renderer, element, classes);
		  }
		  if (styles !== null) {
			 writeDirectStyle(renderer, element, styles);
		  }
		}
		var NO_CHANGE = typeof ngDevMode === "undefined" || ngDevMode ? { __brand__: "NO_CHANGE" } : {};
		function \u0275\u0275advance(delta = 1) {
		  ngDevMode && assertGreaterThan(delta, 0, "Can only advance forward");
		  selectIndexInternal(getTView(), getLView(), getSelectedIndex() + delta, !!ngDevMode && isInCheckNoChangesMode());
		}
		function selectIndexInternal(tView, lView, index, checkNoChangesMode) {
		  ngDevMode && assertIndexInDeclRange(lView[TVIEW], index);
		  if (!checkNoChangesMode) {
			 const hooksInitPhaseCompleted = (lView[FLAGS] & 3) === 3;
			 if (hooksInitPhaseCompleted) {
				const preOrderCheckHooks = tView.preOrderCheckHooks;
				if (preOrderCheckHooks !== null) {
				  executeCheckHooks(lView, preOrderCheckHooks, index);
				}
			 } else {
				const preOrderHooks = tView.preOrderHooks;
				if (preOrderHooks !== null) {
				  executeInitAndCheckHooks(lView, preOrderHooks, 0, index);
				}
			 }
		  }
		  setSelectedIndex(index);
		}
		function \u0275\u0275directiveInject(token, flags = InjectFlags.Default) {
		  const lView = getLView();
		  if (lView === null) {
			 ngDevMode && assertInjectImplementationNotEqual(\u0275\u0275directiveInject);
			 return \u0275\u0275inject(token, flags);
		  }
		  const tNode = getCurrentTNode();
		  const value = getOrCreateInjectable(tNode, lView, resolveForwardRef(token), flags);
		  ngDevMode && emitInjectEvent(token, value, flags);
		  return value;
		}
		function \u0275\u0275invalidFactory() {
		  const msg = ngDevMode ? `This constructor was not compatible with Dependency Injection.` : "invalid";
		  throw new Error(msg);
		}
		function writeToDirectiveInput(def, instance, publicName, privateName, flags, value) {
		  const prevConsumer = setActiveConsumer(null);
		  try {
			 let inputSignalNode = null;
			 if ((flags & InputFlags.SignalBased) !== 0) {
				const field = instance[privateName];
				inputSignalNode = field[SIGNAL];
			 }
			 if (inputSignalNode !== null && inputSignalNode.transformFn !== void 0) {
				value = inputSignalNode.transformFn(value);
			 }
			 if ((flags & InputFlags.HasDecoratorInputTransform) !== 0) {
				value = def.inputTransforms[privateName].call(instance, value);
			 }
			 if (def.setInput !== null) {
				def.setInput(instance, inputSignalNode, value, publicName, privateName);
			 } else {
				applyValueToInputField(instance, inputSignalNode, privateName, value);
			 }
		  } finally {
			 setActiveConsumer(prevConsumer);
		  }
		}
		function processHostBindingOpCodes(tView, lView) {
		  const hostBindingOpCodes = tView.hostBindingOpCodes;
		  if (hostBindingOpCodes === null)
			 return;
		  try {
			 for (let i = 0; i < hostBindingOpCodes.length; i++) {
				const opCode = hostBindingOpCodes[i];
				if (opCode < 0) {
				  setSelectedIndex(~opCode);
				} else {
				  const directiveIdx = opCode;
				  const bindingRootIndx = hostBindingOpCodes[++i];
				  const hostBindingFn = hostBindingOpCodes[++i];
				  setBindingRootForHostBindings(bindingRootIndx, directiveIdx);
				  const context2 = lView[directiveIdx];
				  hostBindingFn(2, context2);
				}
			 }
		  } finally {
			 setSelectedIndex(-1);
		  }
		}
		function createLView(parentLView, tView, context2, flags, host, tHostNode, environment, renderer, injector, embeddedViewInjector, hydrationInfo) {
		  const lView = tView.blueprint.slice();
		  lView[HOST] = host;
		  lView[FLAGS] = flags | 4 | 128 | 8 | 64;
		  if (embeddedViewInjector !== null || parentLView && parentLView[FLAGS] & 2048) {
			 lView[FLAGS] |= 2048;
		  }
		  resetPreOrderHookFlags(lView);
		  ngDevMode && tView.declTNode && parentLView && assertTNodeForLView(tView.declTNode, parentLView);
		  lView[PARENT] = lView[DECLARATION_VIEW] = parentLView;
		  lView[CONTEXT] = context2;
		  lView[ENVIRONMENT] = environment || parentLView && parentLView[ENVIRONMENT];
		  ngDevMode && assertDefined(lView[ENVIRONMENT], "LViewEnvironment is required");
		  lView[RENDERER] = renderer || parentLView && parentLView[RENDERER];
		  ngDevMode && assertDefined(lView[RENDERER], "Renderer is required");
		  lView[INJECTOR] = injector || parentLView && parentLView[INJECTOR] || null;
		  lView[T_HOST] = tHostNode;
		  lView[ID] = getUniqueLViewId();
		  lView[HYDRATION] = hydrationInfo;
		  lView[EMBEDDED_VIEW_INJECTOR] = embeddedViewInjector;
		  ngDevMode && assertEqual(tView.type == 2 ? parentLView !== null : true, true, "Embedded views must have parentLView");
		  lView[DECLARATION_COMPONENT_VIEW] = tView.type == 2 ? parentLView[DECLARATION_COMPONENT_VIEW] : lView;
		  return lView;
		}
		function getOrCreateTNode(tView, index, type2, name, attrs) {
		  ngDevMode && index !== 0 && // 0 are bogus nodes and they are OK. See `createContainerRef` in
		  // `view_engine_compatibility` for additional context.
		  assertGreaterThanOrEqual(index, HEADER_OFFSET, "TNodes can't be in the LView header.");
		  ngDevMode && assertPureTNodeType(type2);
		  let tNode = tView.data[index];
		  if (tNode === null) {
			 tNode = createTNodeAtIndex(tView, index, type2, name, attrs);
			 if (isInI18nBlock()) {
				tNode.flags |= 32;
			 }
		  } else if (tNode.type & 64) {
			 tNode.type = type2;
			 tNode.value = name;
			 tNode.attrs = attrs;
			 const parent = getCurrentParentTNode();
			 tNode.injectorIndex = parent === null ? -1 : parent.injectorIndex;
			 ngDevMode && assertTNodeForTView(tNode, tView);
			 ngDevMode && assertEqual(index, tNode.index, "Expecting same index");
		  }
		  setCurrentTNode(tNode, true);
		  return tNode;
		}
		function createTNodeAtIndex(tView, index, type2, name, attrs) {
		  const currentTNode = getCurrentTNodePlaceholderOk();
		  const isParent = isCurrentTNodeParent();
		  const parent = isParent ? currentTNode : currentTNode && currentTNode.parent;
		  const tNode = tView.data[index] = createTNode(tView, parent, type2, index, name, attrs);
		  if (tView.firstChild === null) {
			 tView.firstChild = tNode;
		  }
		  if (currentTNode !== null) {
			 if (isParent) {
				if (currentTNode.child == null && tNode.parent !== null) {
				  currentTNode.child = tNode;
				}
			 } else {
				if (currentTNode.next === null) {
				  currentTNode.next = tNode;
				  tNode.prev = currentTNode;
				}
			 }
		  }
		  return tNode;
		}
		function allocExpando(tView, lView, numSlotsToAlloc, initialValue) {
		  if (numSlotsToAlloc === 0)
			 return -1;
		  if (ngDevMode) {
			 assertFirstCreatePass(tView);
			 assertSame(tView, lView[TVIEW], "`LView` must be associated with `TView`!");
			 assertEqual(tView.data.length, lView.length, "Expecting LView to be same size as TView");
			 assertEqual(tView.data.length, tView.blueprint.length, "Expecting Blueprint to be same size as TView");
			 assertFirstUpdatePass(tView);
		  }
		  const allocIdx = lView.length;
		  for (let i = 0; i < numSlotsToAlloc; i++) {
			 lView.push(initialValue);
			 tView.blueprint.push(initialValue);
			 tView.data.push(null);
		  }
		  return allocIdx;
		}
		function executeTemplate(tView, lView, templateFn, rf, context2) {
		  const prevSelectedIndex = getSelectedIndex();
		  const isUpdatePhase = rf & 2;
		  try {
			 setSelectedIndex(-1);
			 if (isUpdatePhase && lView.length > HEADER_OFFSET) {
				selectIndexInternal(tView, lView, HEADER_OFFSET, !!ngDevMode && isInCheckNoChangesMode());
			 }
			 const preHookType = isUpdatePhase ? 2 : 0;
			 profiler(preHookType, context2);
			 templateFn(rf, context2);
		  } finally {
			 setSelectedIndex(prevSelectedIndex);
			 const postHookType = isUpdatePhase ? 3 : 1;
			 profiler(postHookType, context2);
		  }
		}
		function executeContentQueries(tView, tNode, lView) {
		  if (isContentQueryHost(tNode)) {
			 const prevConsumer = setActiveConsumer(null);
			 try {
				const start2 = tNode.directiveStart;
				const end = tNode.directiveEnd;
				for (let directiveIndex = start2; directiveIndex < end; directiveIndex++) {
				  const def = tView.data[directiveIndex];
				  if (def.contentQueries) {
					 const directiveInstance = lView[directiveIndex];
					 ngDevMode && assertDefined(directiveIndex, "Incorrect reference to a directive defining a content query");
					 def.contentQueries(1, directiveInstance, directiveIndex);
				  }
				}
			 } finally {
				setActiveConsumer(prevConsumer);
			 }
		  }
		}
		function createDirectivesInstances(tView, lView, tNode) {
		  if (!getBindingsEnabled())
			 return;
		  instantiateAllDirectives(tView, lView, tNode, getNativeByTNode(tNode, lView));
		  if ((tNode.flags & 64) === 64) {
			 invokeDirectivesHostBindings(tView, lView, tNode);
		  }
		}
		function saveResolvedLocalsInData(viewData, tNode, localRefExtractor = getNativeByTNode) {
		  const localNames = tNode.localNames;
		  if (localNames !== null) {
			 let localIndex = tNode.index + 1;
			 for (let i = 0; i < localNames.length; i += 2) {
				const index = localNames[i + 1];
				const value = index === -1 ? localRefExtractor(tNode, viewData) : viewData[index];
				viewData[localIndex++] = value;
			 }
		  }
		}
		function getOrCreateComponentTView(def) {
		  const tView = def.tView;
		  if (tView === null || tView.incompleteFirstPass) {
			 const declTNode = null;
			 return def.tView = createTView(1, declTNode, def.template, def.decls, def.vars, def.directiveDefs, def.pipeDefs, def.viewQuery, def.schemas, def.consts, def.id);
		  }
		  return tView;
		}
		function createTView(type2, declTNode, templateFn, decls, vars, directives, pipes, viewQuery, schemas, constsOrFactory, ssrId) {
		  ngDevMode && ngDevMode.tView++;
		  const bindingStartIndex = HEADER_OFFSET + decls;
		  const initialViewLength = bindingStartIndex + vars;
		  const blueprint = createViewBlueprint(bindingStartIndex, initialViewLength);
		  const consts = typeof constsOrFactory === "function" ? constsOrFactory() : constsOrFactory;
		  const tView = blueprint[TVIEW] = {
			 type: type2,
			 blueprint,
			 template: templateFn,
			 queries: null,
			 viewQuery,
			 declTNode,
			 data: blueprint.slice().fill(null, bindingStartIndex),
			 bindingStartIndex,
			 expandoStartIndex: initialViewLength,
			 hostBindingOpCodes: null,
			 firstCreatePass: true,
			 firstUpdatePass: true,
			 staticViewQueries: false,
			 staticContentQueries: false,
			 preOrderHooks: null,
			 preOrderCheckHooks: null,
			 contentHooks: null,
			 contentCheckHooks: null,
			 viewHooks: null,
			 viewCheckHooks: null,
			 destroyHooks: null,
			 cleanup: null,
			 contentQueries: null,
			 components: null,
			 directiveRegistry: typeof directives === "function" ? directives() : directives,
			 pipeRegistry: typeof pipes === "function" ? pipes() : pipes,
			 firstChild: null,
			 schemas,
			 consts,
			 incompleteFirstPass: false,
			 ssrId
		  };
		  if (ngDevMode) {
			 Object.seal(tView);
		  }
		  return tView;
		}
		function createViewBlueprint(bindingStartIndex, initialViewLength) {
		  const blueprint = [];
		  for (let i = 0; i < initialViewLength; i++) {
			 blueprint.push(i < bindingStartIndex ? null : NO_CHANGE);
		  }
		  return blueprint;
		}
		function locateHostElement(renderer, elementOrSelector, encapsulation, injector) {
		  const preserveHostContent = injector.get(PRESERVE_HOST_CONTENT, PRESERVE_HOST_CONTENT_DEFAULT);
		  const preserveContent = preserveHostContent || encapsulation === ViewEncapsulation$1.ShadowDom;
		  const rootElement = renderer.selectRootElement(elementOrSelector, preserveContent);
		  applyRootElementTransform(rootElement);
		  return rootElement;
		}
		function applyRootElementTransform(rootElement) {
		  _applyRootElementTransformImpl(rootElement);
		}
		var _applyRootElementTransformImpl = () => null;
		function storeCleanupWithContext(tView, lView, context2, cleanupFn) {
		  const lCleanup = getOrCreateLViewCleanup(lView);
		  ngDevMode && assertDefined(context2, "Cleanup context is mandatory when registering framework-level destroy hooks");
		  lCleanup.push(context2);
		  if (tView.firstCreatePass) {
			 getOrCreateTViewCleanup(tView).push(cleanupFn, lCleanup.length - 1);
		  } else {
			 if (ngDevMode) {
				Object.freeze(getOrCreateTViewCleanup(tView));
			 }
		  }
		}
		function createTNode(tView, tParent, type2, index, value, attrs) {
		  ngDevMode && index !== 0 && // 0 are bogus nodes and they are OK. See `createContainerRef` in
		  // `view_engine_compatibility` for additional context.
		  assertGreaterThanOrEqual(index, HEADER_OFFSET, "TNodes can't be in the LView header.");
		  ngDevMode && assertNotSame(attrs, void 0, "'undefined' is not valid value for 'attrs'");
		  ngDevMode && ngDevMode.tNode++;
		  ngDevMode && tParent && assertTNodeForTView(tParent, tView);
		  let injectorIndex = tParent ? tParent.injectorIndex : -1;
		  let flags = 0;
		  if (isInSkipHydrationBlock$1()) {
			 flags |= 128;
		  }
		  const tNode = {
			 type: type2,
			 index,
			 insertBeforeIndex: null,
			 injectorIndex,
			 directiveStart: -1,
			 directiveEnd: -1,
			 directiveStylingLast: -1,
			 componentOffset: -1,
			 propertyBindings: null,
			 flags,
			 providerIndexes: 0,
			 value,
			 attrs,
			 mergedAttrs: null,
			 localNames: null,
			 initialInputs: void 0,
			 inputs: null,
			 outputs: null,
			 tView: null,
			 next: null,
			 prev: null,
			 projectionNext: null,
			 child: null,
			 parent: tParent,
			 projection: null,
			 styles: null,
			 stylesWithoutHost: null,
			 residualStyles: void 0,
			 classes: null,
			 classesWithoutHost: null,
			 residualClasses: void 0,
			 classBindings: 0,
			 styleBindings: 0
		  };
		  if (ngDevMode) {
			 Object.seal(tNode);
		  }
		  return tNode;
		}
		function captureNodeBindings(mode, aliasMap, directiveIndex, bindingsResult, hostDirectiveAliasMap) {
		  for (let publicName in aliasMap) {
			 if (!aliasMap.hasOwnProperty(publicName)) {
				continue;
			 }
			 const value = aliasMap[publicName];
			 if (value === void 0) {
				continue;
			 }
			 bindingsResult ??= {};
			 let internalName;
			 let inputFlags = InputFlags.None;
			 if (Array.isArray(value)) {
				internalName = value[0];
				inputFlags = value[1];
			 } else {
				internalName = value;
			 }
			 let finalPublicName = publicName;
			 if (hostDirectiveAliasMap !== null) {
				if (!hostDirectiveAliasMap.hasOwnProperty(publicName)) {
				  continue;
				}
				finalPublicName = hostDirectiveAliasMap[publicName];
			 }
			 if (mode === 0) {
				addPropertyBinding(bindingsResult, directiveIndex, finalPublicName, internalName, inputFlags);
			 } else {
				addPropertyBinding(bindingsResult, directiveIndex, finalPublicName, internalName);
			 }
		  }
		  return bindingsResult;
		}
		function addPropertyBinding(bindings, directiveIndex, publicName, internalName, inputFlags) {
		  let values;
		  if (bindings.hasOwnProperty(publicName)) {
			 (values = bindings[publicName]).push(directiveIndex, internalName);
		  } else {
			 values = bindings[publicName] = [directiveIndex, internalName];
		  }
		  if (inputFlags !== void 0) {
			 values.push(inputFlags);
		  }
		}
		function initializeInputAndOutputAliases(tView, tNode, hostDirectiveDefinitionMap) {
		  ngDevMode && assertFirstCreatePass(tView);
		  const start2 = tNode.directiveStart;
		  const end = tNode.directiveEnd;
		  const tViewData = tView.data;
		  const tNodeAttrs = tNode.attrs;
		  const inputsFromAttrs = [];
		  let inputsStore = null;
		  let outputsStore = null;
		  for (let directiveIndex = start2; directiveIndex < end; directiveIndex++) {
			 const directiveDef = tViewData[directiveIndex];
			 const aliasData = hostDirectiveDefinitionMap ? hostDirectiveDefinitionMap.get(directiveDef) : null;
			 const aliasedInputs = aliasData ? aliasData.inputs : null;
			 const aliasedOutputs = aliasData ? aliasData.outputs : null;
			 inputsStore = captureNodeBindings(0, directiveDef.inputs, directiveIndex, inputsStore, aliasedInputs);
			 outputsStore = captureNodeBindings(1, directiveDef.outputs, directiveIndex, outputsStore, aliasedOutputs);
			 const initialInputs = inputsStore !== null && tNodeAttrs !== null && !isInlineTemplate(tNode) ? generateInitialInputs(inputsStore, directiveIndex, tNodeAttrs) : null;
			 inputsFromAttrs.push(initialInputs);
		  }
		  if (inputsStore !== null) {
			 if (inputsStore.hasOwnProperty("class")) {
				tNode.flags |= 8;
			 }
			 if (inputsStore.hasOwnProperty("style")) {
				tNode.flags |= 16;
			 }
		  }
		  tNode.initialInputs = inputsFromAttrs;
		  tNode.inputs = inputsStore;
		  tNode.outputs = outputsStore;
		}
		function mapPropName(name) {
		  if (name === "class")
			 return "className";
		  if (name === "for")
			 return "htmlFor";
		  if (name === "formaction")
			 return "formAction";
		  if (name === "innerHtml")
			 return "innerHTML";
		  if (name === "readonly")
			 return "readOnly";
		  if (name === "tabindex")
			 return "tabIndex";
		  return name;
		}
		function elementPropertyInternal(tView, tNode, lView, propName, value, renderer, sanitizer, nativeOnly) {
		  ngDevMode && assertNotSame(value, NO_CHANGE, "Incoming value should never be NO_CHANGE.");
		  const element = getNativeByTNode(tNode, lView);
		  let inputData = tNode.inputs;
		  let dataValue;
		  if (!nativeOnly && inputData != null && (dataValue = inputData[propName])) {
			 setInputsForProperty(tView, lView, dataValue, propName, value);
			 if (isComponentHost(tNode))
				markDirtyIfOnPush(lView, tNode.index);
			 if (ngDevMode) {
				setNgReflectProperties(lView, element, tNode.type, dataValue, value);
			 }
		  } else if (tNode.type & 3) {
			 propName = mapPropName(propName);
			 if (ngDevMode) {
				validateAgainstEventProperties(propName);
				if (!isPropertyValid(element, propName, tNode.value, tView.schemas)) {
				  handleUnknownPropertyError(propName, tNode.value, tNode.type, lView);
				}
				ngDevMode.rendererSetProperty++;
			 }
			 value = sanitizer != null ? sanitizer(value, tNode.value || "", propName) : value;
			 renderer.setProperty(element, propName, value);
		  } else if (tNode.type & 12) {
			 if (ngDevMode && !matchingSchemas(tView.schemas, tNode.value)) {
				handleUnknownPropertyError(propName, tNode.value, tNode.type, lView);
			 }
		  }
		}
		function markDirtyIfOnPush(lView, viewIndex) {
		  ngDevMode && assertLView(lView);
		  const childComponentLView = getComponentLViewByIndex(viewIndex, lView);
		  if (!(childComponentLView[FLAGS] & 16)) {
			 childComponentLView[FLAGS] |= 64;
		  }
		}
		function setNgReflectProperty(lView, element, type2, attrName, value) {
		  const renderer = lView[RENDERER];
		  attrName = normalizeDebugBindingName(attrName);
		  const debugValue = normalizeDebugBindingValue(value);
		  if (type2 & 3) {
			 if (value == null) {
				renderer.removeAttribute(element, attrName);
			 } else {
				renderer.setAttribute(element, attrName, debugValue);
			 }
		  } else {
			 const textContent = escapeCommentText(`bindings=${JSON.stringify({ [attrName]: debugValue }, null, 2)}`);
			 renderer.setValue(element, textContent);
		  }
		}
		function setNgReflectProperties(lView, element, type2, dataValue, value) {
		  if (type2 & (3 | 4)) {
			 for (let i = 0; i < dataValue.length; i += 3) {
				setNgReflectProperty(lView, element, type2, dataValue[i + 1], value);
			 }
		  }
		}
		function resolveDirectives(tView, lView, tNode, localRefs) {
		  ngDevMode && assertFirstCreatePass(tView);
		  if (getBindingsEnabled()) {
			 const exportsMap = localRefs === null ? null : { "": -1 };
			 const matchResult = findDirectiveDefMatches(tView, tNode);
			 let directiveDefs;
			 let hostDirectiveDefs;
			 if (matchResult === null) {
				directiveDefs = hostDirectiveDefs = null;
			 } else {
				[directiveDefs, hostDirectiveDefs] = matchResult;
			 }
			 if (directiveDefs !== null) {
				initializeDirectives(tView, lView, tNode, directiveDefs, exportsMap, hostDirectiveDefs);
			 }
			 if (exportsMap)
				cacheMatchingLocalNames(tNode, localRefs, exportsMap);
		  }
		  tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, tNode.attrs);
		}
		function initializeDirectives(tView, lView, tNode, directives, exportsMap, hostDirectiveDefs) {
		  ngDevMode && assertFirstCreatePass(tView);
		  for (let i = 0; i < directives.length; i++) {
			 diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, directives[i].type);
		  }
		  initTNodeFlags(tNode, tView.data.length, directives.length);
		  for (let i = 0; i < directives.length; i++) {
			 const def = directives[i];
			 if (def.providersResolver)
				def.providersResolver(def);
		  }
		  let preOrderHooksFound = false;
		  let preOrderCheckHooksFound = false;
		  let directiveIdx = allocExpando(tView, lView, directives.length, null);
		  ngDevMode && assertSame(directiveIdx, tNode.directiveStart, "TNode.directiveStart should point to just allocated space");
		  for (let i = 0; i < directives.length; i++) {
			 const def = directives[i];
			 tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, def.hostAttrs);
			 configureViewWithDirective(tView, tNode, lView, directiveIdx, def);
			 saveNameToExportMap(directiveIdx, def, exportsMap);
			 if (def.contentQueries !== null)
				tNode.flags |= 4;
			 if (def.hostBindings !== null || def.hostAttrs !== null || def.hostVars !== 0)
				tNode.flags |= 64;
			 const lifeCycleHooks = def.type.prototype;
			 if (!preOrderHooksFound && (lifeCycleHooks.ngOnChanges || lifeCycleHooks.ngOnInit || lifeCycleHooks.ngDoCheck)) {
				(tView.preOrderHooks ??= []).push(tNode.index);
				preOrderHooksFound = true;
			 }
			 if (!preOrderCheckHooksFound && (lifeCycleHooks.ngOnChanges || lifeCycleHooks.ngDoCheck)) {
				(tView.preOrderCheckHooks ??= []).push(tNode.index);
				preOrderCheckHooksFound = true;
			 }
			 directiveIdx++;
		  }
		  initializeInputAndOutputAliases(tView, tNode, hostDirectiveDefs);
		}
		function registerHostBindingOpCodes(tView, tNode, directiveIdx, directiveVarsIdx, def) {
		  ngDevMode && assertFirstCreatePass(tView);
		  const hostBindings = def.hostBindings;
		  if (hostBindings) {
			 let hostBindingOpCodes = tView.hostBindingOpCodes;
			 if (hostBindingOpCodes === null) {
				hostBindingOpCodes = tView.hostBindingOpCodes = [];
			 }
			 const elementIndx = ~tNode.index;
			 if (lastSelectedElementIdx(hostBindingOpCodes) != elementIndx) {
				hostBindingOpCodes.push(elementIndx);
			 }
			 hostBindingOpCodes.push(directiveIdx, directiveVarsIdx, hostBindings);
		  }
		}
		function lastSelectedElementIdx(hostBindingOpCodes) {
		  let i = hostBindingOpCodes.length;
		  while (i > 0) {
			 const value = hostBindingOpCodes[--i];
			 if (typeof value === "number" && value < 0) {
				return value;
			 }
		  }
		  return 0;
		}
		function instantiateAllDirectives(tView, lView, tNode, native) {
		  const start2 = tNode.directiveStart;
		  const end = tNode.directiveEnd;
		  if (isComponentHost(tNode)) {
			 ngDevMode && assertTNodeType(
				tNode,
				3
				/* TNodeType.AnyRNode */
			 );
			 addComponentLogic(lView, tNode, tView.data[start2 + tNode.componentOffset]);
		  }
		  if (!tView.firstCreatePass) {
			 getOrCreateNodeInjectorForNode(tNode, lView);
		  }
		  attachPatchData(native, lView);
		  const initialInputs = tNode.initialInputs;
		  for (let i = start2; i < end; i++) {
			 const def = tView.data[i];
			 const directive = getNodeInjectable(lView, tView, i, tNode);
			 attachPatchData(directive, lView);
			 if (initialInputs !== null) {
				setInputsFromAttrs(lView, i - start2, directive, def, tNode, initialInputs);
			 }
			 if (isComponentDef(def)) {
				const componentView = getComponentLViewByIndex(tNode.index, lView);
				componentView[CONTEXT] = getNodeInjectable(lView, tView, i, tNode);
			 }
		  }
		}
		function invokeDirectivesHostBindings(tView, lView, tNode) {
		  const start2 = tNode.directiveStart;
		  const end = tNode.directiveEnd;
		  const elementIndex = tNode.index;
		  const currentDirectiveIndex = getCurrentDirectiveIndex();
		  try {
			 setSelectedIndex(elementIndex);
			 for (let dirIndex = start2; dirIndex < end; dirIndex++) {
				const def = tView.data[dirIndex];
				const directive = lView[dirIndex];
				setCurrentDirectiveIndex(dirIndex);
				if (def.hostBindings !== null || def.hostVars !== 0 || def.hostAttrs !== null) {
				  invokeHostBindingsInCreationMode(def, directive);
				}
			 }
		  } finally {
			 setSelectedIndex(-1);
			 setCurrentDirectiveIndex(currentDirectiveIndex);
		  }
		}
		function invokeHostBindingsInCreationMode(def, directive) {
		  if (def.hostBindings !== null) {
			 def.hostBindings(1, directive);
		  }
		}
		function findDirectiveDefMatches(tView, tNode) {
		  ngDevMode && assertFirstCreatePass(tView);
		  ngDevMode && assertTNodeType(
			 tNode,
			 3 | 12
			 /* TNodeType.AnyContainer */
		  );
		  const registry = tView.directiveRegistry;
		  let matches = null;
		  let hostDirectiveDefs = null;
		  if (registry) {
			 for (let i = 0; i < registry.length; i++) {
				const def = registry[i];
				if (isNodeMatchingSelectorList(
				  tNode,
				  def.selectors,
				  /* isProjectionMode */
				  false
				)) {
				  matches || (matches = []);
				  if (isComponentDef(def)) {
					 if (ngDevMode) {
						assertTNodeType(tNode, 2, `"${tNode.value}" tags cannot be used as component hosts. Please use a different tag to activate the ${stringify(def.type)} component.`);
						if (isComponentHost(tNode)) {
						  throwMultipleComponentError(tNode, matches.find(isComponentDef).type, def.type);
						}
					 }
					 if (def.findHostDirectiveDefs !== null) {
						const hostDirectiveMatches = [];
						hostDirectiveDefs = hostDirectiveDefs || /* @__PURE__ */ new Map();
						def.findHostDirectiveDefs(def, hostDirectiveMatches, hostDirectiveDefs);
						matches.unshift(...hostDirectiveMatches, def);
						const componentOffset = hostDirectiveMatches.length;
						markAsComponentHost(tView, tNode, componentOffset);
					 } else {
						matches.unshift(def);
						markAsComponentHost(tView, tNode, 0);
					 }
				  } else {
					 hostDirectiveDefs = hostDirectiveDefs || /* @__PURE__ */ new Map();
					 def.findHostDirectiveDefs?.(def, matches, hostDirectiveDefs);
					 matches.push(def);
				  }
				}
			 }
		  }
		  ngDevMode && matches !== null && assertNoDuplicateDirectives(matches);
		  return matches === null ? null : [matches, hostDirectiveDefs];
		}
		function markAsComponentHost(tView, hostTNode, componentOffset) {
		  ngDevMode && assertFirstCreatePass(tView);
		  ngDevMode && assertGreaterThan(componentOffset, -1, "componentOffset must be great than -1");
		  hostTNode.componentOffset = componentOffset;
		  (tView.components ??= []).push(hostTNode.index);
		}
		function cacheMatchingLocalNames(tNode, localRefs, exportsMap) {
		  if (localRefs) {
			 const localNames = tNode.localNames = [];
			 for (let i = 0; i < localRefs.length; i += 2) {
				const index = exportsMap[localRefs[i + 1]];
				if (index == null)
				  throw new RuntimeError(-301, ngDevMode && `Export of name '${localRefs[i + 1]}' not found!`);
				localNames.push(localRefs[i], index);
			 }
		  }
		}
		function saveNameToExportMap(directiveIdx, def, exportsMap) {
		  if (exportsMap) {
			 if (def.exportAs) {
				for (let i = 0; i < def.exportAs.length; i++) {
				  exportsMap[def.exportAs[i]] = directiveIdx;
				}
			 }
			 if (isComponentDef(def))
				exportsMap[""] = directiveIdx;
		  }
		}
		function initTNodeFlags(tNode, index, numberOfDirectives) {
		  ngDevMode && assertNotEqual(numberOfDirectives, tNode.directiveEnd - tNode.directiveStart, "Reached the max number of directives");
		  tNode.flags |= 1;
		  tNode.directiveStart = index;
		  tNode.directiveEnd = index + numberOfDirectives;
		  tNode.providerIndexes = index;
		}
		function configureViewWithDirective(tView, tNode, lView, directiveIndex, def) {
		  ngDevMode && assertGreaterThanOrEqual(directiveIndex, HEADER_OFFSET, "Must be in Expando section");
		  tView.data[directiveIndex] = def;
		  const directiveFactory = def.factory || (def.factory = getFactoryDef(def.type, true));
		  const nodeInjectorFactory = new NodeInjectorFactory(directiveFactory, isComponentDef(def), \u0275\u0275directiveInject);
		  tView.blueprint[directiveIndex] = nodeInjectorFactory;
		  lView[directiveIndex] = nodeInjectorFactory;
		  registerHostBindingOpCodes(tView, tNode, directiveIndex, allocExpando(tView, lView, def.hostVars, NO_CHANGE), def);
		}
		function addComponentLogic(lView, hostTNode, def) {
		  const native = getNativeByTNode(hostTNode, lView);
		  const tView = getOrCreateComponentTView(def);
		  const rendererFactory = lView[ENVIRONMENT].rendererFactory;
		  let lViewFlags = 16;
		  if (def.signals) {
			 lViewFlags = 4096;
		  } else if (def.onPush) {
			 lViewFlags = 64;
		  }
		  const componentView = addToViewTree(lView, createLView(lView, tView, null, lViewFlags, native, hostTNode, null, rendererFactory.createRenderer(native, def), null, null, null));
		  lView[hostTNode.index] = componentView;
		}
		function elementAttributeInternal(tNode, lView, name, value, sanitizer, namespace) {
		  if (ngDevMode) {
			 assertNotSame(value, NO_CHANGE, "Incoming value should never be NO_CHANGE.");
			 validateAgainstEventAttributes(name);
			 assertTNodeType(tNode, 2, `Attempted to set attribute \`${name}\` on a container node. Host bindings are not valid on ng-container or ng-template.`);
		  }
		  const element = getNativeByTNode(tNode, lView);
		  setElementAttribute(lView[RENDERER], element, namespace, tNode.value, name, value, sanitizer);
		}
		function setElementAttribute(renderer, element, namespace, tagName, name, value, sanitizer) {
		  if (value == null) {
			 ngDevMode && ngDevMode.rendererRemoveAttribute++;
			 renderer.removeAttribute(element, name, namespace);
		  } else {
			 ngDevMode && ngDevMode.rendererSetAttribute++;
			 const strValue = sanitizer == null ? renderStringify(value) : sanitizer(value, tagName || "", name);
			 renderer.setAttribute(element, name, strValue, namespace);
		  }
		}
		function setInputsFromAttrs(lView, directiveIndex, instance, def, tNode, initialInputData) {
		  const initialInputs = initialInputData[directiveIndex];
		  if (initialInputs !== null) {
			 for (let i = 0; i < initialInputs.length; ) {
				const publicName = initialInputs[i++];
				const privateName = initialInputs[i++];
				const flags = initialInputs[i++];
				const value = initialInputs[i++];
				writeToDirectiveInput(def, instance, publicName, privateName, flags, value);
				if (ngDevMode) {
				  const nativeElement = getNativeByTNode(tNode, lView);
				  setNgReflectProperty(lView, nativeElement, tNode.type, privateName, value);
				}
			 }
		  }
		}
		function generateInitialInputs(inputs, directiveIndex, attrs) {
		  let inputsToStore = null;
		  let i = 0;
		  while (i < attrs.length) {
			 const attrName = attrs[i];
			 if (attrName === 0) {
				i += 4;
				continue;
			 } else if (attrName === 5) {
				i += 2;
				continue;
			 }
			 if (typeof attrName === "number")
				break;
			 if (inputs.hasOwnProperty(attrName)) {
				if (inputsToStore === null)
				  inputsToStore = [];
				const inputConfig = inputs[attrName];
				for (let j = 0; j < inputConfig.length; j += 3) {
				  if (inputConfig[j] === directiveIndex) {
					 inputsToStore.push(attrName, inputConfig[j + 1], inputConfig[j + 2], attrs[i + 1]);
					 break;
				  }
				}
			 }
			 i += 2;
		  }
		  return inputsToStore;
		}
		function createLContainer(hostNative, currentView, native, tNode) {
		  ngDevMode && assertLView(currentView);
		  const lContainer = [
			 hostNative,
			 // host native
			 true,
			 // Boolean `true` in this position signifies that this is an `LContainer`
			 0,
			 // flags
			 currentView,
			 // parent
			 null,
			 // next
			 tNode,
			 // t_host
			 null,
			 // dehydrated views
			 native,
			 // native,
			 null,
			 // view refs
			 null
			 // moved views
		  ];
		  ngDevMode && assertEqual(lContainer.length, CONTAINER_HEADER_OFFSET, "Should allocate correct number of slots for LContainer header.");
		  return lContainer;
		}
		function refreshContentQueries(tView, lView) {
		  const contentQueries = tView.contentQueries;
		  if (contentQueries !== null) {
			 const prevConsumer = setActiveConsumer(null);
			 try {
				for (let i = 0; i < contentQueries.length; i += 2) {
				  const queryStartIdx = contentQueries[i];
				  const directiveDefIdx = contentQueries[i + 1];
				  if (directiveDefIdx !== -1) {
					 const directiveDef = tView.data[directiveDefIdx];
					 ngDevMode && assertDefined(directiveDef, "DirectiveDef not found.");
					 ngDevMode && assertDefined(directiveDef.contentQueries, "contentQueries function should be defined");
					 setCurrentQueryIndex(queryStartIdx);
					 directiveDef.contentQueries(2, lView[directiveDefIdx], directiveDefIdx);
				  }
				}
			 } finally {
				setActiveConsumer(prevConsumer);
			 }
		  }
		}
		function addToViewTree(lView, lViewOrLContainer) {
		  if (lView[CHILD_HEAD]) {
			 lView[CHILD_TAIL][NEXT] = lViewOrLContainer;
		  } else {
			 lView[CHILD_HEAD] = lViewOrLContainer;
		  }
		  lView[CHILD_TAIL] = lViewOrLContainer;
		  return lViewOrLContainer;
		}
		function executeViewQueryFn(flags, viewQueryFn, component) {
		  ngDevMode && assertDefined(viewQueryFn, "View queries function to execute must be defined.");
		  setCurrentQueryIndex(0);
		  const prevConsumer = setActiveConsumer(null);
		  try {
			 viewQueryFn(flags, component);
		  } finally {
			 setActiveConsumer(prevConsumer);
		  }
		}
		function storePropertyBindingMetadata(tData, tNode, propertyName, bindingIndex, ...interpolationParts) {
		  if (tData[bindingIndex] === null) {
			 if (tNode.inputs == null || !tNode.inputs[propertyName]) {
				const propBindingIdxs = tNode.propertyBindings || (tNode.propertyBindings = []);
				propBindingIdxs.push(bindingIndex);
				let bindingMetadata = propertyName;
				if (interpolationParts.length > 0) {
				  bindingMetadata += INTERPOLATION_DELIMITER + interpolationParts.join(INTERPOLATION_DELIMITER);
				}
				tData[bindingIndex] = bindingMetadata;
			 }
		  }
		}
		function getOrCreateLViewCleanup(view) {
		  return view[CLEANUP] || (view[CLEANUP] = []);
		}
		function getOrCreateTViewCleanup(tView) {
		  return tView.cleanup || (tView.cleanup = []);
		}
		function loadComponentRenderer(currentDef, tNode, lView) {
		  if (currentDef === null || isComponentDef(currentDef)) {
			 lView = unwrapLView(lView[tNode.index]);
		  }
		  return lView[RENDERER];
		}
		function handleError(lView, error) {
		  const injector = lView[INJECTOR];
		  const errorHandler2 = injector ? injector.get(ErrorHandler, null) : null;
		  errorHandler2 && errorHandler2.handleError(error);
		}
		function setInputsForProperty(tView, lView, inputs, publicName, value) {
		  for (let i = 0; i < inputs.length; ) {
			 const index = inputs[i++];
			 const privateName = inputs[i++];
			 const flags = inputs[i++];
			 const instance = lView[index];
			 ngDevMode && assertIndexInRange(lView, index);
			 const def = tView.data[index];
			 writeToDirectiveInput(def, instance, publicName, privateName, flags, value);
		  }
		}
		function textBindingInternal(lView, index, value) {
		  ngDevMode && assertString(value, "Value should be a string");
		  ngDevMode && assertNotSame(value, NO_CHANGE, "value should not be NO_CHANGE");
		  ngDevMode && assertIndexInRange(lView, index);
		  const element = getNativeByIndex(index, lView);
		  ngDevMode && assertDefined(element, "native element should exist");
		  updateTextNode(lView[RENDERER], element, value);
		}
		function renderComponent(hostLView, componentHostIdx) {
		  ngDevMode && assertEqual(isCreationMode(hostLView), true, "Should be run in creation mode");
		  const componentView = getComponentLViewByIndex(componentHostIdx, hostLView);
		  const componentTView = componentView[TVIEW];
		  syncViewWithBlueprint(componentTView, componentView);
		  const hostRNode = componentView[HOST];
		  if (hostRNode !== null && componentView[HYDRATION] === null) {
			 componentView[HYDRATION] = retrieveHydrationInfo(hostRNode, componentView[INJECTOR]);
		  }
		  renderView(componentTView, componentView, componentView[CONTEXT]);
		}
		function syncViewWithBlueprint(tView, lView) {
		  for (let i = lView.length; i < tView.blueprint.length; i++) {
			 lView.push(tView.blueprint[i]);
		  }
		}
		function renderView(tView, lView, context2) {
		  ngDevMode && assertEqual(isCreationMode(lView), true, "Should be run in creation mode");
		  ngDevMode && assertNotReactive(renderView.name);
		  enterView(lView);
		  try {
			 const viewQuery = tView.viewQuery;
			 if (viewQuery !== null) {
				executeViewQueryFn(1, viewQuery, context2);
			 }
			 const templateFn = tView.template;
			 if (templateFn !== null) {
				executeTemplate(tView, lView, templateFn, 1, context2);
			 }
			 if (tView.firstCreatePass) {
				tView.firstCreatePass = false;
			 }
			 lView[QUERIES]?.finishViewCreation(tView);
			 if (tView.staticContentQueries) {
				refreshContentQueries(tView, lView);
			 }
			 if (tView.staticViewQueries) {
				executeViewQueryFn(2, tView.viewQuery, context2);
			 }
			 const components = tView.components;
			 if (components !== null) {
				renderChildComponents(lView, components);
			 }
		  } catch (error) {
			 if (tView.firstCreatePass) {
				tView.incompleteFirstPass = true;
				tView.firstCreatePass = false;
			 }
			 throw error;
		  } finally {
			 lView[FLAGS] &= ~4;
			 leaveView();
		  }
		}
		function renderChildComponents(hostLView, components) {
		  for (let i = 0; i < components.length; i++) {
			 renderComponent(hostLView, components[i]);
		  }
		}
		function createAndRenderEmbeddedLView(declarationLView, templateTNode, context2, options) {
		  const prevConsumer = setActiveConsumer(null);
		  try {
			 const embeddedTView = templateTNode.tView;
			 ngDevMode && assertDefined(embeddedTView, "TView must be defined for a template node.");
			 ngDevMode && assertTNodeForLView(templateTNode, declarationLView);
			 const isSignalView = declarationLView[FLAGS] & 4096;
			 const viewFlags = isSignalView ? 4096 : 16;
			 const embeddedLView = createLView(declarationLView, embeddedTView, context2, viewFlags, null, templateTNode, null, null, options?.injector ?? null, options?.embeddedViewInjector ?? null, options?.dehydratedView ?? null);
			 const declarationLContainer = declarationLView[templateTNode.index];
			 ngDevMode && assertLContainer(declarationLContainer);
			 embeddedLView[DECLARATION_LCONTAINER] = declarationLContainer;
			 const declarationViewLQueries = declarationLView[QUERIES];
			 if (declarationViewLQueries !== null) {
				embeddedLView[QUERIES] = declarationViewLQueries.createEmbeddedView(embeddedTView);
			 }
			 renderView(embeddedTView, embeddedLView, context2);
			 return embeddedLView;
		  } finally {
			 setActiveConsumer(prevConsumer);
		  }
		}
		function getLViewFromLContainer(lContainer, index) {
		  const adjustedIndex = CONTAINER_HEADER_OFFSET + index;
		  if (adjustedIndex < lContainer.length) {
			 const lView = lContainer[adjustedIndex];
			 ngDevMode && assertLView(lView);
			 return lView;
		  }
		  return void 0;
		}
		function shouldAddViewToDom(tNode, dehydratedView) {
		  return !dehydratedView || dehydratedView.firstChild === null || hasInSkipHydrationBlockFlag(tNode);
		}
		function addLViewToLContainer(lContainer, lView, index, addToDOM = true) {
		  const tView = lView[TVIEW];
		  insertView(tView, lView, lContainer, index);
		  if (addToDOM) {
			 const beforeNode = getBeforeNodeForView(index, lContainer);
			 const renderer = lView[RENDERER];
			 const parentRNode = nativeParentNode(renderer, lContainer[NATIVE]);
			 if (parentRNode !== null) {
				addViewToDOM(tView, lContainer[T_HOST], renderer, lView, parentRNode, beforeNode);
			 }
		  }
		  const hydrationInfo = lView[HYDRATION];
		  if (hydrationInfo !== null && hydrationInfo.firstChild !== null) {
			 hydrationInfo.firstChild = null;
		  }
		}
		function removeLViewFromLContainer(lContainer, index) {
		  const lView = detachView(lContainer, index);
		  if (lView !== void 0) {
			 destroyLView(lView[TVIEW], lView);
		  }
		  return lView;
		}
		function collectNativeNodes(tView, lView, tNode, result, isProjection = false) {
		  while (tNode !== null) {
			 ngDevMode && assertTNodeType(
				tNode,
				3 | 12 | 16 | 32
				/* TNodeType.Icu */
			 );
			 const lNode = lView[tNode.index];
			 if (lNode !== null) {
				result.push(unwrapRNode(lNode));
			 }
			 if (isLContainer(lNode)) {
				collectNativeNodesInLContainer(lNode, result);
			 }
			 const tNodeType = tNode.type;
			 if (tNodeType & 8) {
				collectNativeNodes(tView, lView, tNode.child, result);
			 } else if (tNodeType & 32) {
				const nextRNode = icuContainerIterate(tNode, lView);
				let rNode;
				while (rNode = nextRNode()) {
				  result.push(rNode);
				}
			 } else if (tNodeType & 16) {
				const nodesInSlot = getProjectionNodes(lView, tNode);
				if (Array.isArray(nodesInSlot)) {
				  result.push(...nodesInSlot);
				} else {
				  const parentView = getLViewParent(lView[DECLARATION_COMPONENT_VIEW]);
				  ngDevMode && assertParentView(parentView);
				  collectNativeNodes(parentView[TVIEW], parentView, nodesInSlot, result, true);
				}
			 }
			 tNode = isProjection ? tNode.projectionNext : tNode.next;
		  }
		  return result;
		}
		function collectNativeNodesInLContainer(lContainer, result) {
		  for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
			 const lViewInAContainer = lContainer[i];
			 const lViewFirstChildTNode = lViewInAContainer[TVIEW].firstChild;
			 if (lViewFirstChildTNode !== null) {
				collectNativeNodes(lViewInAContainer[TVIEW], lViewInAContainer, lViewFirstChildTNode, result);
			 }
		  }
		  if (lContainer[NATIVE] !== lContainer[HOST]) {
			 result.push(lContainer[NATIVE]);
		  }
		}
		var freeConsumers = [];
		function getOrBorrowReactiveLViewConsumer(lView) {
		  return lView[REACTIVE_TEMPLATE_CONSUMER] ?? borrowReactiveLViewConsumer(lView);
		}
		function borrowReactiveLViewConsumer(lView) {
		  const consumer = freeConsumers.pop() ?? Object.create(REACTIVE_LVIEW_CONSUMER_NODE);
		  consumer.lView = lView;
		  return consumer;
		}
		function maybeReturnReactiveLViewConsumer(consumer) {
		  if (consumer.lView[REACTIVE_TEMPLATE_CONSUMER] === consumer) {
			 return;
		  }
		  consumer.lView = null;
		  freeConsumers.push(consumer);
		}
		var REACTIVE_LVIEW_CONSUMER_NODE = __spreadProps(__spreadValues({}, REACTIVE_NODE), {
		  consumerIsAlwaysLive: true,
		  consumerMarkedDirty: (node) => {
			 markAncestorsForTraversal(node.lView);
		  },
		  consumerOnSignalRead() {
			 this.lView[REACTIVE_TEMPLATE_CONSUMER] = this;
		  }
		});
		var MAXIMUM_REFRESH_RERUNS = 100;
		function detectChangesInternal(lView, notifyErrorHandler = true, mode = 0) {
		  const environment = lView[ENVIRONMENT];
		  const rendererFactory = environment.rendererFactory;
		  const checkNoChangesMode = !!ngDevMode && isInCheckNoChangesMode();
		  if (!checkNoChangesMode) {
			 rendererFactory.begin?.();
		  }
		  try {
			 detectChangesInViewWhileDirty(lView, mode);
		  } catch (error) {
			 if (notifyErrorHandler) {
				handleError(lView, error);
			 }
			 throw error;
		  } finally {
			 if (!checkNoChangesMode) {
				rendererFactory.end?.();
				environment.inlineEffectRunner?.flush();
			 }
		  }
		}
		function detectChangesInViewWhileDirty(lView, mode) {
		  detectChangesInView$1(lView, mode);
		  let retries = 0;
		  while (requiresRefreshOrTraversal(lView)) {
			 if (retries === MAXIMUM_REFRESH_RERUNS) {
				throw new RuntimeError(103, ngDevMode && "Infinite change detection while trying to refresh views. There may be components which each cause the other to require a refresh, causing an infinite loop.");
			 }
			 retries++;
			 detectChangesInView$1(
				lView,
				1
				/* ChangeDetectionMode.Targeted */
			 );
		  }
		}
		function checkNoChangesInternal(lView, notifyErrorHandler = true) {
		  setIsInCheckNoChangesMode(true);
		  try {
			 detectChangesInternal(lView, notifyErrorHandler);
		  } finally {
			 setIsInCheckNoChangesMode(false);
		  }
		}
		function refreshView(tView, lView, templateFn, context2) {
		  ngDevMode && assertEqual(isCreationMode(lView), false, "Should be run in update mode");
		  const flags = lView[FLAGS];
		  if ((flags & 256) === 256)
			 return;
		  const isInCheckNoChangesPass = ngDevMode && isInCheckNoChangesMode();
		  !isInCheckNoChangesPass && lView[ENVIRONMENT].inlineEffectRunner?.flush();
		  enterView(lView);
		  let prevConsumer = null;
		  let currentConsumer = null;
		  if (!isInCheckNoChangesPass && viewShouldHaveReactiveConsumer(tView)) {
			 currentConsumer = getOrBorrowReactiveLViewConsumer(lView);
			 prevConsumer = consumerBeforeComputation(currentConsumer);
		  }
		  try {
			 resetPreOrderHookFlags(lView);
			 setBindingIndex(tView.bindingStartIndex);
			 if (templateFn !== null) {
				executeTemplate(tView, lView, templateFn, 2, context2);
			 }
			 const hooksInitPhaseCompleted = (flags & 3) === 3;
			 if (!isInCheckNoChangesPass) {
				if (hooksInitPhaseCompleted) {
				  const preOrderCheckHooks = tView.preOrderCheckHooks;
				  if (preOrderCheckHooks !== null) {
					 executeCheckHooks(lView, preOrderCheckHooks, null);
				  }
				} else {
				  const preOrderHooks = tView.preOrderHooks;
				  if (preOrderHooks !== null) {
					 executeInitAndCheckHooks(lView, preOrderHooks, 0, null);
				  }
				  incrementInitPhaseFlags(
					 lView,
					 0
					 /* InitPhaseState.OnInitHooksToBeRun */
				  );
				}
			 }
			 markTransplantedViewsForRefresh(lView);
			 detectChangesInEmbeddedViews(
				lView,
				0
				/* ChangeDetectionMode.Global */
			 );
			 if (tView.contentQueries !== null) {
				refreshContentQueries(tView, lView);
			 }
			 if (!isInCheckNoChangesPass) {
				if (hooksInitPhaseCompleted) {
				  const contentCheckHooks = tView.contentCheckHooks;
				  if (contentCheckHooks !== null) {
					 executeCheckHooks(lView, contentCheckHooks);
				  }
				} else {
				  const contentHooks = tView.contentHooks;
				  if (contentHooks !== null) {
					 executeInitAndCheckHooks(
						lView,
						contentHooks,
						1
						/* InitPhaseState.AfterContentInitHooksToBeRun */
					 );
				  }
				  incrementInitPhaseFlags(
					 lView,
					 1
					 /* InitPhaseState.AfterContentInitHooksToBeRun */
				  );
				}
			 }
			 processHostBindingOpCodes(tView, lView);
			 const components = tView.components;
			 if (components !== null) {
				detectChangesInChildComponents(
				  lView,
				  components,
				  0
				  /* ChangeDetectionMode.Global */
				);
			 }
			 const viewQuery = tView.viewQuery;
			 if (viewQuery !== null) {
				executeViewQueryFn(2, viewQuery, context2);
			 }
			 if (!isInCheckNoChangesPass) {
				if (hooksInitPhaseCompleted) {
				  const viewCheckHooks = tView.viewCheckHooks;
				  if (viewCheckHooks !== null) {
					 executeCheckHooks(lView, viewCheckHooks);
				  }
				} else {
				  const viewHooks = tView.viewHooks;
				  if (viewHooks !== null) {
					 executeInitAndCheckHooks(
						lView,
						viewHooks,
						2
						/* InitPhaseState.AfterViewInitHooksToBeRun */
					 );
				  }
				  incrementInitPhaseFlags(
					 lView,
					 2
					 /* InitPhaseState.AfterViewInitHooksToBeRun */
				  );
				}
			 }
			 if (tView.firstUpdatePass === true) {
				tView.firstUpdatePass = false;
			 }
			 if (lView[EFFECTS_TO_SCHEDULE]) {
				for (const notifyEffect of lView[EFFECTS_TO_SCHEDULE]) {
				  notifyEffect();
				}
				lView[EFFECTS_TO_SCHEDULE] = null;
			 }
			 if (!isInCheckNoChangesPass) {
				lView[FLAGS] &= ~(64 | 8);
			 }
		  } catch (e) {
			 markAncestorsForTraversal(lView);
			 throw e;
		  } finally {
			 if (currentConsumer !== null) {
				consumerAfterComputation(currentConsumer, prevConsumer);
				maybeReturnReactiveLViewConsumer(currentConsumer);
			 }
			 leaveView();
		  }
		}
		function viewShouldHaveReactiveConsumer(tView) {
		  return tView.type !== 2;
		}
		function detectChangesInEmbeddedViews(lView, mode) {
		  for (let lContainer = getFirstLContainer(lView); lContainer !== null; lContainer = getNextLContainer(lContainer)) {
			 for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
				const embeddedLView = lContainer[i];
				detectChangesInViewIfAttached(embeddedLView, mode);
			 }
		  }
		}
		function markTransplantedViewsForRefresh(lView) {
		  for (let lContainer = getFirstLContainer(lView); lContainer !== null; lContainer = getNextLContainer(lContainer)) {
			 if (!(lContainer[FLAGS] & LContainerFlags.HasTransplantedViews))
				continue;
			 const movedViews = lContainer[MOVED_VIEWS];
			 ngDevMode && assertDefined(movedViews, "Transplanted View flags set but missing MOVED_VIEWS");
			 for (let i = 0; i < movedViews.length; i++) {
				const movedLView = movedViews[i];
				const insertionLContainer = movedLView[PARENT];
				ngDevMode && assertLContainer(insertionLContainer);
				markViewForRefresh(movedLView);
			 }
		  }
		}
		function detectChangesInComponent(hostLView, componentHostIdx, mode) {
		  ngDevMode && assertEqual(isCreationMode(hostLView), false, "Should be run in update mode");
		  const componentView = getComponentLViewByIndex(componentHostIdx, hostLView);
		  detectChangesInViewIfAttached(componentView, mode);
		}
		function detectChangesInViewIfAttached(lView, mode) {
		  if (!viewAttachedToChangeDetector(lView)) {
			 return;
		  }
		  detectChangesInView$1(lView, mode);
		}
		function detectChangesInView$1(lView, mode) {
		  const isInCheckNoChangesPass = ngDevMode && isInCheckNoChangesMode();
		  const tView = lView[TVIEW];
		  const flags = lView[FLAGS];
		  const consumer = lView[REACTIVE_TEMPLATE_CONSUMER];
		  let shouldRefreshView = !!(mode === 0 && flags & 16);
		  shouldRefreshView ||= !!(flags & 64 && mode === 0 && !isInCheckNoChangesPass);
		  shouldRefreshView ||= !!(flags & 1024);
		  shouldRefreshView ||= !!(consumer?.dirty && consumerPollProducersForChange(consumer));
		  if (consumer) {
			 consumer.dirty = false;
		  }
		  lView[FLAGS] &= ~(8192 | 1024);
		  if (shouldRefreshView) {
			 refreshView(tView, lView, tView.template, lView[CONTEXT]);
		  } else if (flags & 8192) {
			 detectChangesInEmbeddedViews(
				lView,
				1
				/* ChangeDetectionMode.Targeted */
			 );
			 const components = tView.components;
			 if (components !== null) {
				detectChangesInChildComponents(
				  lView,
				  components,
				  1
				  /* ChangeDetectionMode.Targeted */
				);
			 }
		  }
		}
		function detectChangesInChildComponents(hostLView, components, mode) {
		  for (let i = 0; i < components.length; i++) {
			 detectChangesInComponent(hostLView, components[i], mode);
		  }
		}
		function markViewDirty(lView) {
		  lView[ENVIRONMENT].changeDetectionScheduler?.notify();
		  while (lView) {
			 lView[FLAGS] |= 64;
			 const parent = getLViewParent(lView);
			 if (isRootView(lView) && !parent) {
				return lView;
			 }
			 lView = parent;
		  }
		  return null;
		}
		var ViewRef$1 = class {
		  get rootNodes() {
			 const lView = this._lView;
			 const tView = lView[TVIEW];
			 return collectNativeNodes(tView, lView, tView.firstChild, []);
		  }
		  constructor(_lView, _cdRefInjectingView, notifyErrorHandler = true) {
			 this._lView = _lView;
			 this._cdRefInjectingView = _cdRefInjectingView;
			 this.notifyErrorHandler = notifyErrorHandler;
			 this._appRef = null;
			 this._attachedToViewContainer = false;
		  }
		  get context() {
			 return this._lView[CONTEXT];
		  }
		  /**
			* @deprecated Replacing the full context object is not supported. Modify the context
			*   directly, or consider using a `Proxy` if you need to replace the full object.
			* // TODO(devversion): Remove this.
			*/
		  set context(value) {
			 if (ngDevMode) {
				console.warn("Angular: Replacing the `context` object of an `EmbeddedViewRef` is deprecated.");
			 }
			 this._lView[CONTEXT] = value;
		  }
		  get destroyed() {
			 return (this._lView[FLAGS] & 256) === 256;
		  }
		  destroy() {
			 if (this._appRef) {
				this._appRef.detachView(this);
			 } else if (this._attachedToViewContainer) {
				const parent = this._lView[PARENT];
				if (isLContainer(parent)) {
				  const viewRefs = parent[VIEW_REFS];
				  const index = viewRefs ? viewRefs.indexOf(this) : -1;
				  if (index > -1) {
					 ngDevMode && assertEqual(index, parent.indexOf(this._lView) - CONTAINER_HEADER_OFFSET, "An attached view should be in the same position within its container as its ViewRef in the VIEW_REFS array.");
					 detachView(parent, index);
					 removeFromArray(viewRefs, index);
				  }
				}
				this._attachedToViewContainer = false;
			 }
			 destroyLView(this._lView[TVIEW], this._lView);
		  }
		  onDestroy(callback) {
			 storeLViewOnDestroy(this._lView, callback);
		  }
		  /**
			* Marks a view and all of its ancestors dirty.
			*
			* This can be used to ensure an {@link ChangeDetectionStrategy#OnPush} component is
			* checked when it needs to be re-rendered but the two normal triggers haven't marked it
			* dirty (i.e. inputs haven't changed and events haven't fired in the view).
			*
			* <!-- TODO: Add a link to a chapter on OnPush components -->
			*
			* @usageNotes
			* ### Example
			*
			* ```typescript
			* @Component({
			*   selector: 'app-root',
			*   template: `Number of ticks: {{numberOfTicks}}`
			*   changeDetection: ChangeDetectionStrategy.OnPush,
			* })
			* class AppComponent {
			*   numberOfTicks = 0;
			*
			*   constructor(private ref: ChangeDetectorRef) {
			*     setInterval(() => {
			*       this.numberOfTicks++;
			*       // the following is required, otherwise the view will not be updated
			*       this.ref.markForCheck();
			*     }, 1000);
			*   }
			* }
			* ```
			*/
		  markForCheck() {
			 markViewDirty(this._cdRefInjectingView || this._lView);
		  }
		  /**
			* Detaches the view from the change detection tree.
			*
			* Detached views will not be checked during change detection runs until they are
			* re-attached, even if they are dirty. `detach` can be used in combination with
			* {@link ChangeDetectorRef#detectChanges} to implement local change
			* detection checks.
			*
			* <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
			* <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->
			*
			* @usageNotes
			* ### Example
			*
			* The following example defines a component with a large list of readonly data.
			* Imagine the data changes constantly, many times per second. For performance reasons,
			* we want to check and update the list every five seconds. We can do that by detaching
			* the component's change detector and doing a local check every five seconds.
			*
			* ```typescript
			* class DataProvider {
			*   // in a real application the returned data will be different every time
			*   get data() {
			*     return [1,2,3,4,5];
			*   }
			* }
			*
			* @Component({
			*   selector: 'giant-list',
			*   template: `
			*     <li *ngFor="let d of dataProvider.data">Data {{d}}</li>
			*   `,
			* })
			* class GiantList {
			*   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {
			*     ref.detach();
			*     setInterval(() => {
			*       this.ref.detectChanges();
			*     }, 5000);
			*   }
			* }
			*
			* @Component({
			*   selector: 'app',
			*   providers: [DataProvider],
			*   template: `
			*     <giant-list><giant-list>
			*   `,
			* })
			* class App {
			* }
			* ```
			*/
		  detach() {
			 this._lView[FLAGS] &= ~128;
		  }
		  /**
			* Re-attaches a view to the change detection tree.
			*
			* This can be used to re-attach views that were previously detached from the tree
			* using {@link ChangeDetectorRef#detach}. Views are attached to the tree by default.
			*
			* <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
			*
			* @usageNotes
			* ### Example
			*
			* The following example creates a component displaying `live` data. The component will detach
			* its change detector from the main change detector tree when the component's live property
			* is set to false.
			*
			* ```typescript
			* class DataProvider {
			*   data = 1;
			*
			*   constructor() {
			*     setInterval(() => {
			*       this.data = this.data * 2;
			*     }, 500);
			*   }
			* }
			*
			* @Component({
			*   selector: 'live-data',
			*   inputs: ['live'],
			*   template: 'Data: {{dataProvider.data}}'
			* })
			* class LiveData {
			*   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {}
			*
			*   set live(value) {
			*     if (value) {
			*       this.ref.reattach();
			*     } else {
			*       this.ref.detach();
			*     }
			*   }
			* }
			*
			* @Component({
			*   selector: 'app-root',
			*   providers: [DataProvider],
			*   template: `
			*     Live Update: <input type="checkbox" [(ngModel)]="live">
			*     <live-data [live]="live"><live-data>
			*   `,
			* })
			* class AppComponent {
			*   live = true;
			* }
			* ```
			*/
		  reattach() {
			 updateAncestorTraversalFlagsOnAttach(this._lView);
			 this._lView[FLAGS] |= 128;
		  }
		  /**
			* Checks the view and its children.
			*
			* This can also be used in combination with {@link ChangeDetectorRef#detach} to implement
			* local change detection checks.
			*
			* <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
			* <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->
			*
			* @usageNotes
			* ### Example
			*
			* The following example defines a component with a large list of readonly data.
			* Imagine, the data changes constantly, many times per second. For performance reasons,
			* we want to check and update the list every five seconds.
			*
			* We can do that by detaching the component's change detector and doing a local change detection
			* check every five seconds.
			*
			* See {@link ChangeDetectorRef#detach} for more information.
			*/
		  detectChanges() {
			 this._lView[FLAGS] |= 1024;
			 detectChangesInternal(this._lView, this.notifyErrorHandler);
		  }
		  /**
			* Checks the change detector and its children, and throws if any changes are detected.
			*
			* This is used in development mode to verify that running change detection doesn't
			* introduce other changes.
			*/
		  checkNoChanges() {
			 if (ngDevMode) {
				checkNoChangesInternal(this._lView, this.notifyErrorHandler);
			 }
		  }
		  attachToViewContainerRef() {
			 if (this._appRef) {
				throw new RuntimeError(902, ngDevMode && "This view is already attached directly to the ApplicationRef!");
			 }
			 this._attachedToViewContainer = true;
		  }
		  detachFromAppRef() {
			 this._appRef = null;
			 detachViewFromDOM(this._lView[TVIEW], this._lView);
		  }
		  attachToAppRef(appRef) {
			 if (this._attachedToViewContainer) {
				throw new RuntimeError(902, ngDevMode && "This view is already attached to a ViewContainer!");
			 }
			 this._appRef = appRef;
			 updateAncestorTraversalFlagsOnAttach(this._lView);
		  }
		};
		var TemplateRef = class {
		  static {
			 this.__NG_ELEMENT_ID__ = injectTemplateRef;
		  }
		};
		var ViewEngineTemplateRef = TemplateRef;
		var R3TemplateRef = class TemplateRef2 extends ViewEngineTemplateRef {
		  constructor(_declarationLView, _declarationTContainer, elementRef) {
			 super();
			 this._declarationLView = _declarationLView;
			 this._declarationTContainer = _declarationTContainer;
			 this.elementRef = elementRef;
		  }
		  /**
			* Returns an `ssrId` associated with a TView, which was used to
			* create this instance of the `TemplateRef`.
			*
			* @internal
			*/
		  get ssrId() {
			 return this._declarationTContainer.tView?.ssrId || null;
		  }
		  createEmbeddedView(context2, injector) {
			 return this.createEmbeddedViewImpl(context2, injector);
		  }
		  /**
			* @internal
			*/
		  createEmbeddedViewImpl(context2, injector, dehydratedView) {
			 const embeddedLView = createAndRenderEmbeddedLView(this._declarationLView, this._declarationTContainer, context2, { embeddedViewInjector: injector, dehydratedView });
			 return new ViewRef$1(embeddedLView);
		  }
		};
		function injectTemplateRef() {
		  return createTemplateRef(getCurrentTNode(), getLView());
		}
		function createTemplateRef(hostTNode, hostLView) {
		  if (hostTNode.type & 4) {
			 ngDevMode && assertDefined(hostTNode.tView, "TView must be allocated");
			 return new R3TemplateRef(hostLView, hostTNode, createElementRef(hostTNode, hostLView));
		  }
		  return null;
		}
		var REF_EXTRACTOR_REGEXP = new RegExp(`^(\\d+)*(${REFERENCE_NODE_BODY}|${REFERENCE_NODE_HOST})*(.*)`);
		var _findMatchingDehydratedViewImpl = () => null;
		function findMatchingDehydratedView(lContainer, template) {
		  return _findMatchingDehydratedViewImpl(lContainer, template);
		}
		var ChangeDetectionScheduler = class {
		};
		var ComponentRef$1 = class {
		};
		var ComponentFactory$1 = class {
		};
		function noComponentFactoryError(component) {
		  const error = Error(`No component factory found for ${stringify(component)}.`);
		  error[ERROR_COMPONENT] = component;
		  return error;
		}
		var ERROR_COMPONENT = "ngComponent";
		var _NullComponentFactoryResolver = class {
		  resolveComponentFactory(component) {
			 throw noComponentFactoryError(component);
		  }
		};
		var ComponentFactoryResolver$1 = class {
		  static {
			 this.NULL = /* @__PURE__ */ new _NullComponentFactoryResolver();
		  }
		};
		var RendererFactory2 = class {
		};
		var Renderer2 = class {
		  constructor() {
			 this.destroyNode = null;
		  }
		  static {
			 this.__NG_ELEMENT_ID__ = () => injectRenderer2();
		  }
		};
		function injectRenderer2() {
		  const lView = getLView();
		  const tNode = getCurrentTNode();
		  const nodeAtIndex = getComponentLViewByIndex(tNode.index, lView);
		  return (isLView(nodeAtIndex) ? nodeAtIndex : lView)[RENDERER];
		}
		var Sanitizer = class _Sanitizer {
		  static {
			 this.\u0275prov = \u0275\u0275defineInjectable({
				token: _Sanitizer,
				providedIn: "root",
				factory: () => null
			 });
		  }
		};
		var NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR = {};
		var markedFeatures = /* @__PURE__ */ new Set();
		function performanceMarkFeature(feature) {
		  if (markedFeatures.has(feature)) {
			 return;
		  }
		  markedFeatures.add(feature);
		  performance?.mark?.("mark_feature_usage", { detail: { feature } });
		}
		function noop2(...args) {
		}
		function getNativeRequestAnimationFrame() {
		  const isBrowser2 = typeof _global["requestAnimationFrame"] === "function";
		  let nativeRequestAnimationFrame = _global[isBrowser2 ? "requestAnimationFrame" : "setTimeout"];
		  let nativeCancelAnimationFrame = _global[isBrowser2 ? "cancelAnimationFrame" : "clearTimeout"];
		  if (typeof Zone !== "undefined" && nativeRequestAnimationFrame && nativeCancelAnimationFrame) {
			 const unpatchedRequestAnimationFrame = nativeRequestAnimationFrame[Zone.__symbol__("OriginalDelegate")];
			 if (unpatchedRequestAnimationFrame) {
				nativeRequestAnimationFrame = unpatchedRequestAnimationFrame;
			 }
			 const unpatchedCancelAnimationFrame = nativeCancelAnimationFrame[Zone.__symbol__("OriginalDelegate")];
			 if (unpatchedCancelAnimationFrame) {
				nativeCancelAnimationFrame = unpatchedCancelAnimationFrame;
			 }
		  }
		  return { nativeRequestAnimationFrame, nativeCancelAnimationFrame };
		}
		var AsyncStackTaggingZoneSpec = class {
		  constructor(namePrefix, consoleAsyncStackTaggingImpl = console) {
			 this.name = "asyncStackTagging for " + namePrefix;
			 this.createTask = consoleAsyncStackTaggingImpl?.createTask ?? (() => null);
		  }
		  onScheduleTask(delegate, _current, target, task) {
			 task.consoleTask = this.createTask(`Zone - ${task.source || task.type}`);
			 return delegate.scheduleTask(target, task);
		  }
		  onInvokeTask(delegate, _currentZone, targetZone, task, applyThis, applyArgs) {
			 let ret;
			 if (task.consoleTask) {
				ret = task.consoleTask.run(() => delegate.invokeTask(targetZone, task, applyThis, applyArgs));
			 } else {
				ret = delegate.invokeTask(targetZone, task, applyThis, applyArgs);
			 }
			 return ret;
		  }
		};
		var NgZone = class _NgZone {
		  constructor({ enableLongStackTrace = false, shouldCoalesceEventChangeDetection = false, shouldCoalesceRunChangeDetection = false }) {
			 this.hasPendingMacrotasks = false;
			 this.hasPendingMicrotasks = false;
			 this.isStable = true;
			 this.onUnstable = new EventEmitter(false);
			 this.onMicrotaskEmpty = new EventEmitter(false);
			 this.onStable = new EventEmitter(false);
			 this.onError = new EventEmitter(false);
			 if (typeof Zone == "undefined") {
				throw new RuntimeError(908, ngDevMode && `In this configuration Angular requires Zone.js`);
			 }
			 Zone.assertZonePatched();
			 const self2 = this;
			 self2._nesting = 0;
			 self2._outer = self2._inner = Zone.current;
			 if (ngDevMode) {
				self2._inner = self2._inner.fork(new AsyncStackTaggingZoneSpec("Angular"));
			 }
			 if (Zone["TaskTrackingZoneSpec"]) {
				self2._inner = self2._inner.fork(new Zone["TaskTrackingZoneSpec"]());
			 }
			 if (enableLongStackTrace && Zone["longStackTraceZoneSpec"]) {
				self2._inner = self2._inner.fork(Zone["longStackTraceZoneSpec"]);
			 }
			 self2.shouldCoalesceEventChangeDetection = !shouldCoalesceRunChangeDetection && shouldCoalesceEventChangeDetection;
			 self2.shouldCoalesceRunChangeDetection = shouldCoalesceRunChangeDetection;
			 self2.lastRequestAnimationFrameId = -1;
			 self2.nativeRequestAnimationFrame = getNativeRequestAnimationFrame().nativeRequestAnimationFrame;
			 forkInnerZoneWithAngularBehavior(self2);
		  }
		  /**
			 This method checks whether the method call happens within an Angular Zone instance.
		  */
		  static isInAngularZone() {
			 return typeof Zone !== "undefined" && Zone.current.get("isAngularZone") === true;
		  }
		  /**
			 Assures that the method is called within the Angular Zone, otherwise throws an error.
		  */
		  static assertInAngularZone() {
			 if (!_NgZone.isInAngularZone()) {
				throw new RuntimeError(909, ngDevMode && "Expected to be in Angular Zone, but it is not!");
			 }
		  }
		  /**
			 Assures that the method is called outside of the Angular Zone, otherwise throws an error.
		  */
		  static assertNotInAngularZone() {
			 if (_NgZone.isInAngularZone()) {
				throw new RuntimeError(909, ngDevMode && "Expected to not be in Angular Zone, but it is!");
			 }
		  }
		  /**
			* Executes the `fn` function synchronously within the Angular zone and returns value returned by
			* the function.
			*
			* Running functions via `run` allows you to reenter Angular zone from a task that was executed
			* outside of the Angular zone (typically started via {@link #runOutsideAngular}).
			*
			* Any future tasks or microtasks scheduled from within this function will continue executing from
			* within the Angular zone.
			*
			* If a synchronous error happens it will be rethrown and not reported via `onError`.
			*/
		  run(fn, applyThis, applyArgs) {
			 return this._inner.run(fn, applyThis, applyArgs);
		  }
		  /**
			* Executes the `fn` function synchronously within the Angular zone as a task and returns value
			* returned by the function.
			*
			* Running functions via `run` allows you to reenter Angular zone from a task that was executed
			* outside of the Angular zone (typically started via {@link #runOutsideAngular}).
			*
			* Any future tasks or microtasks scheduled from within this function will continue executing from
			* within the Angular zone.
			*
			* If a synchronous error happens it will be rethrown and not reported via `onError`.
			*/
		  runTask(fn, applyThis, applyArgs, name) {
			 const zone = this._inner;
			 const task = zone.scheduleEventTask("NgZoneEvent: " + name, fn, EMPTY_PAYLOAD, noop2, noop2);
			 try {
				return zone.runTask(task, applyThis, applyArgs);
			 } finally {
				zone.cancelTask(task);
			 }
		  }
		  /**
			* Same as `run`, except that synchronous errors are caught and forwarded via `onError` and not
			* rethrown.
			*/
		  runGuarded(fn, applyThis, applyArgs) {
			 return this._inner.runGuarded(fn, applyThis, applyArgs);
		  }
		  /**
			* Executes the `fn` function synchronously in Angular's parent zone and returns value returned by
			* the function.
			*
			* Running functions via {@link #runOutsideAngular} allows you to escape Angular's zone and do
			* work that
			* doesn't trigger Angular change-detection or is subject to Angular's error handling.
			*
			* Any future tasks or microtasks scheduled from within this function will continue executing from
			* outside of the Angular zone.
			*
			* Use {@link #run} to reenter the Angular zone and do work that updates the application model.
			*/
		  runOutsideAngular(fn) {
			 return this._outer.run(fn);
		  }
		};
		var EMPTY_PAYLOAD = {};
		function checkStable(zone) {
		  if (zone._nesting == 0 && !zone.hasPendingMicrotasks && !zone.isStable) {
			 try {
				zone._nesting++;
				zone.onMicrotaskEmpty.emit(null);
			 } finally {
				zone._nesting--;
				if (!zone.hasPendingMicrotasks) {
				  try {
					 zone.runOutsideAngular(() => zone.onStable.emit(null));
				  } finally {
					 zone.isStable = true;
				  }
				}
			 }
		  }
		}
		function delayChangeDetectionForEvents(zone) {
		  if (zone.isCheckStableRunning || zone.lastRequestAnimationFrameId !== -1) {
			 return;
		  }
		  zone.lastRequestAnimationFrameId = zone.nativeRequestAnimationFrame.call(_global, () => {
			 if (!zone.fakeTopEventTask) {
				zone.fakeTopEventTask = Zone.root.scheduleEventTask("fakeTopEventTask", () => {
				  zone.lastRequestAnimationFrameId = -1;
				  updateMicroTaskStatus(zone);
				  zone.isCheckStableRunning = true;
				  checkStable(zone);
				  zone.isCheckStableRunning = false;
				}, void 0, () => {
				}, () => {
				});
			 }
			 zone.fakeTopEventTask.invoke();
		  });
		  updateMicroTaskStatus(zone);
		}
		function forkInnerZoneWithAngularBehavior(zone) {
		  const delayChangeDetectionForEventsDelegate = () => {
			 delayChangeDetectionForEvents(zone);
		  };
		  zone._inner = zone._inner.fork({
			 name: "angular",
			 properties: { "isAngularZone": true },
			 onInvokeTask: (delegate, current, target, task, applyThis, applyArgs) => {
				if (shouldBeIgnoredByZone(applyArgs)) {
				  return delegate.invokeTask(target, task, applyThis, applyArgs);
				}
				try {
				  onEnter(zone);
				  return delegate.invokeTask(target, task, applyThis, applyArgs);
				} finally {
				  if (zone.shouldCoalesceEventChangeDetection && task.type === "eventTask" || zone.shouldCoalesceRunChangeDetection) {
					 delayChangeDetectionForEventsDelegate();
				  }
				  onLeave(zone);
				}
			 },
			 onInvoke: (delegate, current, target, callback, applyThis, applyArgs, source) => {
				try {
				  onEnter(zone);
				  return delegate.invoke(target, callback, applyThis, applyArgs, source);
				} finally {
				  if (zone.shouldCoalesceRunChangeDetection) {
					 delayChangeDetectionForEventsDelegate();
				  }
				  onLeave(zone);
				}
			 },
			 onHasTask: (delegate, current, target, hasTaskState) => {
				delegate.hasTask(target, hasTaskState);
				if (current === target) {
				  if (hasTaskState.change == "microTask") {
					 zone._hasPendingMicrotasks = hasTaskState.microTask;
					 updateMicroTaskStatus(zone);
					 checkStable(zone);
				  } else if (hasTaskState.change == "macroTask") {
					 zone.hasPendingMacrotasks = hasTaskState.macroTask;
				  }
				}
			 },
			 onHandleError: (delegate, current, target, error) => {
				delegate.handleError(target, error);
				zone.runOutsideAngular(() => zone.onError.emit(error));
				return false;
			 }
		  });
		}
		function updateMicroTaskStatus(zone) {
		  if (zone._hasPendingMicrotasks || (zone.shouldCoalesceEventChangeDetection || zone.shouldCoalesceRunChangeDetection) && zone.lastRequestAnimationFrameId !== -1) {
			 zone.hasPendingMicrotasks = true;
		  } else {
			 zone.hasPendingMicrotasks = false;
		  }
		}
		function onEnter(zone) {
		  zone._nesting++;
		  if (zone.isStable) {
			 zone.isStable = false;
			 zone.onUnstable.emit(null);
		  }
		}
		function onLeave(zone) {
		  zone._nesting--;
		  checkStable(zone);
		}
		var NoopNgZone = class {
		  constructor() {
			 this.hasPendingMicrotasks = false;
			 this.hasPendingMacrotasks = false;
			 this.isStable = true;
			 this.onUnstable = new EventEmitter();
			 this.onMicrotaskEmpty = new EventEmitter();
			 this.onStable = new EventEmitter();
			 this.onError = new EventEmitter();
		  }
		  run(fn, applyThis, applyArgs) {
			 return fn.apply(applyThis, applyArgs);
		  }
		  runGuarded(fn, applyThis, applyArgs) {
			 return fn.apply(applyThis, applyArgs);
		  }
		  runOutsideAngular(fn) {
			 return fn();
		  }
		  runTask(fn, applyThis, applyArgs, name) {
			 return fn.apply(applyThis, applyArgs);
		  }
		};
		function shouldBeIgnoredByZone(applyArgs) {
		  if (!Array.isArray(applyArgs)) {
			 return false;
		  }
		  if (applyArgs.length !== 1) {
			 return false;
		  }
		  return applyArgs[0].data?.["__ignore_ng_zone__"] === true;
		}
		function getNgZone(ngZoneToUse = "zone.js", options) {
		  if (ngZoneToUse === "noop") {
			 return new NoopNgZone();
		  }
		  if (ngZoneToUse === "zone.js") {
			 return new NgZone(options);
		  }
		  return ngZoneToUse;
		}
		var AfterRenderPhase;
		(function(AfterRenderPhase2) {
		  AfterRenderPhase2[AfterRenderPhase2["EarlyRead"] = 0] = "EarlyRead";
		  AfterRenderPhase2[AfterRenderPhase2["Write"] = 1] = "Write";
		  AfterRenderPhase2[AfterRenderPhase2["MixedReadWrite"] = 2] = "MixedReadWrite";
		  AfterRenderPhase2[AfterRenderPhase2["Read"] = 3] = "Read";
		})(AfterRenderPhase || (AfterRenderPhase = {}));
		function internalAfterNextRender(callback, options) {
		  const injector = options?.injector ?? inject(Injector);
		  if (!options?.runOnServer && !isPlatformBrowser(injector))
			 return;
		  const afterRenderEventManager = injector.get(AfterRenderEventManager);
		  afterRenderEventManager.internalCallbacks.push(callback);
		}
		var AfterRenderEventManager = class _AfterRenderEventManager {
		  constructor() {
			 this.handler = null;
			 this.internalCallbacks = [];
		  }
		  /**
			* Executes internal and user-provided callbacks.
			*/
		  execute() {
			 this.executeInternalCallbacks();
			 this.handler?.execute();
		  }
		  executeInternalCallbacks() {
			 const callbacks = [...this.internalCallbacks];
			 this.internalCallbacks.length = 0;
			 for (const callback of callbacks) {
				callback();
			 }
		  }
		  ngOnDestroy() {
			 this.handler?.destroy();
			 this.handler = null;
			 this.internalCallbacks.length = 0;
		  }
		  static {
			 this.\u0275prov = \u0275\u0275defineInjectable({
				token: _AfterRenderEventManager,
				providedIn: "root",
				factory: () => new _AfterRenderEventManager()
			 });
		  }
		};
		function isModuleWithProviders(value) {
		  return value.ngModule !== void 0;
		}
		function isNgModule(value) {
		  return !!getNgModuleDef(value);
		}
		function isPipe(value) {
		  return !!getPipeDef$1(value);
		}
		function isDirective(value) {
		  return !!getDirectiveDef(value);
		}
		function isComponent(value) {
		  return !!getComponentDef(value);
		}
		function getDependencyTypeForError(type2) {
		  if (getComponentDef(type2))
			 return "component";
		  if (getDirectiveDef(type2))
			 return "directive";
		  if (getPipeDef$1(type2))
			 return "pipe";
		  return "type";
		}
		function verifyStandaloneImport(depType, importingType) {
		  if (isForwardRef(depType)) {
			 depType = resolveForwardRef(depType);
			 if (!depType) {
				throw new Error(`Expected forwardRef function, imported from "${stringifyForError(importingType)}", to return a standalone entity or NgModule but got "${stringifyForError(depType) || depType}".`);
			 }
		  }
		  if (getNgModuleDef(depType) == null) {
			 const def = getComponentDef(depType) || getDirectiveDef(depType) || getPipeDef$1(depType);
			 if (def != null) {
				if (!def.standalone) {
				  throw new Error(`The "${stringifyForError(depType)}" ${getDependencyTypeForError(depType)}, imported from "${stringifyForError(importingType)}", is not standalone. Did you forget to add the standalone: true flag?`);
				}
			 } else {
				if (isModuleWithProviders(depType)) {
				  throw new Error(`A module with providers was imported from "${stringifyForError(importingType)}". Modules with providers are not supported in standalone components imports.`);
				} else {
				  throw new Error(`The "${stringifyForError(depType)}" type, imported from "${stringifyForError(importingType)}", must be a standalone component / directive / pipe or an NgModule. Did you forget to add the required @Component / @Directive / @Pipe or @NgModule annotation?`);
				}
			 }
		  }
		}
		var USE_RUNTIME_DEPS_TRACKER_FOR_JIT = true;
		var DepsTracker = class {
		  constructor() {
			 this.ownerNgModule = /* @__PURE__ */ new Map();
			 this.ngModulesWithSomeUnresolvedDecls = /* @__PURE__ */ new Set();
			 this.ngModulesScopeCache = /* @__PURE__ */ new Map();
			 this.standaloneComponentsScopeCache = /* @__PURE__ */ new Map();
		  }
		  /**
			* Attempts to resolve ng module's forward ref declarations as much as possible and add them to
			* the `ownerNgModule` map. This method normally should be called after the initial parsing when
			* all the forward refs are resolved (e.g., when trying to render a component)
			*/
		  resolveNgModulesDecls() {
			 if (this.ngModulesWithSomeUnresolvedDecls.size === 0) {
				return;
			 }
			 for (const moduleType of this.ngModulesWithSomeUnresolvedDecls) {
				const def = getNgModuleDef(moduleType);
				if (def?.declarations) {
				  for (const decl of maybeUnwrapFn(def.declarations)) {
					 if (isComponent(decl)) {
						this.ownerNgModule.set(decl, moduleType);
					 }
				  }
				}
			 }
			 this.ngModulesWithSomeUnresolvedDecls.clear();
		  }
		  /** @override */
		  getComponentDependencies(type2, rawImports) {
			 this.resolveNgModulesDecls();
			 const def = getComponentDef(type2);
			 if (def === null) {
				throw new Error(`Attempting to get component dependencies for a type that is not a component: ${type2}`);
			 }
			 if (def.standalone) {
				const scope = this.getStandaloneComponentScope(type2, rawImports);
				if (scope.compilation.isPoisoned) {
				  return { dependencies: [] };
				}
				return {
				  dependencies: [
					 ...scope.compilation.directives,
					 ...scope.compilation.pipes,
					 ...scope.compilation.ngModules
				  ]
				};
			 } else {
				if (!this.ownerNgModule.has(type2)) {
				  return { dependencies: [] };
				}
				const scope = this.getNgModuleScope(this.ownerNgModule.get(type2));
				if (scope.compilation.isPoisoned) {
				  return { dependencies: [] };
				}
				return {
				  dependencies: [
					 ...scope.compilation.directives,
					 ...scope.compilation.pipes
				  ]
				};
			 }
		  }
		  /**
			* @override
			* This implementation does not make use of param scopeInfo since it assumes the scope info is
			* already added to the type itself through methods like {@link setNgModuleScope}
			*/
		  registerNgModule(type2, scopeInfo) {
			 if (!isNgModule(type2)) {
				throw new Error(`Attempting to register a Type which is not NgModule as NgModule: ${type2}`);
			 }
			 this.ngModulesWithSomeUnresolvedDecls.add(type2);
		  }
		  /** @override */
		  clearScopeCacheFor(type2) {
			 this.ngModulesScopeCache.delete(type2);
			 this.standaloneComponentsScopeCache.delete(type2);
		  }
		  /** @override */
		  getNgModuleScope(type2) {
			 if (this.ngModulesScopeCache.has(type2)) {
				return this.ngModulesScopeCache.get(type2);
			 }
			 const scope = this.computeNgModuleScope(type2);
			 this.ngModulesScopeCache.set(type2, scope);
			 return scope;
		  }
		  /** Compute NgModule scope afresh. */
		  computeNgModuleScope(type2) {
			 const def = getNgModuleDef(type2, true);
			 const scope = {
				exported: { directives: /* @__PURE__ */ new Set(), pipes: /* @__PURE__ */ new Set() },
				compilation: { directives: /* @__PURE__ */ new Set(), pipes: /* @__PURE__ */ new Set() }
			 };
			 for (const imported of maybeUnwrapFn(def.imports)) {
				if (isNgModule(imported)) {
				  const importedScope = this.getNgModuleScope(imported);
				  addSet(importedScope.exported.directives, scope.compilation.directives);
				  addSet(importedScope.exported.pipes, scope.compilation.pipes);
				} else if (isStandalone(imported)) {
				  if (isDirective(imported) || isComponent(imported)) {
					 scope.compilation.directives.add(imported);
				  } else if (isPipe(imported)) {
					 scope.compilation.pipes.add(imported);
				  } else {
					 throw new RuntimeError(1e3, "The standalone imported type is neither a component nor a directive nor a pipe");
				  }
				} else {
				  scope.compilation.isPoisoned = true;
				  break;
				}
			 }
			 if (!scope.compilation.isPoisoned) {
				for (const decl of maybeUnwrapFn(def.declarations)) {
				  if (isNgModule(decl) || isStandalone(decl)) {
					 scope.compilation.isPoisoned = true;
					 break;
				  }
				  if (isPipe(decl)) {
					 scope.compilation.pipes.add(decl);
				  } else {
					 scope.compilation.directives.add(decl);
				  }
				}
			 }
			 for (const exported of maybeUnwrapFn(def.exports)) {
				if (isNgModule(exported)) {
				  const exportedScope = this.getNgModuleScope(exported);
				  addSet(exportedScope.exported.directives, scope.exported.directives);
				  addSet(exportedScope.exported.pipes, scope.exported.pipes);
				  addSet(exportedScope.exported.directives, scope.compilation.directives);
				  addSet(exportedScope.exported.pipes, scope.compilation.pipes);
				} else if (isPipe(exported)) {
				  scope.exported.pipes.add(exported);
				} else {
				  scope.exported.directives.add(exported);
				}
			 }
			 return scope;
		  }
		  /** @override */
		  getStandaloneComponentScope(type2, rawImports) {
			 if (this.standaloneComponentsScopeCache.has(type2)) {
				return this.standaloneComponentsScopeCache.get(type2);
			 }
			 const ans = this.computeStandaloneComponentScope(type2, rawImports);
			 this.standaloneComponentsScopeCache.set(type2, ans);
			 return ans;
		  }
		  computeStandaloneComponentScope(type2, rawImports) {
			 const ans = {
				compilation: {
				  // Standalone components are always able to self-reference.
				  directives: /* @__PURE__ */ new Set([type2]),
				  pipes: /* @__PURE__ */ new Set(),
				  ngModules: /* @__PURE__ */ new Set()
				}
			 };
			 for (const rawImport of flatten(rawImports ?? [])) {
				const imported = resolveForwardRef(rawImport);
				try {
				  verifyStandaloneImport(imported, type2);
				} catch (e) {
				  ans.compilation.isPoisoned = true;
				  return ans;
				}
				if (isNgModule(imported)) {
				  ans.compilation.ngModules.add(imported);
				  const importedScope = this.getNgModuleScope(imported);
				  if (importedScope.exported.isPoisoned) {
					 ans.compilation.isPoisoned = true;
					 return ans;
				  }
				  addSet(importedScope.exported.directives, ans.compilation.directives);
				  addSet(importedScope.exported.pipes, ans.compilation.pipes);
				} else if (isPipe(imported)) {
				  ans.compilation.pipes.add(imported);
				} else if (isDirective(imported) || isComponent(imported)) {
				  ans.compilation.directives.add(imported);
				} else {
				  ans.compilation.isPoisoned = true;
				  return ans;
				}
			 }
			 return ans;
		  }
		  /** @override */
		  isOrphanComponent(cmp) {
			 const def = getComponentDef(cmp);
			 if (!def || def.standalone) {
				return false;
			 }
			 this.resolveNgModulesDecls();
			 return !this.ownerNgModule.has(cmp);
		  }
		};
		function addSet(sourceSet, targetSet) {
		  for (const m of sourceSet) {
			 targetSet.add(m);
		  }
		}
		var depsTracker = new DepsTracker();
		function computeStaticStyling(tNode, attrs, writeToHost) {
		  ngDevMode && assertFirstCreatePass(getTView(), "Expecting to be called in first template pass only");
		  let styles = writeToHost ? tNode.styles : null;
		  let classes = writeToHost ? tNode.classes : null;
		  let mode = 0;
		  if (attrs !== null) {
			 for (let i = 0; i < attrs.length; i++) {
				const value = attrs[i];
				if (typeof value === "number") {
				  mode = value;
				} else if (mode == 1) {
				  classes = concatStringsWithSpace(classes, value);
				} else if (mode == 2) {
				  const style = value;
				  const styleValue2 = attrs[++i];
				  styles = concatStringsWithSpace(styles, style + ": " + styleValue2 + ";");
				}
			 }
		  }
		  writeToHost ? tNode.styles = styles : tNode.stylesWithoutHost = styles;
		  writeToHost ? tNode.classes = classes : tNode.classesWithoutHost = classes;
		}
		var ComponentFactoryResolver = class extends ComponentFactoryResolver$1 {
		  /**
			* @param ngModule The NgModuleRef to which all resolved factories are bound.
			*/
		  constructor(ngModule) {
			 super();
			 this.ngModule = ngModule;
		  }
		  resolveComponentFactory(component) {
			 ngDevMode && assertComponentType(component);
			 const componentDef = getComponentDef(component);
			 return new ComponentFactory(componentDef, this.ngModule);
		  }
		};
		function toRefArray(map3) {
		  const array2 = [];
		  for (const publicName in map3) {
			 if (!map3.hasOwnProperty(publicName)) {
				continue;
			 }
			 const value = map3[publicName];
			 if (value === void 0) {
				continue;
			 }
			 array2.push({
				propName: Array.isArray(value) ? value[0] : value,
				templateName: publicName
			 });
		  }
		  return array2;
		}
		function getNamespace(elementName) {
		  const name = elementName.toLowerCase();
		  return name === "svg" ? SVG_NAMESPACE : name === "math" ? MATH_ML_NAMESPACE : null;
		}
		var ChainedInjector = class {
		  constructor(injector, parentInjector) {
			 this.injector = injector;
			 this.parentInjector = parentInjector;
		  }
		  get(token, notFoundValue, flags) {
			 flags = convertToBitFlags(flags);
			 const value = this.injector.get(token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR, flags);
			 if (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR || notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR) {
				return value;
			 }
			 return this.parentInjector.get(token, notFoundValue, flags);
		  }
		};
		var ComponentFactory = class extends ComponentFactory$1 {
		  get inputs() {
			 const componentDef = this.componentDef;
			 const inputTransforms = componentDef.inputTransforms;
			 const refArray = toRefArray(componentDef.inputs);
			 if (inputTransforms !== null) {
				for (const input2 of refArray) {
				  if (inputTransforms.hasOwnProperty(input2.propName)) {
					 input2.transform = inputTransforms[input2.propName];
				  }
				}
			 }
			 return refArray;
		  }
		  get outputs() {
			 return toRefArray(this.componentDef.outputs);
		  }
		  /**
			* @param componentDef The component definition.
			* @param ngModule The NgModuleRef to which the factory is bound.
			*/
		  constructor(componentDef, ngModule) {
			 super();
			 this.componentDef = componentDef;
			 this.ngModule = ngModule;
			 this.componentType = componentDef.type;
			 this.selector = stringifyCSSSelectorList(componentDef.selectors);
			 this.ngContentSelectors = componentDef.ngContentSelectors ? componentDef.ngContentSelectors : [];
			 this.isBoundToModule = !!ngModule;
		  }
		  create(injector, projectableNodes, rootSelectorOrNode, environmentInjector) {
			 const prevConsumer = setActiveConsumer(null);
			 try {
				if (ngDevMode && false) {
				  if (depsTracker.isOrphanComponent(this.componentType)) {
					 throw new RuntimeError(1001, `Orphan component found! Trying to render the component ${debugStringifyTypeForError(this.componentType)} without first loading the NgModule that declares it. It is recommended to make this component standalone in order to avoid this error. If this is not possible now, import the component's NgModule in the appropriate NgModule, or the standalone component in which you are trying to render this component. If this is a lazy import, load the NgModule lazily as well and use its module injector.`);
				  }
				}
				environmentInjector = environmentInjector || this.ngModule;
				let realEnvironmentInjector = environmentInjector instanceof EnvironmentInjector ? environmentInjector : environmentInjector?.injector;
				if (realEnvironmentInjector && this.componentDef.getStandaloneInjector !== null) {
				  realEnvironmentInjector = this.componentDef.getStandaloneInjector(realEnvironmentInjector) || realEnvironmentInjector;
				}
				const rootViewInjector = realEnvironmentInjector ? new ChainedInjector(injector, realEnvironmentInjector) : injector;
				const rendererFactory = rootViewInjector.get(RendererFactory2, null);
				if (rendererFactory === null) {
				  throw new RuntimeError(407, ngDevMode && "Angular was not able to inject a renderer (RendererFactory2). Likely this is due to a broken DI hierarchy. Make sure that any injector used to create this component has a correct parent.");
				}
				const sanitizer = rootViewInjector.get(Sanitizer, null);
				const afterRenderEventManager = rootViewInjector.get(AfterRenderEventManager, null);
				const changeDetectionScheduler = rootViewInjector.get(ChangeDetectionScheduler, null);
				const environment = {
				  rendererFactory,
				  sanitizer,
				  // We don't use inline effects (yet).
				  inlineEffectRunner: null,
				  afterRenderEventManager,
				  changeDetectionScheduler
				};
				const hostRenderer = rendererFactory.createRenderer(null, this.componentDef);
				const elementName = this.componentDef.selectors[0][0] || "div";
				const hostRNode = rootSelectorOrNode ? locateHostElement(hostRenderer, rootSelectorOrNode, this.componentDef.encapsulation, rootViewInjector) : createElementNode(hostRenderer, elementName, getNamespace(elementName));
				let rootFlags = 512;
				if (this.componentDef.signals) {
				  rootFlags |= 4096;
				} else if (!this.componentDef.onPush) {
				  rootFlags |= 16;
				}
				let hydrationInfo = null;
				if (hostRNode !== null) {
				  hydrationInfo = retrieveHydrationInfo(
					 hostRNode,
					 rootViewInjector,
					 true
					 /* isRootView */
				  );
				}
				const rootTView = createTView(0, null, null, 1, 0, null, null, null, null, null, null);
				const rootLView = createLView(null, rootTView, null, rootFlags, null, null, environment, hostRenderer, rootViewInjector, null, hydrationInfo);
				enterView(rootLView);
				let component;
				let tElementNode;
				try {
				  const rootComponentDef = this.componentDef;
				  let rootDirectives;
				  let hostDirectiveDefs = null;
				  if (rootComponentDef.findHostDirectiveDefs) {
					 rootDirectives = [];
					 hostDirectiveDefs = /* @__PURE__ */ new Map();
					 rootComponentDef.findHostDirectiveDefs(rootComponentDef, rootDirectives, hostDirectiveDefs);
					 rootDirectives.push(rootComponentDef);
					 ngDevMode && assertNoDuplicateDirectives(rootDirectives);
				  } else {
					 rootDirectives = [rootComponentDef];
				  }
				  const hostTNode = createRootComponentTNode(rootLView, hostRNode);
				  const componentView = createRootComponentView(hostTNode, hostRNode, rootComponentDef, rootDirectives, rootLView, environment, hostRenderer);
				  tElementNode = getTNode(rootTView, HEADER_OFFSET);
				  if (hostRNode) {
					 setRootNodeAttributes(hostRenderer, rootComponentDef, hostRNode, rootSelectorOrNode);
				  }
				  if (projectableNodes !== void 0) {
					 projectNodes(tElementNode, this.ngContentSelectors, projectableNodes);
				  }
				  component = createRootComponent(componentView, rootComponentDef, rootDirectives, hostDirectiveDefs, rootLView, [LifecycleHooksFeature]);
				  renderView(rootTView, rootLView, null);
				} finally {
				  leaveView();
				}
				return new ComponentRef(this.componentType, component, createElementRef(tElementNode, rootLView), rootLView, tElementNode);
			 } finally {
				setActiveConsumer(prevConsumer);
			 }
		  }
		};
		var ComponentRef = class extends ComponentRef$1 {
		  constructor(componentType, instance, location2, _rootLView, _tNode) {
			 super();
			 this.location = location2;
			 this._rootLView = _rootLView;
			 this._tNode = _tNode;
			 this.previousInputValues = null;
			 this.instance = instance;
			 this.hostView = this.changeDetectorRef = new ViewRef$1(
				_rootLView,
				void 0,
				/* _cdRefInjectingView */
				false
			 );
			 this.componentType = componentType;
		  }
		  setInput(name, value) {
			 const inputData = this._tNode.inputs;
			 let dataValue;
			 if (inputData !== null && (dataValue = inputData[name])) {
				this.previousInputValues ??= /* @__PURE__ */ new Map();
				if (this.previousInputValues.has(name) && Object.is(this.previousInputValues.get(name), value)) {
				  return;
				}
				const lView = this._rootLView;
				setInputsForProperty(lView[TVIEW], lView, dataValue, name, value);
				this.previousInputValues.set(name, value);
				const childComponentLView = getComponentLViewByIndex(this._tNode.index, lView);
				markViewDirty(childComponentLView);
			 } else {
				if (ngDevMode) {
				  const cmpNameForError = stringifyForError(this.componentType);
				  let message2 = `Can't set value of the '${name}' input on the '${cmpNameForError}' component. `;
				  message2 += `Make sure that the '${name}' property is annotated with @Input() or a mapped @Input('${name}') exists.`;
				  reportUnknownPropertyError(message2);
				}
			 }
		  }
		  get injector() {
			 return new NodeInjector(this._tNode, this._rootLView);
		  }
		  destroy() {
			 this.hostView.destroy();
		  }
		  onDestroy(callback) {
			 this.hostView.onDestroy(callback);
		  }
		};
		function createRootComponentTNode(lView, rNode) {
		  const tView = lView[TVIEW];
		  const index = HEADER_OFFSET;
		  ngDevMode && assertIndexInRange(lView, index);
		  lView[index] = rNode;
		  return getOrCreateTNode(tView, index, 2, "#host", null);
		}
		function createRootComponentView(tNode, hostRNode, rootComponentDef, rootDirectives, rootView, environment, hostRenderer) {
		  const tView = rootView[TVIEW];
		  applyRootComponentStyling(rootDirectives, tNode, hostRNode, hostRenderer);
		  let hydrationInfo = null;
		  if (hostRNode !== null) {
			 hydrationInfo = retrieveHydrationInfo(hostRNode, rootView[INJECTOR]);
		  }
		  const viewRenderer = environment.rendererFactory.createRenderer(hostRNode, rootComponentDef);
		  let lViewFlags = 16;
		  if (rootComponentDef.signals) {
			 lViewFlags = 4096;
		  } else if (rootComponentDef.onPush) {
			 lViewFlags = 64;
		  }
		  const componentView = createLView(rootView, getOrCreateComponentTView(rootComponentDef), null, lViewFlags, rootView[tNode.index], tNode, environment, viewRenderer, null, null, hydrationInfo);
		  if (tView.firstCreatePass) {
			 markAsComponentHost(tView, tNode, rootDirectives.length - 1);
		  }
		  addToViewTree(rootView, componentView);
		  return rootView[tNode.index] = componentView;
		}
		function applyRootComponentStyling(rootDirectives, tNode, rNode, hostRenderer) {
		  for (const def of rootDirectives) {
			 tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, def.hostAttrs);
		  }
		  if (tNode.mergedAttrs !== null) {
			 computeStaticStyling(tNode, tNode.mergedAttrs, true);
			 if (rNode !== null) {
				setupStaticAttributes(hostRenderer, rNode, tNode);
			 }
		  }
		}
		function createRootComponent(componentView, rootComponentDef, rootDirectives, hostDirectiveDefs, rootLView, hostFeatures) {
		  const rootTNode = getCurrentTNode();
		  ngDevMode && assertDefined(rootTNode, "tNode should have been already created");
		  const tView = rootLView[TVIEW];
		  const native = getNativeByTNode(rootTNode, rootLView);
		  initializeDirectives(tView, rootLView, rootTNode, rootDirectives, null, hostDirectiveDefs);
		  for (let i = 0; i < rootDirectives.length; i++) {
			 const directiveIndex = rootTNode.directiveStart + i;
			 const directiveInstance = getNodeInjectable(rootLView, tView, directiveIndex, rootTNode);
			 attachPatchData(directiveInstance, rootLView);
		  }
		  invokeDirectivesHostBindings(tView, rootLView, rootTNode);
		  if (native) {
			 attachPatchData(native, rootLView);
		  }
		  ngDevMode && assertGreaterThan(rootTNode.componentOffset, -1, "componentOffset must be great than -1");
		  const component = getNodeInjectable(rootLView, tView, rootTNode.directiveStart + rootTNode.componentOffset, rootTNode);
		  componentView[CONTEXT] = rootLView[CONTEXT] = component;
		  if (hostFeatures !== null) {
			 for (const feature of hostFeatures) {
				feature(component, rootComponentDef);
			 }
		  }
		  executeContentQueries(tView, rootTNode, rootLView);
		  return component;
		}
		function setRootNodeAttributes(hostRenderer, componentDef, hostRNode, rootSelectorOrNode) {
		  if (rootSelectorOrNode) {
			 setUpAttributes(hostRenderer, hostRNode, ["ng-version", "17.3.12"]);
		  } else {
			 const { attrs, classes } = extractAttrsAndClassesFromSelector(componentDef.selectors[0]);
			 if (attrs) {
				setUpAttributes(hostRenderer, hostRNode, attrs);
			 }
			 if (classes && classes.length > 0) {
				writeDirectClass(hostRenderer, hostRNode, classes.join(" "));
			 }
		  }
		}
		function projectNodes(tNode, ngContentSelectors, projectableNodes) {
		  const projection = tNode.projection = [];
		  for (let i = 0; i < ngContentSelectors.length; i++) {
			 const nodesforSlot = projectableNodes[i];
			 projection.push(nodesforSlot != null ? Array.from(nodesforSlot) : null);
		  }
		}
		function LifecycleHooksFeature() {
		  const tNode = getCurrentTNode();
		  ngDevMode && assertDefined(tNode, "TNode is required");
		  registerPostOrderHooks(getLView()[TVIEW], tNode);
		}
		var ViewContainerRef = class {
		  static {
			 this.__NG_ELEMENT_ID__ = injectViewContainerRef;
		  }
		};
		function injectViewContainerRef() {
		  const previousTNode = getCurrentTNode();
		  return createContainerRef(previousTNode, getLView());
		}
		var VE_ViewContainerRef = ViewContainerRef;
		var R3ViewContainerRef = class ViewContainerRef2 extends VE_ViewContainerRef {
		  constructor(_lContainer, _hostTNode, _hostLView) {
			 super();
			 this._lContainer = _lContainer;
			 this._hostTNode = _hostTNode;
			 this._hostLView = _hostLView;
		  }
		  get element() {
			 return createElementRef(this._hostTNode, this._hostLView);
		  }
		  get injector() {
			 return new NodeInjector(this._hostTNode, this._hostLView);
		  }
		  /** @deprecated No replacement */
		  get parentInjector() {
			 const parentLocation = getParentInjectorLocation(this._hostTNode, this._hostLView);
			 if (hasParentInjector(parentLocation)) {
				const parentView = getParentInjectorView(parentLocation, this._hostLView);
				const injectorIndex = getParentInjectorIndex(parentLocation);
				ngDevMode && assertNodeInjector(parentView, injectorIndex);
				const parentTNode = parentView[TVIEW].data[
				  injectorIndex + 8
				  /* NodeInjectorOffset.TNODE */
				];
				return new NodeInjector(parentTNode, parentView);
			 } else {
				return new NodeInjector(null, this._hostLView);
			 }
		  }
		  clear() {
			 while (this.length > 0) {
				this.remove(this.length - 1);
			 }
		  }
		  get(index) {
			 const viewRefs = getViewRefs(this._lContainer);
			 return viewRefs !== null && viewRefs[index] || null;
		  }
		  get length() {
			 return this._lContainer.length - CONTAINER_HEADER_OFFSET;
		  }
		  createEmbeddedView(templateRef, context2, indexOrOptions) {
			 let index;
			 let injector;
			 if (typeof indexOrOptions === "number") {
				index = indexOrOptions;
			 } else if (indexOrOptions != null) {
				index = indexOrOptions.index;
				injector = indexOrOptions.injector;
			 }
			 const dehydratedView = findMatchingDehydratedView(this._lContainer, templateRef.ssrId);
			 const viewRef = templateRef.createEmbeddedViewImpl(context2 || {}, injector, dehydratedView);
			 this.insertImpl(viewRef, index, shouldAddViewToDom(this._hostTNode, dehydratedView));
			 return viewRef;
		  }
		  createComponent(componentFactoryOrType, indexOrOptions, injector, projectableNodes, environmentInjector) {
			 const isComponentFactory = componentFactoryOrType && !isType(componentFactoryOrType);
			 let index;
			 if (isComponentFactory) {
				if (ngDevMode) {
				  assertEqual(typeof indexOrOptions !== "object", true, "It looks like Component factory was provided as the first argument and an options object as the second argument. This combination of arguments is incompatible. You can either change the first argument to provide Component type or change the second argument to be a number (representing an index at which to insert the new component's host view into this container)");
				}
				index = indexOrOptions;
			 } else {
				if (ngDevMode) {
				  assertDefined(getComponentDef(componentFactoryOrType), `Provided Component class doesn't contain Component definition. Please check whether provided class has @Component decorator.`);
				  assertEqual(typeof indexOrOptions !== "number", true, "It looks like Component type was provided as the first argument and a number (representing an index at which to insert the new component's host view into this container as the second argument. This combination of arguments is incompatible. Please use an object as the second argument instead.");
				}
				const options = indexOrOptions || {};
				if (ngDevMode && options.environmentInjector && options.ngModuleRef) {
				  throwError(`Cannot pass both environmentInjector and ngModuleRef options to createComponent().`);
				}
				index = options.index;
				injector = options.injector;
				projectableNodes = options.projectableNodes;
				environmentInjector = options.environmentInjector || options.ngModuleRef;
			 }
			 const componentFactory = isComponentFactory ? componentFactoryOrType : new ComponentFactory(getComponentDef(componentFactoryOrType));
			 const contextInjector = injector || this.parentInjector;
			 if (!environmentInjector && componentFactory.ngModule == null) {
				const _injector = isComponentFactory ? contextInjector : this.parentInjector;
				const result = _injector.get(EnvironmentInjector, null);
				if (result) {
				  environmentInjector = result;
				}
			 }
			 const componentDef = getComponentDef(componentFactory.componentType ?? {});
			 const dehydratedView = findMatchingDehydratedView(this._lContainer, componentDef?.id ?? null);
			 const rNode = dehydratedView?.firstChild ?? null;
			 const componentRef = componentFactory.create(contextInjector, projectableNodes, rNode, environmentInjector);
			 this.insertImpl(componentRef.hostView, index, shouldAddViewToDom(this._hostTNode, dehydratedView));
			 return componentRef;
		  }
		  insert(viewRef, index) {
			 return this.insertImpl(viewRef, index, true);
		  }
		  insertImpl(viewRef, index, addToDOM) {
			 const lView = viewRef._lView;
			 if (ngDevMode && viewRef.destroyed) {
				throw new Error("Cannot insert a destroyed View in a ViewContainer!");
			 }
			 if (viewAttachedToContainer(lView)) {
				const prevIdx = this.indexOf(viewRef);
				if (prevIdx !== -1) {
				  this.detach(prevIdx);
				} else {
				  const prevLContainer = lView[PARENT];
				  ngDevMode && assertEqual(isLContainer(prevLContainer), true, "An attached view should have its PARENT point to a container.");
				  const prevVCRef = new R3ViewContainerRef(prevLContainer, prevLContainer[T_HOST], prevLContainer[PARENT]);
				  prevVCRef.detach(prevVCRef.indexOf(viewRef));
				}
			 }
			 const adjustedIdx = this._adjustIndex(index);
			 const lContainer = this._lContainer;
			 addLViewToLContainer(lContainer, lView, adjustedIdx, addToDOM);
			 viewRef.attachToViewContainerRef();
			 addToArray(getOrCreateViewRefs(lContainer), adjustedIdx, viewRef);
			 return viewRef;
		  }
		  move(viewRef, newIndex) {
			 if (ngDevMode && viewRef.destroyed) {
				throw new Error("Cannot move a destroyed View in a ViewContainer!");
			 }
			 return this.insert(viewRef, newIndex);
		  }
		  indexOf(viewRef) {
			 const viewRefsArr = getViewRefs(this._lContainer);
			 return viewRefsArr !== null ? viewRefsArr.indexOf(viewRef) : -1;
		  }
		  remove(index) {
			 const adjustedIdx = this._adjustIndex(index, -1);
			 const detachedView = detachView(this._lContainer, adjustedIdx);
			 if (detachedView) {
				removeFromArray(getOrCreateViewRefs(this._lContainer), adjustedIdx);
				destroyLView(detachedView[TVIEW], detachedView);
			 }
		  }
		  detach(index) {
			 const adjustedIdx = this._adjustIndex(index, -1);
			 const view = detachView(this._lContainer, adjustedIdx);
			 const wasDetached = view && removeFromArray(getOrCreateViewRefs(this._lContainer), adjustedIdx) != null;
			 return wasDetached ? new ViewRef$1(view) : null;
		  }
		  _adjustIndex(index, shift = 0) {
			 if (index == null) {
				return this.length + shift;
			 }
			 if (ngDevMode) {
				assertGreaterThan(index, -1, `ViewRef index must be positive, got ${index}`);
				assertLessThan(index, this.length + 1 + shift, "index");
			 }
			 return index;
		  }
		};
		function getViewRefs(lContainer) {
		  return lContainer[VIEW_REFS];
		}
		function getOrCreateViewRefs(lContainer) {
		  return lContainer[VIEW_REFS] || (lContainer[VIEW_REFS] = []);
		}
		function createContainerRef(hostTNode, hostLView) {
		  ngDevMode && assertTNodeType(
			 hostTNode,
			 12 | 3
			 /* TNodeType.AnyRNode */
		  );
		  let lContainer;
		  const slotValue = hostLView[hostTNode.index];
		  if (isLContainer(slotValue)) {
			 lContainer = slotValue;
		  } else {
			 lContainer = createLContainer(slotValue, hostLView, null, hostTNode);
			 hostLView[hostTNode.index] = lContainer;
			 addToViewTree(hostLView, lContainer);
		  }
		  _locateOrCreateAnchorNode(lContainer, hostLView, hostTNode, slotValue);
		  return new R3ViewContainerRef(lContainer, hostTNode, hostLView);
		}
		function insertAnchorNode(hostLView, hostTNode) {
		  const renderer = hostLView[RENDERER];
		  ngDevMode && ngDevMode.rendererCreateComment++;
		  const commentNode = renderer.createComment(ngDevMode ? "container" : "");
		  const hostNative = getNativeByTNode(hostTNode, hostLView);
		  const parentOfHostNative = nativeParentNode(renderer, hostNative);
		  nativeInsertBefore(renderer, parentOfHostNative, commentNode, nativeNextSibling(renderer, hostNative), false);
		  return commentNode;
		}
		var _locateOrCreateAnchorNode = createAnchorNode;
		var _populateDehydratedViewsInLContainer = () => false;
		function populateDehydratedViewsInLContainer(lContainer, tNode, hostLView) {
		  return _populateDehydratedViewsInLContainer(lContainer, tNode, hostLView);
		}
		function createAnchorNode(lContainer, hostLView, hostTNode, slotValue) {
		  if (lContainer[NATIVE])
			 return;
		  let commentNode;
		  if (hostTNode.type & 8) {
			 commentNode = unwrapRNode(slotValue);
		  } else {
			 commentNode = insertAnchorNode(hostLView, hostTNode);
		  }
		  lContainer[NATIVE] = commentNode;
		}
		var LQuery_ = class _LQuery_ {
		  constructor(queryList) {
			 this.queryList = queryList;
			 this.matches = null;
		  }
		  clone() {
			 return new _LQuery_(this.queryList);
		  }
		  setDirty() {
			 this.queryList.setDirty();
		  }
		};
		var LQueries_ = class _LQueries_ {
		  constructor(queries = []) {
			 this.queries = queries;
		  }
		  createEmbeddedView(tView) {
			 const tQueries = tView.queries;
			 if (tQueries !== null) {
				const noOfInheritedQueries = tView.contentQueries !== null ? tView.contentQueries[0] : tQueries.length;
				const viewLQueries = [];
				for (let i = 0; i < noOfInheritedQueries; i++) {
				  const tQuery = tQueries.getByIndex(i);
				  const parentLQuery = this.queries[tQuery.indexInDeclarationView];
				  viewLQueries.push(parentLQuery.clone());
				}
				return new _LQueries_(viewLQueries);
			 }
			 return null;
		  }
		  insertView(tView) {
			 this.dirtyQueriesWithMatches(tView);
		  }
		  detachView(tView) {
			 this.dirtyQueriesWithMatches(tView);
		  }
		  finishViewCreation(tView) {
			 this.dirtyQueriesWithMatches(tView);
		  }
		  dirtyQueriesWithMatches(tView) {
			 for (let i = 0; i < this.queries.length; i++) {
				if (getTQuery(tView, i).matches !== null) {
				  this.queries[i].setDirty();
				}
			 }
		  }
		};
		var TQueryMetadata_ = class {
		  constructor(predicate, flags, read = null) {
			 this.flags = flags;
			 this.read = read;
			 if (typeof predicate === "string") {
				this.predicate = splitQueryMultiSelectors(predicate);
			 } else {
				this.predicate = predicate;
			 }
		  }
		};
		var TQueries_ = class _TQueries_ {
		  constructor(queries = []) {
			 this.queries = queries;
		  }
		  elementStart(tView, tNode) {
			 ngDevMode && assertFirstCreatePass(tView, "Queries should collect results on the first template pass only");
			 for (let i = 0; i < this.queries.length; i++) {
				this.queries[i].elementStart(tView, tNode);
			 }
		  }
		  elementEnd(tNode) {
			 for (let i = 0; i < this.queries.length; i++) {
				this.queries[i].elementEnd(tNode);
			 }
		  }
		  embeddedTView(tNode) {
			 let queriesForTemplateRef = null;
			 for (let i = 0; i < this.length; i++) {
				const childQueryIndex = queriesForTemplateRef !== null ? queriesForTemplateRef.length : 0;
				const tqueryClone = this.getByIndex(i).embeddedTView(tNode, childQueryIndex);
				if (tqueryClone) {
				  tqueryClone.indexInDeclarationView = i;
				  if (queriesForTemplateRef !== null) {
					 queriesForTemplateRef.push(tqueryClone);
				  } else {
					 queriesForTemplateRef = [tqueryClone];
				  }
				}
			 }
			 return queriesForTemplateRef !== null ? new _TQueries_(queriesForTemplateRef) : null;
		  }
		  template(tView, tNode) {
			 ngDevMode && assertFirstCreatePass(tView, "Queries should collect results on the first template pass only");
			 for (let i = 0; i < this.queries.length; i++) {
				this.queries[i].template(tView, tNode);
			 }
		  }
		  getByIndex(index) {
			 ngDevMode && assertIndexInRange(this.queries, index);
			 return this.queries[index];
		  }
		  get length() {
			 return this.queries.length;
		  }
		  track(tquery) {
			 this.queries.push(tquery);
		  }
		};
		var TQuery_ = class _TQuery_ {
		  constructor(metadata, nodeIndex = -1) {
			 this.metadata = metadata;
			 this.matches = null;
			 this.indexInDeclarationView = -1;
			 this.crossesNgTemplate = false;
			 this._appliesToNextNode = true;
			 this._declarationNodeIndex = nodeIndex;
		  }
		  elementStart(tView, tNode) {
			 if (this.isApplyingToNode(tNode)) {
				this.matchTNode(tView, tNode);
			 }
		  }
		  elementEnd(tNode) {
			 if (this._declarationNodeIndex === tNode.index) {
				this._appliesToNextNode = false;
			 }
		  }
		  template(tView, tNode) {
			 this.elementStart(tView, tNode);
		  }
		  embeddedTView(tNode, childQueryIndex) {
			 if (this.isApplyingToNode(tNode)) {
				this.crossesNgTemplate = true;
				this.addMatch(-tNode.index, childQueryIndex);
				return new _TQuery_(this.metadata);
			 }
			 return null;
		  }
		  isApplyingToNode(tNode) {
			 if (this._appliesToNextNode && (this.metadata.flags & 1) !== 1) {
				const declarationNodeIdx = this._declarationNodeIndex;
				let parent = tNode.parent;
				while (parent !== null && parent.type & 8 && parent.index !== declarationNodeIdx) {
				  parent = parent.parent;
				}
				return declarationNodeIdx === (parent !== null ? parent.index : -1);
			 }
			 return this._appliesToNextNode;
		  }
		  matchTNode(tView, tNode) {
			 const predicate = this.metadata.predicate;
			 if (Array.isArray(predicate)) {
				for (let i = 0; i < predicate.length; i++) {
				  const name = predicate[i];
				  this.matchTNodeWithReadOption(tView, tNode, getIdxOfMatchingSelector(tNode, name));
				  this.matchTNodeWithReadOption(tView, tNode, locateDirectiveOrProvider(tNode, tView, name, false, false));
				}
			 } else {
				if (predicate === TemplateRef) {
				  if (tNode.type & 4) {
					 this.matchTNodeWithReadOption(tView, tNode, -1);
				  }
				} else {
				  this.matchTNodeWithReadOption(tView, tNode, locateDirectiveOrProvider(tNode, tView, predicate, false, false));
				}
			 }
		  }
		  matchTNodeWithReadOption(tView, tNode, nodeMatchIdx) {
			 if (nodeMatchIdx !== null) {
				const read = this.metadata.read;
				if (read !== null) {
				  if (read === ElementRef || read === ViewContainerRef || read === TemplateRef && tNode.type & 4) {
					 this.addMatch(tNode.index, -2);
				  } else {
					 const directiveOrProviderIdx = locateDirectiveOrProvider(tNode, tView, read, false, false);
					 if (directiveOrProviderIdx !== null) {
						this.addMatch(tNode.index, directiveOrProviderIdx);
					 }
				  }
				} else {
				  this.addMatch(tNode.index, nodeMatchIdx);
				}
			 }
		  }
		  addMatch(tNodeIdx, matchIdx) {
			 if (this.matches === null) {
				this.matches = [tNodeIdx, matchIdx];
			 } else {
				this.matches.push(tNodeIdx, matchIdx);
			 }
		  }
		};
		function getIdxOfMatchingSelector(tNode, selector) {
		  const localNames = tNode.localNames;
		  if (localNames !== null) {
			 for (let i = 0; i < localNames.length; i += 2) {
				if (localNames[i] === selector) {
				  return localNames[i + 1];
				}
			 }
		  }
		  return null;
		}
		function createResultByTNodeType(tNode, currentView) {
		  if (tNode.type & (3 | 8)) {
			 return createElementRef(tNode, currentView);
		  } else if (tNode.type & 4) {
			 return createTemplateRef(tNode, currentView);
		  }
		  return null;
		}
		function createResultForNode(lView, tNode, matchingIdx, read) {
		  if (matchingIdx === -1) {
			 return createResultByTNodeType(tNode, lView);
		  } else if (matchingIdx === -2) {
			 return createSpecialToken(lView, tNode, read);
		  } else {
			 return getNodeInjectable(lView, lView[TVIEW], matchingIdx, tNode);
		  }
		}
		function createSpecialToken(lView, tNode, read) {
		  if (read === ElementRef) {
			 return createElementRef(tNode, lView);
		  } else if (read === TemplateRef) {
			 return createTemplateRef(tNode, lView);
		  } else if (read === ViewContainerRef) {
			 ngDevMode && assertTNodeType(
				tNode,
				3 | 12
				/* TNodeType.AnyContainer */
			 );
			 return createContainerRef(tNode, lView);
		  } else {
			 ngDevMode && throwError(`Special token to read should be one of ElementRef, TemplateRef or ViewContainerRef but got ${stringify(read)}.`);
		  }
		}
		function materializeViewResults(tView, lView, tQuery, queryIndex) {
		  const lQuery = lView[QUERIES].queries[queryIndex];
		  if (lQuery.matches === null) {
			 const tViewData = tView.data;
			 const tQueryMatches = tQuery.matches;
			 const result = [];
			 for (let i = 0; tQueryMatches !== null && i < tQueryMatches.length; i += 2) {
				const matchedNodeIdx = tQueryMatches[i];
				if (matchedNodeIdx < 0) {
				  result.push(null);
				} else {
				  ngDevMode && assertIndexInRange(tViewData, matchedNodeIdx);
				  const tNode = tViewData[matchedNodeIdx];
				  result.push(createResultForNode(lView, tNode, tQueryMatches[i + 1], tQuery.metadata.read));
				}
			 }
			 lQuery.matches = result;
		  }
		  return lQuery.matches;
		}
		function collectQueryResults(tView, lView, queryIndex, result) {
		  const tQuery = tView.queries.getByIndex(queryIndex);
		  const tQueryMatches = tQuery.matches;
		  if (tQueryMatches !== null) {
			 const lViewResults = materializeViewResults(tView, lView, tQuery, queryIndex);
			 for (let i = 0; i < tQueryMatches.length; i += 2) {
				const tNodeIdx = tQueryMatches[i];
				if (tNodeIdx > 0) {
				  result.push(lViewResults[i / 2]);
				} else {
				  const childQueryIndex = tQueryMatches[i + 1];
				  const declarationLContainer = lView[-tNodeIdx];
				  ngDevMode && assertLContainer(declarationLContainer);
				  for (let i2 = CONTAINER_HEADER_OFFSET; i2 < declarationLContainer.length; i2++) {
					 const embeddedLView = declarationLContainer[i2];
					 if (embeddedLView[DECLARATION_LCONTAINER] === embeddedLView[PARENT]) {
						collectQueryResults(embeddedLView[TVIEW], embeddedLView, childQueryIndex, result);
					 }
				  }
				  if (declarationLContainer[MOVED_VIEWS] !== null) {
					 const embeddedLViews = declarationLContainer[MOVED_VIEWS];
					 for (let i2 = 0; i2 < embeddedLViews.length; i2++) {
						const embeddedLView = embeddedLViews[i2];
						collectQueryResults(embeddedLView[TVIEW], embeddedLView, childQueryIndex, result);
					 }
				  }
				}
			 }
		  }
		  return result;
		}
		function loadQueryInternal(lView, queryIndex) {
		  ngDevMode && assertDefined(lView[QUERIES], "LQueries should be defined when trying to load a query");
		  ngDevMode && assertIndexInRange(lView[QUERIES].queries, queryIndex);
		  return lView[QUERIES].queries[queryIndex].queryList;
		}
		function createLQuery(tView, lView, flags) {
		  const queryList = new QueryList(
			 (flags & 4) === 4
			 /* QueryFlags.emitDistinctChangesOnly */
		  );
		  storeCleanupWithContext(tView, lView, queryList, queryList.destroy);
		  const lQueries = (lView[QUERIES] ??= new LQueries_()).queries;
		  return lQueries.push(new LQuery_(queryList)) - 1;
		}
		function createViewQuery(predicate, flags, read) {
		  ngDevMode && assertNumber(flags, "Expecting flags");
		  const tView = getTView();
		  if (tView.firstCreatePass) {
			 createTQuery(tView, new TQueryMetadata_(predicate, flags, read), -1);
			 if ((flags & 2) === 2) {
				tView.staticViewQueries = true;
			 }
		  }
		  return createLQuery(tView, getLView(), flags);
		}
		function createContentQuery(directiveIndex, predicate, flags, read) {
		  ngDevMode && assertNumber(flags, "Expecting flags");
		  const tView = getTView();
		  if (tView.firstCreatePass) {
			 const tNode = getCurrentTNode();
			 createTQuery(tView, new TQueryMetadata_(predicate, flags, read), tNode.index);
			 saveContentQueryAndDirectiveIndex(tView, directiveIndex);
			 if ((flags & 2) === 2) {
				tView.staticContentQueries = true;
			 }
		  }
		  return createLQuery(tView, getLView(), flags);
		}
		function splitQueryMultiSelectors(locator) {
		  return locator.split(",").map((s) => s.trim());
		}
		function createTQuery(tView, metadata, nodeIndex) {
		  if (tView.queries === null)
			 tView.queries = new TQueries_();
		  tView.queries.track(new TQuery_(metadata, nodeIndex));
		}
		function saveContentQueryAndDirectiveIndex(tView, directiveIndex) {
		  const tViewContentQueries = tView.contentQueries || (tView.contentQueries = []);
		  const lastSavedDirectiveIndex = tViewContentQueries.length ? tViewContentQueries[tViewContentQueries.length - 1] : -1;
		  if (directiveIndex !== lastSavedDirectiveIndex) {
			 tViewContentQueries.push(tView.queries.length - 1, directiveIndex);
		  }
		}
		function getTQuery(tView, index) {
		  ngDevMode && assertDefined(tView.queries, "TQueries must be defined to retrieve a TQuery");
		  return tView.queries.getByIndex(index);
		}
		function getQueryResults(lView, queryIndex) {
		  const tView = lView[TVIEW];
		  const tQuery = getTQuery(tView, queryIndex);
		  return tQuery.crossesNgTemplate ? collectQueryResults(tView, lView, queryIndex, []) : materializeViewResults(tView, lView, tQuery, queryIndex);
		}
		function isSignal(value) {
		  return typeof value === "function" && value[SIGNAL] !== void 0;
		}
		function signal(initialValue, options) {
		  performanceMarkFeature("NgSignals");
		  const signalFn = createSignal(initialValue);
		  const node = signalFn[SIGNAL];
		  if (options?.equal) {
			 node.equal = options.equal;
		  }
		  signalFn.set = (newValue) => signalSetFn(node, newValue);
		  signalFn.update = (updateFn) => signalUpdateFn(node, updateFn);
		  signalFn.asReadonly = signalAsReadonlyFn.bind(signalFn);
		  if (ngDevMode) {
			 signalFn.toString = () => `[Signal: ${signalFn()}]`;
		  }
		  return signalFn;
		}
		function signalAsReadonlyFn() {
		  const node = this[SIGNAL];
		  if (node.readonlyFn === void 0) {
			 const readonlyFn = () => this();
			 readonlyFn[SIGNAL] = node;
			 node.readonlyFn = readonlyFn;
		  }
		  return node.readonlyFn;
		}
		function isWritableSignal(value) {
		  return isSignal(value) && typeof value.set === "function";
		}
		function createQuerySignalFn(firstOnly, required) {
		  let node;
		  const signalFn = createComputed(() => {
			 node._dirtyCounter();
			 const value = refreshSignalQuery(node, firstOnly);
			 if (required && value === void 0) {
				throw new RuntimeError(-951, ngDevMode && "Child query result is required but no value is available.");
			 }
			 return value;
		  });
		  node = signalFn[SIGNAL];
		  node._dirtyCounter = signal(0);
		  node._flatValue = void 0;
		  if (ngDevMode) {
			 signalFn.toString = () => `[Query Signal]`;
		  }
		  return signalFn;
		}
		function createSingleResultOptionalQuerySignalFn() {
		  return createQuerySignalFn(
			 /* firstOnly */
			 true,
			 /* required */
			 false
		  );
		}
		function createSingleResultRequiredQuerySignalFn() {
		  return createQuerySignalFn(
			 /* firstOnly */
			 true,
			 /* required */
			 true
		  );
		}
		function createMultiResultQuerySignalFn() {
		  return createQuerySignalFn(
			 /* firstOnly */
			 false,
			 /* required */
			 false
		  );
		}
		function bindQueryToSignal(target, queryIndex) {
		  const node = target[SIGNAL];
		  node._lView = getLView();
		  node._queryIndex = queryIndex;
		  node._queryList = loadQueryInternal(node._lView, queryIndex);
		  node._queryList.onDirty(() => node._dirtyCounter.update((v) => v + 1));
		}
		function refreshSignalQuery(node, firstOnly) {
		  const lView = node._lView;
		  const queryIndex = node._queryIndex;
		  if (lView === void 0 || queryIndex === void 0 || lView[FLAGS] & 4) {
			 return firstOnly ? void 0 : EMPTY_ARRAY;
		  }
		  const queryList = loadQueryInternal(lView, queryIndex);
		  const results = getQueryResults(lView, queryIndex);
		  queryList.reset(results, unwrapElementRef);
		  if (firstOnly) {
			 return queryList.first;
		  } else {
			 const resultChanged = queryList._changesDetected;
			 if (resultChanged || node._flatValue === void 0) {
				return node._flatValue = queryList.toArray();
			 }
			 return node._flatValue;
		  }
		}
		function viewChildFn(locator, opts) {
		  ngDevMode && assertInInjectionContext(viewChild);
		  return createSingleResultOptionalQuerySignalFn();
		}
		function viewChildRequiredFn(locator, opts) {
		  ngDevMode && assertInInjectionContext(viewChild);
		  return createSingleResultRequiredQuerySignalFn();
		}
		var viewChild = (() => {
		  viewChildFn.required = viewChildRequiredFn;
		  return viewChildFn;
		})();
		function contentChildFn(locator, opts) {
		  ngDevMode && assertInInjectionContext(contentChild);
		  return createSingleResultOptionalQuerySignalFn();
		}
		function contentChildRequiredFn(locator, opts) {
		  ngDevMode && assertInInjectionContext(contentChildren);
		  return createSingleResultRequiredQuerySignalFn();
		}
		var contentChild = (() => {
		  contentChildFn.required = contentChildRequiredFn;
		  return contentChildFn;
		})();
		function contentChildren(locator, opts) {
		  return createMultiResultQuerySignalFn();
		}
		function createModelSignal(initialValue) {
		  const node = Object.create(INPUT_SIGNAL_NODE);
		  const emitterRef = new OutputEmitterRef();
		  node.value = initialValue;
		  function getter() {
			 producerAccessed(node);
			 assertModelSet(node.value);
			 return node.value;
		  }
		  getter[SIGNAL] = node;
		  getter.asReadonly = signalAsReadonlyFn.bind(getter);
		  getter.set = (newValue) => {
			 if (!node.equal(node.value, newValue)) {
				signalSetFn(node, newValue);
				emitterRef.emit(newValue);
			 }
		  };
		  getter.update = (updateFn) => {
			 assertModelSet(node.value);
			 getter.set(updateFn(node.value));
		  };
		  getter.subscribe = emitterRef.subscribe.bind(emitterRef);
		  getter.destroyRef = emitterRef.destroyRef;
		  if (ngDevMode) {
			 getter.toString = () => `[Model Signal: ${getter()}]`;
		  }
		  return getter;
		}
		function assertModelSet(value) {
		  if (value === REQUIRED_UNSET_VALUE) {
			 throw new RuntimeError(-952, ngDevMode && "Model is required but no value is available yet.");
		  }
		}
		function modelFunction(initialValue) {
		  ngDevMode && assertInInjectionContext(model);
		  return createModelSignal(initialValue);
		}
		function modelRequiredFunction() {
		  ngDevMode && assertInInjectionContext(model);
		  return createModelSignal(REQUIRED_UNSET_VALUE);
		}
		var model = (() => {
		  modelFunction.required = modelRequiredFunction;
		  return modelFunction;
		})();
		var emitDistinctChangesOnlyDefaultValue = true;
		var Query = class {
		};
		var ContentChildren = makePropDecorator("ContentChildren", (selector, opts = {}) => __spreadValues({
		  selector,
		  first: false,
		  isViewQuery: false,
		  descendants: false,
		  emitDistinctChangesOnly: emitDistinctChangesOnlyDefaultValue
		}, opts), Query);
		var ContentChild = makePropDecorator("ContentChild", (selector, opts = {}) => __spreadValues({ selector, first: true, isViewQuery: false, descendants: true }, opts), Query);
		var ViewChildren = makePropDecorator("ViewChildren", (selector, opts = {}) => __spreadValues({
		  selector,
		  first: false,
		  isViewQuery: true,
		  descendants: true,
		  emitDistinctChangesOnly: emitDistinctChangesOnlyDefaultValue
		}, opts), Query);
		var ViewChild = makePropDecorator("ViewChild", (selector, opts) => __spreadValues({ selector, first: true, isViewQuery: true, descendants: true }, opts), Query);
		function resolveComponentResources(resourceResolver) {
		  const componentResolved = [];
		  const urlMap = /* @__PURE__ */ new Map();
		  function cachedResourceResolve(url) {
			 let promise = urlMap.get(url);
			 if (!promise) {
				const resp = resourceResolver(url);
				urlMap.set(url, promise = resp.then(unwrapResponse));
			 }
			 return promise;
		  }
		  componentResourceResolutionQueue.forEach((component, type2) => {
			 const promises = [];
			 if (component.templateUrl) {
				promises.push(cachedResourceResolve(component.templateUrl).then((template) => {
				  component.template = template;
				}));
			 }
			 const styles = typeof component.styles === "string" ? [component.styles] : component.styles || [];
			 component.styles = styles;
			 if (component.styleUrl && component.styleUrls?.length) {
				throw new Error("@Component cannot define both `styleUrl` and `styleUrls`. Use `styleUrl` if the component has one stylesheet, or `styleUrls` if it has multiple");
			 } else if (component.styleUrls?.length) {
				const styleOffset = component.styles.length;
				const styleUrls = component.styleUrls;
				component.styleUrls.forEach((styleUrl, index) => {
				  styles.push("");
				  promises.push(cachedResourceResolve(styleUrl).then((style) => {
					 styles[styleOffset + index] = style;
					 styleUrls.splice(styleUrls.indexOf(styleUrl), 1);
					 if (styleUrls.length == 0) {
						component.styleUrls = void 0;
					 }
				  }));
				});
			 } else if (component.styleUrl) {
				promises.push(cachedResourceResolve(component.styleUrl).then((style) => {
				  styles.push(style);
				  component.styleUrl = void 0;
				}));
			 }
			 const fullyResolved = Promise.all(promises).then(() => componentDefResolved(type2));
			 componentResolved.push(fullyResolved);
		  });
		  clearResolutionOfComponentResourcesQueue();
		  return Promise.all(componentResolved).then(() => void 0);
		}
		var componentResourceResolutionQueue = /* @__PURE__ */ new Map();
		var componentDefPendingResolution = /* @__PURE__ */ new Set();
		function maybeQueueResolutionOfComponentResources(type2, metadata) {
		  if (componentNeedsResolution(metadata)) {
			 componentResourceResolutionQueue.set(type2, metadata);
			 componentDefPendingResolution.add(type2);
		  }
		}
		function componentNeedsResolution(component) {
		  return !!(component.templateUrl && !component.hasOwnProperty("template") || component.styleUrls && component.styleUrls.length || component.styleUrl);
		}
		function clearResolutionOfComponentResourcesQueue() {
		  const old = componentResourceResolutionQueue;
		  componentResourceResolutionQueue = /* @__PURE__ */ new Map();
		  return old;
		}
		function isComponentResourceResolutionQueueEmpty() {
		  return componentResourceResolutionQueue.size === 0;
		}
		function unwrapResponse(response) {
		  return typeof response == "string" ? response : response.text();
		}
		function componentDefResolved(type2) {
		  componentDefPendingResolution.delete(type2);
		}
		var modules = /* @__PURE__ */ new Map();
		var checkForDuplicateNgModules = true;
		function assertSameOrNotExisting(id3, type2, incoming) {
		  if (type2 && type2 !== incoming && checkForDuplicateNgModules) {
			 throw new Error(`Duplicate module registered for ${id3} - ${stringify(type2)} vs ${stringify(type2.name)}`);
		  }
		}
		function registerNgModuleType(ngModuleType, id3) {
		  const existing = modules.get(id3) || null;
		  assertSameOrNotExisting(id3, existing, ngModuleType);
		  modules.set(id3, ngModuleType);
		}
		function \u0275\u0275validateIframeAttribute(attrValue, tagName, attrName) {
		  const lView = getLView();
		  const tNode = getSelectedTNode();
		  const element = getNativeByTNode(tNode, lView);
		  if (tNode.type === 2 && tagName.toLowerCase() === "iframe") {
			 const iframe = element;
			 iframe.src = "";
			 iframe.srcdoc = trustedHTMLFromString("");
			 nativeRemoveNode(lView[RENDERER], iframe);
			 const errorMessage = ngDevMode && `Angular has detected that the \`${attrName}\` was applied as a binding to an <iframe>${getTemplateLocationDetails(lView)}. For security reasons, the \`${attrName}\` can be set on an <iframe> as a static attribute only.
		To fix this, switch the \`${attrName}\` binding to a static attribute in a template or in host bindings section.`;
			 throw new RuntimeError(-910, errorMessage);
		  }
		  return attrValue;
		}
		function getSuperType(type2) {
		  return Object.getPrototypeOf(type2.prototype).constructor;
		}
		function \u0275\u0275InheritDefinitionFeature(definition) {
		  let superType = getSuperType(definition.type);
		  let shouldInheritFields = true;
		  const inheritanceChain = [definition];
		  while (superType) {
			 let superDef = void 0;
			 if (isComponentDef(definition)) {
				superDef = superType.\u0275cmp || superType.\u0275dir;
			 } else {
				if (superType.\u0275cmp) {
				  throw new RuntimeError(903, ngDevMode && `Directives cannot inherit Components. Directive ${stringifyForError(definition.type)} is attempting to extend component ${stringifyForError(superType)}`);
				}
				superDef = superType.\u0275dir;
			 }
			 if (superDef) {
				if (shouldInheritFields) {
				  inheritanceChain.push(superDef);
				  const writeableDef = definition;
				  writeableDef.inputs = maybeUnwrapEmpty(definition.inputs);
				  writeableDef.inputTransforms = maybeUnwrapEmpty(definition.inputTransforms);
				  writeableDef.declaredInputs = maybeUnwrapEmpty(definition.declaredInputs);
				  writeableDef.outputs = maybeUnwrapEmpty(definition.outputs);
				  const superHostBindings = superDef.hostBindings;
				  superHostBindings && inheritHostBindings(definition, superHostBindings);
				  const superViewQuery = superDef.viewQuery;
				  const superContentQueries = superDef.contentQueries;
				  superViewQuery && inheritViewQuery(definition, superViewQuery);
				  superContentQueries && inheritContentQueries(definition, superContentQueries);
				  mergeInputsWithTransforms(definition, superDef);
				  fillProperties(definition.outputs, superDef.outputs);
				  if (isComponentDef(superDef) && superDef.data.animation) {
					 const defData = definition.data;
					 defData.animation = (defData.animation || []).concat(superDef.data.animation);
				  }
				}
				const features = superDef.features;
				if (features) {
				  for (let i = 0; i < features.length; i++) {
					 const feature = features[i];
					 if (feature && feature.ngInherit) {
						feature(definition);
					 }
					 if (feature === \u0275\u0275InheritDefinitionFeature) {
						shouldInheritFields = false;
					 }
				  }
				}
			 }
			 superType = Object.getPrototypeOf(superType);
		  }
		  mergeHostAttrsAcrossInheritance(inheritanceChain);
		}
		function mergeInputsWithTransforms(target, source) {
		  for (const key in source.inputs) {
			 if (!source.inputs.hasOwnProperty(key)) {
				continue;
			 }
			 if (target.inputs.hasOwnProperty(key)) {
				continue;
			 }
			 const value = source.inputs[key];
			 if (value === void 0) {
				continue;
			 }
			 target.inputs[key] = value;
			 target.declaredInputs[key] = source.declaredInputs[key];
			 if (source.inputTransforms !== null) {
				const minifiedName = Array.isArray(value) ? value[0] : value;
				if (!source.inputTransforms.hasOwnProperty(minifiedName)) {
				  continue;
				}
				target.inputTransforms ??= {};
				target.inputTransforms[minifiedName] = source.inputTransforms[minifiedName];
			 }
		  }
		}
		function mergeHostAttrsAcrossInheritance(inheritanceChain) {
		  let hostVars = 0;
		  let hostAttrs = null;
		  for (let i = inheritanceChain.length - 1; i >= 0; i--) {
			 const def = inheritanceChain[i];
			 def.hostVars = hostVars += def.hostVars;
			 def.hostAttrs = mergeHostAttrs(def.hostAttrs, hostAttrs = mergeHostAttrs(hostAttrs, def.hostAttrs));
		  }
		}
		function maybeUnwrapEmpty(value) {
		  if (value === EMPTY_OBJ) {
			 return {};
		  } else if (value === EMPTY_ARRAY) {
			 return [];
		  } else {
			 return value;
		  }
		}
		function inheritViewQuery(definition, superViewQuery) {
		  const prevViewQuery = definition.viewQuery;
		  if (prevViewQuery) {
			 definition.viewQuery = (rf, ctx) => {
				superViewQuery(rf, ctx);
				prevViewQuery(rf, ctx);
			 };
		  } else {
			 definition.viewQuery = superViewQuery;
		  }
		}
		function inheritContentQueries(definition, superContentQueries) {
		  const prevContentQueries = definition.contentQueries;
		  if (prevContentQueries) {
			 definition.contentQueries = (rf, ctx, directiveIndex) => {
				superContentQueries(rf, ctx, directiveIndex);
				prevContentQueries(rf, ctx, directiveIndex);
			 };
		  } else {
			 definition.contentQueries = superContentQueries;
		  }
		}
		function inheritHostBindings(definition, superHostBindings) {
		  const prevHostBindings = definition.hostBindings;
		  if (prevHostBindings) {
			 definition.hostBindings = (rf, ctx) => {
				superHostBindings(rf, ctx);
				prevHostBindings(rf, ctx);
			 };
		  } else {
			 definition.hostBindings = superHostBindings;
		  }
		}
		var COPY_DIRECTIVE_FIELDS = [
		  // The child class should use the providers of its parent.
		  "providersResolver"
		  // Not listed here are any fields which are handled by the `InheritDefinitionFeature`, such
		  // as inputs, outputs, and host binding functions.
		];
		var COPY_COMPONENT_FIELDS = [
		  // The child class should use the template function of its parent, including all template
		  // semantics.
		  "template",
		  "decls",
		  "consts",
		  "vars",
		  "onPush",
		  "ngContentSelectors",
		  // The child class should use the CSS styles of its parent, including all styling semantics.
		  "styles",
		  "encapsulation",
		  // The child class should be checked by the runtime in the same way as its parent.
		  "schemas"
		];
		function \u0275\u0275CopyDefinitionFeature(definition) {
		  let superType = getSuperType(definition.type);
		  let superDef = void 0;
		  if (isComponentDef(definition)) {
			 superDef = superType.\u0275cmp;
		  } else {
			 superDef = superType.\u0275dir;
		  }
		  const defAny = definition;
		  for (const field of COPY_DIRECTIVE_FIELDS) {
			 defAny[field] = superDef[field];
		  }
		  if (isComponentDef(superDef)) {
			 for (const field of COPY_COMPONENT_FIELDS) {
				defAny[field] = superDef[field];
			 }
		  }
		}
		function \u0275\u0275HostDirectivesFeature(rawHostDirectives) {
		  const feature = (definition) => {
			 const resolved = (Array.isArray(rawHostDirectives) ? rawHostDirectives : rawHostDirectives()).map((dir) => {
				return typeof dir === "function" ? { directive: resolveForwardRef(dir), inputs: EMPTY_OBJ, outputs: EMPTY_OBJ } : {
				  directive: resolveForwardRef(dir.directive),
				  inputs: bindingArrayToMap(dir.inputs),
				  outputs: bindingArrayToMap(dir.outputs)
				};
			 });
			 if (definition.hostDirectives === null) {
				definition.findHostDirectiveDefs = findHostDirectiveDefs;
				definition.hostDirectives = resolved;
			 } else {
				definition.hostDirectives.unshift(...resolved);
			 }
		  };
		  feature.ngInherit = true;
		  return feature;
		}
		function findHostDirectiveDefs(currentDef, matchedDefs, hostDirectiveDefs) {
		  if (currentDef.hostDirectives !== null) {
			 for (const hostDirectiveConfig of currentDef.hostDirectives) {
				const hostDirectiveDef = getDirectiveDef(hostDirectiveConfig.directive);
				if (typeof ngDevMode === "undefined" || ngDevMode) {
				  validateHostDirective(hostDirectiveConfig, hostDirectiveDef);
				}
				patchDeclaredInputs(hostDirectiveDef.declaredInputs, hostDirectiveConfig.inputs);
				findHostDirectiveDefs(hostDirectiveDef, matchedDefs, hostDirectiveDefs);
				hostDirectiveDefs.set(hostDirectiveDef, hostDirectiveConfig);
				matchedDefs.push(hostDirectiveDef);
			 }
		  }
		}
		function bindingArrayToMap(bindings) {
		  if (bindings === void 0 || bindings.length === 0) {
			 return EMPTY_OBJ;
		  }
		  const result = {};
		  for (let i = 0; i < bindings.length; i += 2) {
			 result[bindings[i]] = bindings[i + 1];
		  }
		  return result;
		}
		function patchDeclaredInputs(declaredInputs, exposedInputs) {
		  for (const publicName in exposedInputs) {
			 if (exposedInputs.hasOwnProperty(publicName)) {
				const remappedPublicName = exposedInputs[publicName];
				const privateName = declaredInputs[publicName];
				if ((typeof ngDevMode === "undefined" || ngDevMode) && declaredInputs.hasOwnProperty(remappedPublicName)) {
				  assertEqual(declaredInputs[remappedPublicName], declaredInputs[publicName], `Conflicting host directive input alias ${publicName}.`);
				}
				declaredInputs[remappedPublicName] = privateName;
			 }
		  }
		}
		function validateHostDirective(hostDirectiveConfig, directiveDef) {
		  const type2 = hostDirectiveConfig.directive;
		  if (directiveDef === null) {
			 if (getComponentDef(type2) !== null) {
				throw new RuntimeError(310, `Host directive ${type2.name} cannot be a component.`);
			 }
			 throw new RuntimeError(307, `Could not resolve metadata for host directive ${type2.name}. Make sure that the ${type2.name} class is annotated with an @Directive decorator.`);
		  }
		  if (!directiveDef.standalone) {
			 throw new RuntimeError(308, `Host directive ${directiveDef.type.name} must be standalone.`);
		  }
		  validateMappings("input", directiveDef, hostDirectiveConfig.inputs);
		  validateMappings("output", directiveDef, hostDirectiveConfig.outputs);
		}
		function validateMappings(bindingType, def, hostDirectiveBindings) {
		  const className = def.type.name;
		  const bindings = bindingType === "input" ? def.inputs : def.outputs;
		  for (const publicName in hostDirectiveBindings) {
			 if (hostDirectiveBindings.hasOwnProperty(publicName)) {
				if (!bindings.hasOwnProperty(publicName)) {
				  throw new RuntimeError(311, `Directive ${className} does not have an ${bindingType} with a public name of ${publicName}.`);
				}
				const remappedPublicName = hostDirectiveBindings[publicName];
				if (bindings.hasOwnProperty(remappedPublicName) && remappedPublicName !== publicName) {
				  throw new RuntimeError(312, `Cannot alias ${bindingType} ${publicName} of host directive ${className} to ${remappedPublicName}, because it already has a different ${bindingType} with the same public name.`);
				}
			 }
		  }
		}
		function \u0275\u0275InputTransformsFeature(definition) {
		  const inputs = definition.inputConfig;
		  const inputTransforms = {};
		  for (const minifiedKey in inputs) {
			 if (inputs.hasOwnProperty(minifiedKey)) {
				const value = inputs[minifiedKey];
				if (Array.isArray(value) && value[3]) {
				  inputTransforms[minifiedKey] = value[3];
				}
			 }
		  }
		  definition.inputTransforms = inputTransforms;
		}
		var NgModuleRef$1 = class {
		};
		var NgModuleFactory$1 = class {
		};
		function createNgModule(ngModule, parentInjector) {
		  return new NgModuleRef(ngModule, parentInjector ?? null, []);
		}
		var NgModuleRef = class extends NgModuleRef$1 {
		  constructor(ngModuleType, _parent, additionalProviders) {
			 super();
			 this._parent = _parent;
			 this._bootstrapComponents = [];
			 this.destroyCbs = [];
			 this.componentFactoryResolver = new ComponentFactoryResolver(this);
			 const ngModuleDef = getNgModuleDef(ngModuleType);
			 ngDevMode && assertDefined(ngModuleDef, `NgModule '${stringify(ngModuleType)}' is not a subtype of 'NgModuleType'.`);
			 this._bootstrapComponents = maybeUnwrapFn(ngModuleDef.bootstrap);
			 this._r3Injector = createInjectorWithoutInjectorInstances(ngModuleType, _parent, [
				{ provide: NgModuleRef$1, useValue: this },
				{
				  provide: ComponentFactoryResolver$1,
				  useValue: this.componentFactoryResolver
				},
				...additionalProviders
			 ], stringify(ngModuleType), /* @__PURE__ */ new Set(["environment"]));
			 this._r3Injector.resolveInjectorInitializers();
			 this.instance = this._r3Injector.get(ngModuleType);
		  }
		  get injector() {
			 return this._r3Injector;
		  }
		  destroy() {
			 ngDevMode && assertDefined(this.destroyCbs, "NgModule already destroyed");
			 const injector = this._r3Injector;
			 !injector.destroyed && injector.destroy();
			 this.destroyCbs.forEach((fn) => fn());
			 this.destroyCbs = null;
		  }
		  onDestroy(callback) {
			 ngDevMode && assertDefined(this.destroyCbs, "NgModule already destroyed");
			 this.destroyCbs.push(callback);
		  }
		};
		var NgModuleFactory = class extends NgModuleFactory$1 {
		  constructor(moduleType) {
			 super();
			 this.moduleType = moduleType;
		  }
		  create(parentInjector) {
			 return new NgModuleRef(this.moduleType, parentInjector, []);
		  }
		};
		function createNgModuleRefWithProviders(moduleType, parentInjector, additionalProviders) {
		  return new NgModuleRef(moduleType, parentInjector, additionalProviders);
		}
		var EnvironmentNgModuleRefAdapter = class extends NgModuleRef$1 {
		  constructor(config2) {
			 super();
			 this.componentFactoryResolver = new ComponentFactoryResolver(this);
			 this.instance = null;
			 const injector = new R3Injector([
				...config2.providers,
				{ provide: NgModuleRef$1, useValue: this },
				{ provide: ComponentFactoryResolver$1, useValue: this.componentFactoryResolver }
			 ], config2.parent || getNullInjector(), config2.debugName, /* @__PURE__ */ new Set(["environment"]));
			 this.injector = injector;
			 if (config2.runEnvironmentInitializers) {
				injector.resolveInjectorInitializers();
			 }
		  }
		  destroy() {
			 this.injector.destroy();
		  }
		  onDestroy(callback) {
			 this.injector.onDestroy(callback);
		  }
		};
		function createEnvironmentInjector(providers, parent, debugName = null) {
		  const adapter = new EnvironmentNgModuleRefAdapter({ providers, parent, debugName, runEnvironmentInitializers: true });
		  return adapter.injector;
		}
		var CachedInjectorService = class _CachedInjectorService {
		  constructor() {
			 this.cachedInjectors = /* @__PURE__ */ new Map();
		  }
		  getOrCreateInjector(key, parentInjector, providers, debugName) {
			 if (!this.cachedInjectors.has(key)) {
				const injector = providers.length > 0 ? createEnvironmentInjector(providers, parentInjector, debugName) : null;
				this.cachedInjectors.set(key, injector);
			 }
			 return this.cachedInjectors.get(key);
		  }
		  ngOnDestroy() {
			 try {
				for (const injector of this.cachedInjectors.values()) {
				  if (injector !== null) {
					 injector.destroy();
				  }
				}
			 } finally {
				this.cachedInjectors.clear();
			 }
		  }
		  static {
			 this.\u0275prov = \u0275\u0275defineInjectable({
				token: _CachedInjectorService,
				providedIn: "environment",
				factory: () => new _CachedInjectorService()
			 });
		  }
		};
		function setClassMetadata(type2, decorators, ctorParameters, propDecorators) {
		  return noSideEffects(() => {
			 const clazz = type2;
			 if (decorators !== null) {
				if (clazz.hasOwnProperty("decorators") && clazz.decorators !== void 0) {
				  clazz.decorators.push(...decorators);
				} else {
				  clazz.decorators = decorators;
				}
			 }
			 if (ctorParameters !== null) {
				clazz.ctorParameters = ctorParameters;
			 }
			 if (propDecorators !== null) {
				if (clazz.hasOwnProperty("propDecorators") && clazz.propDecorators !== void 0) {
				  clazz.propDecorators = __spreadValues(__spreadValues({}, clazz.propDecorators), propDecorators);
				} else {
				  clazz.propDecorators = propDecorators;
				}
			 }
		  });
		}
		var PendingTasks = class _PendingTasks {
		  constructor() {
			 this.taskId = 0;
			 this.pendingTasks = /* @__PURE__ */ new Set();
			 this.hasPendingTasks = new BehaviorSubject(false);
		  }
		  get _hasPendingTasks() {
			 return this.hasPendingTasks.value;
		  }
		  add() {
			 if (!this._hasPendingTasks) {
				this.hasPendingTasks.next(true);
			 }
			 const taskId = this.taskId++;
			 this.pendingTasks.add(taskId);
			 return taskId;
		  }
		  remove(taskId) {
			 this.pendingTasks.delete(taskId);
			 if (this.pendingTasks.size === 0 && this._hasPendingTasks) {
				this.hasPendingTasks.next(false);
			 }
		  }
		  ngOnDestroy() {
			 this.pendingTasks.clear();
			 if (this._hasPendingTasks) {
				this.hasPendingTasks.next(false);
			 }
		  }
		  static {
			 this.\u0275fac = function PendingTasks_Factory(t) {
				return new (t || _PendingTasks)();
			 };
		  }
		  static {
			 this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _PendingTasks, factory: _PendingTasks.\u0275fac, providedIn: "root" });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PendingTasks, [{
			 type: Injectable,
			 args: [{ providedIn: "root" }]
		  }], null, null);
		})();
		function isListLikeIterable(obj) {
		  if (!isJsObject(obj))
			 return false;
		  return Array.isArray(obj) || !(obj instanceof Map) && // JS Map are iterables but return entries as [k, v]
		  Symbol.iterator in obj;
		}
		function areIterablesEqual(a, b, comparator) {
		  const iterator1 = a[Symbol.iterator]();
		  const iterator2 = b[Symbol.iterator]();
		  while (true) {
			 const item1 = iterator1.next();
			 const item2 = iterator2.next();
			 if (item1.done && item2.done)
				return true;
			 if (item1.done || item2.done)
				return false;
			 if (!comparator(item1.value, item2.value))
				return false;
		  }
		}
		function iterateListLike(obj, fn) {
		  if (Array.isArray(obj)) {
			 for (let i = 0; i < obj.length; i++) {
				fn(obj[i]);
			 }
		  } else {
			 const iterator2 = obj[Symbol.iterator]();
			 let item;
			 while (!(item = iterator2.next()).done) {
				fn(item.value);
			 }
		  }
		}
		function isJsObject(o) {
		  return o !== null && (typeof o === "function" || typeof o === "object");
		}
		function devModeEqual(a, b) {
		  const isListLikeIterableA = isListLikeIterable(a);
		  const isListLikeIterableB = isListLikeIterable(b);
		  if (isListLikeIterableA && isListLikeIterableB) {
			 return areIterablesEqual(a, b, devModeEqual);
		  } else {
			 const isAObject = a && (typeof a === "object" || typeof a === "function");
			 const isBObject = b && (typeof b === "object" || typeof b === "function");
			 if (!isListLikeIterableA && isAObject && !isListLikeIterableB && isBObject) {
				return true;
			 } else {
				return Object.is(a, b);
			 }
		  }
		}
		function updateBinding(lView, bindingIndex, value) {
		  return lView[bindingIndex] = value;
		}
		function getBinding(lView, bindingIndex) {
		  ngDevMode && assertIndexInRange(lView, bindingIndex);
		  ngDevMode && assertNotSame(lView[bindingIndex], NO_CHANGE, "Stored value should never be NO_CHANGE.");
		  return lView[bindingIndex];
		}
		function bindingUpdated(lView, bindingIndex, value) {
		  ngDevMode && assertNotSame(value, NO_CHANGE, "Incoming value should never be NO_CHANGE.");
		  ngDevMode && assertLessThan(bindingIndex, lView.length, `Slot should have been initialized to NO_CHANGE`);
		  const oldValue = lView[bindingIndex];
		  if (Object.is(oldValue, value)) {
			 return false;
		  } else {
			 if (ngDevMode && isInCheckNoChangesMode()) {
				const oldValueToCompare = oldValue !== NO_CHANGE ? oldValue : void 0;
				if (!devModeEqual(oldValueToCompare, value)) {
				  const details = getExpressionChangedErrorDetails(lView, bindingIndex, oldValueToCompare, value);
				  throwErrorIfNoChangesMode(oldValue === NO_CHANGE, details.oldValue, details.newValue, details.propName, lView);
				}
				return false;
			 }
			 lView[bindingIndex] = value;
			 return true;
		  }
		}
		function bindingUpdated2(lView, bindingIndex, exp1, exp2) {
		  const different = bindingUpdated(lView, bindingIndex, exp1);
		  return bindingUpdated(lView, bindingIndex + 1, exp2) || different;
		}
		function bindingUpdated3(lView, bindingIndex, exp1, exp2, exp3) {
		  const different = bindingUpdated2(lView, bindingIndex, exp1, exp2);
		  return bindingUpdated(lView, bindingIndex + 2, exp3) || different;
		}
		function bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4) {
		  const different = bindingUpdated2(lView, bindingIndex, exp1, exp2);
		  return bindingUpdated2(lView, bindingIndex + 2, exp3, exp4) || different;
		}
		function isDetachedByI18n(tNode) {
		  return (tNode.flags & 32) === 32;
		}
		function templateFirstCreatePass(index, tView, lView, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex) {
		  ngDevMode && assertFirstCreatePass(tView);
		  ngDevMode && ngDevMode.firstCreatePass++;
		  const tViewConsts = tView.consts;
		  const tNode = getOrCreateTNode(tView, index, 4, tagName || null, getConstant(tViewConsts, attrsIndex));
		  resolveDirectives(tView, lView, tNode, getConstant(tViewConsts, localRefsIndex));
		  registerPostOrderHooks(tView, tNode);
		  const embeddedTView = tNode.tView = createTView(
			 2,
			 tNode,
			 templateFn,
			 decls,
			 vars,
			 tView.directiveRegistry,
			 tView.pipeRegistry,
			 null,
			 tView.schemas,
			 tViewConsts,
			 null
			 /* ssrId */
		  );
		  if (tView.queries !== null) {
			 tView.queries.template(tView, tNode);
			 embeddedTView.queries = tView.queries.embeddedTView(tNode);
		  }
		  return tNode;
		}
		function \u0275\u0275template(index, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex, localRefExtractor) {
		  const lView = getLView();
		  const tView = getTView();
		  const adjustedIndex = index + HEADER_OFFSET;
		  const tNode = tView.firstCreatePass ? templateFirstCreatePass(adjustedIndex, tView, lView, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex) : tView.data[adjustedIndex];
		  setCurrentTNode(tNode, false);
		  const comment = _locateOrCreateContainerAnchor(tView, lView, tNode, index);
		  if (wasLastNodeCreated()) {
			 appendChild(tView, lView, comment, tNode);
		  }
		  attachPatchData(comment, lView);
		  const lContainer = createLContainer(comment, lView, comment, tNode);
		  lView[adjustedIndex] = lContainer;
		  addToViewTree(lView, lContainer);
		  populateDehydratedViewsInLContainer(lContainer, tNode, lView);
		  if (isDirectiveHost(tNode)) {
			 createDirectivesInstances(tView, lView, tNode);
		  }
		  if (localRefsIndex != null) {
			 saveResolvedLocalsInData(lView, tNode, localRefExtractor);
		  }
		  return \u0275\u0275template;
		}
		var _locateOrCreateContainerAnchor = createContainerAnchorImpl;
		function createContainerAnchorImpl(tView, lView, tNode, index) {
		  lastNodeWasCreated(true);
		  return lView[RENDERER].createComment(ngDevMode ? "container" : "");
		}
		var DeferDependenciesLoadingState;
		(function(DeferDependenciesLoadingState2) {
		  DeferDependenciesLoadingState2[DeferDependenciesLoadingState2["NOT_STARTED"] = 0] = "NOT_STARTED";
		  DeferDependenciesLoadingState2[DeferDependenciesLoadingState2["IN_PROGRESS"] = 1] = "IN_PROGRESS";
		  DeferDependenciesLoadingState2[DeferDependenciesLoadingState2["COMPLETE"] = 2] = "COMPLETE";
		  DeferDependenciesLoadingState2[DeferDependenciesLoadingState2["FAILED"] = 3] = "FAILED";
		})(DeferDependenciesLoadingState || (DeferDependenciesLoadingState = {}));
		var MINIMUM_SLOT = 0;
		var LOADING_AFTER_SLOT = 1;
		var DeferBlockState;
		(function(DeferBlockState2) {
		  DeferBlockState2[DeferBlockState2["Placeholder"] = 0] = "Placeholder";
		  DeferBlockState2[DeferBlockState2["Loading"] = 1] = "Loading";
		  DeferBlockState2[DeferBlockState2["Complete"] = 2] = "Complete";
		  DeferBlockState2[DeferBlockState2["Error"] = 3] = "Error";
		})(DeferBlockState || (DeferBlockState = {}));
		var DeferBlockInternalState;
		(function(DeferBlockInternalState2) {
		  DeferBlockInternalState2[DeferBlockInternalState2["Initial"] = -1] = "Initial";
		})(DeferBlockInternalState || (DeferBlockInternalState = {}));
		var NEXT_DEFER_BLOCK_STATE = 0;
		var DEFER_BLOCK_STATE = 1;
		var STATE_IS_FROZEN_UNTIL = 2;
		var LOADING_AFTER_CLEANUP_FN = 3;
		var TRIGGER_CLEANUP_FNS = 4;
		var PREFETCH_TRIGGER_CLEANUP_FNS = 5;
		var DeferBlockBehavior;
		(function(DeferBlockBehavior2) {
		  DeferBlockBehavior2[DeferBlockBehavior2["Manual"] = 0] = "Manual";
		  DeferBlockBehavior2[DeferBlockBehavior2["Playthrough"] = 1] = "Playthrough";
		})(DeferBlockBehavior || (DeferBlockBehavior = {}));
		function storeTriggerCleanupFn(type2, lDetails, cleanupFn) {
		  const key = type2 === 1 ? PREFETCH_TRIGGER_CLEANUP_FNS : TRIGGER_CLEANUP_FNS;
		  if (lDetails[key] === null) {
			 lDetails[key] = [];
		  }
		  lDetails[key].push(cleanupFn);
		}
		function invokeTriggerCleanupFns(type2, lDetails) {
		  const key = type2 === 1 ? PREFETCH_TRIGGER_CLEANUP_FNS : TRIGGER_CLEANUP_FNS;
		  const cleanupFns = lDetails[key];
		  if (cleanupFns !== null) {
			 for (const cleanupFn of cleanupFns) {
				cleanupFn();
			 }
			 lDetails[key] = null;
		  }
		}
		function invokeAllTriggerCleanupFns(lDetails) {
		  invokeTriggerCleanupFns(1, lDetails);
		  invokeTriggerCleanupFns(0, lDetails);
		}
		function getDeferBlockDataIndex(deferBlockIndex) {
		  return deferBlockIndex + 1;
		}
		function getLDeferBlockDetails(lView, tNode) {
		  const tView = lView[TVIEW];
		  const slotIndex = getDeferBlockDataIndex(tNode.index);
		  ngDevMode && assertIndexInDeclRange(tView, slotIndex);
		  return lView[slotIndex];
		}
		function setLDeferBlockDetails(lView, deferBlockIndex, lDetails) {
		  const tView = lView[TVIEW];
		  const slotIndex = getDeferBlockDataIndex(deferBlockIndex);
		  ngDevMode && assertIndexInDeclRange(tView, slotIndex);
		  lView[slotIndex] = lDetails;
		}
		function getTDeferBlockDetails(tView, tNode) {
		  const slotIndex = getDeferBlockDataIndex(tNode.index);
		  ngDevMode && assertIndexInDeclRange(tView, slotIndex);
		  return tView.data[slotIndex];
		}
		function setTDeferBlockDetails(tView, deferBlockIndex, deferBlockConfig) {
		  const slotIndex = getDeferBlockDataIndex(deferBlockIndex);
		  ngDevMode && assertIndexInDeclRange(tView, slotIndex);
		  tView.data[slotIndex] = deferBlockConfig;
		}
		function getTemplateIndexForState(newState, hostLView, tNode) {
		  const tView = hostLView[TVIEW];
		  const tDetails = getTDeferBlockDetails(tView, tNode);
		  switch (newState) {
			 case DeferBlockState.Complete:
				return tDetails.primaryTmplIndex;
			 case DeferBlockState.Loading:
				return tDetails.loadingTmplIndex;
			 case DeferBlockState.Error:
				return tDetails.errorTmplIndex;
			 case DeferBlockState.Placeholder:
				return tDetails.placeholderTmplIndex;
			 default:
				ngDevMode && throwError(`Unexpected defer block state: ${newState}`);
				return null;
		  }
		}
		function getMinimumDurationForState(tDetails, currentState) {
		  if (currentState === DeferBlockState.Placeholder) {
			 return tDetails.placeholderBlockConfig?.[MINIMUM_SLOT] ?? null;
		  } else if (currentState === DeferBlockState.Loading) {
			 return tDetails.loadingBlockConfig?.[MINIMUM_SLOT] ?? null;
		  }
		  return null;
		}
		function getLoadingBlockAfter(tDetails) {
		  return tDetails.loadingBlockConfig?.[LOADING_AFTER_SLOT] ?? null;
		}
		function addDepsToRegistry(currentDeps, newDeps) {
		  if (!currentDeps || currentDeps.length === 0) {
			 return newDeps;
		  }
		  const currentDepSet = new Set(currentDeps);
		  for (const dep of newDeps) {
			 currentDepSet.add(dep);
		  }
		  return currentDeps.length === currentDepSet.size ? currentDeps : Array.from(currentDepSet);
		}
		function getPrimaryBlockTNode(tView, tDetails) {
		  const adjustedIndex = tDetails.primaryTmplIndex + HEADER_OFFSET;
		  return getTNode(tView, adjustedIndex);
		}
		function assertDeferredDependenciesLoaded(tDetails) {
		  assertEqual(tDetails.loadingState, DeferDependenciesLoadingState.COMPLETE, "Expecting all deferred dependencies to be loaded.");
		}
		var eventListenerOptions = {
		  passive: true,
		  capture: true
		};
		var hoverTriggers = /* @__PURE__ */ new WeakMap();
		var interactionTriggers = /* @__PURE__ */ new WeakMap();
		var viewportTriggers = /* @__PURE__ */ new WeakMap();
		var interactionEventNames = ["click", "keydown"];
		var hoverEventNames = ["mouseenter", "focusin"];
		var intersectionObserver = null;
		var observedViewportElements = 0;
		var DeferEventEntry = class {
		  constructor() {
			 this.callbacks = /* @__PURE__ */ new Set();
			 this.listener = () => {
				for (const callback of this.callbacks) {
				  callback();
				}
			 };
		  }
		};
		function onInteraction(trigger, callback) {
		  let entry = interactionTriggers.get(trigger);
		  if (!entry) {
			 entry = new DeferEventEntry();
			 interactionTriggers.set(trigger, entry);
			 for (const name of interactionEventNames) {
				trigger.addEventListener(name, entry.listener, eventListenerOptions);
			 }
		  }
		  entry.callbacks.add(callback);
		  return () => {
			 const { callbacks, listener } = entry;
			 callbacks.delete(callback);
			 if (callbacks.size === 0) {
				interactionTriggers.delete(trigger);
				for (const name of interactionEventNames) {
				  trigger.removeEventListener(name, listener, eventListenerOptions);
				}
			 }
		  };
		}
		function onHover(trigger, callback) {
		  let entry = hoverTriggers.get(trigger);
		  if (!entry) {
			 entry = new DeferEventEntry();
			 hoverTriggers.set(trigger, entry);
			 for (const name of hoverEventNames) {
				trigger.addEventListener(name, entry.listener, eventListenerOptions);
			 }
		  }
		  entry.callbacks.add(callback);
		  return () => {
			 const { callbacks, listener } = entry;
			 callbacks.delete(callback);
			 if (callbacks.size === 0) {
				for (const name of hoverEventNames) {
				  trigger.removeEventListener(name, listener, eventListenerOptions);
				}
				hoverTriggers.delete(trigger);
			 }
		  };
		}
		function onViewport(trigger, callback, injector) {
		  const ngZone = injector.get(NgZone);
		  let entry = viewportTriggers.get(trigger);
		  intersectionObserver = intersectionObserver || ngZone.runOutsideAngular(() => {
			 return new IntersectionObserver((entries) => {
				for (const current of entries) {
				  if (current.isIntersecting && viewportTriggers.has(current.target)) {
					 ngZone.run(viewportTriggers.get(current.target).listener);
				  }
				}
			 });
		  });
		  if (!entry) {
			 entry = new DeferEventEntry();
			 ngZone.runOutsideAngular(() => intersectionObserver.observe(trigger));
			 viewportTriggers.set(trigger, entry);
			 observedViewportElements++;
		  }
		  entry.callbacks.add(callback);
		  return () => {
			 if (!viewportTriggers.has(trigger)) {
				return;
			 }
			 entry.callbacks.delete(callback);
			 if (entry.callbacks.size === 0) {
				intersectionObserver?.unobserve(trigger);
				viewportTriggers.delete(trigger);
				observedViewportElements--;
			 }
			 if (observedViewportElements === 0) {
				intersectionObserver?.disconnect();
				intersectionObserver = null;
			 }
		  };
		}
		function getTriggerLView(deferredHostLView, deferredTNode, walkUpTimes) {
		  if (walkUpTimes == null) {
			 return deferredHostLView;
		  }
		  if (walkUpTimes >= 0) {
			 return walkUpViews(walkUpTimes, deferredHostLView);
		  }
		  const deferredContainer = deferredHostLView[deferredTNode.index];
		  ngDevMode && assertLContainer(deferredContainer);
		  const triggerLView = deferredContainer[CONTAINER_HEADER_OFFSET] ?? null;
		  if (ngDevMode && triggerLView !== null) {
			 const lDetails = getLDeferBlockDetails(deferredHostLView, deferredTNode);
			 const renderedState = lDetails[DEFER_BLOCK_STATE];
			 assertEqual(renderedState, DeferBlockState.Placeholder, "Expected a placeholder to be rendered in this defer block.");
			 assertLView(triggerLView);
		  }
		  return triggerLView;
		}
		function getTriggerElement(triggerLView, triggerIndex) {
		  const element = getNativeByIndex(HEADER_OFFSET + triggerIndex, triggerLView);
		  ngDevMode && assertElement(element);
		  return element;
		}
		function registerDomTrigger(initialLView, tNode, triggerIndex, walkUpTimes, registerFn, callback, type2) {
		  const injector = initialLView[INJECTOR];
		  function pollDomTrigger() {
			 if (isDestroyed(initialLView)) {
				return;
			 }
			 const lDetails = getLDeferBlockDetails(initialLView, tNode);
			 const renderedState = lDetails[DEFER_BLOCK_STATE];
			 if (renderedState !== DeferBlockInternalState.Initial && renderedState !== DeferBlockState.Placeholder) {
				return;
			 }
			 const triggerLView = getTriggerLView(initialLView, tNode, walkUpTimes);
			 if (!triggerLView) {
				internalAfterNextRender(pollDomTrigger, { injector });
				return;
			 }
			 if (isDestroyed(triggerLView)) {
				return;
			 }
			 const element = getTriggerElement(triggerLView, triggerIndex);
			 const cleanup = registerFn(element, () => {
				if (initialLView !== triggerLView) {
				  removeLViewOnDestroy(triggerLView, cleanup);
				}
				callback();
			 }, injector);
			 if (initialLView !== triggerLView) {
				storeLViewOnDestroy(triggerLView, cleanup);
			 }
			 storeTriggerCleanupFn(type2, lDetails, cleanup);
		  }
		  internalAfterNextRender(pollDomTrigger, { injector });
		}
		function onIdle(callback, lView) {
		  const injector = lView[INJECTOR];
		  const scheduler2 = injector.get(IdleScheduler);
		  const cleanupFn = () => scheduler2.remove(callback);
		  scheduler2.add(callback);
		  return cleanupFn;
		}
		var _requestIdleCallback = () => typeof requestIdleCallback !== "undefined" ? requestIdleCallback : setTimeout;
		var _cancelIdleCallback = () => typeof requestIdleCallback !== "undefined" ? cancelIdleCallback : clearTimeout;
		var IdleScheduler = class _IdleScheduler {
		  constructor() {
			 this.executingCallbacks = false;
			 this.idleId = null;
			 this.current = /* @__PURE__ */ new Set();
			 this.deferred = /* @__PURE__ */ new Set();
			 this.ngZone = inject(NgZone);
			 this.requestIdleCallbackFn = _requestIdleCallback().bind(globalThis);
			 this.cancelIdleCallbackFn = _cancelIdleCallback().bind(globalThis);
		  }
		  add(callback) {
			 const target = this.executingCallbacks ? this.deferred : this.current;
			 target.add(callback);
			 if (this.idleId === null) {
				this.scheduleIdleCallback();
			 }
		  }
		  remove(callback) {
			 const { current, deferred } = this;
			 current.delete(callback);
			 deferred.delete(callback);
			 if (current.size === 0 && deferred.size === 0) {
				this.cancelIdleCallback();
			 }
		  }
		  scheduleIdleCallback() {
			 const callback = () => {
				this.cancelIdleCallback();
				this.executingCallbacks = true;
				for (const callback2 of this.current) {
				  callback2();
				}
				this.current.clear();
				this.executingCallbacks = false;
				if (this.deferred.size > 0) {
				  for (const callback2 of this.deferred) {
					 this.current.add(callback2);
				  }
				  this.deferred.clear();
				  this.scheduleIdleCallback();
				}
			 };
			 this.idleId = this.requestIdleCallbackFn(() => this.ngZone.run(callback));
		  }
		  cancelIdleCallback() {
			 if (this.idleId !== null) {
				this.cancelIdleCallbackFn(this.idleId);
				this.idleId = null;
			 }
		  }
		  ngOnDestroy() {
			 this.cancelIdleCallback();
			 this.current.clear();
			 this.deferred.clear();
		  }
		  static {
			 this.\u0275prov = \u0275\u0275defineInjectable({
				token: _IdleScheduler,
				providedIn: "root",
				factory: () => new _IdleScheduler()
			 });
		  }
		};
		function onTimer(delay) {
		  return (callback, lView) => scheduleTimerTrigger(delay, callback, lView);
		}
		function scheduleTimerTrigger(delay, callback, lView) {
		  const injector = lView[INJECTOR];
		  const scheduler2 = injector.get(TimerScheduler);
		  const cleanupFn = () => scheduler2.remove(callback);
		  scheduler2.add(delay, callback);
		  return cleanupFn;
		}
		var TimerScheduler = class _TimerScheduler {
		  constructor() {
			 this.executingCallbacks = false;
			 this.timeoutId = null;
			 this.invokeTimerAt = null;
			 this.current = [];
			 this.deferred = [];
		  }
		  add(delay, callback) {
			 const target = this.executingCallbacks ? this.deferred : this.current;
			 this.addToQueue(target, Date.now() + delay, callback);
			 this.scheduleTimer();
		  }
		  remove(callback) {
			 const { current, deferred } = this;
			 const callbackIndex = this.removeFromQueue(current, callback);
			 if (callbackIndex === -1) {
				this.removeFromQueue(deferred, callback);
			 }
			 if (current.length === 0 && deferred.length === 0) {
				this.clearTimeout();
			 }
		  }
		  addToQueue(target, invokeAt, callback) {
			 let insertAtIndex = target.length;
			 for (let i = 0; i < target.length; i += 2) {
				const invokeQueuedCallbackAt = target[i];
				if (invokeQueuedCallbackAt > invokeAt) {
				  insertAtIndex = i;
				  break;
				}
			 }
			 arrayInsert2(target, insertAtIndex, invokeAt, callback);
		  }
		  removeFromQueue(target, callback) {
			 let index = -1;
			 for (let i = 0; i < target.length; i += 2) {
				const queuedCallback = target[i + 1];
				if (queuedCallback === callback) {
				  index = i;
				  break;
				}
			 }
			 if (index > -1) {
				arraySplice(target, index, 2);
			 }
			 return index;
		  }
		  scheduleTimer() {
			 const callback = () => {
				this.clearTimeout();
				this.executingCallbacks = true;
				const current = [...this.current];
				const now2 = Date.now();
				for (let i = 0; i < current.length; i += 2) {
				  const invokeAt = current[i];
				  const callback2 = current[i + 1];
				  if (invokeAt <= now2) {
					 callback2();
				  } else {
					 break;
				  }
				}
				let lastCallbackIndex = -1;
				for (let i = 0; i < this.current.length; i += 2) {
				  const invokeAt = this.current[i];
				  if (invokeAt <= now2) {
					 lastCallbackIndex = i + 1;
				  } else {
					 break;
				  }
				}
				if (lastCallbackIndex >= 0) {
				  arraySplice(this.current, 0, lastCallbackIndex + 1);
				}
				this.executingCallbacks = false;
				if (this.deferred.length > 0) {
				  for (let i = 0; i < this.deferred.length; i += 2) {
					 const invokeAt = this.deferred[i];
					 const callback2 = this.deferred[i + 1];
					 this.addToQueue(this.current, invokeAt, callback2);
				  }
				  this.deferred.length = 0;
				}
				this.scheduleTimer();
			 };
			 const FRAME_DURATION_MS = 16;
			 if (this.current.length > 0) {
				const now2 = Date.now();
				const invokeAt = this.current[0];
				if (this.timeoutId === null || // Reschedule a timer in case a queue contains an item with
				// an earlier timestamp and the delta is more than an average
				// frame duration.
				this.invokeTimerAt && this.invokeTimerAt - invokeAt > FRAME_DURATION_MS) {
				  this.clearTimeout();
				  const timeout2 = Math.max(invokeAt - now2, FRAME_DURATION_MS);
				  this.invokeTimerAt = invokeAt;
				  this.timeoutId = setTimeout(callback, timeout2);
				}
			 }
		  }
		  clearTimeout() {
			 if (this.timeoutId !== null) {
				clearTimeout(this.timeoutId);
				this.timeoutId = null;
			 }
		  }
		  ngOnDestroy() {
			 this.clearTimeout();
			 this.current.length = 0;
			 this.deferred.length = 0;
		  }
		  static {
			 this.\u0275prov = \u0275\u0275defineInjectable({
				token: _TimerScheduler,
				providedIn: "root",
				factory: () => new _TimerScheduler()
			 });
		  }
		};
		var DEFER_BLOCK_DEPENDENCY_INTERCEPTOR = new InjectionToken("DEFER_BLOCK_DEPENDENCY_INTERCEPTOR");
		var DEFER_BLOCK_CONFIG = new InjectionToken(ngDevMode ? "DEFER_BLOCK_CONFIG" : "");
		function shouldTriggerDeferBlock(injector) {
		  const config2 = injector.get(DEFER_BLOCK_CONFIG, null, { optional: true });
		  if (config2?.behavior === DeferBlockBehavior.Manual) {
			 return false;
		  }
		  return isPlatformBrowser(injector);
		}
		var applyDeferBlockStateWithSchedulingImpl = null;
		function \u0275\u0275deferEnableTimerScheduling(tView, tDetails, placeholderConfigIndex, loadingConfigIndex) {
		  const tViewConsts = tView.consts;
		  if (placeholderConfigIndex != null) {
			 tDetails.placeholderBlockConfig = getConstant(tViewConsts, placeholderConfigIndex);
		  }
		  if (loadingConfigIndex != null) {
			 tDetails.loadingBlockConfig = getConstant(tViewConsts, loadingConfigIndex);
		  }
		  if (applyDeferBlockStateWithSchedulingImpl === null) {
			 applyDeferBlockStateWithSchedulingImpl = applyDeferBlockStateWithScheduling;
		  }
		}
		function \u0275\u0275defer(index, primaryTmplIndex, dependencyResolverFn, loadingTmplIndex, placeholderTmplIndex, errorTmplIndex, loadingConfigIndex, placeholderConfigIndex, enableTimerScheduling) {
		  const lView = getLView();
		  const tView = getTView();
		  const adjustedIndex = index + HEADER_OFFSET;
		  \u0275\u0275template(index, null, 0, 0);
		  if (tView.firstCreatePass) {
			 performanceMarkFeature("NgDefer");
			 const tDetails = {
				primaryTmplIndex,
				loadingTmplIndex: loadingTmplIndex ?? null,
				placeholderTmplIndex: placeholderTmplIndex ?? null,
				errorTmplIndex: errorTmplIndex ?? null,
				placeholderBlockConfig: null,
				loadingBlockConfig: null,
				dependencyResolverFn: dependencyResolverFn ?? null,
				loadingState: DeferDependenciesLoadingState.NOT_STARTED,
				loadingPromise: null,
				providers: null
			 };
			 enableTimerScheduling?.(tView, tDetails, placeholderConfigIndex, loadingConfigIndex);
			 setTDeferBlockDetails(tView, adjustedIndex, tDetails);
		  }
		  const tNode = getCurrentTNode();
		  const lContainer = lView[adjustedIndex];
		  populateDehydratedViewsInLContainer(lContainer, tNode, lView);
		  const lDetails = [
			 null,
			 // NEXT_DEFER_BLOCK_STATE
			 DeferBlockInternalState.Initial,
			 // DEFER_BLOCK_STATE
			 null,
			 // STATE_IS_FROZEN_UNTIL
			 null,
			 // LOADING_AFTER_CLEANUP_FN
			 null,
			 // TRIGGER_CLEANUP_FNS
			 null
			 // PREFETCH_TRIGGER_CLEANUP_FNS
		  ];
		  setLDeferBlockDetails(lView, adjustedIndex, lDetails);
		  const cleanupTriggersFn = () => invokeAllTriggerCleanupFns(lDetails);
		  storeTriggerCleanupFn(0, lDetails, () => removeLViewOnDestroy(lView, cleanupTriggersFn));
		  storeLViewOnDestroy(lView, cleanupTriggersFn);
		}
		function \u0275\u0275deferWhen(rawValue) {
		  const lView = getLView();
		  const bindingIndex = nextBindingIndex();
		  if (bindingUpdated(lView, bindingIndex, rawValue)) {
			 const prevConsumer = setActiveConsumer(null);
			 try {
				const value = Boolean(rawValue);
				const tNode = getSelectedTNode();
				const lDetails = getLDeferBlockDetails(lView, tNode);
				const renderedState = lDetails[DEFER_BLOCK_STATE];
				if (value === false && renderedState === DeferBlockInternalState.Initial) {
				  renderPlaceholder(lView, tNode);
				} else if (value === true && (renderedState === DeferBlockInternalState.Initial || renderedState === DeferBlockState.Placeholder)) {
				  triggerDeferBlock(lView, tNode);
				}
			 } finally {
				setActiveConsumer(prevConsumer);
			 }
		  }
		}
		function \u0275\u0275deferPrefetchWhen(rawValue) {
		  const lView = getLView();
		  const bindingIndex = nextBindingIndex();
		  if (bindingUpdated(lView, bindingIndex, rawValue)) {
			 const prevConsumer = setActiveConsumer(null);
			 try {
				const value = Boolean(rawValue);
				const tView = lView[TVIEW];
				const tNode = getSelectedTNode();
				const tDetails = getTDeferBlockDetails(tView, tNode);
				if (value === true && tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
				  triggerPrefetching(tDetails, lView, tNode);
				}
			 } finally {
				setActiveConsumer(prevConsumer);
			 }
		  }
		}
		function \u0275\u0275deferOnIdle() {
		  scheduleDelayedTrigger(onIdle);
		}
		function \u0275\u0275deferPrefetchOnIdle() {
		  scheduleDelayedPrefetching(onIdle);
		}
		function \u0275\u0275deferOnImmediate() {
		  const lView = getLView();
		  const tNode = getCurrentTNode();
		  const tView = lView[TVIEW];
		  const injector = lView[INJECTOR];
		  const tDetails = getTDeferBlockDetails(tView, tNode);
		  if (!shouldTriggerDeferBlock(injector) || tDetails.loadingTmplIndex === null) {
			 renderPlaceholder(lView, tNode);
		  }
		  triggerDeferBlock(lView, tNode);
		}
		function \u0275\u0275deferPrefetchOnImmediate() {
		  const lView = getLView();
		  const tNode = getCurrentTNode();
		  const tView = lView[TVIEW];
		  const tDetails = getTDeferBlockDetails(tView, tNode);
		  if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
			 triggerResourceLoading(tDetails, lView, tNode);
		  }
		}
		function \u0275\u0275deferOnTimer(delay) {
		  scheduleDelayedTrigger(onTimer(delay));
		}
		function \u0275\u0275deferPrefetchOnTimer(delay) {
		  scheduleDelayedPrefetching(onTimer(delay));
		}
		function \u0275\u0275deferOnHover(triggerIndex, walkUpTimes) {
		  const lView = getLView();
		  const tNode = getCurrentTNode();
		  renderPlaceholder(lView, tNode);
		  registerDomTrigger(
			 lView,
			 tNode,
			 triggerIndex,
			 walkUpTimes,
			 onHover,
			 () => triggerDeferBlock(lView, tNode),
			 0
			 /* TriggerType.Regular */
		  );
		}
		function \u0275\u0275deferPrefetchOnHover(triggerIndex, walkUpTimes) {
		  const lView = getLView();
		  const tNode = getCurrentTNode();
		  const tView = lView[TVIEW];
		  const tDetails = getTDeferBlockDetails(tView, tNode);
		  if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
			 registerDomTrigger(
				lView,
				tNode,
				triggerIndex,
				walkUpTimes,
				onHover,
				() => triggerPrefetching(tDetails, lView, tNode),
				1
				/* TriggerType.Prefetch */
			 );
		  }
		}
		function \u0275\u0275deferOnInteraction(triggerIndex, walkUpTimes) {
		  const lView = getLView();
		  const tNode = getCurrentTNode();
		  renderPlaceholder(lView, tNode);
		  registerDomTrigger(
			 lView,
			 tNode,
			 triggerIndex,
			 walkUpTimes,
			 onInteraction,
			 () => triggerDeferBlock(lView, tNode),
			 0
			 /* TriggerType.Regular */
		  );
		}
		function \u0275\u0275deferPrefetchOnInteraction(triggerIndex, walkUpTimes) {
		  const lView = getLView();
		  const tNode = getCurrentTNode();
		  const tView = lView[TVIEW];
		  const tDetails = getTDeferBlockDetails(tView, tNode);
		  if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
			 registerDomTrigger(
				lView,
				tNode,
				triggerIndex,
				walkUpTimes,
				onInteraction,
				() => triggerPrefetching(tDetails, lView, tNode),
				1
				/* TriggerType.Prefetch */
			 );
		  }
		}
		function \u0275\u0275deferOnViewport(triggerIndex, walkUpTimes) {
		  const lView = getLView();
		  const tNode = getCurrentTNode();
		  renderPlaceholder(lView, tNode);
		  registerDomTrigger(
			 lView,
			 tNode,
			 triggerIndex,
			 walkUpTimes,
			 onViewport,
			 () => triggerDeferBlock(lView, tNode),
			 0
			 /* TriggerType.Regular */
		  );
		}
		function \u0275\u0275deferPrefetchOnViewport(triggerIndex, walkUpTimes) {
		  const lView = getLView();
		  const tNode = getCurrentTNode();
		  const tView = lView[TVIEW];
		  const tDetails = getTDeferBlockDetails(tView, tNode);
		  if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
			 registerDomTrigger(
				lView,
				tNode,
				triggerIndex,
				walkUpTimes,
				onViewport,
				() => triggerPrefetching(tDetails, lView, tNode),
				1
				/* TriggerType.Prefetch */
			 );
		  }
		}
		function scheduleDelayedTrigger(scheduleFn) {
		  const lView = getLView();
		  const tNode = getCurrentTNode();
		  renderPlaceholder(lView, tNode);
		  if (isPlatformBrowser(lView[INJECTOR])) {
			 const cleanupFn = scheduleFn(() => triggerDeferBlock(lView, tNode), lView);
			 const lDetails = getLDeferBlockDetails(lView, tNode);
			 storeTriggerCleanupFn(0, lDetails, cleanupFn);
		  }
		}
		function scheduleDelayedPrefetching(scheduleFn) {
		  const lView = getLView();
		  if (isPlatformBrowser(lView[INJECTOR])) {
			 const tNode = getCurrentTNode();
			 const tView = lView[TVIEW];
			 const tDetails = getTDeferBlockDetails(tView, tNode);
			 if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
				const lDetails = getLDeferBlockDetails(lView, tNode);
				const prefetch = () => triggerPrefetching(tDetails, lView, tNode);
				const cleanupFn = scheduleFn(prefetch, lView);
				storeTriggerCleanupFn(1, lDetails, cleanupFn);
			 }
		  }
		}
		function renderDeferBlockState(newState, tNode, lContainer, skipTimerScheduling = false) {
		  const hostLView = lContainer[PARENT];
		  const hostTView = hostLView[TVIEW];
		  if (isDestroyed(hostLView))
			 return;
		  ngDevMode && assertTNodeForLView(tNode, hostLView);
		  const lDetails = getLDeferBlockDetails(hostLView, tNode);
		  ngDevMode && assertDefined(lDetails, "Expected a defer block state defined");
		  const currentState = lDetails[DEFER_BLOCK_STATE];
		  if (isValidStateChange(currentState, newState) && isValidStateChange(lDetails[NEXT_DEFER_BLOCK_STATE] ?? -1, newState)) {
			 const injector = hostLView[INJECTOR];
			 const tDetails = getTDeferBlockDetails(hostTView, tNode);
			 const needsScheduling = !skipTimerScheduling && isPlatformBrowser(injector) && (getLoadingBlockAfter(tDetails) !== null || getMinimumDurationForState(tDetails, DeferBlockState.Loading) !== null || getMinimumDurationForState(tDetails, DeferBlockState.Placeholder));
			 if (ngDevMode && needsScheduling) {
				assertDefined(applyDeferBlockStateWithSchedulingImpl, "Expected scheduling function to be defined");
			 }
			 const applyStateFn = needsScheduling ? applyDeferBlockStateWithSchedulingImpl : applyDeferBlockState;
			 try {
				applyStateFn(newState, lDetails, lContainer, tNode, hostLView);
			 } catch (error) {
				handleError(hostLView, error);
			 }
		  }
		}
		function isRouterOutletInjector(currentInjector) {
		  return currentInjector instanceof ChainedInjector && typeof currentInjector.injector.__ngOutletInjector === "function";
		}
		function createRouterOutletInjector(parentOutletInjector, parentInjector) {
		  const outletInjector = parentOutletInjector.injector;
		  return outletInjector.__ngOutletInjector(parentInjector);
		}
		function applyDeferBlockState(newState, lDetails, lContainer, tNode, hostLView) {
		  const stateTmplIndex = getTemplateIndexForState(newState, hostLView, tNode);
		  if (stateTmplIndex !== null) {
			 lDetails[DEFER_BLOCK_STATE] = newState;
			 const hostTView = hostLView[TVIEW];
			 const adjustedIndex = stateTmplIndex + HEADER_OFFSET;
			 const activeBlockTNode = getTNode(hostTView, adjustedIndex);
			 const viewIndex = 0;
			 removeLViewFromLContainer(lContainer, viewIndex);
			 let injector;
			 if (newState === DeferBlockState.Complete) {
				const tDetails = getTDeferBlockDetails(hostTView, tNode);
				const providers = tDetails.providers;
				if (providers && providers.length > 0) {
				  const parentInjector = hostLView[INJECTOR];
				  const isParentOutletInjector = isRouterOutletInjector(parentInjector);
				  const parentEnvInjector = isParentOutletInjector ? parentInjector : parentInjector.get(EnvironmentInjector);
				  injector = parentEnvInjector.get(CachedInjectorService).getOrCreateInjector(tDetails, parentEnvInjector, providers, ngDevMode ? "DeferBlock Injector" : "");
				  if (isParentOutletInjector) {
					 injector = createRouterOutletInjector(parentInjector, injector);
				  }
				}
			 }
			 const dehydratedView = findMatchingDehydratedView(lContainer, activeBlockTNode.tView.ssrId);
			 const embeddedLView = createAndRenderEmbeddedLView(hostLView, activeBlockTNode, null, { dehydratedView, injector });
			 addLViewToLContainer(lContainer, embeddedLView, viewIndex, shouldAddViewToDom(activeBlockTNode, dehydratedView));
			 markViewDirty(embeddedLView);
		  }
		}
		function applyDeferBlockStateWithScheduling(newState, lDetails, lContainer, tNode, hostLView) {
		  const now2 = Date.now();
		  const hostTView = hostLView[TVIEW];
		  const tDetails = getTDeferBlockDetails(hostTView, tNode);
		  if (lDetails[STATE_IS_FROZEN_UNTIL] === null || lDetails[STATE_IS_FROZEN_UNTIL] <= now2) {
			 lDetails[STATE_IS_FROZEN_UNTIL] = null;
			 const loadingAfter = getLoadingBlockAfter(tDetails);
			 const inLoadingAfterPhase = lDetails[LOADING_AFTER_CLEANUP_FN] !== null;
			 if (newState === DeferBlockState.Loading && loadingAfter !== null && !inLoadingAfterPhase) {
				lDetails[NEXT_DEFER_BLOCK_STATE] = newState;
				const cleanupFn = scheduleDeferBlockUpdate(loadingAfter, lDetails, tNode, lContainer, hostLView);
				lDetails[LOADING_AFTER_CLEANUP_FN] = cleanupFn;
			 } else {
				if (newState > DeferBlockState.Loading && inLoadingAfterPhase) {
				  lDetails[LOADING_AFTER_CLEANUP_FN]();
				  lDetails[LOADING_AFTER_CLEANUP_FN] = null;
				  lDetails[NEXT_DEFER_BLOCK_STATE] = null;
				}
				applyDeferBlockState(newState, lDetails, lContainer, tNode, hostLView);
				const duration = getMinimumDurationForState(tDetails, newState);
				if (duration !== null) {
				  lDetails[STATE_IS_FROZEN_UNTIL] = now2 + duration;
				  scheduleDeferBlockUpdate(duration, lDetails, tNode, lContainer, hostLView);
				}
			 }
		  } else {
			 lDetails[NEXT_DEFER_BLOCK_STATE] = newState;
		  }
		}
		function scheduleDeferBlockUpdate(timeout2, lDetails, tNode, lContainer, hostLView) {
		  const callback = () => {
			 const nextState = lDetails[NEXT_DEFER_BLOCK_STATE];
			 lDetails[STATE_IS_FROZEN_UNTIL] = null;
			 lDetails[NEXT_DEFER_BLOCK_STATE] = null;
			 if (nextState !== null) {
				renderDeferBlockState(nextState, tNode, lContainer);
			 }
		  };
		  return scheduleTimerTrigger(timeout2, callback, hostLView);
		}
		function isValidStateChange(currentState, newState) {
		  return currentState < newState;
		}
		function triggerPrefetching(tDetails, lView, tNode) {
		  if (lView[INJECTOR] && shouldTriggerDeferBlock(lView[INJECTOR])) {
			 triggerResourceLoading(tDetails, lView, tNode);
		  }
		}
		function triggerResourceLoading(tDetails, lView, tNode) {
		  const injector = lView[INJECTOR];
		  const tView = lView[TVIEW];
		  if (tDetails.loadingState !== DeferDependenciesLoadingState.NOT_STARTED) {
			 return tDetails.loadingPromise ?? Promise.resolve();
		  }
		  const lDetails = getLDeferBlockDetails(lView, tNode);
		  const primaryBlockTNode = getPrimaryBlockTNode(tView, tDetails);
		  tDetails.loadingState = DeferDependenciesLoadingState.IN_PROGRESS;
		  invokeTriggerCleanupFns(1, lDetails);
		  let dependenciesFn = tDetails.dependencyResolverFn;
		  if (ngDevMode) {
			 const deferDependencyInterceptor = injector.get(DEFER_BLOCK_DEPENDENCY_INTERCEPTOR, null, { optional: true });
			 if (deferDependencyInterceptor) {
				dependenciesFn = deferDependencyInterceptor.intercept(dependenciesFn);
			 }
		  }
		  const pendingTasks = injector.get(PendingTasks);
		  const taskId = pendingTasks.add();
		  if (!dependenciesFn) {
			 tDetails.loadingPromise = Promise.resolve().then(() => {
				tDetails.loadingPromise = null;
				tDetails.loadingState = DeferDependenciesLoadingState.COMPLETE;
				pendingTasks.remove(taskId);
			 });
			 return tDetails.loadingPromise;
		  }
		  tDetails.loadingPromise = Promise.allSettled(dependenciesFn()).then((results) => {
			 let failed = false;
			 const directiveDefs = [];
			 const pipeDefs = [];
			 for (const result of results) {
				if (result.status === "fulfilled") {
				  const dependency = result.value;
				  const directiveDef = getComponentDef(dependency) || getDirectiveDef(dependency);
				  if (directiveDef) {
					 directiveDefs.push(directiveDef);
				  } else {
					 const pipeDef = getPipeDef$1(dependency);
					 if (pipeDef) {
						pipeDefs.push(pipeDef);
					 }
				  }
				} else {
				  failed = true;
				  break;
				}
			 }
			 tDetails.loadingPromise = null;
			 pendingTasks.remove(taskId);
			 if (failed) {
				tDetails.loadingState = DeferDependenciesLoadingState.FAILED;
				if (tDetails.errorTmplIndex === null) {
				  const templateLocation = getTemplateLocationDetails(lView);
				  const error = new RuntimeError(750, ngDevMode && `Loading dependencies for \`@defer\` block failed, but no \`@error\` block was configured${templateLocation}. Consider using the \`@error\` block to render an error state.`);
				  handleError(lView, error);
				}
			 } else {
				tDetails.loadingState = DeferDependenciesLoadingState.COMPLETE;
				const primaryBlockTView = primaryBlockTNode.tView;
				if (directiveDefs.length > 0) {
				  primaryBlockTView.directiveRegistry = addDepsToRegistry(primaryBlockTView.directiveRegistry, directiveDefs);
				  const directiveTypes = directiveDefs.map((def) => def.type);
				  const providers = internalImportProvidersFrom(false, ...directiveTypes);
				  tDetails.providers = providers;
				}
				if (pipeDefs.length > 0) {
				  primaryBlockTView.pipeRegistry = addDepsToRegistry(primaryBlockTView.pipeRegistry, pipeDefs);
				}
			 }
		  });
		  return tDetails.loadingPromise;
		}
		function renderPlaceholder(lView, tNode) {
		  const lContainer = lView[tNode.index];
		  ngDevMode && assertLContainer(lContainer);
		  renderDeferBlockState(DeferBlockState.Placeholder, tNode, lContainer);
		}
		function renderDeferStateAfterResourceLoading(tDetails, tNode, lContainer) {
		  ngDevMode && assertDefined(tDetails.loadingPromise, "Expected loading Promise to exist on this defer block");
		  tDetails.loadingPromise.then(() => {
			 if (tDetails.loadingState === DeferDependenciesLoadingState.COMPLETE) {
				ngDevMode && assertDeferredDependenciesLoaded(tDetails);
				renderDeferBlockState(DeferBlockState.Complete, tNode, lContainer);
			 } else if (tDetails.loadingState === DeferDependenciesLoadingState.FAILED) {
				renderDeferBlockState(DeferBlockState.Error, tNode, lContainer);
			 }
		  });
		}
		function triggerDeferBlock(lView, tNode) {
		  const tView = lView[TVIEW];
		  const lContainer = lView[tNode.index];
		  const injector = lView[INJECTOR];
		  ngDevMode && assertLContainer(lContainer);
		  if (!shouldTriggerDeferBlock(injector))
			 return;
		  const lDetails = getLDeferBlockDetails(lView, tNode);
		  const tDetails = getTDeferBlockDetails(tView, tNode);
		  invokeAllTriggerCleanupFns(lDetails);
		  switch (tDetails.loadingState) {
			 case DeferDependenciesLoadingState.NOT_STARTED:
				renderDeferBlockState(DeferBlockState.Loading, tNode, lContainer);
				triggerResourceLoading(tDetails, lView, tNode);
				if (tDetails.loadingState === DeferDependenciesLoadingState.IN_PROGRESS) {
				  renderDeferStateAfterResourceLoading(tDetails, tNode, lContainer);
				}
				break;
			 case DeferDependenciesLoadingState.IN_PROGRESS:
				renderDeferBlockState(DeferBlockState.Loading, tNode, lContainer);
				renderDeferStateAfterResourceLoading(tDetails, tNode, lContainer);
				break;
			 case DeferDependenciesLoadingState.COMPLETE:
				ngDevMode && assertDeferredDependenciesLoaded(tDetails);
				renderDeferBlockState(DeferBlockState.Complete, tNode, lContainer);
				break;
			 case DeferDependenciesLoadingState.FAILED:
				renderDeferBlockState(DeferBlockState.Error, tNode, lContainer);
				break;
			 default:
				if (ngDevMode) {
				  throwError("Unknown defer block state");
				}
		  }
		}
		function \u0275\u0275attribute(name, value, sanitizer, namespace) {
		  const lView = getLView();
		  const bindingIndex = nextBindingIndex();
		  if (bindingUpdated(lView, bindingIndex, value)) {
			 const tView = getTView();
			 const tNode = getSelectedTNode();
			 elementAttributeInternal(tNode, lView, name, value, sanitizer, namespace);
			 ngDevMode && storePropertyBindingMetadata(tView.data, tNode, "attr." + name, bindingIndex);
		  }
		  return \u0275\u0275attribute;
		}
		function interpolationV(lView, values) {
		  ngDevMode && assertLessThan(2, values.length, "should have at least 3 values");
		  ngDevMode && assertEqual(values.length % 2, 1, "should have an odd number of values");
		  let isBindingUpdated = false;
		  let bindingIndex = getBindingIndex();
		  for (let i = 1; i < values.length; i += 2) {
			 isBindingUpdated = bindingUpdated(lView, bindingIndex++, values[i]) || isBindingUpdated;
		  }
		  setBindingIndex(bindingIndex);
		  if (!isBindingUpdated) {
			 return NO_CHANGE;
		  }
		  let content = values[0];
		  for (let i = 1; i < values.length; i += 2) {
			 content += renderStringify(values[i]) + values[i + 1];
		  }
		  return content;
		}
		function interpolation1(lView, prefix, v0, suffix) {
		  const different = bindingUpdated(lView, nextBindingIndex(), v0);
		  return different ? prefix + renderStringify(v0) + suffix : NO_CHANGE;
		}
		function interpolation2(lView, prefix, v0, i0, v1, suffix) {
		  const bindingIndex = getBindingIndex();
		  const different = bindingUpdated2(lView, bindingIndex, v0, v1);
		  incrementBindingIndex(2);
		  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + suffix : NO_CHANGE;
		}
		function interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix) {
		  const bindingIndex = getBindingIndex();
		  const different = bindingUpdated3(lView, bindingIndex, v0, v1, v2);
		  incrementBindingIndex(3);
		  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + suffix : NO_CHANGE;
		}
		function interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {
		  const bindingIndex = getBindingIndex();
		  const different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
		  incrementBindingIndex(4);
		  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + suffix : NO_CHANGE;
		}
		function interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {
		  const bindingIndex = getBindingIndex();
		  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
		  different = bindingUpdated(lView, bindingIndex + 4, v4) || different;
		  incrementBindingIndex(5);
		  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + suffix : NO_CHANGE;
		}
		function interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {
		  const bindingIndex = getBindingIndex();
		  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
		  different = bindingUpdated2(lView, bindingIndex + 4, v4, v5) || different;
		  incrementBindingIndex(6);
		  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + i4 + renderStringify(v5) + suffix : NO_CHANGE;
		}
		function interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {
		  const bindingIndex = getBindingIndex();
		  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
		  different = bindingUpdated3(lView, bindingIndex + 4, v4, v5, v6) || different;
		  incrementBindingIndex(7);
		  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + i4 + renderStringify(v5) + i5 + renderStringify(v6) + suffix : NO_CHANGE;
		}
		function interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {
		  const bindingIndex = getBindingIndex();
		  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
		  different = bindingUpdated4(lView, bindingIndex + 4, v4, v5, v6, v7) || different;
		  incrementBindingIndex(8);
		  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + i4 + renderStringify(v5) + i5 + renderStringify(v6) + i6 + renderStringify(v7) + suffix : NO_CHANGE;
		}
		function \u0275\u0275attributeInterpolate1(attrName, prefix, v0, suffix, sanitizer, namespace) {
		  const lView = getLView();
		  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);
		  if (interpolatedValue !== NO_CHANGE) {
			 const tNode = getSelectedTNode();
			 elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
			 ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 1, prefix, suffix);
		  }
		  return \u0275\u0275attributeInterpolate1;
		}
		function \u0275\u0275attributeInterpolate2(attrName, prefix, v0, i0, v1, suffix, sanitizer, namespace) {
		  const lView = getLView();
		  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);
		  if (interpolatedValue !== NO_CHANGE) {
			 const tNode = getSelectedTNode();
			 elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
			 ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 2, prefix, i0, suffix);
		  }
		  return \u0275\u0275attributeInterpolate2;
		}
		function \u0275\u0275attributeInterpolate3(attrName, prefix, v0, i0, v1, i1, v2, suffix, sanitizer, namespace) {
		  const lView = getLView();
		  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);
		  if (interpolatedValue !== NO_CHANGE) {
			 const tNode = getSelectedTNode();
			 elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
			 ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 3, prefix, i0, i1, suffix);
		  }
		  return \u0275\u0275attributeInterpolate3;
		}
		function \u0275\u0275attributeInterpolate4(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, suffix, sanitizer, namespace) {
		  const lView = getLView();
		  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
		  if (interpolatedValue !== NO_CHANGE) {
			 const tNode = getSelectedTNode();
			 elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
			 ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 4, prefix, i0, i1, i2, suffix);
		  }
		  return \u0275\u0275attributeInterpolate4;
		}
		function \u0275\u0275attributeInterpolate5(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix, sanitizer, namespace) {
		  const lView = getLView();
		  const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
		  if (interpolatedValue !== NO_CHANGE) {
			 const tNode = getSelectedTNode();
			 elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
			 ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 5, prefix, i0, i1, i2, i3, suffix);
		  }
		  return \u0275\u0275attributeInterpolate5;
		}
		function \u0275\u0275attributeInterpolate6(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix, sanitizer, namespace) {
		  const lView = getLView();
		  const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
		  if (interpolatedValue !== NO_CHANGE) {
			 const tNode = getSelectedTNode();
			 elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
			 ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 6, prefix, i0, i1, i2, i3, i4, suffix);
		  }
		  return \u0275\u0275attributeInterpolate6;
		}
		function \u0275\u0275attributeInterpolate7(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix, sanitizer, namespace) {
		  const lView = getLView();
		  const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
		  if (interpolatedValue !== NO_CHANGE) {
			 const tNode = getSelectedTNode();
			 elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
			 ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 7, prefix, i0, i1, i2, i3, i4, i5, suffix);
		  }
		  return \u0275\u0275attributeInterpolate7;
		}
		function \u0275\u0275attributeInterpolate8(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix, sanitizer, namespace) {
		  const lView = getLView();
		  const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
		  if (interpolatedValue !== NO_CHANGE) {
			 const tNode = getSelectedTNode();
			 elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
			 ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 8, prefix, i0, i1, i2, i3, i4, i5, i6, suffix);
		  }
		  return \u0275\u0275attributeInterpolate8;
		}
		function \u0275\u0275attributeInterpolateV(attrName, values, sanitizer, namespace) {
		  const lView = getLView();
		  const interpolated = interpolationV(lView, values);
		  if (interpolated !== NO_CHANGE) {
			 const tNode = getSelectedTNode();
			 elementAttributeInternal(tNode, lView, attrName, interpolated, sanitizer, namespace);
			 if (ngDevMode) {
				const interpolationInBetween = [values[0]];
				for (let i = 2; i < values.length; i += 2) {
				  interpolationInBetween.push(values[i]);
				}
				storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - interpolationInBetween.length + 1, ...interpolationInBetween);
			 }
		  }
		  return \u0275\u0275attributeInterpolateV;
		}
		function toTStylingRange(prev, next) {
		  ngDevMode && assertNumberInRange(
			 prev,
			 0,
			 32767
			 /* StylingRange.UNSIGNED_MASK */
		  );
		  ngDevMode && assertNumberInRange(
			 next,
			 0,
			 32767
			 /* StylingRange.UNSIGNED_MASK */
		  );
		  return prev << 17 | next << 2;
		}
		function getTStylingRangePrev(tStylingRange) {
		  ngDevMode && assertNumber(tStylingRange, "expected number");
		  return tStylingRange >> 17 & 32767;
		}
		function getTStylingRangePrevDuplicate(tStylingRange) {
		  ngDevMode && assertNumber(tStylingRange, "expected number");
		  return (tStylingRange & 2) == 2;
		}
		function setTStylingRangePrev(tStylingRange, previous) {
		  ngDevMode && assertNumber(tStylingRange, "expected number");
		  ngDevMode && assertNumberInRange(
			 previous,
			 0,
			 32767
			 /* StylingRange.UNSIGNED_MASK */
		  );
		  return tStylingRange & ~4294836224 | previous << 17;
		}
		function setTStylingRangePrevDuplicate(tStylingRange) {
		  ngDevMode && assertNumber(tStylingRange, "expected number");
		  return tStylingRange | 2;
		}
		function getTStylingRangeNext(tStylingRange) {
		  ngDevMode && assertNumber(tStylingRange, "expected number");
		  return (tStylingRange & 131068) >> 2;
		}
		function setTStylingRangeNext(tStylingRange, next) {
		  ngDevMode && assertNumber(tStylingRange, "expected number");
		  ngDevMode && assertNumberInRange(
			 next,
			 0,
			 32767
			 /* StylingRange.UNSIGNED_MASK */
		  );
		  return tStylingRange & ~131068 | //
		  next << 2;
		}
		function getTStylingRangeNextDuplicate(tStylingRange) {
		  ngDevMode && assertNumber(tStylingRange, "expected number");
		  return (tStylingRange & 1) === 1;
		}
		function setTStylingRangeNextDuplicate(tStylingRange) {
		  ngDevMode && assertNumber(tStylingRange, "expected number");
		  return tStylingRange | 1;
		}
		function insertTStylingBinding(tData, tNode, tStylingKeyWithStatic, index, isHostBinding, isClassBinding) {
		  ngDevMode && assertFirstUpdatePass(getTView());
		  let tBindings = isClassBinding ? tNode.classBindings : tNode.styleBindings;
		  let tmplHead = getTStylingRangePrev(tBindings);
		  let tmplTail = getTStylingRangeNext(tBindings);
		  tData[index] = tStylingKeyWithStatic;
		  let isKeyDuplicateOfStatic = false;
		  let tStylingKey;
		  if (Array.isArray(tStylingKeyWithStatic)) {
			 const staticKeyValueArray = tStylingKeyWithStatic;
			 tStylingKey = staticKeyValueArray[1];
			 if (tStylingKey === null || keyValueArrayIndexOf(staticKeyValueArray, tStylingKey) > 0) {
				isKeyDuplicateOfStatic = true;
			 }
		  } else {
			 tStylingKey = tStylingKeyWithStatic;
		  }
		  if (isHostBinding) {
			 const hasTemplateBindings = tmplTail !== 0;
			 if (hasTemplateBindings) {
				const previousNode = getTStylingRangePrev(tData[tmplHead + 1]);
				tData[index + 1] = toTStylingRange(previousNode, tmplHead);
				if (previousNode !== 0) {
				  tData[previousNode + 1] = setTStylingRangeNext(tData[previousNode + 1], index);
				}
				tData[tmplHead + 1] = setTStylingRangePrev(tData[tmplHead + 1], index);
			 } else {
				tData[index + 1] = toTStylingRange(tmplHead, 0);
				if (tmplHead !== 0) {
				  tData[tmplHead + 1] = setTStylingRangeNext(tData[tmplHead + 1], index);
				}
				tmplHead = index;
			 }
		  } else {
			 tData[index + 1] = toTStylingRange(tmplTail, 0);
			 ngDevMode && assertEqual(tmplHead !== 0 && tmplTail === 0, false, "Adding template bindings after hostBindings is not allowed.");
			 if (tmplHead === 0) {
				tmplHead = index;
			 } else {
				tData[tmplTail + 1] = setTStylingRangeNext(tData[tmplTail + 1], index);
			 }
			 tmplTail = index;
		  }
		  if (isKeyDuplicateOfStatic) {
			 tData[index + 1] = setTStylingRangePrevDuplicate(tData[index + 1]);
		  }
		  markDuplicates(tData, tStylingKey, index, true);
		  markDuplicates(tData, tStylingKey, index, false);
		  markDuplicateOfResidualStyling(tNode, tStylingKey, tData, index, isClassBinding);
		  tBindings = toTStylingRange(tmplHead, tmplTail);
		  if (isClassBinding) {
			 tNode.classBindings = tBindings;
		  } else {
			 tNode.styleBindings = tBindings;
		  }
		}
		function markDuplicateOfResidualStyling(tNode, tStylingKey, tData, index, isClassBinding) {
		  const residual = isClassBinding ? tNode.residualClasses : tNode.residualStyles;
		  if (residual != null && typeof tStylingKey == "string" && keyValueArrayIndexOf(residual, tStylingKey) >= 0) {
			 tData[index + 1] = setTStylingRangeNextDuplicate(tData[index + 1]);
		  }
		}
		function markDuplicates(tData, tStylingKey, index, isPrevDir) {
		  const tStylingAtIndex = tData[index + 1];
		  const isMap = tStylingKey === null;
		  let cursor = isPrevDir ? getTStylingRangePrev(tStylingAtIndex) : getTStylingRangeNext(tStylingAtIndex);
		  let foundDuplicate = false;
		  while (cursor !== 0 && (foundDuplicate === false || isMap)) {
			 ngDevMode && assertIndexInRange(tData, cursor);
			 const tStylingValueAtCursor = tData[cursor];
			 const tStyleRangeAtCursor = tData[cursor + 1];
			 if (isStylingMatch(tStylingValueAtCursor, tStylingKey)) {
				foundDuplicate = true;
				tData[cursor + 1] = isPrevDir ? setTStylingRangeNextDuplicate(tStyleRangeAtCursor) : setTStylingRangePrevDuplicate(tStyleRangeAtCursor);
			 }
			 cursor = isPrevDir ? getTStylingRangePrev(tStyleRangeAtCursor) : getTStylingRangeNext(tStyleRangeAtCursor);
		  }
		  if (foundDuplicate) {
			 tData[index + 1] = isPrevDir ? setTStylingRangePrevDuplicate(tStylingAtIndex) : setTStylingRangeNextDuplicate(tStylingAtIndex);
		  }
		}
		function isStylingMatch(tStylingKeyCursor, tStylingKey) {
		  ngDevMode && assertNotEqual(Array.isArray(tStylingKey), true, "Expected that 'tStylingKey' has been unwrapped");
		  if (tStylingKeyCursor === null || // If the cursor is `null` it means that we have map at that
		  // location so we must assume that we have a match.
		  tStylingKey == null || // If `tStylingKey` is `null` then it is a map therefor assume that it
		  // contains a match.
		  (Array.isArray(tStylingKeyCursor) ? tStylingKeyCursor[1] : tStylingKeyCursor) === tStylingKey) {
			 return true;
		  } else if (Array.isArray(tStylingKeyCursor) && typeof tStylingKey === "string") {
			 return keyValueArrayIndexOf(tStylingKeyCursor, tStylingKey) >= 0;
		  }
		  return false;
		}
		var parserState = {
		  textEnd: 0,
		  key: 0,
		  keyEnd: 0,
		  value: 0,
		  valueEnd: 0
		};
		function getLastParsedKey(text) {
		  return text.substring(parserState.key, parserState.keyEnd);
		}
		function getLastParsedValue(text) {
		  return text.substring(parserState.value, parserState.valueEnd);
		}
		function parseClassName(text) {
		  resetParserState(text);
		  return parseClassNameNext(text, consumeWhitespace(text, 0, parserState.textEnd));
		}
		function parseClassNameNext(text, index) {
		  const end = parserState.textEnd;
		  if (end === index) {
			 return -1;
		  }
		  index = parserState.keyEnd = consumeClassToken(text, parserState.key = index, end);
		  return consumeWhitespace(text, index, end);
		}
		function parseStyle(text) {
		  resetParserState(text);
		  return parseStyleNext(text, consumeWhitespace(text, 0, parserState.textEnd));
		}
		function parseStyleNext(text, startIndex) {
		  const end = parserState.textEnd;
		  let index = parserState.key = consumeWhitespace(text, startIndex, end);
		  if (end === index) {
			 return -1;
		  }
		  index = parserState.keyEnd = consumeStyleKey(text, index, end);
		  index = consumeSeparator(
			 text,
			 index,
			 end,
			 58
			 /* CharCode.COLON */
		  );
		  index = parserState.value = consumeWhitespace(text, index, end);
		  index = parserState.valueEnd = consumeStyleValue(text, index, end);
		  return consumeSeparator(
			 text,
			 index,
			 end,
			 59
			 /* CharCode.SEMI_COLON */
		  );
		}
		function resetParserState(text) {
		  parserState.key = 0;
		  parserState.keyEnd = 0;
		  parserState.value = 0;
		  parserState.valueEnd = 0;
		  parserState.textEnd = text.length;
		}
		function consumeWhitespace(text, startIndex, endIndex) {
		  while (startIndex < endIndex && text.charCodeAt(startIndex) <= 32) {
			 startIndex++;
		  }
		  return startIndex;
		}
		function consumeClassToken(text, startIndex, endIndex) {
		  while (startIndex < endIndex && text.charCodeAt(startIndex) > 32) {
			 startIndex++;
		  }
		  return startIndex;
		}
		function consumeStyleKey(text, startIndex, endIndex) {
		  let ch;
		  while (startIndex < endIndex && ((ch = text.charCodeAt(startIndex)) === 45 || ch === 95 || (ch & -33) >= 65 && (ch & -33) <= 90 || ch >= 48 && ch <= 57)) {
			 startIndex++;
		  }
		  return startIndex;
		}
		function consumeSeparator(text, startIndex, endIndex, separator) {
		  startIndex = consumeWhitespace(text, startIndex, endIndex);
		  if (startIndex < endIndex) {
			 if (ngDevMode && text.charCodeAt(startIndex) !== separator) {
				malformedStyleError(text, String.fromCharCode(separator), startIndex);
			 }
			 startIndex++;
		  }
		  return startIndex;
		}
		function consumeStyleValue(text, startIndex, endIndex) {
		  let ch1 = -1;
		  let ch2 = -1;
		  let ch3 = -1;
		  let i = startIndex;
		  let lastChIndex = i;
		  while (i < endIndex) {
			 const ch = text.charCodeAt(i++);
			 if (ch === 59) {
				return lastChIndex;
			 } else if (ch === 34 || ch === 39) {
				lastChIndex = i = consumeQuotedText(text, ch, i, endIndex);
			 } else if (startIndex === i - 4 && // We have seen only 4 characters so far "URL(" (Ignore "foo_URL()")
			 ch3 === 85 && ch2 === 82 && ch1 === 76 && ch === 40) {
				lastChIndex = i = consumeQuotedText(text, 41, i, endIndex);
			 } else if (ch > 32) {
				lastChIndex = i;
			 }
			 ch3 = ch2;
			 ch2 = ch1;
			 ch1 = ch & -33;
		  }
		  return lastChIndex;
		}
		function consumeQuotedText(text, quoteCharCode, startIndex, endIndex) {
		  let ch1 = -1;
		  let index = startIndex;
		  while (index < endIndex) {
			 const ch = text.charCodeAt(index++);
			 if (ch == quoteCharCode && ch1 !== 92) {
				return index;
			 }
			 if (ch == 92 && ch1 === 92) {
				ch1 = 0;
			 } else {
				ch1 = ch;
			 }
		  }
		  throw ngDevMode ? malformedStyleError(text, String.fromCharCode(quoteCharCode), endIndex) : new Error();
		}
		function malformedStyleError(text, expecting, index) {
		  ngDevMode && assertEqual(typeof text === "string", true, "String expected here");
		  throw throwError(`Malformed style at location ${index} in string '` + text.substring(0, index) + "[>>" + text.substring(index, index + 1) + "<<]" + text.slice(index + 1) + `'. Expecting '${expecting}'.`);
		}
		function \u0275\u0275property(propName, value, sanitizer) {
		  const lView = getLView();
		  const bindingIndex = nextBindingIndex();
		  if (bindingUpdated(lView, bindingIndex, value)) {
			 const tView = getTView();
			 const tNode = getSelectedTNode();
			 elementPropertyInternal(tView, tNode, lView, propName, value, lView[RENDERER], sanitizer, false);
			 ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);
		  }
		  return \u0275\u0275property;
		}
		function setDirectiveInputsWhichShadowsStyling(tView, tNode, lView, value, isClassBased) {
		  const inputs = tNode.inputs;
		  const property = isClassBased ? "class" : "style";
		  setInputsForProperty(tView, lView, inputs[property], property, value);
		}
		function \u0275\u0275styleProp(prop, value, suffix) {
		  checkStylingProperty(prop, value, suffix, false);
		  return \u0275\u0275styleProp;
		}
		function \u0275\u0275classProp(className, value) {
		  checkStylingProperty(className, value, null, true);
		  return \u0275\u0275classProp;
		}
		function \u0275\u0275styleMap(styles) {
		  checkStylingMap(styleKeyValueArraySet, styleStringParser, styles, false);
		}
		function styleStringParser(keyValueArray, text) {
		  for (let i = parseStyle(text); i >= 0; i = parseStyleNext(text, i)) {
			 styleKeyValueArraySet(keyValueArray, getLastParsedKey(text), getLastParsedValue(text));
		  }
		}
		function \u0275\u0275classMap(classes) {
		  checkStylingMap(classKeyValueArraySet, classStringParser, classes, true);
		}
		function classStringParser(keyValueArray, text) {
		  for (let i = parseClassName(text); i >= 0; i = parseClassNameNext(text, i)) {
			 keyValueArraySet(keyValueArray, getLastParsedKey(text), true);
		  }
		}
		function checkStylingProperty(prop, value, suffix, isClassBased) {
		  const lView = getLView();
		  const tView = getTView();
		  const bindingIndex = incrementBindingIndex(2);
		  if (tView.firstUpdatePass) {
			 stylingFirstUpdatePass(tView, prop, bindingIndex, isClassBased);
		  }
		  if (value !== NO_CHANGE && bindingUpdated(lView, bindingIndex, value)) {
			 const tNode = tView.data[getSelectedIndex()];
			 updateStyling(tView, tNode, lView, lView[RENDERER], prop, lView[bindingIndex + 1] = normalizeSuffix(value, suffix), isClassBased, bindingIndex);
		  }
		}
		function checkStylingMap(keyValueArraySet2, stringParser, value, isClassBased) {
		  const tView = getTView();
		  const bindingIndex = incrementBindingIndex(2);
		  if (tView.firstUpdatePass) {
			 stylingFirstUpdatePass(tView, null, bindingIndex, isClassBased);
		  }
		  const lView = getLView();
		  if (value !== NO_CHANGE && bindingUpdated(lView, bindingIndex, value)) {
			 const tNode = tView.data[getSelectedIndex()];
			 if (hasStylingInputShadow(tNode, isClassBased) && !isInHostBindings(tView, bindingIndex)) {
				if (ngDevMode) {
				  const tStylingKey = tView.data[bindingIndex];
				  assertEqual(Array.isArray(tStylingKey) ? tStylingKey[1] : tStylingKey, false, "Styling linked list shadow input should be marked as 'false'");
				}
				let staticPrefix = isClassBased ? tNode.classesWithoutHost : tNode.stylesWithoutHost;
				ngDevMode && isClassBased === false && staticPrefix !== null && assertEqual(staticPrefix.endsWith(";"), true, "Expecting static portion to end with ';'");
				if (staticPrefix !== null) {
				  value = concatStringsWithSpace(staticPrefix, value ? value : "");
				}
				setDirectiveInputsWhichShadowsStyling(tView, tNode, lView, value, isClassBased);
			 } else {
				updateStylingMap(tView, tNode, lView, lView[RENDERER], lView[bindingIndex + 1], lView[bindingIndex + 1] = toStylingKeyValueArray(keyValueArraySet2, stringParser, value), isClassBased, bindingIndex);
			 }
		  }
		}
		function isInHostBindings(tView, bindingIndex) {
		  return bindingIndex >= tView.expandoStartIndex;
		}
		function stylingFirstUpdatePass(tView, tStylingKey, bindingIndex, isClassBased) {
		  ngDevMode && assertFirstUpdatePass(tView);
		  const tData = tView.data;
		  if (tData[bindingIndex + 1] === null) {
			 const tNode = tData[getSelectedIndex()];
			 ngDevMode && assertDefined(tNode, "TNode expected");
			 const isHostBindings = isInHostBindings(tView, bindingIndex);
			 if (hasStylingInputShadow(tNode, isClassBased) && tStylingKey === null && !isHostBindings) {
				tStylingKey = false;
			 }
			 tStylingKey = wrapInStaticStylingKey(tData, tNode, tStylingKey, isClassBased);
			 insertTStylingBinding(tData, tNode, tStylingKey, bindingIndex, isHostBindings, isClassBased);
		  }
		}
		function wrapInStaticStylingKey(tData, tNode, stylingKey, isClassBased) {
		  const hostDirectiveDef = getCurrentDirectiveDef(tData);
		  let residual = isClassBased ? tNode.residualClasses : tNode.residualStyles;
		  if (hostDirectiveDef === null) {
			 const isFirstStylingInstructionInTemplate = (isClassBased ? tNode.classBindings : tNode.styleBindings) === 0;
			 if (isFirstStylingInstructionInTemplate) {
				stylingKey = collectStylingFromDirectives(null, tData, tNode, stylingKey, isClassBased);
				stylingKey = collectStylingFromTAttrs(stylingKey, tNode.attrs, isClassBased);
				residual = null;
			 }
		  } else {
			 const directiveStylingLast = tNode.directiveStylingLast;
			 const isFirstStylingInstructionInHostBinding = directiveStylingLast === -1 || tData[directiveStylingLast] !== hostDirectiveDef;
			 if (isFirstStylingInstructionInHostBinding) {
				stylingKey = collectStylingFromDirectives(hostDirectiveDef, tData, tNode, stylingKey, isClassBased);
				if (residual === null) {
				  let templateStylingKey = getTemplateHeadTStylingKey(tData, tNode, isClassBased);
				  if (templateStylingKey !== void 0 && Array.isArray(templateStylingKey)) {
					 templateStylingKey = collectStylingFromDirectives(null, tData, tNode, templateStylingKey[1], isClassBased);
					 templateStylingKey = collectStylingFromTAttrs(templateStylingKey, tNode.attrs, isClassBased);
					 setTemplateHeadTStylingKey(tData, tNode, isClassBased, templateStylingKey);
				  }
				} else {
				  residual = collectResidual(tData, tNode, isClassBased);
				}
			 }
		  }
		  if (residual !== void 0) {
			 isClassBased ? tNode.residualClasses = residual : tNode.residualStyles = residual;
		  }
		  return stylingKey;
		}
		function getTemplateHeadTStylingKey(tData, tNode, isClassBased) {
		  const bindings = isClassBased ? tNode.classBindings : tNode.styleBindings;
		  if (getTStylingRangeNext(bindings) === 0) {
			 return void 0;
		  }
		  return tData[getTStylingRangePrev(bindings)];
		}
		function setTemplateHeadTStylingKey(tData, tNode, isClassBased, tStylingKey) {
		  const bindings = isClassBased ? tNode.classBindings : tNode.styleBindings;
		  ngDevMode && assertNotEqual(getTStylingRangeNext(bindings), 0, "Expecting to have at least one template styling binding.");
		  tData[getTStylingRangePrev(bindings)] = tStylingKey;
		}
		function collectResidual(tData, tNode, isClassBased) {
		  let residual = void 0;
		  const directiveEnd = tNode.directiveEnd;
		  ngDevMode && assertNotEqual(tNode.directiveStylingLast, -1, "By the time this function gets called at least one hostBindings-node styling instruction must have executed.");
		  for (let i = 1 + tNode.directiveStylingLast; i < directiveEnd; i++) {
			 const attrs = tData[i].hostAttrs;
			 residual = collectStylingFromTAttrs(residual, attrs, isClassBased);
		  }
		  return collectStylingFromTAttrs(residual, tNode.attrs, isClassBased);
		}
		function collectStylingFromDirectives(hostDirectiveDef, tData, tNode, stylingKey, isClassBased) {
		  let currentDirective = null;
		  const directiveEnd = tNode.directiveEnd;
		  let directiveStylingLast = tNode.directiveStylingLast;
		  if (directiveStylingLast === -1) {
			 directiveStylingLast = tNode.directiveStart;
		  } else {
			 directiveStylingLast++;
		  }
		  while (directiveStylingLast < directiveEnd) {
			 currentDirective = tData[directiveStylingLast];
			 ngDevMode && assertDefined(currentDirective, "expected to be defined");
			 stylingKey = collectStylingFromTAttrs(stylingKey, currentDirective.hostAttrs, isClassBased);
			 if (currentDirective === hostDirectiveDef)
				break;
			 directiveStylingLast++;
		  }
		  if (hostDirectiveDef !== null) {
			 tNode.directiveStylingLast = directiveStylingLast;
		  }
		  return stylingKey;
		}
		function collectStylingFromTAttrs(stylingKey, attrs, isClassBased) {
		  const desiredMarker = isClassBased ? 1 : 2;
		  let currentMarker = -1;
		  if (attrs !== null) {
			 for (let i = 0; i < attrs.length; i++) {
				const item = attrs[i];
				if (typeof item === "number") {
				  currentMarker = item;
				} else {
				  if (currentMarker === desiredMarker) {
					 if (!Array.isArray(stylingKey)) {
						stylingKey = stylingKey === void 0 ? [] : ["", stylingKey];
					 }
					 keyValueArraySet(stylingKey, item, isClassBased ? true : attrs[++i]);
				  }
				}
			 }
		  }
		  return stylingKey === void 0 ? null : stylingKey;
		}
		function toStylingKeyValueArray(keyValueArraySet2, stringParser, value) {
		  if (value == null || value === "")
			 return EMPTY_ARRAY;
		  const styleKeyValueArray = [];
		  const unwrappedValue = unwrapSafeValue(value);
		  if (Array.isArray(unwrappedValue)) {
			 for (let i = 0; i < unwrappedValue.length; i++) {
				keyValueArraySet2(styleKeyValueArray, unwrappedValue[i], true);
			 }
		  } else if (typeof unwrappedValue === "object") {
			 for (const key in unwrappedValue) {
				if (unwrappedValue.hasOwnProperty(key)) {
				  keyValueArraySet2(styleKeyValueArray, key, unwrappedValue[key]);
				}
			 }
		  } else if (typeof unwrappedValue === "string") {
			 stringParser(styleKeyValueArray, unwrappedValue);
		  } else {
			 ngDevMode && throwError("Unsupported styling type " + typeof unwrappedValue + ": " + unwrappedValue);
		  }
		  return styleKeyValueArray;
		}
		function styleKeyValueArraySet(keyValueArray, key, value) {
		  keyValueArraySet(keyValueArray, key, unwrapSafeValue(value));
		}
		function classKeyValueArraySet(keyValueArray, key, value) {
		  const stringKey = String(key);
		  if (stringKey !== "" && !stringKey.includes(" ")) {
			 keyValueArraySet(keyValueArray, stringKey, value);
		  }
		}
		function updateStylingMap(tView, tNode, lView, renderer, oldKeyValueArray, newKeyValueArray, isClassBased, bindingIndex) {
		  if (oldKeyValueArray === NO_CHANGE) {
			 oldKeyValueArray = EMPTY_ARRAY;
		  }
		  let oldIndex = 0;
		  let newIndex = 0;
		  let oldKey = 0 < oldKeyValueArray.length ? oldKeyValueArray[0] : null;
		  let newKey = 0 < newKeyValueArray.length ? newKeyValueArray[0] : null;
		  while (oldKey !== null || newKey !== null) {
			 ngDevMode && assertLessThan(oldIndex, 999, "Are we stuck in infinite loop?");
			 ngDevMode && assertLessThan(newIndex, 999, "Are we stuck in infinite loop?");
			 const oldValue = oldIndex < oldKeyValueArray.length ? oldKeyValueArray[oldIndex + 1] : void 0;
			 const newValue = newIndex < newKeyValueArray.length ? newKeyValueArray[newIndex + 1] : void 0;
			 let setKey = null;
			 let setValue = void 0;
			 if (oldKey === newKey) {
				oldIndex += 2;
				newIndex += 2;
				if (oldValue !== newValue) {
				  setKey = newKey;
				  setValue = newValue;
				}
			 } else if (newKey === null || oldKey !== null && oldKey < newKey) {
				oldIndex += 2;
				setKey = oldKey;
			 } else {
				ngDevMode && assertDefined(newKey, "Expecting to have a valid key");
				newIndex += 2;
				setKey = newKey;
				setValue = newValue;
			 }
			 if (setKey !== null) {
				updateStyling(tView, tNode, lView, renderer, setKey, setValue, isClassBased, bindingIndex);
			 }
			 oldKey = oldIndex < oldKeyValueArray.length ? oldKeyValueArray[oldIndex] : null;
			 newKey = newIndex < newKeyValueArray.length ? newKeyValueArray[newIndex] : null;
		  }
		}
		function updateStyling(tView, tNode, lView, renderer, prop, value, isClassBased, bindingIndex) {
		  if (!(tNode.type & 3)) {
			 return;
		  }
		  const tData = tView.data;
		  const tRange = tData[bindingIndex + 1];
		  const higherPriorityValue = getTStylingRangeNextDuplicate(tRange) ? findStylingValue(tData, tNode, lView, prop, getTStylingRangeNext(tRange), isClassBased) : void 0;
		  if (!isStylingValuePresent(higherPriorityValue)) {
			 if (!isStylingValuePresent(value)) {
				if (getTStylingRangePrevDuplicate(tRange)) {
				  value = findStylingValue(tData, null, lView, prop, bindingIndex, isClassBased);
				}
			 }
			 const rNode = getNativeByIndex(getSelectedIndex(), lView);
			 applyStyling(renderer, isClassBased, rNode, prop, value);
		  }
		}
		function findStylingValue(tData, tNode, lView, prop, index, isClassBased) {
		  const isPrevDirection = tNode === null;
		  let value = void 0;
		  while (index > 0) {
			 const rawKey = tData[index];
			 const containsStatics = Array.isArray(rawKey);
			 const key = containsStatics ? rawKey[1] : rawKey;
			 const isStylingMap = key === null;
			 let valueAtLViewIndex = lView[index + 1];
			 if (valueAtLViewIndex === NO_CHANGE) {
				valueAtLViewIndex = isStylingMap ? EMPTY_ARRAY : void 0;
			 }
			 let currentValue = isStylingMap ? keyValueArrayGet(valueAtLViewIndex, prop) : key === prop ? valueAtLViewIndex : void 0;
			 if (containsStatics && !isStylingValuePresent(currentValue)) {
				currentValue = keyValueArrayGet(rawKey, prop);
			 }
			 if (isStylingValuePresent(currentValue)) {
				value = currentValue;
				if (isPrevDirection) {
				  return value;
				}
			 }
			 const tRange = tData[index + 1];
			 index = isPrevDirection ? getTStylingRangePrev(tRange) : getTStylingRangeNext(tRange);
		  }
		  if (tNode !== null) {
			 let residual = isClassBased ? tNode.residualClasses : tNode.residualStyles;
			 if (residual != null) {
				value = keyValueArrayGet(residual, prop);
			 }
		  }
		  return value;
		}
		function isStylingValuePresent(value) {
		  return value !== void 0;
		}
		function normalizeSuffix(value, suffix) {
		  if (value == null || value === "") {
		  } else if (typeof suffix === "string") {
			 value = value + suffix;
		  } else if (typeof value === "object") {
			 value = stringify(unwrapSafeValue(value));
		  }
		  return value;
		}
		function hasStylingInputShadow(tNode, isClassBased) {
		  return (tNode.flags & (isClassBased ? 8 : 16)) !== 0;
		}
		function \u0275\u0275classMapInterpolate1(prefix, v0, suffix) {
		  const lView = getLView();
		  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);
		  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
		}
		function \u0275\u0275classMapInterpolate2(prefix, v0, i0, v1, suffix) {
		  const lView = getLView();
		  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);
		  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
		}
		function \u0275\u0275classMapInterpolate3(prefix, v0, i0, v1, i1, v2, suffix) {
		  const lView = getLView();
		  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);
		  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
		}
		function \u0275\u0275classMapInterpolate4(prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {
		  const lView = getLView();
		  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
		  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
		}
		function \u0275\u0275classMapInterpolate5(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {
		  const lView = getLView();
		  const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
		  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
		}
		function \u0275\u0275classMapInterpolate6(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {
		  const lView = getLView();
		  const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
		  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
		}
		function \u0275\u0275classMapInterpolate7(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {
		  const lView = getLView();
		  const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
		  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
		}
		function \u0275\u0275classMapInterpolate8(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {
		  const lView = getLView();
		  const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
		  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
		}
		function \u0275\u0275classMapInterpolateV(values) {
		  const lView = getLView();
		  const interpolatedValue = interpolationV(lView, values);
		  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
		}
		function \u0275\u0275componentInstance() {
		  const instance = getLView()[DECLARATION_COMPONENT_VIEW][CONTEXT];
		  ngDevMode && assertDefined(instance, "Expected component instance to be defined");
		  return instance;
		}
		var LiveCollection = class {
		  destroy(item) {
		  }
		  updateValue(index, value) {
		  }
		  // operations below could be implemented on top of the operations defined so far, but having
		  // them explicitly allow clear expression of intent and potentially more performant
		  // implementations
		  swap(index1, index2) {
			 const startIdx = Math.min(index1, index2);
			 const endIdx = Math.max(index1, index2);
			 const endItem = this.detach(endIdx);
			 if (endIdx - startIdx > 1) {
				const startItem = this.detach(startIdx);
				this.attach(startIdx, endItem);
				this.attach(endIdx, startItem);
			 } else {
				this.attach(startIdx, endItem);
			 }
		  }
		  move(prevIndex, newIdx) {
			 this.attach(newIdx, this.detach(prevIndex));
		  }
		};
		function valuesMatching(liveIdx, liveValue, newIdx, newValue, trackBy) {
		  if (liveIdx === newIdx && Object.is(liveValue, newValue)) {
			 return 1;
		  } else if (Object.is(trackBy(liveIdx, liveValue), trackBy(newIdx, newValue))) {
			 return -1;
		  }
		  return 0;
		}
		function reconcile(liveCollection, newCollection, trackByFn) {
		  let detachedItems = void 0;
		  let liveKeysInTheFuture = void 0;
		  let liveStartIdx = 0;
		  let liveEndIdx = liveCollection.length - 1;
		  if (Array.isArray(newCollection)) {
			 let newEndIdx = newCollection.length - 1;
			 while (liveStartIdx <= liveEndIdx && liveStartIdx <= newEndIdx) {
				const liveStartValue = liveCollection.at(liveStartIdx);
				const newStartValue = newCollection[liveStartIdx];
				const isStartMatching = valuesMatching(liveStartIdx, liveStartValue, liveStartIdx, newStartValue, trackByFn);
				if (isStartMatching !== 0) {
				  if (isStartMatching < 0) {
					 liveCollection.updateValue(liveStartIdx, newStartValue);
				  }
				  liveStartIdx++;
				  continue;
				}
				const liveEndValue = liveCollection.at(liveEndIdx);
				const newEndValue = newCollection[newEndIdx];
				const isEndMatching = valuesMatching(liveEndIdx, liveEndValue, newEndIdx, newEndValue, trackByFn);
				if (isEndMatching !== 0) {
				  if (isEndMatching < 0) {
					 liveCollection.updateValue(liveEndIdx, newEndValue);
				  }
				  liveEndIdx--;
				  newEndIdx--;
				  continue;
				}
				const liveStartKey = trackByFn(liveStartIdx, liveStartValue);
				const liveEndKey = trackByFn(liveEndIdx, liveEndValue);
				const newStartKey = trackByFn(liveStartIdx, newStartValue);
				if (Object.is(newStartKey, liveEndKey)) {
				  const newEndKey = trackByFn(newEndIdx, newEndValue);
				  if (Object.is(newEndKey, liveStartKey)) {
					 liveCollection.swap(liveStartIdx, liveEndIdx);
					 liveCollection.updateValue(liveEndIdx, newEndValue);
					 newEndIdx--;
					 liveEndIdx--;
				  } else {
					 liveCollection.move(liveEndIdx, liveStartIdx);
				  }
				  liveCollection.updateValue(liveStartIdx, newStartValue);
				  liveStartIdx++;
				  continue;
				}
				detachedItems ??= new UniqueValueMultiKeyMap();
				liveKeysInTheFuture ??= initLiveItemsInTheFuture(liveCollection, liveStartIdx, liveEndIdx, trackByFn);
				if (attachPreviouslyDetached(liveCollection, detachedItems, liveStartIdx, newStartKey)) {
				  liveCollection.updateValue(liveStartIdx, newStartValue);
				  liveStartIdx++;
				  liveEndIdx++;
				} else if (!liveKeysInTheFuture.has(newStartKey)) {
				  const newItem = liveCollection.create(liveStartIdx, newCollection[liveStartIdx]);
				  liveCollection.attach(liveStartIdx, newItem);
				  liveStartIdx++;
				  liveEndIdx++;
				} else {
				  detachedItems.set(liveStartKey, liveCollection.detach(liveStartIdx));
				  liveEndIdx--;
				}
			 }
			 while (liveStartIdx <= newEndIdx) {
				createOrAttach(liveCollection, detachedItems, trackByFn, liveStartIdx, newCollection[liveStartIdx]);
				liveStartIdx++;
			 }
		  } else if (newCollection != null) {
			 const newCollectionIterator = newCollection[Symbol.iterator]();
			 let newIterationResult = newCollectionIterator.next();
			 while (!newIterationResult.done && liveStartIdx <= liveEndIdx) {
				const liveValue = liveCollection.at(liveStartIdx);
				const newValue = newIterationResult.value;
				const isStartMatching = valuesMatching(liveStartIdx, liveValue, liveStartIdx, newValue, trackByFn);
				if (isStartMatching !== 0) {
				  if (isStartMatching < 0) {
					 liveCollection.updateValue(liveStartIdx, newValue);
				  }
				  liveStartIdx++;
				  newIterationResult = newCollectionIterator.next();
				} else {
				  detachedItems ??= new UniqueValueMultiKeyMap();
				  liveKeysInTheFuture ??= initLiveItemsInTheFuture(liveCollection, liveStartIdx, liveEndIdx, trackByFn);
				  const newKey = trackByFn(liveStartIdx, newValue);
				  if (attachPreviouslyDetached(liveCollection, detachedItems, liveStartIdx, newKey)) {
					 liveCollection.updateValue(liveStartIdx, newValue);
					 liveStartIdx++;
					 liveEndIdx++;
					 newIterationResult = newCollectionIterator.next();
				  } else if (!liveKeysInTheFuture.has(newKey)) {
					 liveCollection.attach(liveStartIdx, liveCollection.create(liveStartIdx, newValue));
					 liveStartIdx++;
					 liveEndIdx++;
					 newIterationResult = newCollectionIterator.next();
				  } else {
					 const liveKey = trackByFn(liveStartIdx, liveValue);
					 detachedItems.set(liveKey, liveCollection.detach(liveStartIdx));
					 liveEndIdx--;
				  }
				}
			 }
			 while (!newIterationResult.done) {
				createOrAttach(liveCollection, detachedItems, trackByFn, liveCollection.length, newIterationResult.value);
				newIterationResult = newCollectionIterator.next();
			 }
		  }
		  while (liveStartIdx <= liveEndIdx) {
			 liveCollection.destroy(liveCollection.detach(liveEndIdx--));
		  }
		  detachedItems?.forEach((item) => {
			 liveCollection.destroy(item);
		  });
		}
		function attachPreviouslyDetached(prevCollection, detachedItems, index, key) {
		  if (detachedItems !== void 0 && detachedItems.has(key)) {
			 prevCollection.attach(index, detachedItems.get(key));
			 detachedItems.delete(key);
			 return true;
		  }
		  return false;
		}
		function createOrAttach(liveCollection, detachedItems, trackByFn, index, value) {
		  if (!attachPreviouslyDetached(liveCollection, detachedItems, index, trackByFn(index, value))) {
			 const newItem = liveCollection.create(index, value);
			 liveCollection.attach(index, newItem);
		  } else {
			 liveCollection.updateValue(index, value);
		  }
		}
		function initLiveItemsInTheFuture(liveCollection, start2, end, trackByFn) {
		  const keys = /* @__PURE__ */ new Set();
		  for (let i = start2; i <= end; i++) {
			 keys.add(trackByFn(i, liveCollection.at(i)));
		  }
		  return keys;
		}
		var UniqueValueMultiKeyMap = class {
		  constructor() {
			 this.kvMap = /* @__PURE__ */ new Map();
			 this._vMap = void 0;
		  }
		  has(key) {
			 return this.kvMap.has(key);
		  }
		  delete(key) {
			 if (!this.has(key))
				return false;
			 const value = this.kvMap.get(key);
			 if (this._vMap !== void 0 && this._vMap.has(value)) {
				this.kvMap.set(key, this._vMap.get(value));
				this._vMap.delete(value);
			 } else {
				this.kvMap.delete(key);
			 }
			 return true;
		  }
		  get(key) {
			 return this.kvMap.get(key);
		  }
		  set(key, value) {
			 if (this.kvMap.has(key)) {
				let prevValue = this.kvMap.get(key);
				ngDevMode && assertNotSame(prevValue, value, `Detected a duplicated value ${value} for the key ${key}`);
				if (this._vMap === void 0) {
				  this._vMap = /* @__PURE__ */ new Map();
				}
				const vMap = this._vMap;
				while (vMap.has(prevValue)) {
				  prevValue = vMap.get(prevValue);
				}
				vMap.set(prevValue, value);
			 } else {
				this.kvMap.set(key, value);
			 }
		  }
		  forEach(cb) {
			 for (let [key, value] of this.kvMap) {
				cb(value, key);
				if (this._vMap !== void 0) {
				  const vMap = this._vMap;
				  while (vMap.has(value)) {
					 value = vMap.get(value);
					 cb(value, key);
				  }
				}
			 }
		  }
		};
		function \u0275\u0275conditional(containerIndex, matchingTemplateIndex, value) {
		  performanceMarkFeature("NgControlFlow");
		  const hostLView = getLView();
		  const bindingIndex = nextBindingIndex();
		  const lContainer = getLContainer(hostLView, HEADER_OFFSET + containerIndex);
		  const viewInContainerIdx = 0;
		  if (bindingUpdated(hostLView, bindingIndex, matchingTemplateIndex)) {
			 const prevConsumer = setActiveConsumer(null);
			 try {
				removeLViewFromLContainer(lContainer, viewInContainerIdx);
				if (matchingTemplateIndex !== -1) {
				  const templateTNode = getExistingTNode(hostLView[TVIEW], HEADER_OFFSET + matchingTemplateIndex);
				  const dehydratedView = findMatchingDehydratedView(lContainer, templateTNode.tView.ssrId);
				  const embeddedLView = createAndRenderEmbeddedLView(hostLView, templateTNode, value, { dehydratedView });
				  addLViewToLContainer(lContainer, embeddedLView, viewInContainerIdx, shouldAddViewToDom(templateTNode, dehydratedView));
				}
			 } finally {
				setActiveConsumer(prevConsumer);
			 }
		  } else {
			 const lView = getLViewFromLContainer(lContainer, viewInContainerIdx);
			 if (lView !== void 0) {
				lView[CONTEXT] = value;
			 }
		  }
		}
		var RepeaterContext = class {
		  constructor(lContainer, $implicit, $index) {
			 this.lContainer = lContainer;
			 this.$implicit = $implicit;
			 this.$index = $index;
		  }
		  get $count() {
			 return this.lContainer.length - CONTAINER_HEADER_OFFSET;
		  }
		};
		function \u0275\u0275repeaterTrackByIndex(index) {
		  return index;
		}
		function \u0275\u0275repeaterTrackByIdentity(_2, value) {
		  return value;
		}
		var RepeaterMetadata = class {
		  constructor(hasEmptyBlock, trackByFn, liveCollection) {
			 this.hasEmptyBlock = hasEmptyBlock;
			 this.trackByFn = trackByFn;
			 this.liveCollection = liveCollection;
		  }
		};
		function \u0275\u0275repeaterCreate(index, templateFn, decls, vars, tagName, attrsIndex, trackByFn, trackByUsesComponentInstance, emptyTemplateFn, emptyDecls, emptyVars, emptyTagName, emptyAttrsIndex) {
		  performanceMarkFeature("NgControlFlow");
		  ngDevMode && assertFunction(trackByFn, `A track expression must be a function, was ${typeof trackByFn} instead.`);
		  const hasEmptyBlock = emptyTemplateFn !== void 0;
		  const hostLView = getLView();
		  const boundTrackBy = trackByUsesComponentInstance ? (
			 // We only want to bind when necessary, because it produces a
			 // new function. For pure functions it's not necessary.
			 trackByFn.bind(hostLView[DECLARATION_COMPONENT_VIEW][CONTEXT])
		  ) : trackByFn;
		  const metadata = new RepeaterMetadata(hasEmptyBlock, boundTrackBy);
		  hostLView[HEADER_OFFSET + index] = metadata;
		  \u0275\u0275template(index + 1, templateFn, decls, vars, tagName, attrsIndex);
		  if (hasEmptyBlock) {
			 ngDevMode && assertDefined(emptyDecls, "Missing number of declarations for the empty repeater block.");
			 ngDevMode && assertDefined(emptyVars, "Missing number of bindings for the empty repeater block.");
			 \u0275\u0275template(index + 2, emptyTemplateFn, emptyDecls, emptyVars, emptyTagName, emptyAttrsIndex);
		  }
		}
		var LiveCollectionLContainerImpl = class extends LiveCollection {
		  constructor(lContainer, hostLView, templateTNode) {
			 super();
			 this.lContainer = lContainer;
			 this.hostLView = hostLView;
			 this.templateTNode = templateTNode;
			 this.needsIndexUpdate = false;
		  }
		  get length() {
			 return this.lContainer.length - CONTAINER_HEADER_OFFSET;
		  }
		  at(index) {
			 return this.getLView(index)[CONTEXT].$implicit;
		  }
		  attach(index, lView) {
			 const dehydratedView = lView[HYDRATION];
			 this.needsIndexUpdate ||= index !== this.length;
			 addLViewToLContainer(this.lContainer, lView, index, shouldAddViewToDom(this.templateTNode, dehydratedView));
		  }
		  detach(index) {
			 this.needsIndexUpdate ||= index !== this.length - 1;
			 return detachExistingView(this.lContainer, index);
		  }
		  create(index, value) {
			 const dehydratedView = findMatchingDehydratedView(this.lContainer, this.templateTNode.tView.ssrId);
			 const embeddedLView = createAndRenderEmbeddedLView(this.hostLView, this.templateTNode, new RepeaterContext(this.lContainer, value, index), { dehydratedView });
			 return embeddedLView;
		  }
		  destroy(lView) {
			 destroyLView(lView[TVIEW], lView);
		  }
		  updateValue(index, value) {
			 this.getLView(index)[CONTEXT].$implicit = value;
		  }
		  reset() {
			 this.needsIndexUpdate = false;
		  }
		  updateIndexes() {
			 if (this.needsIndexUpdate) {
				for (let i = 0; i < this.length; i++) {
				  this.getLView(i)[CONTEXT].$index = i;
				}
			 }
		  }
		  getLView(index) {
			 return getExistingLViewFromLContainer(this.lContainer, index);
		  }
		};
		function \u0275\u0275repeater(collection) {
		  const prevConsumer = setActiveConsumer(null);
		  const metadataSlotIdx = getSelectedIndex();
		  try {
			 const hostLView = getLView();
			 const hostTView = hostLView[TVIEW];
			 const metadata = hostLView[metadataSlotIdx];
			 if (metadata.liveCollection === void 0) {
				const containerIndex = metadataSlotIdx + 1;
				const lContainer = getLContainer(hostLView, containerIndex);
				const itemTemplateTNode = getExistingTNode(hostTView, containerIndex);
				metadata.liveCollection = new LiveCollectionLContainerImpl(lContainer, hostLView, itemTemplateTNode);
			 } else {
				metadata.liveCollection.reset();
			 }
			 const liveCollection = metadata.liveCollection;
			 reconcile(liveCollection, collection, metadata.trackByFn);
			 liveCollection.updateIndexes();
			 if (metadata.hasEmptyBlock) {
				const bindingIndex = nextBindingIndex();
				const isCollectionEmpty = liveCollection.length === 0;
				if (bindingUpdated(hostLView, bindingIndex, isCollectionEmpty)) {
				  const emptyTemplateIndex = metadataSlotIdx + 2;
				  const lContainerForEmpty = getLContainer(hostLView, emptyTemplateIndex);
				  if (isCollectionEmpty) {
					 const emptyTemplateTNode = getExistingTNode(hostTView, emptyTemplateIndex);
					 const dehydratedView = findMatchingDehydratedView(lContainerForEmpty, emptyTemplateTNode.tView.ssrId);
					 const embeddedLView = createAndRenderEmbeddedLView(hostLView, emptyTemplateTNode, void 0, { dehydratedView });
					 addLViewToLContainer(lContainerForEmpty, embeddedLView, 0, shouldAddViewToDom(emptyTemplateTNode, dehydratedView));
				  } else {
					 removeLViewFromLContainer(lContainerForEmpty, 0);
				  }
				}
			 }
		  } finally {
			 setActiveConsumer(prevConsumer);
		  }
		}
		function getLContainer(lView, index) {
		  const lContainer = lView[index];
		  ngDevMode && assertLContainer(lContainer);
		  return lContainer;
		}
		function detachExistingView(lContainer, index) {
		  const existingLView = detachView(lContainer, index);
		  ngDevMode && assertLView(existingLView);
		  return existingLView;
		}
		function getExistingLViewFromLContainer(lContainer, index) {
		  const existingLView = getLViewFromLContainer(lContainer, index);
		  ngDevMode && assertLView(existingLView);
		  return existingLView;
		}
		function getExistingTNode(tView, index) {
		  const tNode = getTNode(tView, index);
		  ngDevMode && assertTNode(tNode);
		  return tNode;
		}
		function elementStartFirstCreatePass(index, tView, lView, name, attrsIndex, localRefsIndex) {
		  ngDevMode && assertFirstCreatePass(tView);
		  ngDevMode && ngDevMode.firstCreatePass++;
		  const tViewConsts = tView.consts;
		  const attrs = getConstant(tViewConsts, attrsIndex);
		  const tNode = getOrCreateTNode(tView, index, 2, name, attrs);
		  resolveDirectives(tView, lView, tNode, getConstant(tViewConsts, localRefsIndex));
		  if (tNode.attrs !== null) {
			 computeStaticStyling(tNode, tNode.attrs, false);
		  }
		  if (tNode.mergedAttrs !== null) {
			 computeStaticStyling(tNode, tNode.mergedAttrs, true);
		  }
		  if (tView.queries !== null) {
			 tView.queries.elementStart(tView, tNode);
		  }
		  return tNode;
		}
		function \u0275\u0275elementStart(index, name, attrsIndex, localRefsIndex) {
		  const lView = getLView();
		  const tView = getTView();
		  const adjustedIndex = HEADER_OFFSET + index;
		  ngDevMode && assertEqual(getBindingIndex(), tView.bindingStartIndex, "elements should be created before any bindings");
		  ngDevMode && assertIndexInRange(lView, adjustedIndex);
		  const renderer = lView[RENDERER];
		  const tNode = tView.firstCreatePass ? elementStartFirstCreatePass(adjustedIndex, tView, lView, name, attrsIndex, localRefsIndex) : tView.data[adjustedIndex];
		  const native = _locateOrCreateElementNode(tView, lView, tNode, renderer, name, index);
		  lView[adjustedIndex] = native;
		  const hasDirectives = isDirectiveHost(tNode);
		  if (ngDevMode && tView.firstCreatePass) {
			 validateElementIsKnown(native, lView, tNode.value, tView.schemas, hasDirectives);
		  }
		  setCurrentTNode(tNode, true);
		  setupStaticAttributes(renderer, native, tNode);
		  if (!isDetachedByI18n(tNode) && wasLastNodeCreated()) {
			 appendChild(tView, lView, native, tNode);
		  }
		  if (getElementDepthCount() === 0) {
			 attachPatchData(native, lView);
		  }
		  increaseElementDepthCount();
		  if (hasDirectives) {
			 createDirectivesInstances(tView, lView, tNode);
			 executeContentQueries(tView, tNode, lView);
		  }
		  if (localRefsIndex !== null) {
			 saveResolvedLocalsInData(lView, tNode);
		  }
		  return \u0275\u0275elementStart;
		}
		function \u0275\u0275elementEnd() {
		  let currentTNode = getCurrentTNode();
		  ngDevMode && assertDefined(currentTNode, "No parent node to close.");
		  if (isCurrentTNodeParent()) {
			 setCurrentTNodeAsNotParent();
		  } else {
			 ngDevMode && assertHasParent(getCurrentTNode());
			 currentTNode = currentTNode.parent;
			 setCurrentTNode(currentTNode, false);
		  }
		  const tNode = currentTNode;
		  ngDevMode && assertTNodeType(
			 tNode,
			 3
			 /* TNodeType.AnyRNode */
		  );
		  if (isSkipHydrationRootTNode(tNode)) {
			 leaveSkipHydrationBlock();
		  }
		  decreaseElementDepthCount();
		  const tView = getTView();
		  if (tView.firstCreatePass) {
			 registerPostOrderHooks(tView, currentTNode);
			 if (isContentQueryHost(currentTNode)) {
				tView.queries.elementEnd(currentTNode);
			 }
		  }
		  if (tNode.classesWithoutHost != null && hasClassInput(tNode)) {
			 setDirectiveInputsWhichShadowsStyling(tView, tNode, getLView(), tNode.classesWithoutHost, true);
		  }
		  if (tNode.stylesWithoutHost != null && hasStyleInput(tNode)) {
			 setDirectiveInputsWhichShadowsStyling(tView, tNode, getLView(), tNode.stylesWithoutHost, false);
		  }
		  return \u0275\u0275elementEnd;
		}
		function \u0275\u0275element(index, name, attrsIndex, localRefsIndex) {
		  \u0275\u0275elementStart(index, name, attrsIndex, localRefsIndex);
		  \u0275\u0275elementEnd();
		  return \u0275\u0275element;
		}
		var _locateOrCreateElementNode = (tView, lView, tNode, renderer, name, index) => {
		  lastNodeWasCreated(true);
		  return createElementNode(renderer, name, getNamespace$1());
		};
		function elementContainerStartFirstCreatePass(index, tView, lView, attrsIndex, localRefsIndex) {
		  ngDevMode && ngDevMode.firstCreatePass++;
		  const tViewConsts = tView.consts;
		  const attrs = getConstant(tViewConsts, attrsIndex);
		  const tNode = getOrCreateTNode(tView, index, 8, "ng-container", attrs);
		  if (attrs !== null) {
			 computeStaticStyling(tNode, attrs, true);
		  }
		  const localRefs = getConstant(tViewConsts, localRefsIndex);
		  resolveDirectives(tView, lView, tNode, localRefs);
		  if (tView.queries !== null) {
			 tView.queries.elementStart(tView, tNode);
		  }
		  return tNode;
		}
		function \u0275\u0275elementContainerStart(index, attrsIndex, localRefsIndex) {
		  const lView = getLView();
		  const tView = getTView();
		  const adjustedIndex = index + HEADER_OFFSET;
		  ngDevMode && assertIndexInRange(lView, adjustedIndex);
		  ngDevMode && assertEqual(getBindingIndex(), tView.bindingStartIndex, "element containers should be created before any bindings");
		  const tNode = tView.firstCreatePass ? elementContainerStartFirstCreatePass(adjustedIndex, tView, lView, attrsIndex, localRefsIndex) : tView.data[adjustedIndex];
		  setCurrentTNode(tNode, true);
		  const comment = _locateOrCreateElementContainerNode(tView, lView, tNode, index);
		  lView[adjustedIndex] = comment;
		  if (wasLastNodeCreated()) {
			 appendChild(tView, lView, comment, tNode);
		  }
		  attachPatchData(comment, lView);
		  if (isDirectiveHost(tNode)) {
			 createDirectivesInstances(tView, lView, tNode);
			 executeContentQueries(tView, tNode, lView);
		  }
		  if (localRefsIndex != null) {
			 saveResolvedLocalsInData(lView, tNode);
		  }
		  return \u0275\u0275elementContainerStart;
		}
		function \u0275\u0275elementContainerEnd() {
		  let currentTNode = getCurrentTNode();
		  const tView = getTView();
		  if (isCurrentTNodeParent()) {
			 setCurrentTNodeAsNotParent();
		  } else {
			 ngDevMode && assertHasParent(currentTNode);
			 currentTNode = currentTNode.parent;
			 setCurrentTNode(currentTNode, false);
		  }
		  ngDevMode && assertTNodeType(
			 currentTNode,
			 8
			 /* TNodeType.ElementContainer */
		  );
		  if (tView.firstCreatePass) {
			 registerPostOrderHooks(tView, currentTNode);
			 if (isContentQueryHost(currentTNode)) {
				tView.queries.elementEnd(currentTNode);
			 }
		  }
		  return \u0275\u0275elementContainerEnd;
		}
		function \u0275\u0275elementContainer(index, attrsIndex, localRefsIndex) {
		  \u0275\u0275elementContainerStart(index, attrsIndex, localRefsIndex);
		  \u0275\u0275elementContainerEnd();
		  return \u0275\u0275elementContainer;
		}
		var _locateOrCreateElementContainerNode = (tView, lView, tNode, index) => {
		  lastNodeWasCreated(true);
		  return createCommentNode(lView[RENDERER], ngDevMode ? "ng-container" : "");
		};
		function \u0275\u0275getCurrentView() {
		  return getLView();
		}
		function \u0275\u0275hostProperty(propName, value, sanitizer) {
		  const lView = getLView();
		  const bindingIndex = nextBindingIndex();
		  if (bindingUpdated(lView, bindingIndex, value)) {
			 const tView = getTView();
			 const tNode = getSelectedTNode();
			 elementPropertyInternal(tView, tNode, lView, propName, value, lView[RENDERER], sanitizer, true);
			 ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);
		  }
		  return \u0275\u0275hostProperty;
		}
		function \u0275\u0275syntheticHostProperty(propName, value, sanitizer) {
		  const lView = getLView();
		  const bindingIndex = nextBindingIndex();
		  if (bindingUpdated(lView, bindingIndex, value)) {
			 const tView = getTView();
			 const tNode = getSelectedTNode();
			 const currentDef = getCurrentDirectiveDef(tView.data);
			 const renderer = loadComponentRenderer(currentDef, tNode, lView);
			 elementPropertyInternal(tView, tNode, lView, propName, value, renderer, sanitizer, true);
			 ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);
		  }
		  return \u0275\u0275syntheticHostProperty;
		}
		if (false) {
		  (function() {
			 _global["ngI18nClosureMode"] = // TODO(FW-1250): validate that this actually, you know, works.
			 // tslint:disable-next-line:no-toplevel-property-access
			 typeof goog !== "undefined" && typeof goog.getMsg === "function";
		  })();
		}
		var u = void 0;
		function plural(val) {
		  const n = val, i = Math.floor(Math.abs(val)), v = val.toString().replace(/^[^.]*\.?/, "").length;
		  if (i === 1 && v === 0)
			 return 1;
		  return 5;
		}
		var localeEn = ["en", [["a", "p"], ["AM", "PM"], u], [["AM", "PM"], u, u], [["S", "M", "T", "W", "T", "F", "S"], ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]], u, [["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"], ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]], u, [["B", "A"], ["BC", "AD"], ["Before Christ", "Anno Domini"]], 0, [6, 0], ["M/d/yy", "MMM d, y", "MMMM d, y", "EEEE, MMMM d, y"], ["h:mm a", "h:mm:ss a", "h:mm:ss a z", "h:mm:ss a zzzz"], ["{1}, {0}", u, "{1} 'at' {0}", u], [".", ",", ";", "%", "+", "-", "E", "\xD7", "\u2030", "\u221E", "NaN", ":"], ["#,##0.###", "#,##0%", "\xA4#,##0.00", "#E0"], "USD", "$", "US Dollar", {}, "ltr", plural];
		var LOCALE_DATA = {};
		function findLocaleData(locale2) {
		  const normalizedLocale = normalizeLocale(locale2);
		  let match23 = getLocaleData(normalizedLocale);
		  if (match23) {
			 return match23;
		  }
		  const parentLocale = normalizedLocale.split("-")[0];
		  match23 = getLocaleData(parentLocale);
		  if (match23) {
			 return match23;
		  }
		  if (parentLocale === "en") {
			 return localeEn;
		  }
		  throw new RuntimeError(701, ngDevMode && `Missing locale data for the locale "${locale2}".`);
		}
		function getLocalePluralCase(locale2) {
		  const data = findLocaleData(locale2);
		  return data[LocaleDataIndex.PluralCase];
		}
		function getLocaleData(normalizedLocale) {
		  if (!(normalizedLocale in LOCALE_DATA)) {
			 LOCALE_DATA[normalizedLocale] = _global.ng && _global.ng.common && _global.ng.common.locales && _global.ng.common.locales[normalizedLocale];
		  }
		  return LOCALE_DATA[normalizedLocale];
		}
		var LocaleDataIndex;
		(function(LocaleDataIndex2) {
		  LocaleDataIndex2[LocaleDataIndex2["LocaleId"] = 0] = "LocaleId";
		  LocaleDataIndex2[LocaleDataIndex2["DayPeriodsFormat"] = 1] = "DayPeriodsFormat";
		  LocaleDataIndex2[LocaleDataIndex2["DayPeriodsStandalone"] = 2] = "DayPeriodsStandalone";
		  LocaleDataIndex2[LocaleDataIndex2["DaysFormat"] = 3] = "DaysFormat";
		  LocaleDataIndex2[LocaleDataIndex2["DaysStandalone"] = 4] = "DaysStandalone";
		  LocaleDataIndex2[LocaleDataIndex2["MonthsFormat"] = 5] = "MonthsFormat";
		  LocaleDataIndex2[LocaleDataIndex2["MonthsStandalone"] = 6] = "MonthsStandalone";
		  LocaleDataIndex2[LocaleDataIndex2["Eras"] = 7] = "Eras";
		  LocaleDataIndex2[LocaleDataIndex2["FirstDayOfWeek"] = 8] = "FirstDayOfWeek";
		  LocaleDataIndex2[LocaleDataIndex2["WeekendRange"] = 9] = "WeekendRange";
		  LocaleDataIndex2[LocaleDataIndex2["DateFormat"] = 10] = "DateFormat";
		  LocaleDataIndex2[LocaleDataIndex2["TimeFormat"] = 11] = "TimeFormat";
		  LocaleDataIndex2[LocaleDataIndex2["DateTimeFormat"] = 12] = "DateTimeFormat";
		  LocaleDataIndex2[LocaleDataIndex2["NumberSymbols"] = 13] = "NumberSymbols";
		  LocaleDataIndex2[LocaleDataIndex2["NumberFormats"] = 14] = "NumberFormats";
		  LocaleDataIndex2[LocaleDataIndex2["CurrencyCode"] = 15] = "CurrencyCode";
		  LocaleDataIndex2[LocaleDataIndex2["CurrencySymbol"] = 16] = "CurrencySymbol";
		  LocaleDataIndex2[LocaleDataIndex2["CurrencyName"] = 17] = "CurrencyName";
		  LocaleDataIndex2[LocaleDataIndex2["Currencies"] = 18] = "Currencies";
		  LocaleDataIndex2[LocaleDataIndex2["Directionality"] = 19] = "Directionality";
		  LocaleDataIndex2[LocaleDataIndex2["PluralCase"] = 20] = "PluralCase";
		  LocaleDataIndex2[LocaleDataIndex2["ExtraData"] = 21] = "ExtraData";
		})(LocaleDataIndex || (LocaleDataIndex = {}));
		function normalizeLocale(locale2) {
		  return locale2.toLowerCase().replace(/_/g, "-");
		}
		var pluralMapping = ["zero", "one", "two", "few", "many"];
		function getPluralCase(value, locale2) {
		  const plural2 = getLocalePluralCase(locale2)(parseInt(value, 10));
		  const result = pluralMapping[plural2];
		  return result !== void 0 ? result : "other";
		}
		var DEFAULT_LOCALE_ID = "en-US";
		var USD_CURRENCY_CODE = "USD";
		var ELEMENT_MARKER = {
		  marker: "element"
		};
		var ICU_MARKER = {
		  marker: "ICU"
		};
		var I18nCreateOpCode;
		(function(I18nCreateOpCode2) {
		  I18nCreateOpCode2[I18nCreateOpCode2["SHIFT"] = 2] = "SHIFT";
		  I18nCreateOpCode2[I18nCreateOpCode2["APPEND_EAGERLY"] = 1] = "APPEND_EAGERLY";
		  I18nCreateOpCode2[I18nCreateOpCode2["COMMENT"] = 2] = "COMMENT";
		})(I18nCreateOpCode || (I18nCreateOpCode = {}));
		var LOCALE_ID$1 = DEFAULT_LOCALE_ID;
		function setLocaleId(localeId) {
		  ngDevMode && assertDefined(localeId, `Expected localeId to be defined`);
		  if (typeof localeId === "string") {
			 LOCALE_ID$1 = localeId.toLowerCase().replace(/_/g, "-");
		  }
		}
		function getLocaleId() {
		  return LOCALE_ID$1;
		}
		function getInsertInFrontOfRNodeWithI18n(parentTNode, currentTNode, lView) {
		  const tNodeInsertBeforeIndex = currentTNode.insertBeforeIndex;
		  const insertBeforeIndex = Array.isArray(tNodeInsertBeforeIndex) ? tNodeInsertBeforeIndex[0] : tNodeInsertBeforeIndex;
		  if (insertBeforeIndex === null) {
			 return getInsertInFrontOfRNodeWithNoI18n(parentTNode, currentTNode, lView);
		  } else {
			 ngDevMode && assertIndexInRange(lView, insertBeforeIndex);
			 return unwrapRNode(lView[insertBeforeIndex]);
		  }
		}
		function processI18nInsertBefore(renderer, childTNode, lView, childRNode, parentRElement) {
		  const tNodeInsertBeforeIndex = childTNode.insertBeforeIndex;
		  if (Array.isArray(tNodeInsertBeforeIndex)) {
			 ngDevMode && assertDomNode(childRNode);
			 let i18nParent = childRNode;
			 let anchorRNode = null;
			 if (!(childTNode.type & 3)) {
				anchorRNode = i18nParent;
				i18nParent = parentRElement;
			 }
			 if (i18nParent !== null && childTNode.componentOffset === -1) {
				for (let i = 1; i < tNodeInsertBeforeIndex.length; i++) {
				  const i18nChild = lView[tNodeInsertBeforeIndex[i]];
				  nativeInsertBefore(renderer, i18nParent, i18nChild, anchorRNode, false);
				}
			 }
		  }
		}
		function addTNodeAndUpdateInsertBeforeIndex(previousTNodes, newTNode) {
		  ngDevMode && assertEqual(newTNode.insertBeforeIndex, null, "We expect that insertBeforeIndex is not set");
		  previousTNodes.push(newTNode);
		  if (previousTNodes.length > 1) {
			 for (let i = previousTNodes.length - 2; i >= 0; i--) {
				const existingTNode = previousTNodes[i];
				if (!isI18nText(existingTNode)) {
				  if (isNewTNodeCreatedBefore(existingTNode, newTNode) && getInsertBeforeIndex(existingTNode) === null) {
					 setInsertBeforeIndex(existingTNode, newTNode.index);
				  }
				}
			 }
		  }
		}
		function isI18nText(tNode) {
		  return !(tNode.type & 64);
		}
		function isNewTNodeCreatedBefore(existingTNode, newTNode) {
		  return isI18nText(newTNode) || existingTNode.index > newTNode.index;
		}
		function getInsertBeforeIndex(tNode) {
		  const index = tNode.insertBeforeIndex;
		  return Array.isArray(index) ? index[0] : index;
		}
		function setInsertBeforeIndex(tNode, value) {
		  const index = tNode.insertBeforeIndex;
		  if (Array.isArray(index)) {
			 index[0] = value;
		  } else {
			 setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore);
			 tNode.insertBeforeIndex = value;
		  }
		}
		function getTIcu(tView, index) {
		  const value = tView.data[index];
		  if (value === null || typeof value === "string")
			 return null;
		  if (ngDevMode && !(value.hasOwnProperty("tView") || value.hasOwnProperty("currentCaseLViewIndex"))) {
			 throwError("We expect to get 'null'|'TIcu'|'TIcuContainer', but got: " + value);
		  }
		  const tIcu = value.hasOwnProperty("currentCaseLViewIndex") ? value : value.value;
		  ngDevMode && assertTIcu(tIcu);
		  return tIcu;
		}
		function setTIcu(tView, index, tIcu) {
		  const tNode = tView.data[index];
		  ngDevMode && assertEqual(tNode === null || tNode.hasOwnProperty("tView"), true, "We expect to get 'null'|'TIcuContainer'");
		  if (tNode === null) {
			 tView.data[index] = tIcu;
		  } else {
			 ngDevMode && assertTNodeType(
				tNode,
				32
				/* TNodeType.Icu */
			 );
			 tNode.value = tIcu;
		  }
		}
		function setTNodeInsertBeforeIndex(tNode, index) {
		  ngDevMode && assertTNode(tNode);
		  let insertBeforeIndex = tNode.insertBeforeIndex;
		  if (insertBeforeIndex === null) {
			 setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore);
			 insertBeforeIndex = tNode.insertBeforeIndex = [null, index];
		  } else {
			 assertEqual(Array.isArray(insertBeforeIndex), true, "Expecting array here");
			 insertBeforeIndex.push(index);
		  }
		}
		function createTNodePlaceholder(tView, previousTNodes, index) {
		  const tNode = createTNodeAtIndex(tView, index, 64, null, null);
		  addTNodeAndUpdateInsertBeforeIndex(previousTNodes, tNode);
		  return tNode;
		}
		function getCurrentICUCaseIndex(tIcu, lView) {
		  const currentCase = lView[tIcu.currentCaseLViewIndex];
		  return currentCase === null ? currentCase : currentCase < 0 ? ~currentCase : currentCase;
		}
		function getParentFromIcuCreateOpCode(mergedCode) {
		  return mergedCode >>> 17;
		}
		function getRefFromIcuCreateOpCode(mergedCode) {
		  return (mergedCode & 131070) >>> 1;
		}
		function getInstructionFromIcuCreateOpCode(mergedCode) {
		  return mergedCode & 1;
		}
		function icuCreateOpCode(opCode, parentIdx, refIdx) {
		  ngDevMode && assertGreaterThanOrEqual(parentIdx, 0, "Missing parent index");
		  ngDevMode && assertGreaterThan(refIdx, 0, "Missing ref index");
		  return opCode | parentIdx << 17 | refIdx << 1;
		}
		var changeMask = 0;
		var changeMaskCounter = 0;
		function setMaskBit(hasChange) {
		  if (hasChange) {
			 changeMask = changeMask | 1 << Math.min(changeMaskCounter, 31);
		  }
		  changeMaskCounter++;
		}
		function applyI18n(tView, lView, index) {
		  if (changeMaskCounter > 0) {
			 ngDevMode && assertDefined(tView, `tView should be defined`);
			 const tI18n = tView.data[index];
			 const updateOpCodes = Array.isArray(tI18n) ? tI18n : tI18n.update;
			 const bindingsStartIndex = getBindingIndex() - changeMaskCounter - 1;
			 applyUpdateOpCodes(tView, lView, updateOpCodes, bindingsStartIndex, changeMask);
		  }
		  changeMask = 0;
		  changeMaskCounter = 0;
		}
		function createNodeWithoutHydration(lView, textOrName, nodeType) {
		  const renderer = lView[RENDERER];
		  switch (nodeType) {
			 case Node.COMMENT_NODE:
				return createCommentNode(renderer, textOrName);
			 case Node.TEXT_NODE:
				return createTextNode(renderer, textOrName);
			 case Node.ELEMENT_NODE:
				return createElementNode(renderer, textOrName, null);
		  }
		}
		var _locateOrCreateNode = (lView, index, textOrName, nodeType) => {
		  lastNodeWasCreated(true);
		  return createNodeWithoutHydration(lView, textOrName, nodeType);
		};
		function applyCreateOpCodes(lView, createOpCodes, parentRNode, insertInFrontOf) {
		  const renderer = lView[RENDERER];
		  for (let i = 0; i < createOpCodes.length; i++) {
			 const opCode = createOpCodes[i++];
			 const text = createOpCodes[i];
			 const isComment = (opCode & I18nCreateOpCode.COMMENT) === I18nCreateOpCode.COMMENT;
			 const appendNow = (opCode & I18nCreateOpCode.APPEND_EAGERLY) === I18nCreateOpCode.APPEND_EAGERLY;
			 const index = opCode >>> I18nCreateOpCode.SHIFT;
			 let rNode = lView[index];
			 let lastNodeWasCreated2 = false;
			 if (rNode === null) {
				rNode = lView[index] = _locateOrCreateNode(lView, index, text, isComment ? Node.COMMENT_NODE : Node.TEXT_NODE);
				lastNodeWasCreated2 = wasLastNodeCreated();
			 }
			 if (appendNow && parentRNode !== null && lastNodeWasCreated2) {
				nativeInsertBefore(renderer, parentRNode, rNode, insertInFrontOf, false);
			 }
		  }
		}
		function applyMutableOpCodes(tView, mutableOpCodes, lView, anchorRNode) {
		  ngDevMode && assertDomNode(anchorRNode);
		  const renderer = lView[RENDERER];
		  let rootIdx = null;
		  let rootRNode;
		  for (let i = 0; i < mutableOpCodes.length; i++) {
			 const opCode = mutableOpCodes[i];
			 if (typeof opCode == "string") {
				const textNodeIndex = mutableOpCodes[++i];
				if (lView[textNodeIndex] === null) {
				  ngDevMode && ngDevMode.rendererCreateTextNode++;
				  ngDevMode && assertIndexInRange(lView, textNodeIndex);
				  lView[textNodeIndex] = _locateOrCreateNode(lView, textNodeIndex, opCode, Node.TEXT_NODE);
				}
			 } else if (typeof opCode == "number") {
				switch (opCode & 1) {
				  case 0:
					 const parentIdx = getParentFromIcuCreateOpCode(opCode);
					 if (rootIdx === null) {
						rootIdx = parentIdx;
						rootRNode = nativeParentNode(renderer, anchorRNode);
					 }
					 let insertInFrontOf;
					 let parentRNode;
					 if (parentIdx === rootIdx) {
						insertInFrontOf = anchorRNode;
						parentRNode = rootRNode;
					 } else {
						insertInFrontOf = null;
						parentRNode = unwrapRNode(lView[parentIdx]);
					 }
					 if (parentRNode !== null) {
						ngDevMode && assertDomNode(parentRNode);
						const refIdx = getRefFromIcuCreateOpCode(opCode);
						ngDevMode && assertGreaterThan(refIdx, HEADER_OFFSET, "Missing ref");
						const child = lView[refIdx];
						ngDevMode && assertDomNode(child);
						nativeInsertBefore(renderer, parentRNode, child, insertInFrontOf, false);
						const tIcu = getTIcu(tView, refIdx);
						if (tIcu !== null && typeof tIcu === "object") {
						  ngDevMode && assertTIcu(tIcu);
						  const caseIndex = getCurrentICUCaseIndex(tIcu, lView);
						  if (caseIndex !== null) {
							 applyMutableOpCodes(tView, tIcu.create[caseIndex], lView, lView[tIcu.anchorIdx]);
						  }
						}
					 }
					 break;
				  case 1:
					 const elementNodeIndex = opCode >>> 1;
					 const attrName = mutableOpCodes[++i];
					 const attrValue = mutableOpCodes[++i];
					 setElementAttribute(renderer, getNativeByIndex(elementNodeIndex, lView), null, null, attrName, attrValue, null);
					 break;
				  default:
					 if (ngDevMode) {
						throw new RuntimeError(700, `Unable to determine the type of mutate operation for "${opCode}"`);
					 }
				}
			 } else {
				switch (opCode) {
				  case ICU_MARKER:
					 const commentValue = mutableOpCodes[++i];
					 const commentNodeIndex = mutableOpCodes[++i];
					 if (lView[commentNodeIndex] === null) {
						ngDevMode && assertEqual(typeof commentValue, "string", `Expected "${commentValue}" to be a comment node value`);
						ngDevMode && ngDevMode.rendererCreateComment++;
						ngDevMode && assertIndexInExpandoRange(lView, commentNodeIndex);
						const commentRNode = lView[commentNodeIndex] = _locateOrCreateNode(lView, commentNodeIndex, commentValue, Node.COMMENT_NODE);
						attachPatchData(commentRNode, lView);
					 }
					 break;
				  case ELEMENT_MARKER:
					 const tagName = mutableOpCodes[++i];
					 const elementNodeIndex = mutableOpCodes[++i];
					 if (lView[elementNodeIndex] === null) {
						ngDevMode && assertEqual(typeof tagName, "string", `Expected "${tagName}" to be an element node tag name`);
						ngDevMode && ngDevMode.rendererCreateElement++;
						ngDevMode && assertIndexInExpandoRange(lView, elementNodeIndex);
						const elementRNode = lView[elementNodeIndex] = _locateOrCreateNode(lView, elementNodeIndex, tagName, Node.ELEMENT_NODE);
						attachPatchData(elementRNode, lView);
					 }
					 break;
				  default:
					 ngDevMode && throwError(`Unable to determine the type of mutate operation for "${opCode}"`);
				}
			 }
		  }
		}
		function applyUpdateOpCodes(tView, lView, updateOpCodes, bindingsStartIndex, changeMask2) {
		  for (let i = 0; i < updateOpCodes.length; i++) {
			 const checkBit = updateOpCodes[i];
			 const skipCodes = updateOpCodes[++i];
			 if (checkBit & changeMask2) {
				let value = "";
				for (let j = i + 1; j <= i + skipCodes; j++) {
				  const opCode = updateOpCodes[j];
				  if (typeof opCode == "string") {
					 value += opCode;
				  } else if (typeof opCode == "number") {
					 if (opCode < 0) {
						value += renderStringify(lView[bindingsStartIndex - opCode]);
					 } else {
						const nodeIndex = opCode >>> 2;
						switch (opCode & 3) {
						  case 1:
							 const propName = updateOpCodes[++j];
							 const sanitizeFn = updateOpCodes[++j];
							 const tNodeOrTagName = tView.data[nodeIndex];
							 ngDevMode && assertDefined(tNodeOrTagName, "Experting TNode or string");
							 if (typeof tNodeOrTagName === "string") {
								setElementAttribute(lView[RENDERER], lView[nodeIndex], null, tNodeOrTagName, propName, value, sanitizeFn);
							 } else {
								elementPropertyInternal(tView, tNodeOrTagName, lView, propName, value, lView[RENDERER], sanitizeFn, false);
							 }
							 break;
						  case 0:
							 const rText = lView[nodeIndex];
							 rText !== null && updateTextNode(lView[RENDERER], rText, value);
							 break;
						  case 2:
							 applyIcuSwitchCase(tView, getTIcu(tView, nodeIndex), lView, value);
							 break;
						  case 3:
							 applyIcuUpdateCase(tView, getTIcu(tView, nodeIndex), bindingsStartIndex, lView);
							 break;
						}
					 }
				  }
				}
			 } else {
				const opCode = updateOpCodes[i + 1];
				if (opCode > 0 && (opCode & 3) === 3) {
				  const nodeIndex = opCode >>> 2;
				  const tIcu = getTIcu(tView, nodeIndex);
				  const currentIndex = lView[tIcu.currentCaseLViewIndex];
				  if (currentIndex < 0) {
					 applyIcuUpdateCase(tView, tIcu, bindingsStartIndex, lView);
				  }
				}
			 }
			 i += skipCodes;
		  }
		}
		function applyIcuUpdateCase(tView, tIcu, bindingsStartIndex, lView) {
		  ngDevMode && assertIndexInRange(lView, tIcu.currentCaseLViewIndex);
		  let activeCaseIndex = lView[tIcu.currentCaseLViewIndex];
		  if (activeCaseIndex !== null) {
			 let mask = changeMask;
			 if (activeCaseIndex < 0) {
				activeCaseIndex = lView[tIcu.currentCaseLViewIndex] = ~activeCaseIndex;
				mask = -1;
			 }
			 applyUpdateOpCodes(tView, lView, tIcu.update[activeCaseIndex], bindingsStartIndex, mask);
		  }
		}
		function applyIcuSwitchCase(tView, tIcu, lView, value) {
		  const caseIndex = getCaseIndex(tIcu, value);
		  let activeCaseIndex = getCurrentICUCaseIndex(tIcu, lView);
		  if (activeCaseIndex !== caseIndex) {
			 applyIcuSwitchCaseRemove(tView, tIcu, lView);
			 lView[tIcu.currentCaseLViewIndex] = caseIndex === null ? null : ~caseIndex;
			 if (caseIndex !== null) {
				const anchorRNode = lView[tIcu.anchorIdx];
				if (anchorRNode) {
				  ngDevMode && assertDomNode(anchorRNode);
				  applyMutableOpCodes(tView, tIcu.create[caseIndex], lView, anchorRNode);
				}
			 }
		  }
		}
		function applyIcuSwitchCaseRemove(tView, tIcu, lView) {
		  let activeCaseIndex = getCurrentICUCaseIndex(tIcu, lView);
		  if (activeCaseIndex !== null) {
			 const removeCodes = tIcu.remove[activeCaseIndex];
			 for (let i = 0; i < removeCodes.length; i++) {
				const nodeOrIcuIndex = removeCodes[i];
				if (nodeOrIcuIndex > 0) {
				  const rNode = getNativeByIndex(nodeOrIcuIndex, lView);
				  rNode !== null && nativeRemoveNode(lView[RENDERER], rNode);
				} else {
				  applyIcuSwitchCaseRemove(tView, getTIcu(tView, ~nodeOrIcuIndex), lView);
				}
			 }
		  }
		}
		function getCaseIndex(icuExpression, bindingValue) {
		  let index = icuExpression.cases.indexOf(bindingValue);
		  if (index === -1) {
			 switch (icuExpression.type) {
				case 1: {
				  const resolvedCase = getPluralCase(bindingValue, getLocaleId());
				  index = icuExpression.cases.indexOf(resolvedCase);
				  if (index === -1 && resolvedCase !== "other") {
					 index = icuExpression.cases.indexOf("other");
				  }
				  break;
				}
				case 0: {
				  index = icuExpression.cases.indexOf("other");
				  break;
				}
			 }
		  }
		  return index === -1 ? null : index;
		}
		function loadIcuContainerVisitor() {
		  const _stack = [];
		  let _index = -1;
		  let _lView;
		  let _removes;
		  function icuContainerIteratorStart(tIcuContainerNode, lView) {
			 _lView = lView;
			 while (_stack.length)
				_stack.pop();
			 ngDevMode && assertTNodeForLView(tIcuContainerNode, lView);
			 enterIcu(tIcuContainerNode.value, lView);
			 return icuContainerIteratorNext;
		  }
		  function enterIcu(tIcu, lView) {
			 _index = 0;
			 const currentCase = getCurrentICUCaseIndex(tIcu, lView);
			 if (currentCase !== null) {
				ngDevMode && assertNumberInRange(currentCase, 0, tIcu.cases.length - 1);
				_removes = tIcu.remove[currentCase];
			 } else {
				_removes = EMPTY_ARRAY;
			 }
		  }
		  function icuContainerIteratorNext() {
			 if (_index < _removes.length) {
				const removeOpCode = _removes[_index++];
				ngDevMode && assertNumber(removeOpCode, "Expecting OpCode number");
				if (removeOpCode > 0) {
				  const rNode = _lView[removeOpCode];
				  ngDevMode && assertDomNode(rNode);
				  return rNode;
				} else {
				  _stack.push(_index, _removes);
				  const tIcuIndex = ~removeOpCode;
				  const tIcu = _lView[TVIEW].data[tIcuIndex];
				  ngDevMode && assertTIcu(tIcu);
				  enterIcu(tIcu, _lView);
				  return icuContainerIteratorNext();
				}
			 } else {
				if (_stack.length === 0) {
				  return null;
				} else {
				  _removes = _stack.pop();
				  _index = _stack.pop();
				  return icuContainerIteratorNext();
				}
			 }
		  }
		  return icuContainerIteratorStart;
		}
		function i18nCreateOpCodesToString(opcodes) {
		  const createOpCodes = opcodes || (Array.isArray(this) ? this : []);
		  let lines = [];
		  for (let i = 0; i < createOpCodes.length; i++) {
			 const opCode = createOpCodes[i++];
			 const text = createOpCodes[i];
			 const isComment = (opCode & I18nCreateOpCode.COMMENT) === I18nCreateOpCode.COMMENT;
			 const appendNow = (opCode & I18nCreateOpCode.APPEND_EAGERLY) === I18nCreateOpCode.APPEND_EAGERLY;
			 const index = opCode >>> I18nCreateOpCode.SHIFT;
			 lines.push(`lView[${index}] = document.${isComment ? "createComment" : "createText"}(${JSON.stringify(text)});`);
			 if (appendNow) {
				lines.push(`parent.appendChild(lView[${index}]);`);
			 }
		  }
		  return lines;
		}
		function i18nUpdateOpCodesToString(opcodes) {
		  const parser = new OpCodeParser(opcodes || (Array.isArray(this) ? this : []));
		  let lines = [];
		  function consumeOpCode(value) {
			 const ref = value >>> 2;
			 const opCode = value & 3;
			 switch (opCode) {
				case 0:
				  return `(lView[${ref}] as Text).textContent = $$$`;
				case 1:
				  const attrName = parser.consumeString();
				  const sanitizationFn = parser.consumeFunction();
				  const value2 = sanitizationFn ? `(${sanitizationFn})($$$)` : "$$$";
				  return `(lView[${ref}] as Element).setAttribute('${attrName}', ${value2})`;
				case 2:
				  return `icuSwitchCase(${ref}, $$$)`;
				case 3:
				  return `icuUpdateCase(${ref})`;
			 }
			 throw new Error("unexpected OpCode");
		  }
		  while (parser.hasMore()) {
			 let mask = parser.consumeNumber();
			 let size = parser.consumeNumber();
			 const end = parser.i + size;
			 const statements = [];
			 let statement = "";
			 while (parser.i < end) {
				let value = parser.consumeNumberOrString();
				if (typeof value === "string") {
				  statement += value;
				} else if (value < 0) {
				  statement += "${lView[i" + value + "]}";
				} else {
				  const opCodeText = consumeOpCode(value);
				  statements.push(opCodeText.replace("$$$", "`" + statement + "`") + ";");
				  statement = "";
				}
			 }
			 lines.push(`if (mask & 0b${mask.toString(2)}) { ${statements.join(" ")} }`);
		  }
		  return lines;
		}
		function icuCreateOpCodesToString(opcodes) {
		  const parser = new OpCodeParser(opcodes || (Array.isArray(this) ? this : []));
		  let lines = [];
		  function consumeOpCode(opCode) {
			 const parent = getParentFromIcuCreateOpCode(opCode);
			 const ref = getRefFromIcuCreateOpCode(opCode);
			 switch (getInstructionFromIcuCreateOpCode(opCode)) {
				case 0:
				  return `(lView[${parent}] as Element).appendChild(lView[${lastRef}])`;
				case 1:
				  return `(lView[${ref}] as Element).setAttribute("${parser.consumeString()}", "${parser.consumeString()}")`;
			 }
			 throw new Error("Unexpected OpCode: " + getInstructionFromIcuCreateOpCode(opCode));
		  }
		  let lastRef = -1;
		  while (parser.hasMore()) {
			 let value = parser.consumeNumberStringOrMarker();
			 if (value === ICU_MARKER) {
				const text = parser.consumeString();
				lastRef = parser.consumeNumber();
				lines.push(`lView[${lastRef}] = document.createComment("${text}")`);
			 } else if (value === ELEMENT_MARKER) {
				const text = parser.consumeString();
				lastRef = parser.consumeNumber();
				lines.push(`lView[${lastRef}] = document.createElement("${text}")`);
			 } else if (typeof value === "string") {
				lastRef = parser.consumeNumber();
				lines.push(`lView[${lastRef}] = document.createTextNode("${value}")`);
			 } else if (typeof value === "number") {
				const line = consumeOpCode(value);
				line && lines.push(line);
			 } else {
				throw new Error("Unexpected value");
			 }
		  }
		  return lines;
		}
		function i18nRemoveOpCodesToString(opcodes) {
		  const removeCodes = opcodes || (Array.isArray(this) ? this : []);
		  let lines = [];
		  for (let i = 0; i < removeCodes.length; i++) {
			 const nodeOrIcuIndex = removeCodes[i];
			 if (nodeOrIcuIndex > 0) {
				lines.push(`remove(lView[${nodeOrIcuIndex}])`);
			 } else {
				lines.push(`removeNestedICU(${~nodeOrIcuIndex})`);
			 }
		  }
		  return lines;
		}
		var OpCodeParser = class {
		  constructor(codes) {
			 this.i = 0;
			 this.codes = codes;
		  }
		  hasMore() {
			 return this.i < this.codes.length;
		  }
		  consumeNumber() {
			 let value = this.codes[this.i++];
			 assertNumber(value, "expecting number in OpCode");
			 return value;
		  }
		  consumeString() {
			 let value = this.codes[this.i++];
			 assertString(value, "expecting string in OpCode");
			 return value;
		  }
		  consumeFunction() {
			 let value = this.codes[this.i++];
			 if (value === null || typeof value === "function") {
				return value;
			 }
			 throw new Error("expecting function in OpCode");
		  }
		  consumeNumberOrString() {
			 let value = this.codes[this.i++];
			 if (typeof value === "string") {
				return value;
			 }
			 assertNumber(value, "expecting number or string in OpCode");
			 return value;
		  }
		  consumeNumberStringOrMarker() {
			 let value = this.codes[this.i++];
			 if (typeof value === "string" || typeof value === "number" || value == ICU_MARKER || value == ELEMENT_MARKER) {
				return value;
			 }
			 assertNumber(value, "expecting number, string, ICU_MARKER or ELEMENT_MARKER in OpCode");
			 return value;
		  }
		};
		var BINDING_REGEXP = /(\d+):?\d*/gi;
		var ICU_REGEXP = /({\s*\d+:?\d*\s*,\s*\S{6}\s*,[\s\S]*})/gi;
		var NESTED_ICU = /(\d+)/;
		var ICU_BLOCK_REGEXP = /^\s*(\d+:?\d*)\s*,\s*(select|plural)\s*,/;
		var MARKER = `\uFFFD`;
		var SUBTEMPLATE_REGEXP = /\/?\*(\d+:\d+)/gi;
		var PH_REGEXP = /(\/?[#*]\d+):?\d*/gi;
		var NGSP_UNICODE_REGEXP = /\uE500/g;
		function replaceNgsp(value) {
		  return value.replace(NGSP_UNICODE_REGEXP, " ");
		}
		function attachDebugGetter(obj, debugGetter) {
		  if (ngDevMode) {
			 Object.defineProperty(obj, "debug", { get: debugGetter, enumerable: false });
		  } else {
			 throw new Error("This method should be guarded with `ngDevMode` so that it can be tree shaken in production!");
		  }
		}
		function i18nStartFirstCreatePass(tView, parentTNodeIndex, lView, index, message2, subTemplateIndex) {
		  const rootTNode = getCurrentParentTNode();
		  const createOpCodes = [];
		  const updateOpCodes = [];
		  const existingTNodeStack = [[]];
		  const astStack = [[]];
		  if (ngDevMode) {
			 attachDebugGetter(createOpCodes, i18nCreateOpCodesToString);
			 attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);
		  }
		  message2 = getTranslationForTemplate(message2, subTemplateIndex);
		  const msgParts = replaceNgsp(message2).split(PH_REGEXP);
		  for (let i = 0; i < msgParts.length; i++) {
			 let value = msgParts[i];
			 if ((i & 1) === 0) {
				const parts = i18nParseTextIntoPartsAndICU(value);
				for (let j = 0; j < parts.length; j++) {
				  let part = parts[j];
				  if ((j & 1) === 0) {
					 const text = part;
					 ngDevMode && assertString(text, "Parsed ICU part should be string");
					 if (text !== "") {
						i18nStartFirstCreatePassProcessTextNode(astStack[0], tView, rootTNode, existingTNodeStack[0], createOpCodes, updateOpCodes, lView, text);
					 }
				  } else {
					 const icuExpression = part;
					 if (typeof icuExpression !== "object") {
						throw new Error(`Unable to parse ICU expression in "${message2}" message.`);
					 }
					 const icuContainerTNode = createTNodeAndAddOpCode(tView, rootTNode, existingTNodeStack[0], lView, createOpCodes, ngDevMode ? `ICU ${index}:${icuExpression.mainBinding}` : "", true);
					 const icuNodeIndex = icuContainerTNode.index;
					 ngDevMode && assertGreaterThanOrEqual(icuNodeIndex, HEADER_OFFSET, "Index must be in absolute LView offset");
					 icuStart(astStack[0], tView, lView, updateOpCodes, parentTNodeIndex, icuExpression, icuNodeIndex);
				  }
				}
			 } else {
				const isClosing = value.charCodeAt(0) === 47;
				const type2 = value.charCodeAt(isClosing ? 1 : 0);
				ngDevMode && assertOneOf(
				  type2,
				  42,
				  35
				  /* CharCode.HASH */
				);
				const index2 = HEADER_OFFSET + Number.parseInt(value.substring(isClosing ? 2 : 1));
				if (isClosing) {
				  existingTNodeStack.shift();
				  astStack.shift();
				  setCurrentTNode(getCurrentParentTNode(), false);
				} else {
				  const tNode = createTNodePlaceholder(tView, existingTNodeStack[0], index2);
				  existingTNodeStack.unshift([]);
				  setCurrentTNode(tNode, true);
				  const placeholderNode = {
					 kind: 2,
					 index: index2,
					 children: [],
					 type: type2 === 35 ? 0 : 1
				  };
				  astStack[0].push(placeholderNode);
				  astStack.unshift(placeholderNode.children);
				}
			 }
		  }
		  tView.data[index] = {
			 create: createOpCodes,
			 update: updateOpCodes,
			 ast: astStack[0]
		  };
		}
		function createTNodeAndAddOpCode(tView, rootTNode, existingTNodes, lView, createOpCodes, text, isICU) {
		  const i18nNodeIdx = allocExpando(tView, lView, 1, null);
		  let opCode = i18nNodeIdx << I18nCreateOpCode.SHIFT;
		  let parentTNode = getCurrentParentTNode();
		  if (rootTNode === parentTNode) {
			 parentTNode = null;
		  }
		  if (parentTNode === null) {
			 opCode |= I18nCreateOpCode.APPEND_EAGERLY;
		  }
		  if (isICU) {
			 opCode |= I18nCreateOpCode.COMMENT;
			 ensureIcuContainerVisitorLoaded(loadIcuContainerVisitor);
		  }
		  createOpCodes.push(opCode, text === null ? "" : text);
		  const tNode = createTNodeAtIndex(tView, i18nNodeIdx, isICU ? 32 : 1, text === null ? ngDevMode ? "{{?}}" : "" : text, null);
		  addTNodeAndUpdateInsertBeforeIndex(existingTNodes, tNode);
		  const tNodeIdx = tNode.index;
		  setCurrentTNode(
			 tNode,
			 false
			 /* Text nodes are self closing */
		  );
		  if (parentTNode !== null && rootTNode !== parentTNode) {
			 setTNodeInsertBeforeIndex(parentTNode, tNodeIdx);
		  }
		  return tNode;
		}
		function i18nStartFirstCreatePassProcessTextNode(ast, tView, rootTNode, existingTNodes, createOpCodes, updateOpCodes, lView, text) {
		  const hasBinding = text.match(BINDING_REGEXP);
		  const tNode = createTNodeAndAddOpCode(tView, rootTNode, existingTNodes, lView, createOpCodes, hasBinding ? null : text, false);
		  const index = tNode.index;
		  if (hasBinding) {
			 generateBindingUpdateOpCodes(updateOpCodes, text, index, null, 0, null);
		  }
		  ast.push({ kind: 0, index });
		}
		function i18nAttributesFirstPass(tView, index, values) {
		  const previousElement = getCurrentTNode();
		  const previousElementIndex = previousElement.index;
		  const updateOpCodes = [];
		  if (ngDevMode) {
			 attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);
		  }
		  if (tView.firstCreatePass && tView.data[index] === null) {
			 for (let i = 0; i < values.length; i += 2) {
				const attrName = values[i];
				const message2 = values[i + 1];
				if (message2 !== "") {
				  if (ICU_REGEXP.test(message2)) {
					 throw new Error(`ICU expressions are not supported in attributes. Message: "${message2}".`);
				  }
				  generateBindingUpdateOpCodes(updateOpCodes, message2, previousElementIndex, attrName, countBindings(updateOpCodes), null);
				}
			 }
			 tView.data[index] = updateOpCodes;
		  }
		}
		function generateBindingUpdateOpCodes(updateOpCodes, str, destinationNode, attrName, bindingStart, sanitizeFn) {
		  ngDevMode && assertGreaterThanOrEqual(destinationNode, HEADER_OFFSET, "Index must be in absolute LView offset");
		  const maskIndex = updateOpCodes.length;
		  const sizeIndex = maskIndex + 1;
		  updateOpCodes.push(null, null);
		  const startIndex = maskIndex + 2;
		  if (ngDevMode) {
			 attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);
		  }
		  const textParts = str.split(BINDING_REGEXP);
		  let mask = 0;
		  for (let j = 0; j < textParts.length; j++) {
			 const textValue = textParts[j];
			 if (j & 1) {
				const bindingIndex = bindingStart + parseInt(textValue, 10);
				updateOpCodes.push(-1 - bindingIndex);
				mask = mask | toMaskBit(bindingIndex);
			 } else if (textValue !== "") {
				updateOpCodes.push(textValue);
			 }
		  }
		  updateOpCodes.push(destinationNode << 2 | (attrName ? 1 : 0));
		  if (attrName) {
			 updateOpCodes.push(attrName, sanitizeFn);
		  }
		  updateOpCodes[maskIndex] = mask;
		  updateOpCodes[sizeIndex] = updateOpCodes.length - startIndex;
		  return mask;
		}
		function countBindings(opCodes) {
		  let count = 0;
		  for (let i = 0; i < opCodes.length; i++) {
			 const opCode = opCodes[i];
			 if (typeof opCode === "number" && opCode < 0) {
				count++;
			 }
		  }
		  return count;
		}
		function toMaskBit(bindingIndex) {
		  return 1 << Math.min(bindingIndex, 31);
		}
		function isRootTemplateMessage(subTemplateIndex) {
		  return subTemplateIndex === -1;
		}
		function removeInnerTemplateTranslation(message2) {
		  let match23;
		  let res = "";
		  let index = 0;
		  let inTemplate = false;
		  let tagMatched;
		  while ((match23 = SUBTEMPLATE_REGEXP.exec(message2)) !== null) {
			 if (!inTemplate) {
				res += message2.substring(index, match23.index + match23[0].length);
				tagMatched = match23[1];
				inTemplate = true;
			 } else {
				if (match23[0] === `${MARKER}/*${tagMatched}${MARKER}`) {
				  index = match23.index;
				  inTemplate = false;
				}
			 }
		  }
		  ngDevMode && assertEqual(inTemplate, false, `Tag mismatch: unable to find the end of the sub-template in the translation "${message2}"`);
		  res += message2.slice(index);
		  return res;
		}
		function getTranslationForTemplate(message2, subTemplateIndex) {
		  if (isRootTemplateMessage(subTemplateIndex)) {
			 return removeInnerTemplateTranslation(message2);
		  } else {
			 const start2 = message2.indexOf(`:${subTemplateIndex}${MARKER}`) + 2 + subTemplateIndex.toString().length;
			 const end = message2.search(new RegExp(`${MARKER}\\/\\*\\d+:${subTemplateIndex}${MARKER}`));
			 return removeInnerTemplateTranslation(message2.substring(start2, end));
		  }
		}
		function icuStart(ast, tView, lView, updateOpCodes, parentIdx, icuExpression, anchorIdx) {
		  ngDevMode && assertDefined(icuExpression, "ICU expression must be defined");
		  let bindingMask = 0;
		  const tIcu = {
			 type: icuExpression.type,
			 currentCaseLViewIndex: allocExpando(tView, lView, 1, null),
			 anchorIdx,
			 cases: [],
			 create: [],
			 remove: [],
			 update: []
		  };
		  addUpdateIcuSwitch(updateOpCodes, icuExpression, anchorIdx);
		  setTIcu(tView, anchorIdx, tIcu);
		  const values = icuExpression.values;
		  const cases = [];
		  for (let i = 0; i < values.length; i++) {
			 const valueArr = values[i];
			 const nestedIcus = [];
			 for (let j = 0; j < valueArr.length; j++) {
				const value = valueArr[j];
				if (typeof value !== "string") {
				  const icuIndex = nestedIcus.push(value) - 1;
				  valueArr[j] = `<!--\uFFFD${icuIndex}\uFFFD-->`;
				}
			 }
			 const caseAst = [];
			 cases.push(caseAst);
			 bindingMask = parseIcuCase(caseAst, tView, tIcu, lView, updateOpCodes, parentIdx, icuExpression.cases[i], valueArr.join(""), nestedIcus) | bindingMask;
		  }
		  if (bindingMask) {
			 addUpdateIcuUpdate(updateOpCodes, bindingMask, anchorIdx);
		  }
		  ast.push({
			 kind: 3,
			 index: anchorIdx,
			 cases,
			 currentCaseLViewIndex: tIcu.currentCaseLViewIndex
		  });
		}
		function parseICUBlock(pattern) {
		  const cases = [];
		  const values = [];
		  let icuType = 1;
		  let mainBinding = 0;
		  pattern = pattern.replace(ICU_BLOCK_REGEXP, function(str, binding, type2) {
			 if (type2 === "select") {
				icuType = 0;
			 } else {
				icuType = 1;
			 }
			 mainBinding = parseInt(binding.slice(1), 10);
			 return "";
		  });
		  const parts = i18nParseTextIntoPartsAndICU(pattern);
		  for (let pos = 0; pos < parts.length; ) {
			 let key = parts[pos++].trim();
			 if (icuType === 1) {
				key = key.replace(/\s*(?:=)?(\w+)\s*/, "$1");
			 }
			 if (key.length) {
				cases.push(key);
			 }
			 const blocks = i18nParseTextIntoPartsAndICU(parts[pos++]);
			 if (cases.length > values.length) {
				values.push(blocks);
			 }
		  }
		  return { type: icuType, mainBinding, cases, values };
		}
		function i18nParseTextIntoPartsAndICU(pattern) {
		  if (!pattern) {
			 return [];
		  }
		  let prevPos = 0;
		  const braceStack = [];
		  const results = [];
		  const braces = /[{}]/g;
		  braces.lastIndex = 0;
		  let match23;
		  while (match23 = braces.exec(pattern)) {
			 const pos = match23.index;
			 if (match23[0] == "}") {
				braceStack.pop();
				if (braceStack.length == 0) {
				  const block = pattern.substring(prevPos, pos);
				  if (ICU_BLOCK_REGEXP.test(block)) {
					 results.push(parseICUBlock(block));
				  } else {
					 results.push(block);
				  }
				  prevPos = pos + 1;
				}
			 } else {
				if (braceStack.length == 0) {
				  const substring2 = pattern.substring(prevPos, pos);
				  results.push(substring2);
				  prevPos = pos + 1;
				}
				braceStack.push("{");
			 }
		  }
		  const substring = pattern.substring(prevPos);
		  results.push(substring);
		  return results;
		}
		function parseIcuCase(ast, tView, tIcu, lView, updateOpCodes, parentIdx, caseName, unsafeCaseHtml, nestedIcus) {
		  const create2 = [];
		  const remove4 = [];
		  const update = [];
		  if (ngDevMode) {
			 attachDebugGetter(create2, icuCreateOpCodesToString);
			 attachDebugGetter(remove4, i18nRemoveOpCodesToString);
			 attachDebugGetter(update, i18nUpdateOpCodesToString);
		  }
		  tIcu.cases.push(caseName);
		  tIcu.create.push(create2);
		  tIcu.remove.push(remove4);
		  tIcu.update.push(update);
		  const inertBodyHelper2 = getInertBodyHelper(getDocument());
		  const inertBodyElement = inertBodyHelper2.getInertBodyElement(unsafeCaseHtml);
		  ngDevMode && assertDefined(inertBodyElement, "Unable to generate inert body element");
		  const inertRootNode = getTemplateContent(inertBodyElement) || inertBodyElement;
		  if (inertRootNode) {
			 return walkIcuTree(ast, tView, tIcu, lView, updateOpCodes, create2, remove4, update, inertRootNode, parentIdx, nestedIcus, 0);
		  } else {
			 return 0;
		  }
		}
		function walkIcuTree(ast, tView, tIcu, lView, sharedUpdateOpCodes, create2, remove4, update, parentNode, parentIdx, nestedIcus, depth) {
		  let bindingMask = 0;
		  let currentNode = parentNode.firstChild;
		  while (currentNode) {
			 const newIndex = allocExpando(tView, lView, 1, null);
			 switch (currentNode.nodeType) {
				case Node.ELEMENT_NODE:
				  const element = currentNode;
				  const tagName = element.tagName.toLowerCase();
				  if (VALID_ELEMENTS.hasOwnProperty(tagName)) {
					 addCreateNodeAndAppend(create2, ELEMENT_MARKER, tagName, parentIdx, newIndex);
					 tView.data[newIndex] = tagName;
					 const elAttrs = element.attributes;
					 for (let i = 0; i < elAttrs.length; i++) {
						const attr = elAttrs.item(i);
						const lowerAttrName = attr.name.toLowerCase();
						const hasBinding2 = !!attr.value.match(BINDING_REGEXP);
						if (hasBinding2) {
						  if (VALID_ATTRS.hasOwnProperty(lowerAttrName)) {
							 if (URI_ATTRS[lowerAttrName]) {
								generateBindingUpdateOpCodes(update, attr.value, newIndex, attr.name, 0, _sanitizeUrl);
							 } else {
								generateBindingUpdateOpCodes(update, attr.value, newIndex, attr.name, 0, null);
							 }
						  } else {
							 ngDevMode && console.warn(`WARNING: ignoring unsafe attribute value ${lowerAttrName} on element ${tagName} (see ${XSS_SECURITY_URL})`);
						  }
						} else {
						  addCreateAttribute(create2, newIndex, attr);
						}
					 }
					 const elementNode = {
						kind: 1,
						index: newIndex,
						children: []
					 };
					 ast.push(elementNode);
					 bindingMask = walkIcuTree(elementNode.children, tView, tIcu, lView, sharedUpdateOpCodes, create2, remove4, update, currentNode, newIndex, nestedIcus, depth + 1) | bindingMask;
					 addRemoveNode(remove4, newIndex, depth);
				  }
				  break;
				case Node.TEXT_NODE:
				  const value = currentNode.textContent || "";
				  const hasBinding = value.match(BINDING_REGEXP);
				  addCreateNodeAndAppend(create2, null, hasBinding ? "" : value, parentIdx, newIndex);
				  addRemoveNode(remove4, newIndex, depth);
				  if (hasBinding) {
					 bindingMask = generateBindingUpdateOpCodes(update, value, newIndex, null, 0, null) | bindingMask;
				  }
				  ast.push({
					 kind: 0,
					 index: newIndex
				  });
				  break;
				case Node.COMMENT_NODE:
				  const isNestedIcu = NESTED_ICU.exec(currentNode.textContent || "");
				  if (isNestedIcu) {
					 const nestedIcuIndex = parseInt(isNestedIcu[1], 10);
					 const icuExpression = nestedIcus[nestedIcuIndex];
					 addCreateNodeAndAppend(create2, ICU_MARKER, ngDevMode ? `nested ICU ${nestedIcuIndex}` : "", parentIdx, newIndex);
					 icuStart(ast, tView, lView, sharedUpdateOpCodes, parentIdx, icuExpression, newIndex);
					 addRemoveNestedIcu(remove4, newIndex, depth);
				  }
				  break;
			 }
			 currentNode = currentNode.nextSibling;
		  }
		  return bindingMask;
		}
		function addRemoveNode(remove4, index, depth) {
		  if (depth === 0) {
			 remove4.push(index);
		  }
		}
		function addRemoveNestedIcu(remove4, index, depth) {
		  if (depth === 0) {
			 remove4.push(~index);
			 remove4.push(index);
		  }
		}
		function addUpdateIcuSwitch(update, icuExpression, index) {
		  update.push(
			 toMaskBit(icuExpression.mainBinding),
			 2,
			 -1 - icuExpression.mainBinding,
			 index << 2 | 2
			 /* I18nUpdateOpCode.IcuSwitch */
		  );
		}
		function addUpdateIcuUpdate(update, bindingMask, index) {
		  update.push(
			 bindingMask,
			 1,
			 index << 2 | 3
			 /* I18nUpdateOpCode.IcuUpdate */
		  );
		}
		function addCreateNodeAndAppend(create2, marker, text, appendToParentIdx, createAtIdx) {
		  if (marker !== null) {
			 create2.push(marker);
		  }
		  create2.push(text, createAtIdx, icuCreateOpCode(0, appendToParentIdx, createAtIdx));
		}
		function addCreateAttribute(create2, newIndex, attr) {
		  create2.push(newIndex << 1 | 1, attr.name, attr.value);
		}
		var ROOT_TEMPLATE_ID = 0;
		var PP_MULTI_VALUE_PLACEHOLDERS_REGEXP = /\[(.+??)\]/;
		var PP_PLACEHOLDERS_REGEXP = /\[(.+??)\]|(\/?\*\d+:\d+)/g;
		var PP_ICU_VARS_REGEXP = /({\s*)(VAR_(PLURAL|SELECT)(_\d+)?)(\s*,)/g;
		var PP_ICU_PLACEHOLDERS_REGEXP = /{([A-Z0-9_]+)}/g;
		var PP_ICUS_REGEXP = /I18N_EXP_(ICU(_\d+)?)/g;
		var PP_CLOSE_TEMPLATE_REGEXP = /\/\*/;
		var PP_TEMPLATE_ID_REGEXP = /\d+\:(\d+)/;
		function i18nPostprocess(message2, replacements = {}) {
		  let result = message2;
		  if (PP_MULTI_VALUE_PLACEHOLDERS_REGEXP.test(message2)) {
			 const matches = {};
			 const templateIdsStack = [ROOT_TEMPLATE_ID];
			 result = result.replace(PP_PLACEHOLDERS_REGEXP, (m, phs, tmpl) => {
				const content = phs || tmpl;
				const placeholders = matches[content] || [];
				if (!placeholders.length) {
				  content.split("|").forEach((placeholder2) => {
					 const match23 = placeholder2.match(PP_TEMPLATE_ID_REGEXP);
					 const templateId2 = match23 ? parseInt(match23[1], 10) : ROOT_TEMPLATE_ID;
					 const isCloseTemplateTag2 = PP_CLOSE_TEMPLATE_REGEXP.test(placeholder2);
					 placeholders.push([templateId2, isCloseTemplateTag2, placeholder2]);
				  });
				  matches[content] = placeholders;
				}
				if (!placeholders.length) {
				  throw new Error(`i18n postprocess: unmatched placeholder - ${content}`);
				}
				const currentTemplateId = templateIdsStack[templateIdsStack.length - 1];
				let idx = 0;
				for (let i = 0; i < placeholders.length; i++) {
				  if (placeholders[i][0] === currentTemplateId) {
					 idx = i;
					 break;
				  }
				}
				const [templateId, isCloseTemplateTag, placeholder] = placeholders[idx];
				if (isCloseTemplateTag) {
				  templateIdsStack.pop();
				} else if (currentTemplateId !== templateId) {
				  templateIdsStack.push(templateId);
				}
				placeholders.splice(idx, 1);
				return placeholder;
			 });
		  }
		  if (!Object.keys(replacements).length) {
			 return result;
		  }
		  result = result.replace(PP_ICU_VARS_REGEXP, (match23, start2, key, _type, _idx, end) => {
			 return replacements.hasOwnProperty(key) ? `${start2}${replacements[key]}${end}` : match23;
		  });
		  result = result.replace(PP_ICU_PLACEHOLDERS_REGEXP, (match23, key) => {
			 return replacements.hasOwnProperty(key) ? replacements[key] : match23;
		  });
		  result = result.replace(PP_ICUS_REGEXP, (match23, key) => {
			 if (replacements.hasOwnProperty(key)) {
				const list = replacements[key];
				if (!list.length) {
				  throw new Error(`i18n postprocess: unmatched ICU - ${match23} with key: ${key}`);
				}
				return list.shift();
			 }
			 return match23;
		  });
		  return result;
		}
		function \u0275\u0275i18nStart(index, messageIndex, subTemplateIndex = -1) {
		  const tView = getTView();
		  const lView = getLView();
		  const adjustedIndex = HEADER_OFFSET + index;
		  ngDevMode && assertDefined(tView, `tView should be defined`);
		  const message2 = getConstant(tView.consts, messageIndex);
		  const parentTNode = getCurrentParentTNode();
		  if (tView.firstCreatePass) {
			 i18nStartFirstCreatePass(tView, parentTNode === null ? 0 : parentTNode.index, lView, adjustedIndex, message2, subTemplateIndex);
		  }
		  if (tView.type === 2) {
			 const componentLView = lView[DECLARATION_COMPONENT_VIEW];
			 componentLView[FLAGS] |= 32;
		  } else {
			 lView[FLAGS] |= 32;
		  }
		  const tI18n = tView.data[adjustedIndex];
		  const sameViewParentTNode = parentTNode === lView[T_HOST] ? null : parentTNode;
		  const parentRNode = getClosestRElement(tView, sameViewParentTNode, lView);
		  const insertInFrontOf = parentTNode && parentTNode.type & 8 ? lView[parentTNode.index] : null;
		  applyCreateOpCodes(lView, tI18n.create, parentRNode, insertInFrontOf);
		  setInI18nBlock(true);
		}
		function \u0275\u0275i18nEnd() {
		  setInI18nBlock(false);
		}
		function \u0275\u0275i18n(index, messageIndex, subTemplateIndex) {
		  \u0275\u0275i18nStart(index, messageIndex, subTemplateIndex);
		  \u0275\u0275i18nEnd();
		}
		function \u0275\u0275i18nAttributes(index, attrsIndex) {
		  const tView = getTView();
		  ngDevMode && assertDefined(tView, `tView should be defined`);
		  const attrs = getConstant(tView.consts, attrsIndex);
		  i18nAttributesFirstPass(tView, index + HEADER_OFFSET, attrs);
		}
		function \u0275\u0275i18nExp(value) {
		  const lView = getLView();
		  setMaskBit(bindingUpdated(lView, nextBindingIndex(), value));
		  return \u0275\u0275i18nExp;
		}
		function \u0275\u0275i18nApply(index) {
		  applyI18n(getTView(), getLView(), index + HEADER_OFFSET);
		}
		function \u0275\u0275i18nPostprocess(message2, replacements = {}) {
		  return i18nPostprocess(message2, replacements);
		}
		function \u0275\u0275listener(eventName, listenerFn, useCapture, eventTargetResolver) {
		  const lView = getLView();
		  const tView = getTView();
		  const tNode = getCurrentTNode();
		  listenerInternal(tView, lView, lView[RENDERER], tNode, eventName, listenerFn, eventTargetResolver);
		  return \u0275\u0275listener;
		}
		function \u0275\u0275syntheticHostListener(eventName, listenerFn) {
		  const tNode = getCurrentTNode();
		  const lView = getLView();
		  const tView = getTView();
		  const currentDef = getCurrentDirectiveDef(tView.data);
		  const renderer = loadComponentRenderer(currentDef, tNode, lView);
		  listenerInternal(tView, lView, renderer, tNode, eventName, listenerFn);
		  return \u0275\u0275syntheticHostListener;
		}
		function findExistingListener(tView, lView, eventName, tNodeIdx) {
		  const tCleanup = tView.cleanup;
		  if (tCleanup != null) {
			 for (let i = 0; i < tCleanup.length - 1; i += 2) {
				const cleanupEventName = tCleanup[i];
				if (cleanupEventName === eventName && tCleanup[i + 1] === tNodeIdx) {
				  const lCleanup = lView[CLEANUP];
				  const listenerIdxInLCleanup = tCleanup[i + 2];
				  return lCleanup.length > listenerIdxInLCleanup ? lCleanup[listenerIdxInLCleanup] : null;
				}
				if (typeof cleanupEventName === "string") {
				  i += 2;
				}
			 }
		  }
		  return null;
		}
		function listenerInternal(tView, lView, renderer, tNode, eventName, listenerFn, eventTargetResolver) {
		  const isTNodeDirectiveHost = isDirectiveHost(tNode);
		  const firstCreatePass = tView.firstCreatePass;
		  const tCleanup = firstCreatePass && getOrCreateTViewCleanup(tView);
		  const context2 = lView[CONTEXT];
		  const lCleanup = getOrCreateLViewCleanup(lView);
		  ngDevMode && assertTNodeType(
			 tNode,
			 3 | 12
			 /* TNodeType.AnyContainer */
		  );
		  let processOutputs = true;
		  if (tNode.type & 3 || eventTargetResolver) {
			 const native = getNativeByTNode(tNode, lView);
			 const target = eventTargetResolver ? eventTargetResolver(native) : native;
			 const lCleanupIndex = lCleanup.length;
			 const idxOrTargetGetter = eventTargetResolver ? (_lView) => eventTargetResolver(unwrapRNode(_lView[tNode.index])) : tNode.index;
			 let existingListener = null;
			 if (!eventTargetResolver && isTNodeDirectiveHost) {
				existingListener = findExistingListener(tView, lView, eventName, tNode.index);
			 }
			 if (existingListener !== null) {
				const lastListenerFn = existingListener.__ngLastListenerFn__ || existingListener;
				lastListenerFn.__ngNextListenerFn__ = listenerFn;
				existingListener.__ngLastListenerFn__ = listenerFn;
				processOutputs = false;
			 } else {
				listenerFn = wrapListener(
				  tNode,
				  lView,
				  context2,
				  listenerFn,
				  false
				  /** preventDefault */
				);
				const cleanupFn = renderer.listen(target, eventName, listenerFn);
				ngDevMode && ngDevMode.rendererAddEventListener++;
				lCleanup.push(listenerFn, cleanupFn);
				tCleanup && tCleanup.push(eventName, idxOrTargetGetter, lCleanupIndex, lCleanupIndex + 1);
			 }
		  } else {
			 listenerFn = wrapListener(
				tNode,
				lView,
				context2,
				listenerFn,
				false
				/** preventDefault */
			 );
		  }
		  const outputs = tNode.outputs;
		  let props;
		  if (processOutputs && outputs !== null && (props = outputs[eventName])) {
			 const propsLength = props.length;
			 if (propsLength) {
				for (let i = 0; i < propsLength; i += 2) {
				  const index = props[i];
				  ngDevMode && assertIndexInRange(lView, index);
				  const minifiedName = props[i + 1];
				  const directiveInstance = lView[index];
				  const output = directiveInstance[minifiedName];
				  if (ngDevMode && !isOutputSubscribable(output)) {
					 throw new Error(`@Output ${minifiedName} not initialized in '${directiveInstance.constructor.name}'.`);
				  }
				  const subscription = output.subscribe(listenerFn);
				  const idx = lCleanup.length;
				  lCleanup.push(listenerFn, subscription);
				  tCleanup && tCleanup.push(eventName, tNode.index, idx, -(idx + 1));
				}
			 }
		  }
		}
		function executeListenerWithErrorHandling(lView, context2, listenerFn, e) {
		  const prevConsumer = setActiveConsumer(null);
		  try {
			 profiler(6, context2, listenerFn);
			 return listenerFn(e) !== false;
		  } catch (error) {
			 handleError(lView, error);
			 return false;
		  } finally {
			 profiler(7, context2, listenerFn);
			 setActiveConsumer(prevConsumer);
		  }
		}
		function wrapListener(tNode, lView, context2, listenerFn, wrapWithPreventDefault) {
		  return function wrapListenerIn_markDirtyAndPreventDefault(e) {
			 if (e === Function) {
				return listenerFn;
			 }
			 const startView = tNode.componentOffset > -1 ? getComponentLViewByIndex(tNode.index, lView) : lView;
			 markViewDirty(startView);
			 let result = executeListenerWithErrorHandling(lView, context2, listenerFn, e);
			 let nextListenerFn = wrapListenerIn_markDirtyAndPreventDefault.__ngNextListenerFn__;
			 while (nextListenerFn) {
				result = executeListenerWithErrorHandling(lView, context2, nextListenerFn, e) && result;
				nextListenerFn = nextListenerFn.__ngNextListenerFn__;
			 }
			 if (wrapWithPreventDefault && result === false) {
				e.preventDefault();
			 }
			 return result;
		  };
		}
		function isOutputSubscribable(value) {
		  return value != null && typeof value.subscribe === "function";
		}
		function \u0275\u0275nextContext(level = 1) {
		  return nextContextImpl(level);
		}
		function matchingProjectionSlotIndex(tNode, projectionSlots) {
		  let wildcardNgContentIndex = null;
		  const ngProjectAsAttrVal = getProjectAsAttrValue(tNode);
		  for (let i = 0; i < projectionSlots.length; i++) {
			 const slotValue = projectionSlots[i];
			 if (slotValue === "*") {
				wildcardNgContentIndex = i;
				continue;
			 }
			 if (ngProjectAsAttrVal === null ? isNodeMatchingSelectorList(
				tNode,
				slotValue,
				/* isProjectionMode */
				true
			 ) : isSelectorInSelectorList(ngProjectAsAttrVal, slotValue)) {
				return i;
			 }
		  }
		  return wildcardNgContentIndex;
		}
		function \u0275\u0275projectionDef(projectionSlots) {
		  const componentNode = getLView()[DECLARATION_COMPONENT_VIEW][T_HOST];
		  if (!componentNode.projection) {
			 const numProjectionSlots = projectionSlots ? projectionSlots.length : 1;
			 const projectionHeads = componentNode.projection = newArray(numProjectionSlots, null);
			 const tails = projectionHeads.slice();
			 let componentChild = componentNode.child;
			 while (componentChild !== null) {
				const slotIndex = projectionSlots ? matchingProjectionSlotIndex(componentChild, projectionSlots) : 0;
				if (slotIndex !== null) {
				  if (tails[slotIndex]) {
					 tails[slotIndex].projectionNext = componentChild;
				  } else {
					 projectionHeads[slotIndex] = componentChild;
				  }
				  tails[slotIndex] = componentChild;
				}
				componentChild = componentChild.next;
			 }
		  }
		}
		function \u0275\u0275projection(nodeIndex, selectorIndex = 0, attrs) {
		  const lView = getLView();
		  const tView = getTView();
		  const tProjectionNode = getOrCreateTNode(tView, HEADER_OFFSET + nodeIndex, 16, null, attrs || null);
		  if (tProjectionNode.projection === null)
			 tProjectionNode.projection = selectorIndex;
		  setCurrentTNodeAsNotParent();
		  const hydrationInfo = lView[HYDRATION];
		  const isNodeCreationMode = !hydrationInfo || isInSkipHydrationBlock$1();
		  if (isNodeCreationMode && (tProjectionNode.flags & 32) !== 32) {
			 applyProjection(tView, lView, tProjectionNode);
		  }
		}
		function \u0275\u0275propertyInterpolate(propName, v0, sanitizer) {
		  \u0275\u0275propertyInterpolate1(propName, "", v0, "", sanitizer);
		  return \u0275\u0275propertyInterpolate;
		}
		function \u0275\u0275propertyInterpolate1(propName, prefix, v0, suffix, sanitizer) {
		  const lView = getLView();
		  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);
		  if (interpolatedValue !== NO_CHANGE) {
			 const tView = getTView();
			 const tNode = getSelectedTNode();
			 elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
			 ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 1, prefix, suffix);
		  }
		  return \u0275\u0275propertyInterpolate1;
		}
		function \u0275\u0275propertyInterpolate2(propName, prefix, v0, i0, v1, suffix, sanitizer) {
		  const lView = getLView();
		  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);
		  if (interpolatedValue !== NO_CHANGE) {
			 const tView = getTView();
			 const tNode = getSelectedTNode();
			 elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
			 ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 2, prefix, i0, suffix);
		  }
		  return \u0275\u0275propertyInterpolate2;
		}
		function \u0275\u0275propertyInterpolate3(propName, prefix, v0, i0, v1, i1, v2, suffix, sanitizer) {
		  const lView = getLView();
		  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);
		  if (interpolatedValue !== NO_CHANGE) {
			 const tView = getTView();
			 const tNode = getSelectedTNode();
			 elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
			 ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 3, prefix, i0, i1, suffix);
		  }
		  return \u0275\u0275propertyInterpolate3;
		}
		function \u0275\u0275propertyInterpolate4(propName, prefix, v0, i0, v1, i1, v2, i2, v3, suffix, sanitizer) {
		  const lView = getLView();
		  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
		  if (interpolatedValue !== NO_CHANGE) {
			 const tView = getTView();
			 const tNode = getSelectedTNode();
			 elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
			 ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 4, prefix, i0, i1, i2, suffix);
		  }
		  return \u0275\u0275propertyInterpolate4;
		}
		function \u0275\u0275propertyInterpolate5(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix, sanitizer) {
		  const lView = getLView();
		  const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
		  if (interpolatedValue !== NO_CHANGE) {
			 const tView = getTView();
			 const tNode = getSelectedTNode();
			 elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
			 ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 5, prefix, i0, i1, i2, i3, suffix);
		  }
		  return \u0275\u0275propertyInterpolate5;
		}
		function \u0275\u0275propertyInterpolate6(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix, sanitizer) {
		  const lView = getLView();
		  const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
		  if (interpolatedValue !== NO_CHANGE) {
			 const tView = getTView();
			 const tNode = getSelectedTNode();
			 elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
			 ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 6, prefix, i0, i1, i2, i3, i4, suffix);
		  }
		  return \u0275\u0275propertyInterpolate6;
		}
		function \u0275\u0275propertyInterpolate7(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix, sanitizer) {
		  const lView = getLView();
		  const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
		  if (interpolatedValue !== NO_CHANGE) {
			 const tView = getTView();
			 const tNode = getSelectedTNode();
			 elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
			 ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 7, prefix, i0, i1, i2, i3, i4, i5, suffix);
		  }
		  return \u0275\u0275propertyInterpolate7;
		}
		function \u0275\u0275propertyInterpolate8(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix, sanitizer) {
		  const lView = getLView();
		  const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
		  if (interpolatedValue !== NO_CHANGE) {
			 const tView = getTView();
			 const tNode = getSelectedTNode();
			 elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
			 ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 8, prefix, i0, i1, i2, i3, i4, i5, i6, suffix);
		  }
		  return \u0275\u0275propertyInterpolate8;
		}
		function \u0275\u0275propertyInterpolateV(propName, values, sanitizer) {
		  const lView = getLView();
		  const interpolatedValue = interpolationV(lView, values);
		  if (interpolatedValue !== NO_CHANGE) {
			 const tView = getTView();
			 const tNode = getSelectedTNode();
			 elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
			 if (ngDevMode) {
				const interpolationInBetween = [values[0]];
				for (let i = 2; i < values.length; i += 2) {
				  interpolationInBetween.push(values[i]);
				}
				storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - interpolationInBetween.length + 1, ...interpolationInBetween);
			 }
		  }
		  return \u0275\u0275propertyInterpolateV;
		}
		function \u0275\u0275contentQuery(directiveIndex, predicate, flags, read) {
		  createContentQuery(directiveIndex, predicate, flags, read);
		}
		function \u0275\u0275viewQuery(predicate, flags, read) {
		  createViewQuery(predicate, flags, read);
		}
		function \u0275\u0275queryRefresh(queryList) {
		  const lView = getLView();
		  const tView = getTView();
		  const queryIndex = getCurrentQueryIndex();
		  setCurrentQueryIndex(queryIndex + 1);
		  const tQuery = getTQuery(tView, queryIndex);
		  if (queryList.dirty && isCreationMode(lView) === ((tQuery.metadata.flags & 2) === 2)) {
			 if (tQuery.matches === null) {
				queryList.reset([]);
			 } else {
				const result = getQueryResults(lView, queryIndex);
				queryList.reset(result, unwrapElementRef);
				queryList.notifyOnChanges();
			 }
			 return true;
		  }
		  return false;
		}
		function \u0275\u0275loadQuery() {
		  return loadQueryInternal(getLView(), getCurrentQueryIndex());
		}
		function \u0275\u0275contentQuerySignal(directiveIndex, target, predicate, flags, read) {
		  bindQueryToSignal(target, createContentQuery(directiveIndex, predicate, flags, read));
		}
		function \u0275\u0275viewQuerySignal(target, predicate, flags, read) {
		  bindQueryToSignal(target, createViewQuery(predicate, flags, read));
		}
		function \u0275\u0275queryAdvance(indexOffset = 1) {
		  setCurrentQueryIndex(getCurrentQueryIndex() + indexOffset);
		}
		function store(tView, lView, index, value) {
		  if (index >= tView.data.length) {
			 tView.data[index] = null;
			 tView.blueprint[index] = null;
		  }
		  lView[index] = value;
		}
		function \u0275\u0275reference(index) {
		  const contextLView = getContextLView();
		  return load(contextLView, HEADER_OFFSET + index);
		}
		function \u0275\u0275styleMapInterpolate1(prefix, v0, suffix) {
		  const lView = getLView();
		  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);
		  \u0275\u0275styleMap(interpolatedValue);
		}
		function \u0275\u0275styleMapInterpolate2(prefix, v0, i0, v1, suffix) {
		  const lView = getLView();
		  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);
		  \u0275\u0275styleMap(interpolatedValue);
		}
		function \u0275\u0275styleMapInterpolate3(prefix, v0, i0, v1, i1, v2, suffix) {
		  const lView = getLView();
		  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);
		  \u0275\u0275styleMap(interpolatedValue);
		}
		function \u0275\u0275styleMapInterpolate4(prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {
		  const lView = getLView();
		  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
		  \u0275\u0275styleMap(interpolatedValue);
		}
		function \u0275\u0275styleMapInterpolate5(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {
		  const lView = getLView();
		  const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
		  \u0275\u0275styleMap(interpolatedValue);
		}
		function \u0275\u0275styleMapInterpolate6(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {
		  const lView = getLView();
		  const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
		  \u0275\u0275styleMap(interpolatedValue);
		}
		function \u0275\u0275styleMapInterpolate7(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {
		  const lView = getLView();
		  const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
		  \u0275\u0275styleMap(interpolatedValue);
		}
		function \u0275\u0275styleMapInterpolate8(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {
		  const lView = getLView();
		  const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
		  \u0275\u0275styleMap(interpolatedValue);
		}
		function \u0275\u0275styleMapInterpolateV(values) {
		  const lView = getLView();
		  const interpolatedValue = interpolationV(lView, values);
		  \u0275\u0275styleMap(interpolatedValue);
		}
		function \u0275\u0275stylePropInterpolate1(prop, prefix, v0, suffix, valueSuffix) {
		  const lView = getLView();
		  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);
		  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
		  return \u0275\u0275stylePropInterpolate1;
		}
		function \u0275\u0275stylePropInterpolate2(prop, prefix, v0, i0, v1, suffix, valueSuffix) {
		  const lView = getLView();
		  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);
		  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
		  return \u0275\u0275stylePropInterpolate2;
		}
		function \u0275\u0275stylePropInterpolate3(prop, prefix, v0, i0, v1, i1, v2, suffix, valueSuffix) {
		  const lView = getLView();
		  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);
		  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
		  return \u0275\u0275stylePropInterpolate3;
		}
		function \u0275\u0275stylePropInterpolate4(prop, prefix, v0, i0, v1, i1, v2, i2, v3, suffix, valueSuffix) {
		  const lView = getLView();
		  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
		  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
		  return \u0275\u0275stylePropInterpolate4;
		}
		function \u0275\u0275stylePropInterpolate5(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix, valueSuffix) {
		  const lView = getLView();
		  const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
		  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
		  return \u0275\u0275stylePropInterpolate5;
		}
		function \u0275\u0275stylePropInterpolate6(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix, valueSuffix) {
		  const lView = getLView();
		  const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
		  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
		  return \u0275\u0275stylePropInterpolate6;
		}
		function \u0275\u0275stylePropInterpolate7(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix, valueSuffix) {
		  const lView = getLView();
		  const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
		  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
		  return \u0275\u0275stylePropInterpolate7;
		}
		function \u0275\u0275stylePropInterpolate8(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix, valueSuffix) {
		  const lView = getLView();
		  const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
		  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
		  return \u0275\u0275stylePropInterpolate8;
		}
		function \u0275\u0275stylePropInterpolateV(prop, values, valueSuffix) {
		  const lView = getLView();
		  const interpolatedValue = interpolationV(lView, values);
		  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
		  return \u0275\u0275stylePropInterpolateV;
		}
		function \u0275\u0275text(index, value = "") {
		  const lView = getLView();
		  const tView = getTView();
		  const adjustedIndex = index + HEADER_OFFSET;
		  ngDevMode && assertEqual(getBindingIndex(), tView.bindingStartIndex, "text nodes should be created before any bindings");
		  ngDevMode && assertIndexInRange(lView, adjustedIndex);
		  const tNode = tView.firstCreatePass ? getOrCreateTNode(tView, adjustedIndex, 1, value, null) : tView.data[adjustedIndex];
		  const textNative = _locateOrCreateTextNode(tView, lView, tNode, value, index);
		  lView[adjustedIndex] = textNative;
		  if (wasLastNodeCreated()) {
			 appendChild(tView, lView, textNative, tNode);
		  }
		  setCurrentTNode(tNode, false);
		}
		var _locateOrCreateTextNode = (tView, lView, tNode, value, index) => {
		  lastNodeWasCreated(true);
		  return createTextNode(lView[RENDERER], value);
		};
		function \u0275\u0275textInterpolate(v0) {
		  \u0275\u0275textInterpolate1("", v0, "");
		  return \u0275\u0275textInterpolate;
		}
		function \u0275\u0275textInterpolate1(prefix, v0, suffix) {
		  const lView = getLView();
		  const interpolated = interpolation1(lView, prefix, v0, suffix);
		  if (interpolated !== NO_CHANGE) {
			 textBindingInternal(lView, getSelectedIndex(), interpolated);
		  }
		  return \u0275\u0275textInterpolate1;
		}
		function \u0275\u0275textInterpolate2(prefix, v0, i0, v1, suffix) {
		  const lView = getLView();
		  const interpolated = interpolation2(lView, prefix, v0, i0, v1, suffix);
		  if (interpolated !== NO_CHANGE) {
			 textBindingInternal(lView, getSelectedIndex(), interpolated);
		  }
		  return \u0275\u0275textInterpolate2;
		}
		function \u0275\u0275textInterpolate3(prefix, v0, i0, v1, i1, v2, suffix) {
		  const lView = getLView();
		  const interpolated = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);
		  if (interpolated !== NO_CHANGE) {
			 textBindingInternal(lView, getSelectedIndex(), interpolated);
		  }
		  return \u0275\u0275textInterpolate3;
		}
		function \u0275\u0275textInterpolate4(prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {
		  const lView = getLView();
		  const interpolated = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
		  if (interpolated !== NO_CHANGE) {
			 textBindingInternal(lView, getSelectedIndex(), interpolated);
		  }
		  return \u0275\u0275textInterpolate4;
		}
		function \u0275\u0275textInterpolate5(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {
		  const lView = getLView();
		  const interpolated = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
		  if (interpolated !== NO_CHANGE) {
			 textBindingInternal(lView, getSelectedIndex(), interpolated);
		  }
		  return \u0275\u0275textInterpolate5;
		}
		function \u0275\u0275textInterpolate6(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {
		  const lView = getLView();
		  const interpolated = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
		  if (interpolated !== NO_CHANGE) {
			 textBindingInternal(lView, getSelectedIndex(), interpolated);
		  }
		  return \u0275\u0275textInterpolate6;
		}
		function \u0275\u0275textInterpolate7(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {
		  const lView = getLView();
		  const interpolated = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
		  if (interpolated !== NO_CHANGE) {
			 textBindingInternal(lView, getSelectedIndex(), interpolated);
		  }
		  return \u0275\u0275textInterpolate7;
		}
		function \u0275\u0275textInterpolate8(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {
		  const lView = getLView();
		  const interpolated = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
		  if (interpolated !== NO_CHANGE) {
			 textBindingInternal(lView, getSelectedIndex(), interpolated);
		  }
		  return \u0275\u0275textInterpolate8;
		}
		function \u0275\u0275textInterpolateV(values) {
		  const lView = getLView();
		  const interpolated = interpolationV(lView, values);
		  if (interpolated !== NO_CHANGE) {
			 textBindingInternal(lView, getSelectedIndex(), interpolated);
		  }
		  return \u0275\u0275textInterpolateV;
		}
		function \u0275\u0275twoWayProperty(propName, value, sanitizer) {
		  if (isWritableSignal(value)) {
			 value = value();
		  }
		  const lView = getLView();
		  const bindingIndex = nextBindingIndex();
		  if (bindingUpdated(lView, bindingIndex, value)) {
			 const tView = getTView();
			 const tNode = getSelectedTNode();
			 elementPropertyInternal(tView, tNode, lView, propName, value, lView[RENDERER], sanitizer, false);
			 ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);
		  }
		  return \u0275\u0275twoWayProperty;
		}
		function \u0275\u0275twoWayBindingSet(target, value) {
		  const canWrite = isWritableSignal(target);
		  canWrite && target.set(value);
		  return canWrite;
		}
		function \u0275\u0275twoWayListener(eventName, listenerFn) {
		  const lView = getLView();
		  const tView = getTView();
		  const tNode = getCurrentTNode();
		  listenerInternal(tView, lView, lView[RENDERER], tNode, eventName, listenerFn);
		  return \u0275\u0275twoWayListener;
		}
		function providersResolver(def, providers, viewProviders) {
		  const tView = getTView();
		  if (tView.firstCreatePass) {
			 const isComponent2 = isComponentDef(def);
			 resolveProvider(viewProviders, tView.data, tView.blueprint, isComponent2, true);
			 resolveProvider(providers, tView.data, tView.blueprint, isComponent2, false);
		  }
		}
		function resolveProvider(provider, tInjectables, lInjectablesBlueprint, isComponent2, isViewProvider) {
		  provider = resolveForwardRef(provider);
		  if (Array.isArray(provider)) {
			 for (let i = 0; i < provider.length; i++) {
				resolveProvider(provider[i], tInjectables, lInjectablesBlueprint, isComponent2, isViewProvider);
			 }
		  } else {
			 const tView = getTView();
			 const lView = getLView();
			 const tNode = getCurrentTNode();
			 let token = isTypeProvider(provider) ? provider : resolveForwardRef(provider.provide);
			 const providerFactory = providerToFactory(provider);
			 if (ngDevMode) {
				const injector = new NodeInjector(tNode, lView);
				runInInjectorProfilerContext(injector, token, () => {
				  emitProviderConfiguredEvent(provider, isViewProvider);
				});
			 }
			 const beginIndex = tNode.providerIndexes & 1048575;
			 const endIndex = tNode.directiveStart;
			 const cptViewProvidersCount = tNode.providerIndexes >> 20;
			 if (isTypeProvider(provider) || !provider.multi) {
				const factory = new NodeInjectorFactory(providerFactory, isViewProvider, \u0275\u0275directiveInject);
				const existingFactoryIndex = indexOf(token, tInjectables, isViewProvider ? beginIndex : beginIndex + cptViewProvidersCount, endIndex);
				if (existingFactoryIndex === -1) {
				  diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, token);
				  registerDestroyHooksIfSupported(tView, provider, tInjectables.length);
				  tInjectables.push(token);
				  tNode.directiveStart++;
				  tNode.directiveEnd++;
				  if (isViewProvider) {
					 tNode.providerIndexes += 1048576;
				  }
				  lInjectablesBlueprint.push(factory);
				  lView.push(factory);
				} else {
				  lInjectablesBlueprint[existingFactoryIndex] = factory;
				  lView[existingFactoryIndex] = factory;
				}
			 } else {
				const existingProvidersFactoryIndex = indexOf(token, tInjectables, beginIndex + cptViewProvidersCount, endIndex);
				const existingViewProvidersFactoryIndex = indexOf(token, tInjectables, beginIndex, beginIndex + cptViewProvidersCount);
				const doesProvidersFactoryExist = existingProvidersFactoryIndex >= 0 && lInjectablesBlueprint[existingProvidersFactoryIndex];
				const doesViewProvidersFactoryExist = existingViewProvidersFactoryIndex >= 0 && lInjectablesBlueprint[existingViewProvidersFactoryIndex];
				if (isViewProvider && !doesViewProvidersFactoryExist || !isViewProvider && !doesProvidersFactoryExist) {
				  diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, token);
				  const factory = multiFactory(isViewProvider ? multiViewProvidersFactoryResolver : multiProvidersFactoryResolver, lInjectablesBlueprint.length, isViewProvider, isComponent2, providerFactory);
				  if (!isViewProvider && doesViewProvidersFactoryExist) {
					 lInjectablesBlueprint[existingViewProvidersFactoryIndex].providerFactory = factory;
				  }
				  registerDestroyHooksIfSupported(tView, provider, tInjectables.length, 0);
				  tInjectables.push(token);
				  tNode.directiveStart++;
				  tNode.directiveEnd++;
				  if (isViewProvider) {
					 tNode.providerIndexes += 1048576;
				  }
				  lInjectablesBlueprint.push(factory);
				  lView.push(factory);
				} else {
				  const indexInFactory = multiFactoryAdd(lInjectablesBlueprint[isViewProvider ? existingViewProvidersFactoryIndex : existingProvidersFactoryIndex], providerFactory, !isViewProvider && isComponent2);
				  registerDestroyHooksIfSupported(tView, provider, existingProvidersFactoryIndex > -1 ? existingProvidersFactoryIndex : existingViewProvidersFactoryIndex, indexInFactory);
				}
				if (!isViewProvider && isComponent2 && doesViewProvidersFactoryExist) {
				  lInjectablesBlueprint[existingViewProvidersFactoryIndex].componentProviders++;
				}
			 }
		  }
		}
		function registerDestroyHooksIfSupported(tView, provider, contextIndex, indexInFactory) {
		  const providerIsTypeProvider = isTypeProvider(provider);
		  const providerIsClassProvider = isClassProvider(provider);
		  if (providerIsTypeProvider || providerIsClassProvider) {
			 const classToken = providerIsClassProvider ? resolveForwardRef(provider.useClass) : provider;
			 const prototype = classToken.prototype;
			 const ngOnDestroy = prototype.ngOnDestroy;
			 if (ngOnDestroy) {
				const hooks = tView.destroyHooks || (tView.destroyHooks = []);
				if (!providerIsTypeProvider && provider.multi) {
				  ngDevMode && assertDefined(indexInFactory, "indexInFactory when registering multi factory destroy hook");
				  const existingCallbacksIndex = hooks.indexOf(contextIndex);
				  if (existingCallbacksIndex === -1) {
					 hooks.push(contextIndex, [indexInFactory, ngOnDestroy]);
				  } else {
					 hooks[existingCallbacksIndex + 1].push(indexInFactory, ngOnDestroy);
				  }
				} else {
				  hooks.push(contextIndex, ngOnDestroy);
				}
			 }
		  }
		}
		function multiFactoryAdd(multiFactory2, factory, isComponentProvider) {
		  if (isComponentProvider) {
			 multiFactory2.componentProviders++;
		  }
		  return multiFactory2.multi.push(factory) - 1;
		}
		function indexOf(item, arr, begin, end) {
		  for (let i = begin; i < end; i++) {
			 if (arr[i] === item)
				return i;
		  }
		  return -1;
		}
		function multiProvidersFactoryResolver(_2, tData, lData, tNode) {
		  return multiResolve(this.multi, []);
		}
		function multiViewProvidersFactoryResolver(_2, tData, lView, tNode) {
		  const factories = this.multi;
		  let result;
		  if (this.providerFactory) {
			 const componentCount = this.providerFactory.componentProviders;
			 const multiProviders = getNodeInjectable(lView, lView[TVIEW], this.providerFactory.index, tNode);
			 result = multiProviders.slice(0, componentCount);
			 multiResolve(factories, result);
			 for (let i = componentCount; i < multiProviders.length; i++) {
				result.push(multiProviders[i]);
			 }
		  } else {
			 result = [];
			 multiResolve(factories, result);
		  }
		  return result;
		}
		function multiResolve(factories, result) {
		  for (let i = 0; i < factories.length; i++) {
			 const factory = factories[i];
			 result.push(factory());
		  }
		  return result;
		}
		function multiFactory(factoryFn, index, isViewProvider, isComponent2, f) {
		  const factory = new NodeInjectorFactory(factoryFn, isViewProvider, \u0275\u0275directiveInject);
		  factory.multi = [];
		  factory.index = index;
		  factory.componentProviders = 0;
		  multiFactoryAdd(factory, f, isComponent2 && !isViewProvider);
		  return factory;
		}
		function \u0275\u0275ProvidersFeature(providers, viewProviders = []) {
		  return (definition) => {
			 definition.providersResolver = (def, processProvidersFn) => {
				return providersResolver(
				  def,
				  //
				  processProvidersFn ? processProvidersFn(providers) : providers,
				  //
				  viewProviders
				);
			 };
		  };
		}
		var StandaloneService = class _StandaloneService {
		  constructor(_injector) {
			 this._injector = _injector;
			 this.cachedInjectors = /* @__PURE__ */ new Map();
		  }
		  getOrCreateStandaloneInjector(componentDef) {
			 if (!componentDef.standalone) {
				return null;
			 }
			 if (!this.cachedInjectors.has(componentDef)) {
				const providers = internalImportProvidersFrom(false, componentDef.type);
				const standaloneInjector = providers.length > 0 ? createEnvironmentInjector([providers], this._injector, `Standalone[${componentDef.type.name}]`) : null;
				this.cachedInjectors.set(componentDef, standaloneInjector);
			 }
			 return this.cachedInjectors.get(componentDef);
		  }
		  ngOnDestroy() {
			 try {
				for (const injector of this.cachedInjectors.values()) {
				  if (injector !== null) {
					 injector.destroy();
				  }
				}
			 } finally {
				this.cachedInjectors.clear();
			 }
		  }
		  static {
			 this.\u0275prov = \u0275\u0275defineInjectable({
				token: _StandaloneService,
				providedIn: "environment",
				factory: () => new _StandaloneService(\u0275\u0275inject(EnvironmentInjector))
			 });
		  }
		};
		function \u0275\u0275StandaloneFeature(definition) {
		  performanceMarkFeature("NgStandalone");
		  definition.getStandaloneInjector = (parentInjector) => {
			 return parentInjector.get(StandaloneService).getOrCreateStandaloneInjector(definition);
		  };
		}
		function \u0275\u0275setComponentScope(type2, directives, pipes) {
		  const def = type2.\u0275cmp;
		  def.directiveDefs = extractDefListOrFactory(
			 directives,
			 /* pipeDef */
			 false
		  );
		  def.pipeDefs = extractDefListOrFactory(
			 pipes,
			 /* pipeDef */
			 true
		  );
		}
		function \u0275\u0275setNgModuleScope(type2, scope) {
		  return noSideEffects(() => {
			 const ngModuleDef = getNgModuleDef(type2, true);
			 ngModuleDef.declarations = convertToTypeArray(scope.declarations || EMPTY_ARRAY);
			 ngModuleDef.imports = convertToTypeArray(scope.imports || EMPTY_ARRAY);
			 ngModuleDef.exports = convertToTypeArray(scope.exports || EMPTY_ARRAY);
			 if (scope.bootstrap) {
				ngModuleDef.bootstrap = convertToTypeArray(scope.bootstrap);
			 }
			 depsTracker.registerNgModule(type2, scope);
		  });
		}
		function convertToTypeArray(values) {
		  if (typeof values === "function") {
			 return values;
		  }
		  const flattenValues = flatten(values);
		  if (flattenValues.some(isForwardRef)) {
			 return () => flattenValues.map(resolveForwardRef).map(maybeUnwrapModuleWithProviders);
		  } else {
			 return flattenValues.map(maybeUnwrapModuleWithProviders);
		  }
		}
		function maybeUnwrapModuleWithProviders(value) {
		  return isModuleWithProviders(value) ? value.ngModule : value;
		}
		function \u0275\u0275pureFunction0(slotOffset, pureFn, thisArg) {
		  const bindingIndex = getBindingRoot() + slotOffset;
		  const lView = getLView();
		  return lView[bindingIndex] === NO_CHANGE ? updateBinding(lView, bindingIndex, thisArg ? pureFn.call(thisArg) : pureFn()) : getBinding(lView, bindingIndex);
		}
		function \u0275\u0275pureFunction1(slotOffset, pureFn, exp, thisArg) {
		  return pureFunction1Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp, thisArg);
		}
		function \u0275\u0275pureFunction2(slotOffset, pureFn, exp1, exp2, thisArg) {
		  return pureFunction2Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, thisArg);
		}
		function \u0275\u0275pureFunction3(slotOffset, pureFn, exp1, exp2, exp3, thisArg) {
		  return pureFunction3Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, exp3, thisArg);
		}
		function \u0275\u0275pureFunction4(slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg) {
		  return pureFunction4Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg);
		}
		function \u0275\u0275pureFunction5(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, thisArg) {
		  const bindingIndex = getBindingRoot() + slotOffset;
		  const lView = getLView();
		  const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
		  return bindingUpdated(lView, bindingIndex + 4, exp5) || different ? updateBinding(lView, bindingIndex + 5, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5) : pureFn(exp1, exp2, exp3, exp4, exp5)) : getBinding(lView, bindingIndex + 5);
		}
		function \u0275\u0275pureFunction6(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, thisArg) {
		  const bindingIndex = getBindingRoot() + slotOffset;
		  const lView = getLView();
		  const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
		  return bindingUpdated2(lView, bindingIndex + 4, exp5, exp6) || different ? updateBinding(lView, bindingIndex + 6, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6) : pureFn(exp1, exp2, exp3, exp4, exp5, exp6)) : getBinding(lView, bindingIndex + 6);
		}
		function \u0275\u0275pureFunction7(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, exp7, thisArg) {
		  const bindingIndex = getBindingRoot() + slotOffset;
		  const lView = getLView();
		  let different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
		  return bindingUpdated3(lView, bindingIndex + 4, exp5, exp6, exp7) || different ? updateBinding(lView, bindingIndex + 7, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6, exp7) : pureFn(exp1, exp2, exp3, exp4, exp5, exp6, exp7)) : getBinding(lView, bindingIndex + 7);
		}
		function \u0275\u0275pureFunction8(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8, thisArg) {
		  const bindingIndex = getBindingRoot() + slotOffset;
		  const lView = getLView();
		  const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
		  return bindingUpdated4(lView, bindingIndex + 4, exp5, exp6, exp7, exp8) || different ? updateBinding(lView, bindingIndex + 8, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8) : pureFn(exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8)) : getBinding(lView, bindingIndex + 8);
		}
		function \u0275\u0275pureFunctionV(slotOffset, pureFn, exps, thisArg) {
		  return pureFunctionVInternal(getLView(), getBindingRoot(), slotOffset, pureFn, exps, thisArg);
		}
		function getPureFunctionReturnValue(lView, returnValueIndex) {
		  ngDevMode && assertIndexInRange(lView, returnValueIndex);
		  const lastReturnValue = lView[returnValueIndex];
		  return lastReturnValue === NO_CHANGE ? void 0 : lastReturnValue;
		}
		function pureFunction1Internal(lView, bindingRoot, slotOffset, pureFn, exp, thisArg) {
		  const bindingIndex = bindingRoot + slotOffset;
		  return bindingUpdated(lView, bindingIndex, exp) ? updateBinding(lView, bindingIndex + 1, thisArg ? pureFn.call(thisArg, exp) : pureFn(exp)) : getPureFunctionReturnValue(lView, bindingIndex + 1);
		}
		function pureFunction2Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, thisArg) {
		  const bindingIndex = bindingRoot + slotOffset;
		  return bindingUpdated2(lView, bindingIndex, exp1, exp2) ? updateBinding(lView, bindingIndex + 2, thisArg ? pureFn.call(thisArg, exp1, exp2) : pureFn(exp1, exp2)) : getPureFunctionReturnValue(lView, bindingIndex + 2);
		}
		function pureFunction3Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, exp3, thisArg) {
		  const bindingIndex = bindingRoot + slotOffset;
		  return bindingUpdated3(lView, bindingIndex, exp1, exp2, exp3) ? updateBinding(lView, bindingIndex + 3, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3) : pureFn(exp1, exp2, exp3)) : getPureFunctionReturnValue(lView, bindingIndex + 3);
		}
		function pureFunction4Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg) {
		  const bindingIndex = bindingRoot + slotOffset;
		  return bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4) ? updateBinding(lView, bindingIndex + 4, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4) : pureFn(exp1, exp2, exp3, exp4)) : getPureFunctionReturnValue(lView, bindingIndex + 4);
		}
		function pureFunctionVInternal(lView, bindingRoot, slotOffset, pureFn, exps, thisArg) {
		  let bindingIndex = bindingRoot + slotOffset;
		  let different = false;
		  for (let i = 0; i < exps.length; i++) {
			 bindingUpdated(lView, bindingIndex++, exps[i]) && (different = true);
		  }
		  return different ? updateBinding(lView, bindingIndex, pureFn.apply(thisArg, exps)) : getPureFunctionReturnValue(lView, bindingIndex);
		}
		function \u0275\u0275pipe(index, pipeName) {
		  const tView = getTView();
		  let pipeDef;
		  const adjustedIndex = index + HEADER_OFFSET;
		  if (tView.firstCreatePass) {
			 pipeDef = getPipeDef(pipeName, tView.pipeRegistry);
			 tView.data[adjustedIndex] = pipeDef;
			 if (pipeDef.onDestroy) {
				(tView.destroyHooks ??= []).push(adjustedIndex, pipeDef.onDestroy);
			 }
		  } else {
			 pipeDef = tView.data[adjustedIndex];
		  }
		  const pipeFactory = pipeDef.factory || (pipeDef.factory = getFactoryDef(pipeDef.type, true));
		  let previousInjectorProfilerContext;
		  if (ngDevMode) {
			 previousInjectorProfilerContext = setInjectorProfilerContext({
				injector: new NodeInjector(getCurrentTNode(), getLView()),
				token: pipeDef.type
			 });
		  }
		  const previousInjectImplementation = setInjectImplementation(\u0275\u0275directiveInject);
		  try {
			 const previousIncludeViewProviders = setIncludeViewProviders(false);
			 const pipeInstance = pipeFactory();
			 setIncludeViewProviders(previousIncludeViewProviders);
			 store(tView, getLView(), adjustedIndex, pipeInstance);
			 return pipeInstance;
		  } finally {
			 setInjectImplementation(previousInjectImplementation);
			 ngDevMode && setInjectorProfilerContext(previousInjectorProfilerContext);
		  }
		}
		function getPipeDef(name, registry) {
		  if (registry) {
			 if (ngDevMode) {
				const pipes = registry.filter((pipe) => pipe.name === name);
				if (pipes.length > 1) {
				  console.warn(formatRuntimeError(313, getMultipleMatchingPipesMessage(name)));
				}
			 }
			 for (let i = registry.length - 1; i >= 0; i--) {
				const pipeDef = registry[i];
				if (name === pipeDef.name) {
				  return pipeDef;
				}
			 }
		  }
		  if (ngDevMode) {
			 throw new RuntimeError(-302, getPipeNotFoundErrorMessage(name));
		  }
		  return;
		}
		function getMultipleMatchingPipesMessage(name) {
		  const lView = getLView();
		  const declarationLView = lView[DECLARATION_COMPONENT_VIEW];
		  const context2 = declarationLView[CONTEXT];
		  const hostIsStandalone = isHostComponentStandalone(lView);
		  const componentInfoMessage = context2 ? ` in the '${context2.constructor.name}' component` : "";
		  const verifyMessage = `check ${hostIsStandalone ? "'@Component.imports' of this component" : "the imports of this module"}`;
		  const errorMessage = `Multiple pipes match the name \`${name}\`${componentInfoMessage}. ${verifyMessage}`;
		  return errorMessage;
		}
		function getPipeNotFoundErrorMessage(name) {
		  const lView = getLView();
		  const declarationLView = lView[DECLARATION_COMPONENT_VIEW];
		  const context2 = declarationLView[CONTEXT];
		  const hostIsStandalone = isHostComponentStandalone(lView);
		  const componentInfoMessage = context2 ? ` in the '${context2.constructor.name}' component` : "";
		  const verifyMessage = `Verify that it is ${hostIsStandalone ? "included in the '@Component.imports' of this component" : "declared or imported in this module"}`;
		  const errorMessage = `The pipe '${name}' could not be found${componentInfoMessage}. ${verifyMessage}`;
		  return errorMessage;
		}
		function \u0275\u0275pipeBind1(index, offset, v1) {
		  const adjustedIndex = index + HEADER_OFFSET;
		  const lView = getLView();
		  const pipeInstance = load(lView, adjustedIndex);
		  return isPure(lView, adjustedIndex) ? pureFunction1Internal(lView, getBindingRoot(), offset, pipeInstance.transform, v1, pipeInstance) : pipeInstance.transform(v1);
		}
		function \u0275\u0275pipeBind2(index, slotOffset, v1, v2) {
		  const adjustedIndex = index + HEADER_OFFSET;
		  const lView = getLView();
		  const pipeInstance = load(lView, adjustedIndex);
		  return isPure(lView, adjustedIndex) ? pureFunction2Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, v2, pipeInstance) : pipeInstance.transform(v1, v2);
		}
		function \u0275\u0275pipeBind3(index, slotOffset, v1, v2, v3) {
		  const adjustedIndex = index + HEADER_OFFSET;
		  const lView = getLView();
		  const pipeInstance = load(lView, adjustedIndex);
		  return isPure(lView, adjustedIndex) ? pureFunction3Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, v2, v3, pipeInstance) : pipeInstance.transform(v1, v2, v3);
		}
		function \u0275\u0275pipeBind4(index, slotOffset, v1, v2, v3, v4) {
		  const adjustedIndex = index + HEADER_OFFSET;
		  const lView = getLView();
		  const pipeInstance = load(lView, adjustedIndex);
		  return isPure(lView, adjustedIndex) ? pureFunction4Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, v2, v3, v4, pipeInstance) : pipeInstance.transform(v1, v2, v3, v4);
		}
		function \u0275\u0275pipeBindV(index, slotOffset, values) {
		  const adjustedIndex = index + HEADER_OFFSET;
		  const lView = getLView();
		  const pipeInstance = load(lView, adjustedIndex);
		  return isPure(lView, adjustedIndex) ? pureFunctionVInternal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, values, pipeInstance) : pipeInstance.transform.apply(pipeInstance, values);
		}
		function isPure(lView, index) {
		  return lView[TVIEW].data[index].pure;
		}
		function \u0275\u0275templateRefExtractor(tNode, lView) {
		  return createTemplateRef(tNode, lView);
		}
		function \u0275\u0275getComponentDepsFactory(type2, rawImports) {
		  return () => {
			 try {
				return depsTracker.getComponentDependencies(type2, rawImports).dependencies;
			 } catch (e) {
				console.error(`Computing dependencies in local compilation mode for the component "${type2.name}" failed with the exception:`, e);
				throw e;
			 }
		  };
		}
		function \u0275setClassDebugInfo(type2, debugInfo) {
		  const def = getComponentDef(type2);
		  if (def !== null) {
			 def.debugInfo = debugInfo;
		  }
		}
		var angularCoreEnv = /* @__PURE__ */ (() => ({
		  "\u0275\u0275attribute": \u0275\u0275attribute,
		  "\u0275\u0275attributeInterpolate1": \u0275\u0275attributeInterpolate1,
		  "\u0275\u0275attributeInterpolate2": \u0275\u0275attributeInterpolate2,
		  "\u0275\u0275attributeInterpolate3": \u0275\u0275attributeInterpolate3,
		  "\u0275\u0275attributeInterpolate4": \u0275\u0275attributeInterpolate4,
		  "\u0275\u0275attributeInterpolate5": \u0275\u0275attributeInterpolate5,
		  "\u0275\u0275attributeInterpolate6": \u0275\u0275attributeInterpolate6,
		  "\u0275\u0275attributeInterpolate7": \u0275\u0275attributeInterpolate7,
		  "\u0275\u0275attributeInterpolate8": \u0275\u0275attributeInterpolate8,
		  "\u0275\u0275attributeInterpolateV": \u0275\u0275attributeInterpolateV,
		  "\u0275\u0275defineComponent": \u0275\u0275defineComponent,
		  "\u0275\u0275defineDirective": \u0275\u0275defineDirective,
		  "\u0275\u0275defineInjectable": \u0275\u0275defineInjectable,
		  "\u0275\u0275defineInjector": \u0275\u0275defineInjector,
		  "\u0275\u0275defineNgModule": \u0275\u0275defineNgModule,
		  "\u0275\u0275definePipe": \u0275\u0275definePipe,
		  "\u0275\u0275directiveInject": \u0275\u0275directiveInject,
		  "\u0275\u0275getInheritedFactory": \u0275\u0275getInheritedFactory,
		  "\u0275\u0275inject": \u0275\u0275inject,
		  "\u0275\u0275injectAttribute": \u0275\u0275injectAttribute,
		  "\u0275\u0275invalidFactory": \u0275\u0275invalidFactory,
		  "\u0275\u0275invalidFactoryDep": \u0275\u0275invalidFactoryDep,
		  "\u0275\u0275templateRefExtractor": \u0275\u0275templateRefExtractor,
		  "\u0275\u0275resetView": \u0275\u0275resetView,
		  "\u0275\u0275HostDirectivesFeature": \u0275\u0275HostDirectivesFeature,
		  "\u0275\u0275NgOnChangesFeature": \u0275\u0275NgOnChangesFeature,
		  "\u0275\u0275ProvidersFeature": \u0275\u0275ProvidersFeature,
		  "\u0275\u0275CopyDefinitionFeature": \u0275\u0275CopyDefinitionFeature,
		  "\u0275\u0275InheritDefinitionFeature": \u0275\u0275InheritDefinitionFeature,
		  "\u0275\u0275InputTransformsFeature": \u0275\u0275InputTransformsFeature,
		  "\u0275\u0275StandaloneFeature": \u0275\u0275StandaloneFeature,
		  "\u0275\u0275nextContext": \u0275\u0275nextContext,
		  "\u0275\u0275namespaceHTML": \u0275\u0275namespaceHTML,
		  "\u0275\u0275namespaceMathML": \u0275\u0275namespaceMathML,
		  "\u0275\u0275namespaceSVG": \u0275\u0275namespaceSVG,
		  "\u0275\u0275enableBindings": \u0275\u0275enableBindings,
		  "\u0275\u0275disableBindings": \u0275\u0275disableBindings,
		  "\u0275\u0275elementStart": \u0275\u0275elementStart,
		  "\u0275\u0275elementEnd": \u0275\u0275elementEnd,
		  "\u0275\u0275element": \u0275\u0275element,
		  "\u0275\u0275elementContainerStart": \u0275\u0275elementContainerStart,
		  "\u0275\u0275elementContainerEnd": \u0275\u0275elementContainerEnd,
		  "\u0275\u0275elementContainer": \u0275\u0275elementContainer,
		  "\u0275\u0275pureFunction0": \u0275\u0275pureFunction0,
		  "\u0275\u0275pureFunction1": \u0275\u0275pureFunction1,
		  "\u0275\u0275pureFunction2": \u0275\u0275pureFunction2,
		  "\u0275\u0275pureFunction3": \u0275\u0275pureFunction3,
		  "\u0275\u0275pureFunction4": \u0275\u0275pureFunction4,
		  "\u0275\u0275pureFunction5": \u0275\u0275pureFunction5,
		  "\u0275\u0275pureFunction6": \u0275\u0275pureFunction6,
		  "\u0275\u0275pureFunction7": \u0275\u0275pureFunction7,
		  "\u0275\u0275pureFunction8": \u0275\u0275pureFunction8,
		  "\u0275\u0275pureFunctionV": \u0275\u0275pureFunctionV,
		  "\u0275\u0275getCurrentView": \u0275\u0275getCurrentView,
		  "\u0275\u0275restoreView": \u0275\u0275restoreView,
		  "\u0275\u0275listener": \u0275\u0275listener,
		  "\u0275\u0275projection": \u0275\u0275projection,
		  "\u0275\u0275syntheticHostProperty": \u0275\u0275syntheticHostProperty,
		  "\u0275\u0275syntheticHostListener": \u0275\u0275syntheticHostListener,
		  "\u0275\u0275pipeBind1": \u0275\u0275pipeBind1,
		  "\u0275\u0275pipeBind2": \u0275\u0275pipeBind2,
		  "\u0275\u0275pipeBind3": \u0275\u0275pipeBind3,
		  "\u0275\u0275pipeBind4": \u0275\u0275pipeBind4,
		  "\u0275\u0275pipeBindV": \u0275\u0275pipeBindV,
		  "\u0275\u0275projectionDef": \u0275\u0275projectionDef,
		  "\u0275\u0275hostProperty": \u0275\u0275hostProperty,
		  "\u0275\u0275property": \u0275\u0275property,
		  "\u0275\u0275propertyInterpolate": \u0275\u0275propertyInterpolate,
		  "\u0275\u0275propertyInterpolate1": \u0275\u0275propertyInterpolate1,
		  "\u0275\u0275propertyInterpolate2": \u0275\u0275propertyInterpolate2,
		  "\u0275\u0275propertyInterpolate3": \u0275\u0275propertyInterpolate3,
		  "\u0275\u0275propertyInterpolate4": \u0275\u0275propertyInterpolate4,
		  "\u0275\u0275propertyInterpolate5": \u0275\u0275propertyInterpolate5,
		  "\u0275\u0275propertyInterpolate6": \u0275\u0275propertyInterpolate6,
		  "\u0275\u0275propertyInterpolate7": \u0275\u0275propertyInterpolate7,
		  "\u0275\u0275propertyInterpolate8": \u0275\u0275propertyInterpolate8,
		  "\u0275\u0275propertyInterpolateV": \u0275\u0275propertyInterpolateV,
		  "\u0275\u0275pipe": \u0275\u0275pipe,
		  "\u0275\u0275queryRefresh": \u0275\u0275queryRefresh,
		  "\u0275\u0275queryAdvance": \u0275\u0275queryAdvance,
		  "\u0275\u0275viewQuery": \u0275\u0275viewQuery,
		  "\u0275\u0275viewQuerySignal": \u0275\u0275viewQuerySignal,
		  "\u0275\u0275loadQuery": \u0275\u0275loadQuery,
		  "\u0275\u0275contentQuery": \u0275\u0275contentQuery,
		  "\u0275\u0275contentQuerySignal": \u0275\u0275contentQuerySignal,
		  "\u0275\u0275reference": \u0275\u0275reference,
		  "\u0275\u0275classMap": \u0275\u0275classMap,
		  "\u0275\u0275classMapInterpolate1": \u0275\u0275classMapInterpolate1,
		  "\u0275\u0275classMapInterpolate2": \u0275\u0275classMapInterpolate2,
		  "\u0275\u0275classMapInterpolate3": \u0275\u0275classMapInterpolate3,
		  "\u0275\u0275classMapInterpolate4": \u0275\u0275classMapInterpolate4,
		  "\u0275\u0275classMapInterpolate5": \u0275\u0275classMapInterpolate5,
		  "\u0275\u0275classMapInterpolate6": \u0275\u0275classMapInterpolate6,
		  "\u0275\u0275classMapInterpolate7": \u0275\u0275classMapInterpolate7,
		  "\u0275\u0275classMapInterpolate8": \u0275\u0275classMapInterpolate8,
		  "\u0275\u0275classMapInterpolateV": \u0275\u0275classMapInterpolateV,
		  "\u0275\u0275styleMap": \u0275\u0275styleMap,
		  "\u0275\u0275styleMapInterpolate1": \u0275\u0275styleMapInterpolate1,
		  "\u0275\u0275styleMapInterpolate2": \u0275\u0275styleMapInterpolate2,
		  "\u0275\u0275styleMapInterpolate3": \u0275\u0275styleMapInterpolate3,
		  "\u0275\u0275styleMapInterpolate4": \u0275\u0275styleMapInterpolate4,
		  "\u0275\u0275styleMapInterpolate5": \u0275\u0275styleMapInterpolate5,
		  "\u0275\u0275styleMapInterpolate6": \u0275\u0275styleMapInterpolate6,
		  "\u0275\u0275styleMapInterpolate7": \u0275\u0275styleMapInterpolate7,
		  "\u0275\u0275styleMapInterpolate8": \u0275\u0275styleMapInterpolate8,
		  "\u0275\u0275styleMapInterpolateV": \u0275\u0275styleMapInterpolateV,
		  "\u0275\u0275styleProp": \u0275\u0275styleProp,
		  "\u0275\u0275stylePropInterpolate1": \u0275\u0275stylePropInterpolate1,
		  "\u0275\u0275stylePropInterpolate2": \u0275\u0275stylePropInterpolate2,
		  "\u0275\u0275stylePropInterpolate3": \u0275\u0275stylePropInterpolate3,
		  "\u0275\u0275stylePropInterpolate4": \u0275\u0275stylePropInterpolate4,
		  "\u0275\u0275stylePropInterpolate5": \u0275\u0275stylePropInterpolate5,
		  "\u0275\u0275stylePropInterpolate6": \u0275\u0275stylePropInterpolate6,
		  "\u0275\u0275stylePropInterpolate7": \u0275\u0275stylePropInterpolate7,
		  "\u0275\u0275stylePropInterpolate8": \u0275\u0275stylePropInterpolate8,
		  "\u0275\u0275stylePropInterpolateV": \u0275\u0275stylePropInterpolateV,
		  "\u0275\u0275classProp": \u0275\u0275classProp,
		  "\u0275\u0275advance": \u0275\u0275advance,
		  "\u0275\u0275template": \u0275\u0275template,
		  "\u0275\u0275conditional": \u0275\u0275conditional,
		  "\u0275\u0275defer": \u0275\u0275defer,
		  "\u0275\u0275deferWhen": \u0275\u0275deferWhen,
		  "\u0275\u0275deferOnIdle": \u0275\u0275deferOnIdle,
		  "\u0275\u0275deferOnImmediate": \u0275\u0275deferOnImmediate,
		  "\u0275\u0275deferOnTimer": \u0275\u0275deferOnTimer,
		  "\u0275\u0275deferOnHover": \u0275\u0275deferOnHover,
		  "\u0275\u0275deferOnInteraction": \u0275\u0275deferOnInteraction,
		  "\u0275\u0275deferOnViewport": \u0275\u0275deferOnViewport,
		  "\u0275\u0275deferPrefetchWhen": \u0275\u0275deferPrefetchWhen,
		  "\u0275\u0275deferPrefetchOnIdle": \u0275\u0275deferPrefetchOnIdle,
		  "\u0275\u0275deferPrefetchOnImmediate": \u0275\u0275deferPrefetchOnImmediate,
		  "\u0275\u0275deferPrefetchOnTimer": \u0275\u0275deferPrefetchOnTimer,
		  "\u0275\u0275deferPrefetchOnHover": \u0275\u0275deferPrefetchOnHover,
		  "\u0275\u0275deferPrefetchOnInteraction": \u0275\u0275deferPrefetchOnInteraction,
		  "\u0275\u0275deferPrefetchOnViewport": \u0275\u0275deferPrefetchOnViewport,
		  "\u0275\u0275deferEnableTimerScheduling": \u0275\u0275deferEnableTimerScheduling,
		  "\u0275\u0275repeater": \u0275\u0275repeater,
		  "\u0275\u0275repeaterCreate": \u0275\u0275repeaterCreate,
		  "\u0275\u0275repeaterTrackByIndex": \u0275\u0275repeaterTrackByIndex,
		  "\u0275\u0275repeaterTrackByIdentity": \u0275\u0275repeaterTrackByIdentity,
		  "\u0275\u0275componentInstance": \u0275\u0275componentInstance,
		  "\u0275\u0275text": \u0275\u0275text,
		  "\u0275\u0275textInterpolate": \u0275\u0275textInterpolate,
		  "\u0275\u0275textInterpolate1": \u0275\u0275textInterpolate1,
		  "\u0275\u0275textInterpolate2": \u0275\u0275textInterpolate2,
		  "\u0275\u0275textInterpolate3": \u0275\u0275textInterpolate3,
		  "\u0275\u0275textInterpolate4": \u0275\u0275textInterpolate4,
		  "\u0275\u0275textInterpolate5": \u0275\u0275textInterpolate5,
		  "\u0275\u0275textInterpolate6": \u0275\u0275textInterpolate6,
		  "\u0275\u0275textInterpolate7": \u0275\u0275textInterpolate7,
		  "\u0275\u0275textInterpolate8": \u0275\u0275textInterpolate8,
		  "\u0275\u0275textInterpolateV": \u0275\u0275textInterpolateV,
		  "\u0275\u0275i18n": \u0275\u0275i18n,
		  "\u0275\u0275i18nAttributes": \u0275\u0275i18nAttributes,
		  "\u0275\u0275i18nExp": \u0275\u0275i18nExp,
		  "\u0275\u0275i18nStart": \u0275\u0275i18nStart,
		  "\u0275\u0275i18nEnd": \u0275\u0275i18nEnd,
		  "\u0275\u0275i18nApply": \u0275\u0275i18nApply,
		  "\u0275\u0275i18nPostprocess": \u0275\u0275i18nPostprocess,
		  "\u0275\u0275resolveWindow": \u0275\u0275resolveWindow,
		  "\u0275\u0275resolveDocument": \u0275\u0275resolveDocument,
		  "\u0275\u0275resolveBody": \u0275\u0275resolveBody,
		  "\u0275\u0275setComponentScope": \u0275\u0275setComponentScope,
		  "\u0275\u0275setNgModuleScope": \u0275\u0275setNgModuleScope,
		  "\u0275\u0275registerNgModuleType": registerNgModuleType,
		  "\u0275\u0275getComponentDepsFactory": \u0275\u0275getComponentDepsFactory,
		  "\u0275setClassDebugInfo": \u0275setClassDebugInfo,
		  "\u0275\u0275sanitizeHtml": \u0275\u0275sanitizeHtml,
		  "\u0275\u0275sanitizeStyle": \u0275\u0275sanitizeStyle,
		  "\u0275\u0275sanitizeResourceUrl": \u0275\u0275sanitizeResourceUrl,
		  "\u0275\u0275sanitizeScript": \u0275\u0275sanitizeScript,
		  "\u0275\u0275sanitizeUrl": \u0275\u0275sanitizeUrl,
		  "\u0275\u0275sanitizeUrlOrResourceUrl": \u0275\u0275sanitizeUrlOrResourceUrl,
		  "\u0275\u0275trustConstantHtml": \u0275\u0275trustConstantHtml,
		  "\u0275\u0275trustConstantResourceUrl": \u0275\u0275trustConstantResourceUrl,
		  "\u0275\u0275validateIframeAttribute": \u0275\u0275validateIframeAttribute,
		  "forwardRef": forwardRef,
		  "resolveForwardRef": resolveForwardRef,
		  "\u0275\u0275twoWayProperty": \u0275\u0275twoWayProperty,
		  "\u0275\u0275twoWayBindingSet": \u0275\u0275twoWayBindingSet,
		  "\u0275\u0275twoWayListener": \u0275\u0275twoWayListener,
		  "\u0275\u0275InputFlags": InputFlags
		}))();
		var jitOptions = null;
		function setJitOptions(options) {
		  if (jitOptions !== null) {
			 if (options.defaultEncapsulation !== jitOptions.defaultEncapsulation) {
				ngDevMode && console.error("Provided value for `defaultEncapsulation` can not be changed once it has been set.");
				return;
			 }
			 if (options.preserveWhitespaces !== jitOptions.preserveWhitespaces) {
				ngDevMode && console.error("Provided value for `preserveWhitespaces` can not be changed once it has been set.");
				return;
			 }
		  }
		  jitOptions = options;
		}
		function getJitOptions() {
		  return jitOptions;
		}
		function patchModuleCompilation() {
		}
		var moduleQueue = [];
		function enqueueModuleForDelayedScoping(moduleType, ngModule) {
		  moduleQueue.push({ moduleType, ngModule });
		}
		var flushingModuleQueue = false;
		function flushModuleScopingQueueAsMuchAsPossible() {
		  if (!flushingModuleQueue) {
			 flushingModuleQueue = true;
			 try {
				for (let i = moduleQueue.length - 1; i >= 0; i--) {
				  const { moduleType, ngModule } = moduleQueue[i];
				  if (ngModule.declarations && ngModule.declarations.every(isResolvedDeclaration)) {
					 moduleQueue.splice(i, 1);
					 setScopeOnDeclaredComponents(moduleType, ngModule);
				  }
				}
			 } finally {
				flushingModuleQueue = false;
			 }
		  }
		}
		function isResolvedDeclaration(declaration) {
		  if (Array.isArray(declaration)) {
			 return declaration.every(isResolvedDeclaration);
		  }
		  return !!resolveForwardRef(declaration);
		}
		function compileNgModule(moduleType, ngModule = {}) {
		  patchModuleCompilation();
		  compileNgModuleDefs(moduleType, ngModule);
		  if (ngModule.id !== void 0) {
			 registerNgModuleType(moduleType, ngModule.id);
		  }
		  enqueueModuleForDelayedScoping(moduleType, ngModule);
		}
		function compileNgModuleDefs(moduleType, ngModule, allowDuplicateDeclarationsInRoot = false) {
		  ngDevMode && assertDefined(moduleType, "Required value moduleType");
		  ngDevMode && assertDefined(ngModule, "Required value ngModule");
		  const declarations = flatten(ngModule.declarations || EMPTY_ARRAY);
		  let ngModuleDef = null;
		  Object.defineProperty(moduleType, NG_MOD_DEF, {
			 configurable: true,
			 get: () => {
				if (ngModuleDef === null) {
				  if (ngDevMode && ngModule.imports && ngModule.imports.indexOf(moduleType) > -1) {
					 throw new Error(`'${stringifyForError(moduleType)}' module can't import itself`);
				  }
				  const compiler = getCompilerFacade({ usage: 0, kind: "NgModule", type: moduleType });
				  ngModuleDef = compiler.compileNgModule(angularCoreEnv, `ng:///${moduleType.name}/\u0275mod.js`, {
					 type: moduleType,
					 bootstrap: flatten(ngModule.bootstrap || EMPTY_ARRAY).map(resolveForwardRef),
					 declarations: declarations.map(resolveForwardRef),
					 imports: flatten(ngModule.imports || EMPTY_ARRAY).map(resolveForwardRef).map(expandModuleWithProviders),
					 exports: flatten(ngModule.exports || EMPTY_ARRAY).map(resolveForwardRef).map(expandModuleWithProviders),
					 schemas: ngModule.schemas ? flatten(ngModule.schemas) : null,
					 id: ngModule.id || null
				  });
				  if (!ngModuleDef.schemas) {
					 ngModuleDef.schemas = [];
				  }
				}
				return ngModuleDef;
			 }
		  });
		  let ngFactoryDef = null;
		  Object.defineProperty(moduleType, NG_FACTORY_DEF, {
			 get: () => {
				if (ngFactoryDef === null) {
				  const compiler = getCompilerFacade({ usage: 0, kind: "NgModule", type: moduleType });
				  ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${moduleType.name}/\u0275fac.js`, {
					 name: moduleType.name,
					 type: moduleType,
					 deps: reflectDependencies(moduleType),
					 target: compiler.FactoryTarget.NgModule,
					 typeArgumentCount: 0
				  });
				}
				return ngFactoryDef;
			 },
			 // Make the property configurable in dev mode to allow overriding in tests
			 configurable: !!ngDevMode
		  });
		  let ngInjectorDef = null;
		  Object.defineProperty(moduleType, NG_INJ_DEF, {
			 get: () => {
				if (ngInjectorDef === null) {
				  ngDevMode && verifySemanticsOfNgModuleDef(moduleType, allowDuplicateDeclarationsInRoot);
				  const meta = {
					 name: moduleType.name,
					 type: moduleType,
					 providers: ngModule.providers || EMPTY_ARRAY,
					 imports: [
						(ngModule.imports || EMPTY_ARRAY).map(resolveForwardRef),
						(ngModule.exports || EMPTY_ARRAY).map(resolveForwardRef)
					 ]
				  };
				  const compiler = getCompilerFacade({ usage: 0, kind: "NgModule", type: moduleType });
				  ngInjectorDef = compiler.compileInjector(angularCoreEnv, `ng:///${moduleType.name}/\u0275inj.js`, meta);
				}
				return ngInjectorDef;
			 },
			 // Make the property configurable in dev mode to allow overriding in tests
			 configurable: !!ngDevMode
		  });
		}
		function generateStandaloneInDeclarationsError(type2, location2) {
		  const prefix = `Unexpected "${stringifyForError(type2)}" found in the "declarations" array of the`;
		  const suffix = `"${stringifyForError(type2)}" is marked as standalone and can't be declared in any NgModule - did you intend to import it instead (by adding it to the "imports" array)?`;
		  return `${prefix} ${location2}, ${suffix}`;
		}
		function verifySemanticsOfNgModuleDef(moduleType, allowDuplicateDeclarationsInRoot, importingModule) {
		  if (verifiedNgModule.get(moduleType))
			 return;
		  if (isStandalone(moduleType))
			 return;
		  verifiedNgModule.set(moduleType, true);
		  moduleType = resolveForwardRef(moduleType);
		  let ngModuleDef;
		  if (importingModule) {
			 ngModuleDef = getNgModuleDef(moduleType);
			 if (!ngModuleDef) {
				throw new Error(`Unexpected value '${moduleType.name}' imported by the module '${importingModule.name}'. Please add an @NgModule annotation.`);
			 }
		  } else {
			 ngModuleDef = getNgModuleDef(moduleType, true);
		  }
		  const errors = [];
		  const declarations = maybeUnwrapFn(ngModuleDef.declarations);
		  const imports = maybeUnwrapFn(ngModuleDef.imports);
		  flatten(imports).map(unwrapModuleWithProvidersImports).forEach((modOrStandaloneCmpt) => {
			 verifySemanticsOfNgModuleImport(modOrStandaloneCmpt, moduleType);
			 verifySemanticsOfNgModuleDef(modOrStandaloneCmpt, false, moduleType);
		  });
		  const exports = maybeUnwrapFn(ngModuleDef.exports);
		  declarations.forEach(verifyDeclarationsHaveDefinitions);
		  declarations.forEach(verifyDirectivesHaveSelector);
		  declarations.forEach((declarationType) => verifyNotStandalone(declarationType, moduleType));
		  const combinedDeclarations = [
			 ...declarations.map(resolveForwardRef),
			 ...flatten(imports.map(computeCombinedExports)).map(resolveForwardRef)
		  ];
		  exports.forEach(verifyExportsAreDeclaredOrReExported);
		  declarations.forEach((decl) => verifyDeclarationIsUnique(decl, allowDuplicateDeclarationsInRoot));
		  const ngModule = getAnnotation(moduleType, "NgModule");
		  if (ngModule) {
			 ngModule.imports && flatten(ngModule.imports).map(unwrapModuleWithProvidersImports).forEach((mod) => {
				verifySemanticsOfNgModuleImport(mod, moduleType);
				verifySemanticsOfNgModuleDef(mod, false, moduleType);
			 });
			 ngModule.bootstrap && deepForEach(ngModule.bootstrap, verifyCorrectBootstrapType);
			 ngModule.bootstrap && deepForEach(ngModule.bootstrap, verifyComponentIsPartOfNgModule);
		  }
		  if (errors.length) {
			 throw new Error(errors.join("\n"));
		  }
		  function verifyDeclarationsHaveDefinitions(type2) {
			 type2 = resolveForwardRef(type2);
			 const def = getComponentDef(type2) || getDirectiveDef(type2) || getPipeDef$1(type2);
			 if (!def) {
				errors.push(`Unexpected value '${stringifyForError(type2)}' declared by the module '${stringifyForError(moduleType)}'. Please add a @Pipe/@Directive/@Component annotation.`);
			 }
		  }
		  function verifyDirectivesHaveSelector(type2) {
			 type2 = resolveForwardRef(type2);
			 const def = getDirectiveDef(type2);
			 if (!getComponentDef(type2) && def && def.selectors.length == 0) {
				errors.push(`Directive ${stringifyForError(type2)} has no selector, please add it!`);
			 }
		  }
		  function verifyNotStandalone(type2, moduleType2) {
			 type2 = resolveForwardRef(type2);
			 const def = getComponentDef(type2) || getDirectiveDef(type2) || getPipeDef$1(type2);
			 if (def?.standalone) {
				const location2 = `"${stringifyForError(moduleType2)}" NgModule`;
				errors.push(generateStandaloneInDeclarationsError(type2, location2));
			 }
		  }
		  function verifyExportsAreDeclaredOrReExported(type2) {
			 type2 = resolveForwardRef(type2);
			 const kind = getComponentDef(type2) && "component" || getDirectiveDef(type2) && "directive" || getPipeDef$1(type2) && "pipe";
			 if (kind) {
				if (combinedDeclarations.lastIndexOf(type2) === -1) {
				  errors.push(`Can't export ${kind} ${stringifyForError(type2)} from ${stringifyForError(moduleType)} as it was neither declared nor imported!`);
				}
			 }
		  }
		  function verifyDeclarationIsUnique(type2, suppressErrors) {
			 type2 = resolveForwardRef(type2);
			 const existingModule = ownerNgModule.get(type2);
			 if (existingModule && existingModule !== moduleType) {
				if (!suppressErrors) {
				  const modules2 = [existingModule, moduleType].map(stringifyForError).sort();
				  errors.push(`Type ${stringifyForError(type2)} is part of the declarations of 2 modules: ${modules2[0]} and ${modules2[1]}! Please consider moving ${stringifyForError(type2)} to a higher module that imports ${modules2[0]} and ${modules2[1]}. You can also create a new NgModule that exports and includes ${stringifyForError(type2)} then import that NgModule in ${modules2[0]} and ${modules2[1]}.`);
				}
			 } else {
				ownerNgModule.set(type2, moduleType);
			 }
		  }
		  function verifyComponentIsPartOfNgModule(type2) {
			 type2 = resolveForwardRef(type2);
			 const existingModule = ownerNgModule.get(type2);
			 if (!existingModule && !isStandalone(type2)) {
				errors.push(`Component ${stringifyForError(type2)} is not part of any NgModule or the module has not been imported into your module.`);
			 }
		  }
		  function verifyCorrectBootstrapType(type2) {
			 type2 = resolveForwardRef(type2);
			 if (!getComponentDef(type2)) {
				errors.push(`${stringifyForError(type2)} cannot be used as an entry component.`);
			 }
			 if (isStandalone(type2)) {
				errors.push(`The \`${stringifyForError(type2)}\` class is a standalone component, which can not be used in the \`@NgModule.bootstrap\` array. Use the \`bootstrapApplication\` function for bootstrap instead.`);
			 }
		  }
		  function verifySemanticsOfNgModuleImport(type2, importingModule2) {
			 type2 = resolveForwardRef(type2);
			 const directiveDef = getComponentDef(type2) || getDirectiveDef(type2);
			 if (directiveDef !== null && !directiveDef.standalone) {
				throw new Error(`Unexpected directive '${type2.name}' imported by the module '${importingModule2.name}'. Please add an @NgModule annotation.`);
			 }
			 const pipeDef = getPipeDef$1(type2);
			 if (pipeDef !== null && !pipeDef.standalone) {
				throw new Error(`Unexpected pipe '${type2.name}' imported by the module '${importingModule2.name}'. Please add an @NgModule annotation.`);
			 }
		  }
		}
		function unwrapModuleWithProvidersImports(typeOrWithProviders) {
		  typeOrWithProviders = resolveForwardRef(typeOrWithProviders);
		  return typeOrWithProviders.ngModule || typeOrWithProviders;
		}
		function getAnnotation(type2, name) {
		  let annotation = null;
		  collect(type2.__annotations__);
		  collect(type2.decorators);
		  return annotation;
		  function collect(annotations) {
			 if (annotations) {
				annotations.forEach(readAnnotation);
			 }
		  }
		  function readAnnotation(decorator) {
			 if (!annotation) {
				const proto = Object.getPrototypeOf(decorator);
				if (proto.ngMetadataName == name) {
				  annotation = decorator;
				} else if (decorator.type) {
				  const proto2 = Object.getPrototypeOf(decorator.type);
				  if (proto2.ngMetadataName == name) {
					 annotation = decorator.args[0];
				  }
				}
			 }
		  }
		}
		var ownerNgModule = /* @__PURE__ */ new WeakMap();
		var verifiedNgModule = /* @__PURE__ */ new WeakMap();
		function computeCombinedExports(type2) {
		  type2 = resolveForwardRef(type2);
		  const ngModuleDef = getNgModuleDef(type2);
		  if (ngModuleDef === null) {
			 return [type2];
		  }
		  return flatten(maybeUnwrapFn(ngModuleDef.exports).map((type3) => {
			 const ngModuleDef2 = getNgModuleDef(type3);
			 if (ngModuleDef2) {
				verifySemanticsOfNgModuleDef(type3, false);
				return computeCombinedExports(type3);
			 } else {
				return type3;
			 }
		  }));
		}
		function setScopeOnDeclaredComponents(moduleType, ngModule) {
		  const declarations = flatten(ngModule.declarations || EMPTY_ARRAY);
		  const transitiveScopes = transitiveScopesFor(moduleType);
		  declarations.forEach((declaration) => {
			 declaration = resolveForwardRef(declaration);
			 if (declaration.hasOwnProperty(NG_COMP_DEF)) {
				const component = declaration;
				const componentDef = getComponentDef(component);
				patchComponentDefWithScope(componentDef, transitiveScopes);
			 } else if (!declaration.hasOwnProperty(NG_DIR_DEF) && !declaration.hasOwnProperty(NG_PIPE_DEF)) {
				declaration.ngSelectorScope = moduleType;
			 }
		  });
		}
		function patchComponentDefWithScope(componentDef, transitiveScopes) {
		  componentDef.directiveDefs = () => Array.from(transitiveScopes.compilation.directives).map((dir) => dir.hasOwnProperty(NG_COMP_DEF) ? getComponentDef(dir) : getDirectiveDef(dir)).filter((def) => !!def);
		  componentDef.pipeDefs = () => Array.from(transitiveScopes.compilation.pipes).map((pipe) => getPipeDef$1(pipe));
		  componentDef.schemas = transitiveScopes.schemas;
		  componentDef.tView = null;
		}
		function transitiveScopesFor(type2) {
		  if (isNgModule(type2)) {
			 if (USE_RUNTIME_DEPS_TRACKER_FOR_JIT) {
				const scope = depsTracker.getNgModuleScope(type2);
				const def = getNgModuleDef(type2, true);
				return __spreadValues({
				  schemas: def.schemas || null
				}, scope);
			 } else {
				return transitiveScopesForNgModule(type2);
			 }
		  } else if (isStandalone(type2)) {
			 const directiveDef = getComponentDef(type2) || getDirectiveDef(type2);
			 if (directiveDef !== null) {
				return {
				  schemas: null,
				  compilation: {
					 directives: /* @__PURE__ */ new Set(),
					 pipes: /* @__PURE__ */ new Set()
				  },
				  exported: {
					 directives: /* @__PURE__ */ new Set([type2]),
					 pipes: /* @__PURE__ */ new Set()
				  }
				};
			 }
			 const pipeDef = getPipeDef$1(type2);
			 if (pipeDef !== null) {
				return {
				  schemas: null,
				  compilation: {
					 directives: /* @__PURE__ */ new Set(),
					 pipes: /* @__PURE__ */ new Set()
				  },
				  exported: {
					 directives: /* @__PURE__ */ new Set(),
					 pipes: /* @__PURE__ */ new Set([type2])
				  }
				};
			 }
		  }
		  throw new Error(`${type2.name} does not have a module def (\u0275mod property)`);
		}
		function transitiveScopesForNgModule(moduleType) {
		  const def = getNgModuleDef(moduleType, true);
		  if (def.transitiveCompileScopes !== null) {
			 return def.transitiveCompileScopes;
		  }
		  const scopes = {
			 schemas: def.schemas || null,
			 compilation: {
				directives: /* @__PURE__ */ new Set(),
				pipes: /* @__PURE__ */ new Set()
			 },
			 exported: {
				directives: /* @__PURE__ */ new Set(),
				pipes: /* @__PURE__ */ new Set()
			 }
		  };
		  maybeUnwrapFn(def.imports).forEach((imported) => {
			 const importedScope = transitiveScopesFor(imported);
			 importedScope.exported.directives.forEach((entry) => scopes.compilation.directives.add(entry));
			 importedScope.exported.pipes.forEach((entry) => scopes.compilation.pipes.add(entry));
		  });
		  maybeUnwrapFn(def.declarations).forEach((declared) => {
			 const declaredWithDefs = declared;
			 if (getPipeDef$1(declaredWithDefs)) {
				scopes.compilation.pipes.add(declared);
			 } else {
				scopes.compilation.directives.add(declared);
			 }
		  });
		  maybeUnwrapFn(def.exports).forEach((exported) => {
			 const exportedType = exported;
			 if (isNgModule(exportedType)) {
				const exportedScope = transitiveScopesFor(exportedType);
				exportedScope.exported.directives.forEach((entry) => {
				  scopes.compilation.directives.add(entry);
				  scopes.exported.directives.add(entry);
				});
				exportedScope.exported.pipes.forEach((entry) => {
				  scopes.compilation.pipes.add(entry);
				  scopes.exported.pipes.add(entry);
				});
			 } else if (getPipeDef$1(exportedType)) {
				scopes.exported.pipes.add(exportedType);
			 } else {
				scopes.exported.directives.add(exportedType);
			 }
		  });
		  def.transitiveCompileScopes = scopes;
		  return scopes;
		}
		function expandModuleWithProviders(value) {
		  if (isModuleWithProviders(value)) {
			 return value.ngModule;
		  }
		  return value;
		}
		var compilationDepth = 0;
		function compileComponent(type2, metadata) {
		  (typeof ngDevMode === "undefined" || ngDevMode) && initNgDevMode();
		  let ngComponentDef = null;
		  maybeQueueResolutionOfComponentResources(type2, metadata);
		  addDirectiveFactoryDef(type2, metadata);
		  Object.defineProperty(type2, NG_COMP_DEF, {
			 get: () => {
				if (ngComponentDef === null) {
				  const compiler = getCompilerFacade({ usage: 0, kind: "component", type: type2 });
				  if (componentNeedsResolution(metadata)) {
					 const error = [`Component '${type2.name}' is not resolved:`];
					 if (metadata.templateUrl) {
						error.push(` - templateUrl: ${metadata.templateUrl}`);
					 }
					 if (metadata.styleUrls && metadata.styleUrls.length) {
						error.push(` - styleUrls: ${JSON.stringify(metadata.styleUrls)}`);
					 }
					 if (metadata.styleUrl) {
						error.push(` - styleUrl: ${metadata.styleUrl}`);
					 }
					 error.push(`Did you run and wait for 'resolveComponentResources()'?`);
					 throw new Error(error.join("\n"));
				  }
				  const options = getJitOptions();
				  let preserveWhitespaces = metadata.preserveWhitespaces;
				  if (preserveWhitespaces === void 0) {
					 if (options !== null && options.preserveWhitespaces !== void 0) {
						preserveWhitespaces = options.preserveWhitespaces;
					 } else {
						preserveWhitespaces = false;
					 }
				  }
				  let encapsulation = metadata.encapsulation;
				  if (encapsulation === void 0) {
					 if (options !== null && options.defaultEncapsulation !== void 0) {
						encapsulation = options.defaultEncapsulation;
					 } else {
						encapsulation = ViewEncapsulation$1.Emulated;
					 }
				  }
				  const templateUrl = metadata.templateUrl || `ng:///${type2.name}/template.html`;
				  const meta = __spreadProps(__spreadValues({}, directiveMetadata(type2, metadata)), {
					 typeSourceSpan: compiler.createParseSourceSpan("Component", type2.name, templateUrl),
					 template: metadata.template || "",
					 preserveWhitespaces,
					 styles: typeof metadata.styles === "string" ? [metadata.styles] : metadata.styles || EMPTY_ARRAY,
					 animations: metadata.animations,
					 // JIT components are always compiled against an empty set of `declarations`. Instead, the
					 // `directiveDefs` and `pipeDefs` are updated at a later point:
					 //  * for NgModule-based components, they're set when the NgModule which declares the
					 //    component resolves in the module scoping queue
					 //  * for standalone components, they're set just below, after `compileComponent`.
					 declarations: [],
					 changeDetection: metadata.changeDetection,
					 encapsulation,
					 interpolation: metadata.interpolation,
					 viewProviders: metadata.viewProviders || null
				  });
				  compilationDepth++;
				  try {
					 if (meta.usesInheritance) {
						addDirectiveDefToUndecoratedParents(type2);
					 }
					 ngComponentDef = compiler.compileComponent(angularCoreEnv, templateUrl, meta);
					 if (metadata.standalone) {
						const imports = flatten(metadata.imports || EMPTY_ARRAY);
						const { directiveDefs, pipeDefs } = getStandaloneDefFunctions(type2, imports);
						ngComponentDef.directiveDefs = directiveDefs;
						ngComponentDef.pipeDefs = pipeDefs;
						ngComponentDef.dependencies = () => imports.map(resolveForwardRef);
					 }
				  } finally {
					 compilationDepth--;
				  }
				  if (compilationDepth === 0) {
					 flushModuleScopingQueueAsMuchAsPossible();
				  }
				  if (hasSelectorScope(type2)) {
					 const scopes = transitiveScopesFor(type2.ngSelectorScope);
					 patchComponentDefWithScope(ngComponentDef, scopes);
				  }
				  if (metadata.schemas) {
					 if (metadata.standalone) {
						ngComponentDef.schemas = metadata.schemas;
					 } else {
						throw new Error(`The 'schemas' was specified for the ${stringifyForError(type2)} but is only valid on a component that is standalone.`);
					 }
				  } else if (metadata.standalone) {
					 ngComponentDef.schemas = [];
				  }
				}
				return ngComponentDef;
			 },
			 // Make the property configurable in dev mode to allow overriding in tests
			 configurable: !!ngDevMode
		  });
		}
		function getStandaloneDefFunctions(type2, imports) {
		  let cachedDirectiveDefs = null;
		  let cachedPipeDefs = null;
		  const directiveDefs = () => {
			 if (!USE_RUNTIME_DEPS_TRACKER_FOR_JIT) {
				if (cachedDirectiveDefs === null) {
				  cachedDirectiveDefs = [getComponentDef(type2)];
				  const seen = /* @__PURE__ */ new Set([type2]);
				  for (const rawDep of imports) {
					 ngDevMode && verifyStandaloneImport(rawDep, type2);
					 const dep = resolveForwardRef(rawDep);
					 if (seen.has(dep)) {
						continue;
					 }
					 seen.add(dep);
					 if (!!getNgModuleDef(dep)) {
						const scope = transitiveScopesFor(dep);
						for (const dir of scope.exported.directives) {
						  const def = getComponentDef(dir) || getDirectiveDef(dir);
						  if (def && !seen.has(dir)) {
							 seen.add(dir);
							 cachedDirectiveDefs.push(def);
						  }
						}
					 } else {
						const def = getComponentDef(dep) || getDirectiveDef(dep);
						if (def) {
						  cachedDirectiveDefs.push(def);
						}
					 }
				  }
				}
				return cachedDirectiveDefs;
			 } else {
				if (ngDevMode) {
				  for (const rawDep of imports) {
					 verifyStandaloneImport(rawDep, type2);
				  }
				}
				if (!isComponent(type2)) {
				  return [];
				}
				const scope = depsTracker.getStandaloneComponentScope(type2, imports);
				return [...scope.compilation.directives].map((p) => getComponentDef(p) || getDirectiveDef(p)).filter((d) => d !== null);
			 }
		  };
		  const pipeDefs = () => {
			 if (!USE_RUNTIME_DEPS_TRACKER_FOR_JIT) {
				if (cachedPipeDefs === null) {
				  cachedPipeDefs = [];
				  const seen = /* @__PURE__ */ new Set();
				  for (const rawDep of imports) {
					 const dep = resolveForwardRef(rawDep);
					 if (seen.has(dep)) {
						continue;
					 }
					 seen.add(dep);
					 if (!!getNgModuleDef(dep)) {
						const scope = transitiveScopesFor(dep);
						for (const pipe of scope.exported.pipes) {
						  const def = getPipeDef$1(pipe);
						  if (def && !seen.has(pipe)) {
							 seen.add(pipe);
							 cachedPipeDefs.push(def);
						  }
						}
					 } else {
						const def = getPipeDef$1(dep);
						if (def) {
						  cachedPipeDefs.push(def);
						}
					 }
				  }
				}
				return cachedPipeDefs;
			 } else {
				if (ngDevMode) {
				  for (const rawDep of imports) {
					 verifyStandaloneImport(rawDep, type2);
				  }
				}
				if (!isComponent(type2)) {
				  return [];
				}
				const scope = depsTracker.getStandaloneComponentScope(type2, imports);
				return [...scope.compilation.pipes].map((p) => getPipeDef$1(p)).filter((d) => d !== null);
			 }
		  };
		  return {
			 directiveDefs,
			 pipeDefs
		  };
		}
		function hasSelectorScope(component) {
		  return component.ngSelectorScope !== void 0;
		}
		function compileDirective(type2, directive) {
		  let ngDirectiveDef = null;
		  addDirectiveFactoryDef(type2, directive || {});
		  Object.defineProperty(type2, NG_DIR_DEF, {
			 get: () => {
				if (ngDirectiveDef === null) {
				  const meta = getDirectiveMetadata(type2, directive || {});
				  const compiler = getCompilerFacade({ usage: 0, kind: "directive", type: type2 });
				  ngDirectiveDef = compiler.compileDirective(angularCoreEnv, meta.sourceMapUrl, meta.metadata);
				}
				return ngDirectiveDef;
			 },
			 // Make the property configurable in dev mode to allow overriding in tests
			 configurable: !!ngDevMode
		  });
		}
		function getDirectiveMetadata(type2, metadata) {
		  const name = type2 && type2.name;
		  const sourceMapUrl = `ng:///${name}/\u0275dir.js`;
		  const compiler = getCompilerFacade({ usage: 0, kind: "directive", type: type2 });
		  const facade = directiveMetadata(type2, metadata);
		  facade.typeSourceSpan = compiler.createParseSourceSpan("Directive", name, sourceMapUrl);
		  if (facade.usesInheritance) {
			 addDirectiveDefToUndecoratedParents(type2);
		  }
		  return { metadata: facade, sourceMapUrl };
		}
		function addDirectiveFactoryDef(type2, metadata) {
		  let ngFactoryDef = null;
		  Object.defineProperty(type2, NG_FACTORY_DEF, {
			 get: () => {
				if (ngFactoryDef === null) {
				  const meta = getDirectiveMetadata(type2, metadata);
				  const compiler = getCompilerFacade({ usage: 0, kind: "directive", type: type2 });
				  ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${type2.name}/\u0275fac.js`, {
					 name: meta.metadata.name,
					 type: meta.metadata.type,
					 typeArgumentCount: 0,
					 deps: reflectDependencies(type2),
					 target: compiler.FactoryTarget.Directive
				  });
				}
				return ngFactoryDef;
			 },
			 // Make the property configurable in dev mode to allow overriding in tests
			 configurable: !!ngDevMode
		  });
		}
		function extendsDirectlyFromObject(type2) {
		  return Object.getPrototypeOf(type2.prototype) === Object.prototype;
		}
		function directiveMetadata(type2, metadata) {
		  const reflect = getReflect();
		  const propMetadata = reflect.ownPropMetadata(type2);
		  return {
			 name: type2.name,
			 type: type2,
			 selector: metadata.selector !== void 0 ? metadata.selector : null,
			 host: metadata.host || EMPTY_OBJ,
			 propMetadata,
			 inputs: metadata.inputs || EMPTY_ARRAY,
			 outputs: metadata.outputs || EMPTY_ARRAY,
			 queries: extractQueriesMetadata(type2, propMetadata, isContentQuery),
			 lifecycle: { usesOnChanges: reflect.hasLifecycleHook(type2, "ngOnChanges") },
			 typeSourceSpan: null,
			 usesInheritance: !extendsDirectlyFromObject(type2),
			 exportAs: extractExportAs(metadata.exportAs),
			 providers: metadata.providers || null,
			 viewQueries: extractQueriesMetadata(type2, propMetadata, isViewQuery),
			 isStandalone: !!metadata.standalone,
			 isSignal: !!metadata.signals,
			 hostDirectives: metadata.hostDirectives?.map((directive) => typeof directive === "function" ? { directive } : directive) || null
		  };
		}
		function addDirectiveDefToUndecoratedParents(type2) {
		  const objPrototype = Object.prototype;
		  let parent = Object.getPrototypeOf(type2.prototype).constructor;
		  while (parent && parent !== objPrototype) {
			 if (!getDirectiveDef(parent) && !getComponentDef(parent) && shouldAddAbstractDirective(parent)) {
				compileDirective(parent, null);
			 }
			 parent = Object.getPrototypeOf(parent);
		  }
		}
		function convertToR3QueryPredicate(selector) {
		  return typeof selector === "string" ? splitByComma(selector) : resolveForwardRef(selector);
		}
		function convertToR3QueryMetadata(propertyName, ann) {
		  return {
			 propertyName,
			 predicate: convertToR3QueryPredicate(ann.selector),
			 descendants: ann.descendants,
			 first: ann.first,
			 read: ann.read ? ann.read : null,
			 static: !!ann.static,
			 emitDistinctChangesOnly: !!ann.emitDistinctChangesOnly,
			 isSignal: !!ann.isSignal
		  };
		}
		function extractQueriesMetadata(type2, propMetadata, isQueryAnn) {
		  const queriesMeta = [];
		  for (const field in propMetadata) {
			 if (propMetadata.hasOwnProperty(field)) {
				const annotations = propMetadata[field];
				annotations.forEach((ann) => {
				  if (isQueryAnn(ann)) {
					 if (!ann.selector) {
						throw new Error(`Can't construct a query for the property "${field}" of "${stringifyForError(type2)}" since the query selector wasn't defined.`);
					 }
					 if (annotations.some(isInputAnnotation)) {
						throw new Error(`Cannot combine @Input decorators with query decorators`);
					 }
					 queriesMeta.push(convertToR3QueryMetadata(field, ann));
				  }
				});
			 }
		  }
		  return queriesMeta;
		}
		function extractExportAs(exportAs) {
		  return exportAs === void 0 ? null : splitByComma(exportAs);
		}
		function isContentQuery(value) {
		  const name = value.ngMetadataName;
		  return name === "ContentChild" || name === "ContentChildren";
		}
		function isViewQuery(value) {
		  const name = value.ngMetadataName;
		  return name === "ViewChild" || name === "ViewChildren";
		}
		function isInputAnnotation(value) {
		  return value.ngMetadataName === "Input";
		}
		function splitByComma(value) {
		  return value.split(",").map((piece) => piece.trim());
		}
		var LIFECYCLE_HOOKS = [
		  "ngOnChanges",
		  "ngOnInit",
		  "ngOnDestroy",
		  "ngDoCheck",
		  "ngAfterViewInit",
		  "ngAfterViewChecked",
		  "ngAfterContentInit",
		  "ngAfterContentChecked"
		];
		function shouldAddAbstractDirective(type2) {
		  const reflect = getReflect();
		  if (LIFECYCLE_HOOKS.some((hookName) => reflect.hasLifecycleHook(type2, hookName))) {
			 return true;
		  }
		  const propMetadata = reflect.propMetadata(type2);
		  for (const field in propMetadata) {
			 const annotations = propMetadata[field];
			 for (let i = 0; i < annotations.length; i++) {
				const current = annotations[i];
				const metadataName = current.ngMetadataName;
				if (isInputAnnotation(current) || isContentQuery(current) || isViewQuery(current) || metadataName === "Output" || metadataName === "HostBinding" || metadataName === "HostListener") {
				  return true;
				}
			 }
		  }
		  return false;
		}
		function compilePipe(type2, meta) {
		  let ngPipeDef = null;
		  let ngFactoryDef = null;
		  Object.defineProperty(type2, NG_FACTORY_DEF, {
			 get: () => {
				if (ngFactoryDef === null) {
				  const metadata = getPipeMetadata(type2, meta);
				  const compiler = getCompilerFacade({ usage: 0, kind: "pipe", type: metadata.type });
				  ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${metadata.name}/\u0275fac.js`, {
					 name: metadata.name,
					 type: metadata.type,
					 typeArgumentCount: 0,
					 deps: reflectDependencies(type2),
					 target: compiler.FactoryTarget.Pipe
				  });
				}
				return ngFactoryDef;
			 },
			 // Make the property configurable in dev mode to allow overriding in tests
			 configurable: !!ngDevMode
		  });
		  Object.defineProperty(type2, NG_PIPE_DEF, {
			 get: () => {
				if (ngPipeDef === null) {
				  const metadata = getPipeMetadata(type2, meta);
				  const compiler = getCompilerFacade({ usage: 0, kind: "pipe", type: metadata.type });
				  ngPipeDef = compiler.compilePipe(angularCoreEnv, `ng:///${metadata.name}/\u0275pipe.js`, metadata);
				}
				return ngPipeDef;
			 },
			 // Make the property configurable in dev mode to allow overriding in tests
			 configurable: !!ngDevMode
		  });
		}
		function getPipeMetadata(type2, meta) {
		  return {
			 type: type2,
			 name: type2.name,
			 pipeName: meta.name,
			 pure: meta.pure !== void 0 ? meta.pure : true,
			 isStandalone: !!meta.standalone
		  };
		}
		var Directive = makeDecorator("Directive", (dir = {}) => dir, void 0, void 0, (type2, meta) => compileDirective(type2, meta));
		var Component = makeDecorator("Component", (c2 = {}) => __spreadValues({ changeDetection: ChangeDetectionStrategy.Default }, c2), Directive, void 0, (type2, meta) => compileComponent(type2, meta));
		var Pipe = makeDecorator("Pipe", (p) => __spreadValues({ pure: true }, p), void 0, void 0, (type2, meta) => compilePipe(type2, meta));
		var Input = makePropDecorator("Input", (arg) => {
		  if (!arg) {
			 return {};
		  }
		  return typeof arg === "string" ? { alias: arg } : arg;
		});
		var Output = makePropDecorator("Output", (alias) => ({ alias }));
		var HostBinding = makePropDecorator("HostBinding", (hostPropertyName) => ({ hostPropertyName }));
		var HostListener = makePropDecorator("HostListener", (eventName, args) => ({ eventName, args }));
		var NgModule = makeDecorator(
		  "NgModule",
		  (ngModule) => ngModule,
		  void 0,
		  void 0,
		  /**
			* Decorator that marks the following class as an NgModule, and supplies
			* configuration metadata for it.
			*
			* * The `declarations` option configures the compiler
			* with information about what belongs to the NgModule.
			* * The `providers` options configures the NgModule's injector to provide
			* dependencies the NgModule members.
			* * The `imports` and `exports` options bring in members from other modules, and make
			* this module's members available to others.
			*/
		  (type2, meta) => compileNgModule(type2, meta)
		);
		var Version = class {
		  constructor(full) {
			 this.full = full;
			 const parts = full.split(".");
			 this.major = parts[0];
			 this.minor = parts[1];
			 this.patch = parts.slice(2).join(".");
		  }
		};
		var VERSION = new Version("17.3.12");
		var Console = class _Console {
		  log(message2) {
			 console.log(message2);
		  }
		  // Note: for reporting errors use `DOM.logError()` as it is platform specific
		  warn(message2) {
			 console.warn(message2);
		  }
		  static {
			 this.\u0275fac = function Console_Factory(t) {
				return new (t || _Console)();
			 };
		  }
		  static {
			 this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _Console, factory: _Console.\u0275fac, providedIn: "platform" });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Console, [{
			 type: Injectable,
			 args: [{ providedIn: "platform" }]
		  }], null, null);
		})();
		var DIDebugData = class {
		  constructor() {
			 this.resolverToTokenToDependencies = /* @__PURE__ */ new WeakMap();
			 this.resolverToProviders = /* @__PURE__ */ new WeakMap();
			 this.standaloneInjectorToComponent = /* @__PURE__ */ new WeakMap();
		  }
		  reset() {
			 this.resolverToTokenToDependencies = /* @__PURE__ */ new WeakMap();
			 this.resolverToProviders = /* @__PURE__ */ new WeakMap();
			 this.standaloneInjectorToComponent = /* @__PURE__ */ new WeakMap();
		  }
		};
		var frameworkDIDebugData = new DIDebugData();
		function getFrameworkDIDebugData() {
		  return frameworkDIDebugData;
		}
		function setupFrameworkInjectorProfiler() {
		  frameworkDIDebugData.reset();
		  setInjectorProfiler((injectorProfilerEvent) => handleInjectorProfilerEvent(injectorProfilerEvent));
		}
		function handleInjectorProfilerEvent(injectorProfilerEvent) {
		  const { context: context2, type: type2 } = injectorProfilerEvent;
		  if (type2 === 0) {
			 handleInjectEvent(context2, injectorProfilerEvent.service);
		  } else if (type2 === 1) {
			 handleInstanceCreatedByInjectorEvent(context2, injectorProfilerEvent.instance);
		  } else if (type2 === 2) {
			 handleProviderConfiguredEvent(context2, injectorProfilerEvent.providerRecord);
		  }
		}
		function handleInjectEvent(context2, data) {
		  const diResolver = getDIResolver(context2.injector);
		  if (diResolver === null) {
			 throwError("An Inject event must be run within an injection context.");
		  }
		  const diResolverToInstantiatedToken = frameworkDIDebugData.resolverToTokenToDependencies;
		  if (!diResolverToInstantiatedToken.has(diResolver)) {
			 diResolverToInstantiatedToken.set(diResolver, /* @__PURE__ */ new WeakMap());
		  }
		  if (!canBeHeldWeakly(context2.token)) {
			 return;
		  }
		  const instantiatedTokenToDependencies = diResolverToInstantiatedToken.get(diResolver);
		  if (!instantiatedTokenToDependencies.has(context2.token)) {
			 instantiatedTokenToDependencies.set(context2.token, []);
		  }
		  const { token, value, flags } = data;
		  assertDefined(context2.token, "Injector profiler context token is undefined.");
		  const dependencies = instantiatedTokenToDependencies.get(context2.token);
		  assertDefined(dependencies, "Could not resolve dependencies for token.");
		  if (context2.injector instanceof NodeInjector) {
			 dependencies.push({ token, value, flags, injectedIn: getNodeInjectorContext(context2.injector) });
		  } else {
			 dependencies.push({ token, value, flags });
		  }
		}
		function getNodeInjectorContext(injector) {
		  if (!(injector instanceof NodeInjector)) {
			 throwError("getNodeInjectorContext must be called with a NodeInjector");
		  }
		  const lView = getNodeInjectorLView(injector);
		  const tNode = getNodeInjectorTNode(injector);
		  if (tNode === null) {
			 return;
		  }
		  assertTNodeForLView(tNode, lView);
		  return { lView, tNode };
		}
		function handleInstanceCreatedByInjectorEvent(context2, data) {
		  const { value } = data;
		  if (getDIResolver(context2.injector) === null) {
			 throwError("An InjectorCreatedInstance event must be run within an injection context.");
		  }
		  let standaloneComponent = void 0;
		  if (typeof value === "object") {
			 standaloneComponent = value?.constructor;
		  }
		  if (standaloneComponent === void 0 || !isStandaloneComponent(standaloneComponent)) {
			 return;
		  }
		  const environmentInjector = context2.injector.get(EnvironmentInjector, null, { optional: true });
		  if (environmentInjector === null) {
			 return;
		  }
		  const { standaloneInjectorToComponent } = frameworkDIDebugData;
		  if (standaloneInjectorToComponent.has(environmentInjector)) {
			 return;
		  }
		  standaloneInjectorToComponent.set(environmentInjector, standaloneComponent);
		}
		function isStandaloneComponent(value) {
		  const def = getComponentDef(value);
		  return !!def?.standalone;
		}
		function handleProviderConfiguredEvent(context2, data) {
		  const { resolverToProviders } = frameworkDIDebugData;
		  let diResolver;
		  if (context2?.injector instanceof NodeInjector) {
			 diResolver = getNodeInjectorTNode(context2.injector);
		  } else {
			 diResolver = context2.injector;
		  }
		  if (diResolver === null) {
			 throwError("A ProviderConfigured event must be run within an injection context.");
		  }
		  if (!resolverToProviders.has(diResolver)) {
			 resolverToProviders.set(diResolver, []);
		  }
		  resolverToProviders.get(diResolver).push(data);
		}
		function getDIResolver(injector) {
		  let diResolver = null;
		  if (injector === void 0) {
			 return diResolver;
		  }
		  if (injector instanceof NodeInjector) {
			 diResolver = getNodeInjectorLView(injector);
		  } else {
			 diResolver = injector;
		  }
		  return diResolver;
		}
		function canBeHeldWeakly(value) {
		  return value !== null && (typeof value === "object" || typeof value === "function" || typeof value === "symbol");
		}
		function applyChanges(component) {
		  ngDevMode && assertDefined(component, "component");
		  markViewDirty(getComponentViewByInstance(component));
		  getRootComponents(component).forEach((rootComponent) => detectChanges(rootComponent));
		}
		function detectChanges(component) {
		  const view = getComponentViewByInstance(component);
		  view[FLAGS] |= 1024;
		  detectChangesInternal(view);
		}
		function getDependenciesFromInjectable(injector, token) {
		  const instance = injector.get(token, null, { self: true, optional: true });
		  if (instance === null) {
			 throw new Error(`Unable to determine instance of ${token} in given injector`);
		  }
		  const unformattedDependencies = getDependenciesForTokenInInjector(token, injector);
		  const resolutionPath = getInjectorResolutionPath(injector);
		  const dependencies = unformattedDependencies.map((dep) => {
			 const formattedDependency = {
				value: dep.value
			 };
			 const flags = dep.flags;
			 formattedDependency.flags = {
				optional: (8 & flags) === 8,
				host: (1 & flags) === 1,
				self: (2 & flags) === 2,
				skipSelf: (4 & flags) === 4
			 };
			 for (let i = 0; i < resolutionPath.length; i++) {
				const injectorToCheck = resolutionPath[i];
				if (i === 0 && formattedDependency.flags.skipSelf) {
				  continue;
				}
				if (formattedDependency.flags.host && injectorToCheck instanceof EnvironmentInjector) {
				  break;
				}
				const instance2 = injectorToCheck.get(dep.token, null, { self: true, optional: true });
				if (instance2 !== null) {
				  if (formattedDependency.flags.host) {
					 const firstInjector = resolutionPath[0];
					 const lookupFromFirstInjector = firstInjector.get(dep.token, null, __spreadProps(__spreadValues({}, formattedDependency.flags), { optional: true }));
					 if (lookupFromFirstInjector !== null) {
						formattedDependency.providedIn = injectorToCheck;
					 }
					 break;
				  }
				  formattedDependency.providedIn = injectorToCheck;
				  break;
				}
				if (i === 0 && formattedDependency.flags.self) {
				  break;
				}
			 }
			 if (dep.token)
				formattedDependency.token = dep.token;
			 return formattedDependency;
		  });
		  return { instance, dependencies };
		}
		function getDependenciesForTokenInInjector(token, injector) {
		  const { resolverToTokenToDependencies } = getFrameworkDIDebugData();
		  if (!(injector instanceof NodeInjector)) {
			 return resolverToTokenToDependencies.get(injector)?.get?.(token) ?? [];
		  }
		  const lView = getNodeInjectorLView(injector);
		  const tokenDependencyMap = resolverToTokenToDependencies.get(lView);
		  const dependencies = tokenDependencyMap?.get(token) ?? [];
		  return dependencies.filter((dependency) => {
			 const dependencyNode = dependency.injectedIn?.tNode;
			 if (dependencyNode === void 0) {
				return false;
			 }
			 const instanceNode = getNodeInjectorTNode(injector);
			 assertTNode(dependencyNode);
			 assertTNode(instanceNode);
			 return dependencyNode === instanceNode;
		  });
		}
		function getProviderImportsContainer(injector) {
		  const { standaloneInjectorToComponent } = getFrameworkDIDebugData();
		  if (standaloneInjectorToComponent.has(injector)) {
			 return standaloneInjectorToComponent.get(injector);
		  }
		  const defTypeRef = injector.get(NgModuleRef$1, null, { self: true, optional: true });
		  if (defTypeRef === null) {
			 return null;
		  }
		  if (defTypeRef.instance === null) {
			 return null;
		  }
		  return defTypeRef.instance.constructor;
		}
		function getNodeInjectorProviders(injector) {
		  const diResolver = getNodeInjectorTNode(injector);
		  const { resolverToProviders } = getFrameworkDIDebugData();
		  return resolverToProviders.get(diResolver) ?? [];
		}
		function getProviderImportPaths(providerImportsContainer) {
		  const providerToPath = /* @__PURE__ */ new Map();
		  const visitedContainers = /* @__PURE__ */ new Set();
		  const visitor = walkProviderTreeToDiscoverImportPaths(providerToPath, visitedContainers);
		  walkProviderTree(providerImportsContainer, visitor, [], /* @__PURE__ */ new Set());
		  return providerToPath;
		}
		function walkProviderTreeToDiscoverImportPaths(providerToPath, visitedContainers) {
		  return (provider, container) => {
			 if (!providerToPath.has(provider)) {
				providerToPath.set(provider, [container]);
			 }
			 if (!visitedContainers.has(container)) {
				for (const prov of providerToPath.keys()) {
				  const existingImportPath = providerToPath.get(prov);
				  let containerDef = getInjectorDef(container);
				  if (!containerDef) {
					 const ngModule = container.ngModule;
					 containerDef = getInjectorDef(ngModule);
				  }
				  if (!containerDef) {
					 return;
				  }
				  const lastContainerAddedToPath = existingImportPath[0];
				  let isNextStepInPath = false;
				  deepForEach(containerDef.imports, (moduleImport) => {
					 if (isNextStepInPath) {
						return;
					 }
					 isNextStepInPath = moduleImport.ngModule === lastContainerAddedToPath || moduleImport === lastContainerAddedToPath;
					 if (isNextStepInPath) {
						providerToPath.get(prov)?.unshift(container);
					 }
				  });
				}
			 }
			 visitedContainers.add(container);
		  };
		}
		function getEnvironmentInjectorProviders(injector) {
		  const providerRecordsWithoutImportPaths = getFrameworkDIDebugData().resolverToProviders.get(injector) ?? [];
		  if (isPlatformInjector(injector)) {
			 return providerRecordsWithoutImportPaths;
		  }
		  const providerImportsContainer = getProviderImportsContainer(injector);
		  if (providerImportsContainer === null) {
			 return providerRecordsWithoutImportPaths;
		  }
		  const providerToPath = getProviderImportPaths(providerImportsContainer);
		  const providerRecords = [];
		  for (const providerRecord of providerRecordsWithoutImportPaths) {
			 const provider = providerRecord.provider;
			 const token = provider.provide;
			 if (token === ENVIRONMENT_INITIALIZER || token === INJECTOR_DEF_TYPES) {
				continue;
			 }
			 let importPath = providerToPath.get(provider) ?? [];
			 const def = getComponentDef(providerImportsContainer);
			 const isStandaloneComponent2 = !!def?.standalone;
			 if (isStandaloneComponent2) {
				importPath = [providerImportsContainer, ...importPath];
			 }
			 providerRecords.push(__spreadProps(__spreadValues({}, providerRecord), { importPath }));
		  }
		  return providerRecords;
		}
		function isPlatformInjector(injector) {
		  return injector instanceof R3Injector && injector.scopes.has("platform");
		}
		function getInjectorProviders(injector) {
		  if (injector instanceof NodeInjector) {
			 return getNodeInjectorProviders(injector);
		  } else if (injector instanceof EnvironmentInjector) {
			 return getEnvironmentInjectorProviders(injector);
		  }
		  throwError("getInjectorProviders only supports NodeInjector and EnvironmentInjector");
		}
		function getInjectorMetadata(injector) {
		  if (injector instanceof NodeInjector) {
			 const lView = getNodeInjectorLView(injector);
			 const tNode = getNodeInjectorTNode(injector);
			 assertTNodeForLView(tNode, lView);
			 return { type: "element", source: getNativeByTNode(tNode, lView) };
		  }
		  if (injector instanceof R3Injector) {
			 return { type: "environment", source: injector.source ?? null };
		  }
		  if (injector instanceof NullInjector) {
			 return { type: "null", source: null };
		  }
		  return null;
		}
		function getInjectorResolutionPath(injector) {
		  const resolutionPath = [injector];
		  getInjectorResolutionPathHelper(injector, resolutionPath);
		  return resolutionPath;
		}
		function getInjectorResolutionPathHelper(injector, resolutionPath) {
		  const parent = getInjectorParent(injector);
		  if (parent === null) {
			 if (injector instanceof NodeInjector) {
				const firstInjector = resolutionPath[0];
				if (firstInjector instanceof NodeInjector) {
				  const moduleInjector = getModuleInjectorOfNodeInjector(firstInjector);
				  if (moduleInjector === null) {
					 throwError("NodeInjector must have some connection to the module injector tree");
				  }
				  resolutionPath.push(moduleInjector);
				  getInjectorResolutionPathHelper(moduleInjector, resolutionPath);
				}
				return resolutionPath;
			 }
		  } else {
			 resolutionPath.push(parent);
			 getInjectorResolutionPathHelper(parent, resolutionPath);
		  }
		  return resolutionPath;
		}
		function getInjectorParent(injector) {
		  if (injector instanceof R3Injector) {
			 return injector.parent;
		  }
		  let tNode;
		  let lView;
		  if (injector instanceof NodeInjector) {
			 tNode = getNodeInjectorTNode(injector);
			 lView = getNodeInjectorLView(injector);
		  } else if (injector instanceof NullInjector) {
			 return null;
		  } else if (injector instanceof ChainedInjector) {
			 return injector.parentInjector;
		  } else {
			 throwError("getInjectorParent only support injectors of type R3Injector, NodeInjector, NullInjector, ChainedInjector");
		  }
		  const parentLocation = getParentInjectorLocation(tNode, lView);
		  if (hasParentInjector(parentLocation)) {
			 const parentInjectorIndex = getParentInjectorIndex(parentLocation);
			 const parentLView = getParentInjectorView(parentLocation, lView);
			 const parentTView = parentLView[TVIEW];
			 const parentTNode = parentTView.data[
				parentInjectorIndex + 8
				/* NodeInjectorOffset.TNODE */
			 ];
			 return new NodeInjector(parentTNode, parentLView);
		  } else {
			 const chainedInjector = lView[INJECTOR];
			 const injectorParent = chainedInjector.injector?.parent;
			 if (injectorParent instanceof NodeInjector) {
				return injectorParent;
			 }
		  }
		  return null;
		}
		function getModuleInjectorOfNodeInjector(injector) {
		  let lView;
		  if (injector instanceof NodeInjector) {
			 lView = getNodeInjectorLView(injector);
		  } else {
			 throwError("getModuleInjectorOfNodeInjector must be called with a NodeInjector");
		  }
		  const inj = lView[INJECTOR];
		  const moduleInjector = inj instanceof ChainedInjector ? inj.parentInjector : inj.parent;
		  if (!moduleInjector) {
			 throwError("NodeInjector must have some connection to the module injector tree");
		  }
		  return moduleInjector;
		}
		var GLOBAL_PUBLISH_EXPANDO_KEY = "ng";
		var globalUtilsFunctions = {
		  /**
			* Warning: functions that start with `` are considered *INTERNAL* and should not be relied upon
			* in application's code. The contract of those functions might be changed in any release and/or a
			* function can be removed completely.
			*/
		  "\u0275getDependenciesFromInjectable": getDependenciesFromInjectable,
		  "\u0275getInjectorProviders": getInjectorProviders,
		  "\u0275getInjectorResolutionPath": getInjectorResolutionPath,
		  "\u0275getInjectorMetadata": getInjectorMetadata,
		  "\u0275setProfiler": setProfiler,
		  "getDirectiveMetadata": getDirectiveMetadata$1,
		  "getComponent": getComponent$1,
		  "getContext": getContext,
		  "getListeners": getListeners,
		  "getOwningComponent": getOwningComponent,
		  "getHostElement": getHostElement,
		  "getInjector": getInjector,
		  "getRootComponents": getRootComponents,
		  "getDirectives": getDirectives,
		  "applyChanges": applyChanges,
		  "isSignal": isSignal
		};
		var _published = false;
		function publishDefaultGlobalUtils$1() {
		  if (!_published) {
			 _published = true;
			 if (typeof window !== "undefined") {
				setupFrameworkInjectorProfiler();
			 }
			 for (const [methodName, method] of Object.entries(globalUtilsFunctions)) {
				publishGlobalUtil(methodName, method);
			 }
		  }
		}
		function publishGlobalUtil(name, fn) {
		  if (typeof COMPILED === "undefined" || !COMPILED) {
			 const w = _global;
			 ngDevMode && assertDefined(fn, "function not defined");
			 w[GLOBAL_PUBLISH_EXPANDO_KEY] ??= {};
			 w[GLOBAL_PUBLISH_EXPANDO_KEY][name] = fn;
		  }
		}
		var TESTABILITY = new InjectionToken("");
		var TESTABILITY_GETTER = new InjectionToken("");
		var Testability = class _Testability {
		  constructor(_ngZone, registry, testabilityGetter) {
			 this._ngZone = _ngZone;
			 this.registry = registry;
			 this._pendingCount = 0;
			 this._isZoneStable = true;
			 this._callbacks = [];
			 this.taskTrackingZone = null;
			 if (!_testabilityGetter) {
				setTestabilityGetter(testabilityGetter);
				testabilityGetter.addToWindow(registry);
			 }
			 this._watchAngularEvents();
			 _ngZone.run(() => {
				this.taskTrackingZone = typeof Zone == "undefined" ? null : Zone.current.get("TaskTrackingZone");
			 });
		  }
		  _watchAngularEvents() {
			 this._ngZone.onUnstable.subscribe({
				next: () => {
				  this._isZoneStable = false;
				}
			 });
			 this._ngZone.runOutsideAngular(() => {
				this._ngZone.onStable.subscribe({
				  next: () => {
					 NgZone.assertNotInAngularZone();
					 queueMicrotask(() => {
						this._isZoneStable = true;
						this._runCallbacksIfReady();
					 });
				  }
				});
			 });
		  }
		  /**
			* Increases the number of pending request
			* @deprecated pending requests are now tracked with zones.
			*/
		  increasePendingRequestCount() {
			 this._pendingCount += 1;
			 return this._pendingCount;
		  }
		  /**
			* Decreases the number of pending request
			* @deprecated pending requests are now tracked with zones
			*/
		  decreasePendingRequestCount() {
			 this._pendingCount -= 1;
			 if (this._pendingCount < 0) {
				throw new Error("pending async requests below zero");
			 }
			 this._runCallbacksIfReady();
			 return this._pendingCount;
		  }
		  /**
			* Whether an associated application is stable
			*/
		  isStable() {
			 return this._isZoneStable && this._pendingCount === 0 && !this._ngZone.hasPendingMacrotasks;
		  }
		  _runCallbacksIfReady() {
			 if (this.isStable()) {
				queueMicrotask(() => {
				  while (this._callbacks.length !== 0) {
					 let cb = this._callbacks.pop();
					 clearTimeout(cb.timeoutId);
					 cb.doneCb();
				  }
				});
			 } else {
				let pending = this.getPendingTasks();
				this._callbacks = this._callbacks.filter((cb) => {
				  if (cb.updateCb && cb.updateCb(pending)) {
					 clearTimeout(cb.timeoutId);
					 return false;
				  }
				  return true;
				});
			 }
		  }
		  getPendingTasks() {
			 if (!this.taskTrackingZone) {
				return [];
			 }
			 return this.taskTrackingZone.macroTasks.map((t) => {
				return {
				  source: t.source,
				  // From TaskTrackingZone:
				  // https://github.com/angular/zone.js/blob/master/lib/zone-spec/task-tracking.ts#L40
				  creationLocation: t.creationLocation,
				  data: t.data
				};
			 });
		  }
		  addCallback(cb, timeout2, updateCb) {
			 let timeoutId = -1;
			 if (timeout2 && timeout2 > 0) {
				timeoutId = setTimeout(() => {
				  this._callbacks = this._callbacks.filter((cb2) => cb2.timeoutId !== timeoutId);
				  cb();
				}, timeout2);
			 }
			 this._callbacks.push({ doneCb: cb, timeoutId, updateCb });
		  }
		  /**
			* Wait for the application to be stable with a timeout. If the timeout is reached before that
			* happens, the callback receives a list of the macro tasks that were pending, otherwise null.
			*
			* @param doneCb The callback to invoke when Angular is stable or the timeout expires
			*    whichever comes first.
			* @param timeout Optional. The maximum time to wait for Angular to become stable. If not
			*    specified, whenStable() will wait forever.
			* @param updateCb Optional. If specified, this callback will be invoked whenever the set of
			*    pending macrotasks changes. If this callback returns true doneCb will not be invoked
			*    and no further updates will be issued.
			*/
		  whenStable(doneCb, timeout2, updateCb) {
			 if (updateCb && !this.taskTrackingZone) {
				throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?');
			 }
			 this.addCallback(doneCb, timeout2, updateCb);
			 this._runCallbacksIfReady();
		  }
		  /**
			* Get the number of pending requests
			* @deprecated pending requests are now tracked with zones
			*/
		  getPendingRequestCount() {
			 return this._pendingCount;
		  }
		  /**
			* Registers an application with a testability hook so that it can be tracked.
			* @param token token of application, root element
			*
			* @internal
			*/
		  registerApplication(token) {
			 this.registry.registerApplication(token, this);
		  }
		  /**
			* Unregisters an application.
			* @param token token of application, root element
			*
			* @internal
			*/
		  unregisterApplication(token) {
			 this.registry.unregisterApplication(token);
		  }
		  /**
			* Find providers by name
			* @param using The root element to search from
			* @param provider The name of binding variable
			* @param exactMatch Whether using exactMatch
			*/
		  findProviders(using, provider, exactMatch) {
			 return [];
		  }
		  static {
			 this.\u0275fac = function Testability_Factory(t) {
				return new (t || _Testability)(\u0275\u0275inject(NgZone), \u0275\u0275inject(TestabilityRegistry), \u0275\u0275inject(TESTABILITY_GETTER));
			 };
		  }
		  static {
			 this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _Testability, factory: _Testability.\u0275fac });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Testability, [{
			 type: Injectable
		  }], () => [{ type: NgZone }, { type: TestabilityRegistry }, { type: void 0, decorators: [{
			 type: Inject,
			 args: [TESTABILITY_GETTER]
		  }] }], null);
		})();
		var TestabilityRegistry = class _TestabilityRegistry {
		  constructor() {
			 this._applications = /* @__PURE__ */ new Map();
		  }
		  /**
			* Registers an application with a testability hook so that it can be tracked
			* @param token token of application, root element
			* @param testability Testability hook
			*/
		  registerApplication(token, testability) {
			 this._applications.set(token, testability);
		  }
		  /**
			* Unregisters an application.
			* @param token token of application, root element
			*/
		  unregisterApplication(token) {
			 this._applications.delete(token);
		  }
		  /**
			* Unregisters all applications
			*/
		  unregisterAllApplications() {
			 this._applications.clear();
		  }
		  /**
			* Get a testability hook associated with the application
			* @param elem root element
			*/
		  getTestability(elem2) {
			 return this._applications.get(elem2) || null;
		  }
		  /**
			* Get all registered testabilities
			*/
		  getAllTestabilities() {
			 return Array.from(this._applications.values());
		  }
		  /**
			* Get all registered applications(root elements)
			*/
		  getAllRootElements() {
			 return Array.from(this._applications.keys());
		  }
		  /**
			* Find testability of a node in the Tree
			* @param elem node
			* @param findInAncestors whether finding testability in ancestors if testability was not found in
			* current node
			*/
		  findTestabilityInTree(elem2, findInAncestors = true) {
			 return _testabilityGetter?.findTestabilityInTree(this, elem2, findInAncestors) ?? null;
		  }
		  static {
			 this.\u0275fac = function TestabilityRegistry_Factory(t) {
				return new (t || _TestabilityRegistry)();
			 };
		  }
		  static {
			 this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _TestabilityRegistry, factory: _TestabilityRegistry.\u0275fac, providedIn: "platform" });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TestabilityRegistry, [{
			 type: Injectable,
			 args: [{ providedIn: "platform" }]
		  }], null, null);
		})();
		function setTestabilityGetter(getter) {
		  _testabilityGetter = getter;
		}
		var _testabilityGetter;
		function isPromise2(obj) {
		  return !!obj && typeof obj.then === "function";
		}
		function isSubscribable(obj) {
		  return !!obj && typeof obj.subscribe === "function";
		}
		var APP_INITIALIZER = new InjectionToken(ngDevMode ? "Application Initializer" : "");
		var ApplicationInitStatus = class _ApplicationInitStatus {
		  constructor() {
			 this.initialized = false;
			 this.done = false;
			 this.donePromise = new Promise((res, rej) => {
				this.resolve = res;
				this.reject = rej;
			 });
			 this.appInits = inject(APP_INITIALIZER, { optional: true }) ?? [];
			 if ((typeof ngDevMode === "undefined" || ngDevMode) && !Array.isArray(this.appInits)) {
				throw new RuntimeError(-209, `Unexpected type of the \`APP_INITIALIZER\` token value (expected an array, but got ${typeof this.appInits}). Please check that the \`APP_INITIALIZER\` token is configured as a \`multi: true\` provider.`);
			 }
		  }
		  /** @internal */
		  runInitializers() {
			 if (this.initialized) {
				return;
			 }
			 const asyncInitPromises = [];
			 for (const appInits of this.appInits) {
				const initResult = appInits();
				if (isPromise2(initResult)) {
				  asyncInitPromises.push(initResult);
				} else if (isSubscribable(initResult)) {
				  const observableAsPromise = new Promise((resolve, reject) => {
					 initResult.subscribe({ complete: resolve, error: reject });
				  });
				  asyncInitPromises.push(observableAsPromise);
				}
			 }
			 const complete = () => {
				this.done = true;
				this.resolve();
			 };
			 Promise.all(asyncInitPromises).then(() => {
				complete();
			 }).catch((e) => {
				this.reject(e);
			 });
			 if (asyncInitPromises.length === 0) {
				complete();
			 }
			 this.initialized = true;
		  }
		  static {
			 this.\u0275fac = function ApplicationInitStatus_Factory(t) {
				return new (t || _ApplicationInitStatus)();
			 };
		  }
		  static {
			 this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _ApplicationInitStatus, factory: _ApplicationInitStatus.\u0275fac, providedIn: "root" });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ApplicationInitStatus, [{
			 type: Injectable,
			 args: [{ providedIn: "root" }]
		  }], () => [], null);
		})();
		var APP_BOOTSTRAP_LISTENER = new InjectionToken(ngDevMode ? "appBootstrapListener" : "");
		function publishDefaultGlobalUtils() {
		  ngDevMode && publishDefaultGlobalUtils$1();
		}
		function publishSignalConfiguration() {
		  setThrowInvalidWriteToSignalError(() => {
			 throw new RuntimeError(600, ngDevMode && "Writing to signals is not allowed in a `computed` or an `effect` by default. Use `allowSignalWrites` in the `CreateEffectOptions` to enable this inside effects.");
		  });
		}
		function isBoundToModule(cf) {
		  return cf.isBoundToModule;
		}
		function _callAndReportToErrorHandler(errorHandler2, ngZone, callback) {
		  try {
			 const result = callback();
			 if (isPromise2(result)) {
				return result.catch((e) => {
				  ngZone.runOutsideAngular(() => errorHandler2.handleError(e));
				  throw e;
				});
			 }
			 return result;
		  } catch (e) {
			 ngZone.runOutsideAngular(() => errorHandler2.handleError(e));
			 throw e;
		  }
		}
		function optionsReducer(dst, objs) {
		  if (Array.isArray(objs)) {
			 return objs.reduce(optionsReducer, dst);
		  }
		  return __spreadValues(__spreadValues({}, dst), objs);
		}
		var ApplicationRef = class _ApplicationRef {
		  constructor() {
			 this._bootstrapListeners = [];
			 this._runningTick = false;
			 this._destroyed = false;
			 this._destroyListeners = [];
			 this._views = [];
			 this.internalErrorHandler = inject(INTERNAL_APPLICATION_ERROR_HANDLER);
			 this.afterRenderEffectManager = inject(AfterRenderEventManager);
			 this.externalTestViews = /* @__PURE__ */ new Set();
			 this.beforeRender = new Subject();
			 this.afterTick = new Subject();
			 this.componentTypes = [];
			 this.components = [];
			 this.isStable = inject(PendingTasks).hasPendingTasks.pipe(map((pending) => !pending));
			 this._injector = inject(EnvironmentInjector);
		  }
		  /**
			* Indicates whether this instance was destroyed.
			*/
		  get destroyed() {
			 return this._destroyed;
		  }
		  /**
			* The `EnvironmentInjector` used to create this application.
			*/
		  get injector() {
			 return this._injector;
		  }
		  /**
			* Bootstrap a component onto the element identified by its selector or, optionally, to a
			* specified element.
			*
			* @usageNotes
			* ### Bootstrap process
			*
			* When bootstrapping a component, Angular mounts it onto a target DOM element
			* and kicks off automatic change detection. The target DOM element can be
			* provided using the `rootSelectorOrNode` argument.
			*
			* If the target DOM element is not provided, Angular tries to find one on a page
			* using the `selector` of the component that is being bootstrapped
			* (first matched element is used).
			*
			* ### Example
			*
			* Generally, we define the component to bootstrap in the `bootstrap` array of `NgModule`,
			* but it requires us to know the component while writing the application code.
			*
			* Imagine a situation where we have to wait for an API call to decide about the component to
			* bootstrap. We can use the `ngDoBootstrap` hook of the `NgModule` and call this method to
			* dynamically bootstrap a component.
			*
			* {@example core/ts/platform/platform.ts region='componentSelector'}
			*
			* Optionally, a component can be mounted onto a DOM element that does not match the
			* selector of the bootstrapped component.
			*
			* In the following example, we are providing a CSS selector to match the target element.
			*
			* {@example core/ts/platform/platform.ts region='cssSelector'}
			*
			* While in this example, we are providing reference to a DOM node.
			*
			* {@example core/ts/platform/platform.ts region='domNode'}
			*/
		  bootstrap(componentOrFactory, rootSelectorOrNode) {
			 (typeof ngDevMode === "undefined" || ngDevMode) && this.warnIfDestroyed();
			 const isComponentFactory = componentOrFactory instanceof ComponentFactory$1;
			 const initStatus = this._injector.get(ApplicationInitStatus);
			 if (!initStatus.done) {
				const standalone = !isComponentFactory && isStandalone(componentOrFactory);
				const errorMessage = (typeof ngDevMode === "undefined" || ngDevMode) && "Cannot bootstrap as there are still asynchronous initializers running." + (standalone ? "" : " Bootstrap components in the `ngDoBootstrap` method of the root module.");
				throw new RuntimeError(405, errorMessage);
			 }
			 let componentFactory;
			 if (isComponentFactory) {
				componentFactory = componentOrFactory;
			 } else {
				const resolver = this._injector.get(ComponentFactoryResolver$1);
				componentFactory = resolver.resolveComponentFactory(componentOrFactory);
			 }
			 this.componentTypes.push(componentFactory.componentType);
			 const ngModule = isBoundToModule(componentFactory) ? void 0 : this._injector.get(NgModuleRef$1);
			 const selectorOrNode = rootSelectorOrNode || componentFactory.selector;
			 const compRef = componentFactory.create(Injector.NULL, [], selectorOrNode, ngModule);
			 const nativeElement = compRef.location.nativeElement;
			 const testability = compRef.injector.get(TESTABILITY, null);
			 testability?.registerApplication(nativeElement);
			 compRef.onDestroy(() => {
				this.detachView(compRef.hostView);
				remove(this.components, compRef);
				testability?.unregisterApplication(nativeElement);
			 });
			 this._loadComponent(compRef);
			 if (typeof ngDevMode === "undefined" || ngDevMode) {
				const _console = this._injector.get(Console);
				_console.log(`Angular is running in development mode.`);
			 }
			 return compRef;
		  }
		  /**
			* Invoke this method to explicitly process change detection and its side-effects.
			*
			* In development mode, `tick()` also performs a second change detection cycle to ensure that no
			* further changes are detected. If additional changes are picked up during this second cycle,
			* bindings in the app have side-effects that cannot be resolved in a single change detection
			* pass.
			* In this case, Angular throws an error, since an Angular application can only have one change
			* detection pass during which all change detection must complete.
			*/
		  tick() {
			 this._tick(true);
		  }
		  /** @internal */
		  _tick(refreshViews) {
			 (typeof ngDevMode === "undefined" || ngDevMode) && this.warnIfDestroyed();
			 if (this._runningTick) {
				throw new RuntimeError(101, ngDevMode && "ApplicationRef.tick is called recursively");
			 }
			 const prevConsumer = setActiveConsumer(null);
			 try {
				this._runningTick = true;
				this.detectChangesInAttachedViews(refreshViews);
				if (typeof ngDevMode === "undefined" || ngDevMode) {
				  for (let view of this._views) {
					 view.checkNoChanges();
				  }
				}
			 } catch (e) {
				this.internalErrorHandler(e);
			 } finally {
				this.afterTick.next();
				this._runningTick = false;
				setActiveConsumer(prevConsumer);
			 }
		  }
		  detectChangesInAttachedViews(refreshViews) {
			 let runs = 0;
			 const afterRenderEffectManager = this.afterRenderEffectManager;
			 while (true) {
				if (runs === MAXIMUM_REFRESH_RERUNS) {
				  throw new RuntimeError(103, ngDevMode && "Infinite change detection while refreshing application views. Ensure afterRender or queueStateUpdate hooks are not continuously causing updates.");
				}
				if (refreshViews) {
				  const isFirstPass = runs === 0;
				  this.beforeRender.next(isFirstPass);
				  for (let { _lView, notifyErrorHandler } of this._views) {
					 detectChangesInViewIfRequired(_lView, isFirstPass, notifyErrorHandler);
				  }
				}
				runs++;
				afterRenderEffectManager.executeInternalCallbacks();
				if ([...this.externalTestViews.keys(), ...this._views].some(({ _lView }) => shouldRecheckView(_lView))) {
				  continue;
				}
				afterRenderEffectManager.execute();
				if (![...this.externalTestViews.keys(), ...this._views].some(({ _lView }) => shouldRecheckView(_lView))) {
				  break;
				}
			 }
		  }
		  /**
			* Attaches a view so that it will be dirty checked.
			* The view will be automatically detached when it is destroyed.
			* This will throw if the view is already attached to a ViewContainer.
			*/
		  attachView(viewRef) {
			 (typeof ngDevMode === "undefined" || ngDevMode) && this.warnIfDestroyed();
			 const view = viewRef;
			 this._views.push(view);
			 view.attachToAppRef(this);
		  }
		  /**
			* Detaches a view from dirty checking again.
			*/
		  detachView(viewRef) {
			 (typeof ngDevMode === "undefined" || ngDevMode) && this.warnIfDestroyed();
			 const view = viewRef;
			 remove(this._views, view);
			 view.detachFromAppRef();
		  }
		  _loadComponent(componentRef) {
			 this.attachView(componentRef.hostView);
			 this.tick();
			 this.components.push(componentRef);
			 const listeners = this._injector.get(APP_BOOTSTRAP_LISTENER, []);
			 if (ngDevMode && !Array.isArray(listeners)) {
				throw new RuntimeError(-209, `Unexpected type of the \`APP_BOOTSTRAP_LISTENER\` token value (expected an array, but got ${typeof listeners}). Please check that the \`APP_BOOTSTRAP_LISTENER\` token is configured as a \`multi: true\` provider.`);
			 }
			 [...this._bootstrapListeners, ...listeners].forEach((listener) => listener(componentRef));
		  }
		  /** @internal */
		  ngOnDestroy() {
			 if (this._destroyed)
				return;
			 try {
				this._destroyListeners.forEach((listener) => listener());
				this._views.slice().forEach((view) => view.destroy());
			 } finally {
				this._destroyed = true;
				this._views = [];
				this._bootstrapListeners = [];
				this._destroyListeners = [];
			 }
		  }
		  /**
			* Registers a listener to be called when an instance is destroyed.
			*
			* @param callback A callback function to add as a listener.
			* @returns A function which unregisters a listener.
			*/
		  onDestroy(callback) {
			 (typeof ngDevMode === "undefined" || ngDevMode) && this.warnIfDestroyed();
			 this._destroyListeners.push(callback);
			 return () => remove(this._destroyListeners, callback);
		  }
		  /**
			* Destroys an Angular application represented by this `ApplicationRef`. Calling this function
			* will destroy the associated environment injectors as well as all the bootstrapped components
			* with their views.
			*/
		  destroy() {
			 if (this._destroyed) {
				throw new RuntimeError(406, ngDevMode && "This instance of the `ApplicationRef` has already been destroyed.");
			 }
			 const injector = this._injector;
			 if (injector.destroy && !injector.destroyed) {
				injector.destroy();
			 }
		  }
		  /**
			* Returns the number of attached views.
			*/
		  get viewCount() {
			 return this._views.length;
		  }
		  warnIfDestroyed() {
			 if ((typeof ngDevMode === "undefined" || ngDevMode) && this._destroyed) {
				console.warn(formatRuntimeError(406, "This instance of the `ApplicationRef` has already been destroyed."));
			 }
		  }
		  static {
			 this.\u0275fac = function ApplicationRef_Factory(t) {
				return new (t || _ApplicationRef)();
			 };
		  }
		  static {
			 this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _ApplicationRef, factory: _ApplicationRef.\u0275fac, providedIn: "root" });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ApplicationRef, [{
			 type: Injectable,
			 args: [{ providedIn: "root" }]
		  }], null, null);
		})();
		function remove(list, el) {
		  const index = list.indexOf(el);
		  if (index > -1) {
			 list.splice(index, 1);
		  }
		}
		function detectChangesInViewIfRequired(lView, isFirstPass, notifyErrorHandler) {
		  if (!isFirstPass && !shouldRecheckView(lView)) {
			 return;
		  }
		  detectChangesInView(lView, notifyErrorHandler, isFirstPass);
		}
		function shouldRecheckView(view) {
		  return requiresRefreshOrTraversal(view);
		}
		function detectChangesInView(lView, notifyErrorHandler, isFirstPass) {
		  let mode;
		  if (isFirstPass) {
			 mode = 0;
			 lView[FLAGS] |= 1024;
		  } else if (lView[FLAGS] & 64) {
			 mode = 0;
		  } else {
			 mode = 1;
		  }
		  detectChangesInternal(lView, notifyErrorHandler, mode);
		}
		var ModuleWithComponentFactories = class {
		  constructor(ngModuleFactory, componentFactories) {
			 this.ngModuleFactory = ngModuleFactory;
			 this.componentFactories = componentFactories;
		  }
		};
		var Compiler = class _Compiler {
		  /**
			* Compiles the given NgModule and all of its components. All templates of the components
			* have to be inlined.
			*/
		  compileModuleSync(moduleType) {
			 return new NgModuleFactory(moduleType);
		  }
		  /**
			* Compiles the given NgModule and all of its components
			*/
		  compileModuleAsync(moduleType) {
			 return Promise.resolve(this.compileModuleSync(moduleType));
		  }
		  /**
			* Same as {@link #compileModuleSync} but also creates ComponentFactories for all components.
			*/
		  compileModuleAndAllComponentsSync(moduleType) {
			 const ngModuleFactory = this.compileModuleSync(moduleType);
			 const moduleDef = getNgModuleDef(moduleType);
			 const componentFactories = maybeUnwrapFn(moduleDef.declarations).reduce((factories, declaration) => {
				const componentDef = getComponentDef(declaration);
				componentDef && factories.push(new ComponentFactory(componentDef));
				return factories;
			 }, []);
			 return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);
		  }
		  /**
			* Same as {@link #compileModuleAsync} but also creates ComponentFactories for all components.
			*/
		  compileModuleAndAllComponentsAsync(moduleType) {
			 return Promise.resolve(this.compileModuleAndAllComponentsSync(moduleType));
		  }
		  /**
			* Clears all caches.
			*/
		  clearCache() {
		  }
		  /**
			* Clears the cache for the given component/ngModule.
			*/
		  clearCacheFor(type2) {
		  }
		  /**
			* Returns the id for a given NgModule, if one is defined and known to the compiler.
			*/
		  getModuleId(moduleType) {
			 return void 0;
		  }
		  static {
			 this.\u0275fac = function Compiler_Factory(t) {
				return new (t || _Compiler)();
			 };
		  }
		  static {
			 this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _Compiler, factory: _Compiler.\u0275fac, providedIn: "root" });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Compiler, [{
			 type: Injectable,
			 args: [{ providedIn: "root" }]
		  }], null, null);
		})();
		var COMPILER_OPTIONS = new InjectionToken(ngDevMode ? "compilerOptions" : "");
		function compileNgModuleFactory(injector, options, moduleType) {
		  ngDevMode && assertNgModuleType(moduleType);
		  const moduleFactory = new NgModuleFactory(moduleType);
		  if (true) {
			 return Promise.resolve(moduleFactory);
		  }
		  const compilerOptions = injector.get(COMPILER_OPTIONS, []).concat(options);
		  setJitOptions({
			 defaultEncapsulation: _lastDefined(compilerOptions.map((opts) => opts.defaultEncapsulation)),
			 preserveWhitespaces: _lastDefined(compilerOptions.map((opts) => opts.preserveWhitespaces))
		  });
		  if (isComponentResourceResolutionQueueEmpty()) {
			 return Promise.resolve(moduleFactory);
		  }
		  const compilerProviders = compilerOptions.flatMap((option) => option.providers ?? []);
		  if (compilerProviders.length === 0) {
			 return Promise.resolve(moduleFactory);
		  }
		  const compiler = getCompilerFacade({
			 usage: 0,
			 kind: "NgModule",
			 type: moduleType
		  });
		  const compilerInjector = Injector.create({ providers: compilerProviders });
		  const resourceLoader = compilerInjector.get(compiler.ResourceLoader);
		  return resolveComponentResources((url) => Promise.resolve(resourceLoader.get(url))).then(() => moduleFactory);
		}
		function _lastDefined(args) {
		  for (let i = args.length - 1; i >= 0; i--) {
			 if (args[i] !== void 0) {
				return args[i];
			 }
		  }
		  return void 0;
		}
		var NgZoneChangeDetectionScheduler = class _NgZoneChangeDetectionScheduler {
		  constructor() {
			 this.zone = inject(NgZone);
			 this.applicationRef = inject(ApplicationRef);
		  }
		  initialize() {
			 if (this._onMicrotaskEmptySubscription) {
				return;
			 }
			 this._onMicrotaskEmptySubscription = this.zone.onMicrotaskEmpty.subscribe({
				next: () => {
				  this.zone.run(() => {
					 this.applicationRef.tick();
				  });
				}
			 });
		  }
		  ngOnDestroy() {
			 this._onMicrotaskEmptySubscription?.unsubscribe();
		  }
		  static {
			 this.\u0275fac = function NgZoneChangeDetectionScheduler_Factory(t) {
				return new (t || _NgZoneChangeDetectionScheduler)();
			 };
		  }
		  static {
			 this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _NgZoneChangeDetectionScheduler, factory: _NgZoneChangeDetectionScheduler.\u0275fac, providedIn: "root" });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgZoneChangeDetectionScheduler, [{
			 type: Injectable,
			 args: [{ providedIn: "root" }]
		  }], null, null);
		})();
		var PROVIDED_NG_ZONE = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "provideZoneChangeDetection token" : "");
		function internalProvideZoneChangeDetection(ngZoneFactory) {
		  return [
			 { provide: NgZone, useFactory: ngZoneFactory },
			 {
				provide: ENVIRONMENT_INITIALIZER,
				multi: true,
				useFactory: () => {
				  const ngZoneChangeDetectionScheduler = inject(NgZoneChangeDetectionScheduler, { optional: true });
				  if ((typeof ngDevMode === "undefined" || ngDevMode) && ngZoneChangeDetectionScheduler === null) {
					 throw new RuntimeError(402, `A required Injectable was not found in the dependency injection tree. If you are bootstrapping an NgModule, make sure that the \`BrowserModule\` is imported.`);
				  }
				  return () => ngZoneChangeDetectionScheduler.initialize();
				}
			 },
			 {
				provide: ENVIRONMENT_INITIALIZER,
				multi: true,
				useFactory: () => {
				  const service = inject(ZoneStablePendingTask);
				  return () => {
					 service.initialize();
				  };
				}
			 },
			 { provide: INTERNAL_APPLICATION_ERROR_HANDLER, useFactory: ngZoneApplicationErrorHandlerFactory }
		  ];
		}
		function ngZoneApplicationErrorHandlerFactory() {
		  const zone = inject(NgZone);
		  const userErrorHandler = inject(ErrorHandler);
		  return (e) => zone.runOutsideAngular(() => userErrorHandler.handleError(e));
		}
		function provideZoneChangeDetection(options) {
		  const zoneProviders = internalProvideZoneChangeDetection(() => new NgZone(getNgZoneOptions(options)));
		  return makeEnvironmentProviders([
			 typeof ngDevMode === "undefined" || ngDevMode ? { provide: PROVIDED_NG_ZONE, useValue: true } : [],
			 zoneProviders
		  ]);
		}
		function getNgZoneOptions(options) {
		  return {
			 enableLongStackTrace: typeof ngDevMode === "undefined" ? false : !!ngDevMode,
			 shouldCoalesceEventChangeDetection: options?.eventCoalescing ?? false,
			 shouldCoalesceRunChangeDetection: options?.runCoalescing ?? false
		  };
		}
		var ZoneStablePendingTask = class _ZoneStablePendingTask {
		  constructor() {
			 this.subscription = new Subscription();
			 this.initialized = false;
			 this.zone = inject(NgZone);
			 this.pendingTasks = inject(PendingTasks);
		  }
		  initialize() {
			 if (this.initialized) {
				return;
			 }
			 this.initialized = true;
			 let task = null;
			 if (!this.zone.isStable && !this.zone.hasPendingMacrotasks && !this.zone.hasPendingMicrotasks) {
				task = this.pendingTasks.add();
			 }
			 this.zone.runOutsideAngular(() => {
				this.subscription.add(this.zone.onStable.subscribe(() => {
				  NgZone.assertNotInAngularZone();
				  queueMicrotask(() => {
					 if (task !== null && !this.zone.hasPendingMacrotasks && !this.zone.hasPendingMicrotasks) {
						this.pendingTasks.remove(task);
						task = null;
					 }
				  });
				}));
			 });
			 this.subscription.add(this.zone.onUnstable.subscribe(() => {
				NgZone.assertInAngularZone();
				task ??= this.pendingTasks.add();
			 }));
		  }
		  ngOnDestroy() {
			 this.subscription.unsubscribe();
		  }
		  static {
			 this.\u0275fac = function ZoneStablePendingTask_Factory(t) {
				return new (t || _ZoneStablePendingTask)();
			 };
		  }
		  static {
			 this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _ZoneStablePendingTask, factory: _ZoneStablePendingTask.\u0275fac, providedIn: "root" });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ZoneStablePendingTask, [{
			 type: Injectable,
			 args: [{ providedIn: "root" }]
		  }], null, null);
		})();
		function getGlobalLocale() {
		  if (false) {
			 return goog.LOCALE;
		  } else {
			 return typeof $localize !== "undefined" && $localize.locale || DEFAULT_LOCALE_ID;
		  }
		}
		var LOCALE_ID = new InjectionToken(ngDevMode ? "LocaleId" : "", {
		  providedIn: "root",
		  factory: () => inject(LOCALE_ID, InjectFlags.Optional | InjectFlags.SkipSelf) || getGlobalLocale()
		});
		var DEFAULT_CURRENCY_CODE = new InjectionToken(ngDevMode ? "DefaultCurrencyCode" : "", {
		  providedIn: "root",
		  factory: () => USD_CURRENCY_CODE
		});
		var TRANSLATIONS = new InjectionToken(ngDevMode ? "Translations" : "");
		var TRANSLATIONS_FORMAT = new InjectionToken(ngDevMode ? "TranslationsFormat" : "");
		var MissingTranslationStrategy;
		(function(MissingTranslationStrategy2) {
		  MissingTranslationStrategy2[MissingTranslationStrategy2["Error"] = 0] = "Error";
		  MissingTranslationStrategy2[MissingTranslationStrategy2["Warning"] = 1] = "Warning";
		  MissingTranslationStrategy2[MissingTranslationStrategy2["Ignore"] = 2] = "Ignore";
		})(MissingTranslationStrategy || (MissingTranslationStrategy = {}));
		var PLATFORM_DESTROY_LISTENERS = new InjectionToken(ngDevMode ? "PlatformDestroyListeners" : "");
		var PlatformRef = class _PlatformRef {
		  /** @internal */
		  constructor(_injector) {
			 this._injector = _injector;
			 this._modules = [];
			 this._destroyListeners = [];
			 this._destroyed = false;
		  }
		  /**
			* Creates an instance of an `@NgModule` for the given platform.
			*
			* @deprecated Passing NgModule factories as the `PlatformRef.bootstrapModuleFactory` function
			*     argument is deprecated. Use the `PlatformRef.bootstrapModule` API instead.
			*/
		  bootstrapModuleFactory(moduleFactory, options) {
			 const ngZone = getNgZone(options?.ngZone, getNgZoneOptions({
				eventCoalescing: options?.ngZoneEventCoalescing,
				runCoalescing: options?.ngZoneRunCoalescing
			 }));
			 return ngZone.run(() => {
				const moduleRef = createNgModuleRefWithProviders(moduleFactory.moduleType, this.injector, internalProvideZoneChangeDetection(() => ngZone));
				if ((typeof ngDevMode === "undefined" || ngDevMode) && moduleRef.injector.get(PROVIDED_NG_ZONE, null) !== null) {
				  throw new RuntimeError(207, "`bootstrapModule` does not support `provideZoneChangeDetection`. Use `BootstrapOptions` instead.");
				}
				const exceptionHandler = moduleRef.injector.get(ErrorHandler, null);
				if ((typeof ngDevMode === "undefined" || ngDevMode) && exceptionHandler === null) {
				  throw new RuntimeError(402, "No ErrorHandler. Is platform module (BrowserModule) included?");
				}
				ngZone.runOutsideAngular(() => {
				  const subscription = ngZone.onError.subscribe({
					 next: (error) => {
						exceptionHandler.handleError(error);
					 }
				  });
				  moduleRef.onDestroy(() => {
					 remove(this._modules, moduleRef);
					 subscription.unsubscribe();
				  });
				});
				return _callAndReportToErrorHandler(exceptionHandler, ngZone, () => {
				  const initStatus = moduleRef.injector.get(ApplicationInitStatus);
				  initStatus.runInitializers();
				  return initStatus.donePromise.then(() => {
					 const localeId = moduleRef.injector.get(LOCALE_ID, DEFAULT_LOCALE_ID);
					 setLocaleId(localeId || DEFAULT_LOCALE_ID);
					 this._moduleDoBootstrap(moduleRef);
					 return moduleRef;
				  });
				});
			 });
		  }
		  /**
			* Creates an instance of an `@NgModule` for a given platform.
			*
			* @usageNotes
			* ### Simple Example
			*
			* ```typescript
			* @NgModule({
			*   imports: [BrowserModule]
			* })
			* class MyModule {}
			*
			* let moduleRef = platformBrowser().bootstrapModule(MyModule);
			* ```
			*
			*/
		  bootstrapModule(moduleType, compilerOptions = []) {
			 const options = optionsReducer({}, compilerOptions);
			 return compileNgModuleFactory(this.injector, options, moduleType).then((moduleFactory) => this.bootstrapModuleFactory(moduleFactory, options));
		  }
		  _moduleDoBootstrap(moduleRef) {
			 const appRef = moduleRef.injector.get(ApplicationRef);
			 if (moduleRef._bootstrapComponents.length > 0) {
				moduleRef._bootstrapComponents.forEach((f) => appRef.bootstrap(f));
			 } else if (moduleRef.instance.ngDoBootstrap) {
				moduleRef.instance.ngDoBootstrap(appRef);
			 } else {
				throw new RuntimeError(-403, ngDevMode && `The module ${stringify(moduleRef.instance.constructor)} was bootstrapped, but it does not declare "@NgModule.bootstrap" components nor a "ngDoBootstrap" method. Please define one of these.`);
			 }
			 this._modules.push(moduleRef);
		  }
		  /**
			* Registers a listener to be called when the platform is destroyed.
			*/
		  onDestroy(callback) {
			 this._destroyListeners.push(callback);
		  }
		  /**
			* Retrieves the platform {@link Injector}, which is the parent injector for
			* every Angular application on the page and provides singleton providers.
			*/
		  get injector() {
			 return this._injector;
		  }
		  /**
			* Destroys the current Angular platform and all Angular applications on the page.
			* Destroys all modules and listeners registered with the platform.
			*/
		  destroy() {
			 if (this._destroyed) {
				throw new RuntimeError(404, ngDevMode && "The platform has already been destroyed!");
			 }
			 this._modules.slice().forEach((module) => module.destroy());
			 this._destroyListeners.forEach((listener) => listener());
			 const destroyListeners = this._injector.get(PLATFORM_DESTROY_LISTENERS, null);
			 if (destroyListeners) {
				destroyListeners.forEach((listener) => listener());
				destroyListeners.clear();
			 }
			 this._destroyed = true;
		  }
		  /**
			* Indicates whether this instance was destroyed.
			*/
		  get destroyed() {
			 return this._destroyed;
		  }
		  static {
			 this.\u0275fac = function PlatformRef_Factory(t) {
				return new (t || _PlatformRef)(\u0275\u0275inject(Injector));
			 };
		  }
		  static {
			 this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _PlatformRef, factory: _PlatformRef.\u0275fac, providedIn: "platform" });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlatformRef, [{
			 type: Injectable,
			 args: [{ providedIn: "platform" }]
		  }], () => [{ type: Injector }], null);
		})();
		var _platformInjector = null;
		var ALLOW_MULTIPLE_PLATFORMS = new InjectionToken(ngDevMode ? "AllowMultipleToken" : "");
		function createPlatform(injector) {
		  if (_platformInjector && !_platformInjector.get(ALLOW_MULTIPLE_PLATFORMS, false)) {
			 throw new RuntimeError(400, ngDevMode && "There can be only one platform. Destroy the previous one to create a new one.");
		  }
		  publishDefaultGlobalUtils();
		  publishSignalConfiguration();
		  _platformInjector = injector;
		  const platform = injector.get(PlatformRef);
		  runPlatformInitializers(injector);
		  return platform;
		}
		function createPlatformFactory(parentPlatformFactory, name, providers = []) {
		  const desc = `Platform: ${name}`;
		  const marker = new InjectionToken(desc);
		  return (extraProviders = []) => {
			 let platform = getPlatform();
			 if (!platform || platform.injector.get(ALLOW_MULTIPLE_PLATFORMS, false)) {
				const platformProviders = [...providers, ...extraProviders, { provide: marker, useValue: true }];
				if (parentPlatformFactory) {
				  parentPlatformFactory(platformProviders);
				} else {
				  createPlatform(createPlatformInjector(platformProviders, desc));
				}
			 }
			 return assertPlatform(marker);
		  };
		}
		function createPlatformInjector(providers = [], name) {
		  return Injector.create({
			 name,
			 providers: [
				{ provide: INJECTOR_SCOPE, useValue: "platform" },
				{ provide: PLATFORM_DESTROY_LISTENERS, useValue: /* @__PURE__ */ new Set([() => _platformInjector = null]) },
				...providers
			 ]
		  });
		}
		function assertPlatform(requiredToken) {
		  const platform = getPlatform();
		  if (!platform) {
			 throw new RuntimeError(401, ngDevMode && "No platform exists!");
		  }
		  if ((typeof ngDevMode === "undefined" || ngDevMode) && !platform.injector.get(requiredToken, null)) {
			 throw new RuntimeError(400, "A platform with a different configuration has been created. Please destroy it first.");
		  }
		  return platform;
		}
		function getPlatform() {
		  return _platformInjector?.get(PlatformRef) ?? null;
		}
		function createOrReusePlatformInjector(providers = []) {
		  if (_platformInjector)
			 return _platformInjector;
		  publishDefaultGlobalUtils();
		  const injector = createPlatformInjector(providers);
		  _platformInjector = injector;
		  publishSignalConfiguration();
		  runPlatformInitializers(injector);
		  return injector;
		}
		function runPlatformInitializers(injector) {
		  const inits = injector.get(PLATFORM_INITIALIZER, null);
		  inits?.forEach((init2) => init2());
		}
		var ChangeDetectorRef = class {
		  static {
			 this.__NG_ELEMENT_ID__ = injectChangeDetectorRef;
		  }
		};
		function injectChangeDetectorRef(flags) {
		  return createViewRef(
			 getCurrentTNode(),
			 getLView(),
			 (flags & 16) === 16
			 /* InternalInjectFlags.ForPipe */
		  );
		}
		function createViewRef(tNode, lView, isPipe2) {
		  if (isComponentHost(tNode) && !isPipe2) {
			 const componentView = getComponentLViewByIndex(tNode.index, lView);
			 return new ViewRef$1(componentView, componentView);
		  } else if (tNode.type & (3 | 12 | 32)) {
			 const hostComponentView = lView[DECLARATION_COMPONENT_VIEW];
			 return new ViewRef$1(hostComponentView, lView);
		  }
		  return null;
		}
		var DefaultIterableDifferFactory = class {
		  constructor() {
		  }
		  supports(obj) {
			 return isListLikeIterable(obj);
		  }
		  create(trackByFn) {
			 return new DefaultIterableDiffer(trackByFn);
		  }
		};
		var trackByIdentity = (index, item) => item;
		var DefaultIterableDiffer = class {
		  constructor(trackByFn) {
			 this.length = 0;
			 this._linkedRecords = null;
			 this._unlinkedRecords = null;
			 this._previousItHead = null;
			 this._itHead = null;
			 this._itTail = null;
			 this._additionsHead = null;
			 this._additionsTail = null;
			 this._movesHead = null;
			 this._movesTail = null;
			 this._removalsHead = null;
			 this._removalsTail = null;
			 this._identityChangesHead = null;
			 this._identityChangesTail = null;
			 this._trackByFn = trackByFn || trackByIdentity;
		  }
		  forEachItem(fn) {
			 let record;
			 for (record = this._itHead; record !== null; record = record._next) {
				fn(record);
			 }
		  }
		  forEachOperation(fn) {
			 let nextIt = this._itHead;
			 let nextRemove = this._removalsHead;
			 let addRemoveOffset = 0;
			 let moveOffsets = null;
			 while (nextIt || nextRemove) {
				const record = !nextRemove || nextIt && nextIt.currentIndex < getPreviousIndex(nextRemove, addRemoveOffset, moveOffsets) ? nextIt : nextRemove;
				const adjPreviousIndex = getPreviousIndex(record, addRemoveOffset, moveOffsets);
				const currentIndex = record.currentIndex;
				if (record === nextRemove) {
				  addRemoveOffset--;
				  nextRemove = nextRemove._nextRemoved;
				} else {
				  nextIt = nextIt._next;
				  if (record.previousIndex == null) {
					 addRemoveOffset++;
				  } else {
					 if (!moveOffsets)
						moveOffsets = [];
					 const localMovePreviousIndex = adjPreviousIndex - addRemoveOffset;
					 const localCurrentIndex = currentIndex - addRemoveOffset;
					 if (localMovePreviousIndex != localCurrentIndex) {
						for (let i = 0; i < localMovePreviousIndex; i++) {
						  const offset = i < moveOffsets.length ? moveOffsets[i] : moveOffsets[i] = 0;
						  const index = offset + i;
						  if (localCurrentIndex <= index && index < localMovePreviousIndex) {
							 moveOffsets[i] = offset + 1;
						  }
						}
						const previousIndex = record.previousIndex;
						moveOffsets[previousIndex] = localCurrentIndex - localMovePreviousIndex;
					 }
				  }
				}
				if (adjPreviousIndex !== currentIndex) {
				  fn(record, adjPreviousIndex, currentIndex);
				}
			 }
		  }
		  forEachPreviousItem(fn) {
			 let record;
			 for (record = this._previousItHead; record !== null; record = record._nextPrevious) {
				fn(record);
			 }
		  }
		  forEachAddedItem(fn) {
			 let record;
			 for (record = this._additionsHead; record !== null; record = record._nextAdded) {
				fn(record);
			 }
		  }
		  forEachMovedItem(fn) {
			 let record;
			 for (record = this._movesHead; record !== null; record = record._nextMoved) {
				fn(record);
			 }
		  }
		  forEachRemovedItem(fn) {
			 let record;
			 for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
				fn(record);
			 }
		  }
		  forEachIdentityChange(fn) {
			 let record;
			 for (record = this._identityChangesHead; record !== null; record = record._nextIdentityChange) {
				fn(record);
			 }
		  }
		  diff(collection) {
			 if (collection == null)
				collection = [];
			 if (!isListLikeIterable(collection)) {
				throw new RuntimeError(900, ngDevMode && `Error trying to diff '${stringify(collection)}'. Only arrays and iterables are allowed`);
			 }
			 if (this.check(collection)) {
				return this;
			 } else {
				return null;
			 }
		  }
		  onDestroy() {
		  }
		  check(collection) {
			 this._reset();
			 let record = this._itHead;
			 let mayBeDirty = false;
			 let index;
			 let item;
			 let itemTrackBy;
			 if (Array.isArray(collection)) {
				this.length = collection.length;
				for (let index2 = 0; index2 < this.length; index2++) {
				  item = collection[index2];
				  itemTrackBy = this._trackByFn(index2, item);
				  if (record === null || !Object.is(record.trackById, itemTrackBy)) {
					 record = this._mismatch(record, item, itemTrackBy, index2);
					 mayBeDirty = true;
				  } else {
					 if (mayBeDirty) {
						record = this._verifyReinsertion(record, item, itemTrackBy, index2);
					 }
					 if (!Object.is(record.item, item))
						this._addIdentityChange(record, item);
				  }
				  record = record._next;
				}
			 } else {
				index = 0;
				iterateListLike(collection, (item2) => {
				  itemTrackBy = this._trackByFn(index, item2);
				  if (record === null || !Object.is(record.trackById, itemTrackBy)) {
					 record = this._mismatch(record, item2, itemTrackBy, index);
					 mayBeDirty = true;
				  } else {
					 if (mayBeDirty) {
						record = this._verifyReinsertion(record, item2, itemTrackBy, index);
					 }
					 if (!Object.is(record.item, item2))
						this._addIdentityChange(record, item2);
				  }
				  record = record._next;
				  index++;
				});
				this.length = index;
			 }
			 this._truncate(record);
			 this.collection = collection;
			 return this.isDirty;
		  }
		  /* CollectionChanges is considered dirty if it has any additions, moves, removals, or identity
			* changes.
			*/
		  get isDirty() {
			 return this._additionsHead !== null || this._movesHead !== null || this._removalsHead !== null || this._identityChangesHead !== null;
		  }
		  /**
			* Reset the state of the change objects to show no changes. This means set previousKey to
			* currentKey, and clear all of the queues (additions, moves, removals).
			* Set the previousIndexes of moved and added items to their currentIndexes
			* Reset the list of additions, moves and removals
			*
			* @internal
			*/
		  _reset() {
			 if (this.isDirty) {
				let record;
				for (record = this._previousItHead = this._itHead; record !== null; record = record._next) {
				  record._nextPrevious = record._next;
				}
				for (record = this._additionsHead; record !== null; record = record._nextAdded) {
				  record.previousIndex = record.currentIndex;
				}
				this._additionsHead = this._additionsTail = null;
				for (record = this._movesHead; record !== null; record = record._nextMoved) {
				  record.previousIndex = record.currentIndex;
				}
				this._movesHead = this._movesTail = null;
				this._removalsHead = this._removalsTail = null;
				this._identityChangesHead = this._identityChangesTail = null;
			 }
		  }
		  /**
			* This is the core function which handles differences between collections.
			*
			* - `record` is the record which we saw at this position last time. If null then it is a new
			*   item.
			* - `item` is the current item in the collection
			* - `index` is the position of the item in the collection
			*
			* @internal
			*/
		  _mismatch(record, item, itemTrackBy, index) {
			 let previousRecord;
			 if (record === null) {
				previousRecord = this._itTail;
			 } else {
				previousRecord = record._prev;
				this._remove(record);
			 }
			 record = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);
			 if (record !== null) {
				if (!Object.is(record.item, item))
				  this._addIdentityChange(record, item);
				this._reinsertAfter(record, previousRecord, index);
			 } else {
				record = this._linkedRecords === null ? null : this._linkedRecords.get(itemTrackBy, index);
				if (record !== null) {
				  if (!Object.is(record.item, item))
					 this._addIdentityChange(record, item);
				  this._moveAfter(record, previousRecord, index);
				} else {
				  record = this._addAfter(new IterableChangeRecord_(item, itemTrackBy), previousRecord, index);
				}
			 }
			 return record;
		  }
		  /**
			* This check is only needed if an array contains duplicates. (Short circuit of nothing dirty)
			*
			* Use case: `[a, a]` => `[b, a, a]`
			*
			* If we did not have this check then the insertion of `b` would:
			*   1) evict first `a`
			*   2) insert `b` at `0` index.
			*   3) leave `a` at index `1` as is. <-- this is wrong!
			*   3) reinsert `a` at index 2. <-- this is wrong!
			*
			* The correct behavior is:
			*   1) evict first `a`
			*   2) insert `b` at `0` index.
			*   3) reinsert `a` at index 1.
			*   3) move `a` at from `1` to `2`.
			*
			*
			* Double check that we have not evicted a duplicate item. We need to check if the item type may
			* have already been removed:
			* The insertion of b will evict the first 'a'. If we don't reinsert it now it will be reinserted
			* at the end. Which will show up as the two 'a's switching position. This is incorrect, since a
			* better way to think of it is as insert of 'b' rather then switch 'a' with 'b' and then add 'a'
			* at the end.
			*
			* @internal
			*/
		  _verifyReinsertion(record, item, itemTrackBy, index) {
			 let reinsertRecord = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);
			 if (reinsertRecord !== null) {
				record = this._reinsertAfter(reinsertRecord, record._prev, index);
			 } else if (record.currentIndex != index) {
				record.currentIndex = index;
				this._addToMoves(record, index);
			 }
			 return record;
		  }
		  /**
			* Get rid of any excess {@link IterableChangeRecord_}s from the previous collection
			*
			* - `record` The first excess {@link IterableChangeRecord_}.
			*
			* @internal
			*/
		  _truncate(record) {
			 while (record !== null) {
				const nextRecord = record._next;
				this._addToRemovals(this._unlink(record));
				record = nextRecord;
			 }
			 if (this._unlinkedRecords !== null) {
				this._unlinkedRecords.clear();
			 }
			 if (this._additionsTail !== null) {
				this._additionsTail._nextAdded = null;
			 }
			 if (this._movesTail !== null) {
				this._movesTail._nextMoved = null;
			 }
			 if (this._itTail !== null) {
				this._itTail._next = null;
			 }
			 if (this._removalsTail !== null) {
				this._removalsTail._nextRemoved = null;
			 }
			 if (this._identityChangesTail !== null) {
				this._identityChangesTail._nextIdentityChange = null;
			 }
		  }
		  /** @internal */
		  _reinsertAfter(record, prevRecord, index) {
			 if (this._unlinkedRecords !== null) {
				this._unlinkedRecords.remove(record);
			 }
			 const prev = record._prevRemoved;
			 const next = record._nextRemoved;
			 if (prev === null) {
				this._removalsHead = next;
			 } else {
				prev._nextRemoved = next;
			 }
			 if (next === null) {
				this._removalsTail = prev;
			 } else {
				next._prevRemoved = prev;
			 }
			 this._insertAfter(record, prevRecord, index);
			 this._addToMoves(record, index);
			 return record;
		  }
		  /** @internal */
		  _moveAfter(record, prevRecord, index) {
			 this._unlink(record);
			 this._insertAfter(record, prevRecord, index);
			 this._addToMoves(record, index);
			 return record;
		  }
		  /** @internal */
		  _addAfter(record, prevRecord, index) {
			 this._insertAfter(record, prevRecord, index);
			 if (this._additionsTail === null) {
				this._additionsTail = this._additionsHead = record;
			 } else {
				this._additionsTail = this._additionsTail._nextAdded = record;
			 }
			 return record;
		  }
		  /** @internal */
		  _insertAfter(record, prevRecord, index) {
			 const next = prevRecord === null ? this._itHead : prevRecord._next;
			 record._next = next;
			 record._prev = prevRecord;
			 if (next === null) {
				this._itTail = record;
			 } else {
				next._prev = record;
			 }
			 if (prevRecord === null) {
				this._itHead = record;
			 } else {
				prevRecord._next = record;
			 }
			 if (this._linkedRecords === null) {
				this._linkedRecords = new _DuplicateMap();
			 }
			 this._linkedRecords.put(record);
			 record.currentIndex = index;
			 return record;
		  }
		  /** @internal */
		  _remove(record) {
			 return this._addToRemovals(this._unlink(record));
		  }
		  /** @internal */
		  _unlink(record) {
			 if (this._linkedRecords !== null) {
				this._linkedRecords.remove(record);
			 }
			 const prev = record._prev;
			 const next = record._next;
			 if (prev === null) {
				this._itHead = next;
			 } else {
				prev._next = next;
			 }
			 if (next === null) {
				this._itTail = prev;
			 } else {
				next._prev = prev;
			 }
			 return record;
		  }
		  /** @internal */
		  _addToMoves(record, toIndex) {
			 if (record.previousIndex === toIndex) {
				return record;
			 }
			 if (this._movesTail === null) {
				this._movesTail = this._movesHead = record;
			 } else {
				this._movesTail = this._movesTail._nextMoved = record;
			 }
			 return record;
		  }
		  _addToRemovals(record) {
			 if (this._unlinkedRecords === null) {
				this._unlinkedRecords = new _DuplicateMap();
			 }
			 this._unlinkedRecords.put(record);
			 record.currentIndex = null;
			 record._nextRemoved = null;
			 if (this._removalsTail === null) {
				this._removalsTail = this._removalsHead = record;
				record._prevRemoved = null;
			 } else {
				record._prevRemoved = this._removalsTail;
				this._removalsTail = this._removalsTail._nextRemoved = record;
			 }
			 return record;
		  }
		  /** @internal */
		  _addIdentityChange(record, item) {
			 record.item = item;
			 if (this._identityChangesTail === null) {
				this._identityChangesTail = this._identityChangesHead = record;
			 } else {
				this._identityChangesTail = this._identityChangesTail._nextIdentityChange = record;
			 }
			 return record;
		  }
		};
		var IterableChangeRecord_ = class {
		  constructor(item, trackById) {
			 this.item = item;
			 this.trackById = trackById;
			 this.currentIndex = null;
			 this.previousIndex = null;
			 this._nextPrevious = null;
			 this._prev = null;
			 this._next = null;
			 this._prevDup = null;
			 this._nextDup = null;
			 this._prevRemoved = null;
			 this._nextRemoved = null;
			 this._nextAdded = null;
			 this._nextMoved = null;
			 this._nextIdentityChange = null;
		  }
		};
		var _DuplicateItemRecordList = class {
		  constructor() {
			 this._head = null;
			 this._tail = null;
		  }
		  /**
			* Append the record to the list of duplicates.
			*
			* Note: by design all records in the list of duplicates hold the same value in record.item.
			*/
		  add(record) {
			 if (this._head === null) {
				this._head = this._tail = record;
				record._nextDup = null;
				record._prevDup = null;
			 } else {
				this._tail._nextDup = record;
				record._prevDup = this._tail;
				record._nextDup = null;
				this._tail = record;
			 }
		  }
		  // Returns a IterableChangeRecord_ having IterableChangeRecord_.trackById == trackById and
		  // IterableChangeRecord_.currentIndex >= atOrAfterIndex
		  get(trackById, atOrAfterIndex) {
			 let record;
			 for (record = this._head; record !== null; record = record._nextDup) {
				if ((atOrAfterIndex === null || atOrAfterIndex <= record.currentIndex) && Object.is(record.trackById, trackById)) {
				  return record;
				}
			 }
			 return null;
		  }
		  /**
			* Remove one {@link IterableChangeRecord_} from the list of duplicates.
			*
			* Returns whether the list of duplicates is empty.
			*/
		  remove(record) {
			 const prev = record._prevDup;
			 const next = record._nextDup;
			 if (prev === null) {
				this._head = next;
			 } else {
				prev._nextDup = next;
			 }
			 if (next === null) {
				this._tail = prev;
			 } else {
				next._prevDup = prev;
			 }
			 return this._head === null;
		  }
		};
		var _DuplicateMap = class {
		  constructor() {
			 this.map = /* @__PURE__ */ new Map();
		  }
		  put(record) {
			 const key = record.trackById;
			 let duplicates = this.map.get(key);
			 if (!duplicates) {
				duplicates = new _DuplicateItemRecordList();
				this.map.set(key, duplicates);
			 }
			 duplicates.add(record);
		  }
		  /**
			* Retrieve the `value` using key. Because the IterableChangeRecord_ value may be one which we
			* have already iterated over, we use the `atOrAfterIndex` to pretend it is not there.
			*
			* Use case: `[a, b, c, a, a]` if we are at index `3` which is the second `a` then asking if we
			* have any more `a`s needs to return the second `a`.
			*/
		  get(trackById, atOrAfterIndex) {
			 const key = trackById;
			 const recordList = this.map.get(key);
			 return recordList ? recordList.get(trackById, atOrAfterIndex) : null;
		  }
		  /**
			* Removes a {@link IterableChangeRecord_} from the list of duplicates.
			*
			* The list of duplicates also is removed from the map if it gets empty.
			*/
		  remove(record) {
			 const key = record.trackById;
			 const recordList = this.map.get(key);
			 if (recordList.remove(record)) {
				this.map.delete(key);
			 }
			 return record;
		  }
		  get isEmpty() {
			 return this.map.size === 0;
		  }
		  clear() {
			 this.map.clear();
		  }
		};
		function getPreviousIndex(item, addRemoveOffset, moveOffsets) {
		  const previousIndex = item.previousIndex;
		  if (previousIndex === null)
			 return previousIndex;
		  let moveOffset = 0;
		  if (moveOffsets && previousIndex < moveOffsets.length) {
			 moveOffset = moveOffsets[previousIndex];
		  }
		  return previousIndex + addRemoveOffset + moveOffset;
		}
		var DefaultKeyValueDifferFactory = class {
		  constructor() {
		  }
		  supports(obj) {
			 return obj instanceof Map || isJsObject(obj);
		  }
		  create() {
			 return new DefaultKeyValueDiffer();
		  }
		};
		var DefaultKeyValueDiffer = class {
		  constructor() {
			 this._records = /* @__PURE__ */ new Map();
			 this._mapHead = null;
			 this._appendAfter = null;
			 this._previousMapHead = null;
			 this._changesHead = null;
			 this._changesTail = null;
			 this._additionsHead = null;
			 this._additionsTail = null;
			 this._removalsHead = null;
			 this._removalsTail = null;
		  }
		  get isDirty() {
			 return this._additionsHead !== null || this._changesHead !== null || this._removalsHead !== null;
		  }
		  forEachItem(fn) {
			 let record;
			 for (record = this._mapHead; record !== null; record = record._next) {
				fn(record);
			 }
		  }
		  forEachPreviousItem(fn) {
			 let record;
			 for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {
				fn(record);
			 }
		  }
		  forEachChangedItem(fn) {
			 let record;
			 for (record = this._changesHead; record !== null; record = record._nextChanged) {
				fn(record);
			 }
		  }
		  forEachAddedItem(fn) {
			 let record;
			 for (record = this._additionsHead; record !== null; record = record._nextAdded) {
				fn(record);
			 }
		  }
		  forEachRemovedItem(fn) {
			 let record;
			 for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
				fn(record);
			 }
		  }
		  diff(map3) {
			 if (!map3) {
				map3 = /* @__PURE__ */ new Map();
			 } else if (!(map3 instanceof Map || isJsObject(map3))) {
				throw new RuntimeError(900, ngDevMode && `Error trying to diff '${stringify(map3)}'. Only maps and objects are allowed`);
			 }
			 return this.check(map3) ? this : null;
		  }
		  onDestroy() {
		  }
		  /**
			* Check the current state of the map vs the previous.
			* The algorithm is optimised for when the keys do no change.
			*/
		  check(map3) {
			 this._reset();
			 let insertBefore = this._mapHead;
			 this._appendAfter = null;
			 this._forEach(map3, (value, key) => {
				if (insertBefore && insertBefore.key === key) {
				  this._maybeAddToChanges(insertBefore, value);
				  this._appendAfter = insertBefore;
				  insertBefore = insertBefore._next;
				} else {
				  const record = this._getOrCreateRecordForKey(key, value);
				  insertBefore = this._insertBeforeOrAppend(insertBefore, record);
				}
			 });
			 if (insertBefore) {
				if (insertBefore._prev) {
				  insertBefore._prev._next = null;
				}
				this._removalsHead = insertBefore;
				for (let record = insertBefore; record !== null; record = record._nextRemoved) {
				  if (record === this._mapHead) {
					 this._mapHead = null;
				  }
				  this._records.delete(record.key);
				  record._nextRemoved = record._next;
				  record.previousValue = record.currentValue;
				  record.currentValue = null;
				  record._prev = null;
				  record._next = null;
				}
			 }
			 if (this._changesTail)
				this._changesTail._nextChanged = null;
			 if (this._additionsTail)
				this._additionsTail._nextAdded = null;
			 return this.isDirty;
		  }
		  /**
			* Inserts a record before `before` or append at the end of the list when `before` is null.
			*
			* Notes:
			* - This method appends at `this._appendAfter`,
			* - This method updates `this._appendAfter`,
			* - The return value is the new value for the insertion pointer.
			*/
		  _insertBeforeOrAppend(before, record) {
			 if (before) {
				const prev = before._prev;
				record._next = before;
				record._prev = prev;
				before._prev = record;
				if (prev) {
				  prev._next = record;
				}
				if (before === this._mapHead) {
				  this._mapHead = record;
				}
				this._appendAfter = before;
				return before;
			 }
			 if (this._appendAfter) {
				this._appendAfter._next = record;
				record._prev = this._appendAfter;
			 } else {
				this._mapHead = record;
			 }
			 this._appendAfter = record;
			 return null;
		  }
		  _getOrCreateRecordForKey(key, value) {
			 if (this._records.has(key)) {
				const record2 = this._records.get(key);
				this._maybeAddToChanges(record2, value);
				const prev = record2._prev;
				const next = record2._next;
				if (prev) {
				  prev._next = next;
				}
				if (next) {
				  next._prev = prev;
				}
				record2._next = null;
				record2._prev = null;
				return record2;
			 }
			 const record = new KeyValueChangeRecord_(key);
			 this._records.set(key, record);
			 record.currentValue = value;
			 this._addToAdditions(record);
			 return record;
		  }
		  /** @internal */
		  _reset() {
			 if (this.isDirty) {
				let record;
				this._previousMapHead = this._mapHead;
				for (record = this._previousMapHead; record !== null; record = record._next) {
				  record._nextPrevious = record._next;
				}
				for (record = this._changesHead; record !== null; record = record._nextChanged) {
				  record.previousValue = record.currentValue;
				}
				for (record = this._additionsHead; record != null; record = record._nextAdded) {
				  record.previousValue = record.currentValue;
				}
				this._changesHead = this._changesTail = null;
				this._additionsHead = this._additionsTail = null;
				this._removalsHead = null;
			 }
		  }
		  // Add the record or a given key to the list of changes only when the value has actually changed
		  _maybeAddToChanges(record, newValue) {
			 if (!Object.is(newValue, record.currentValue)) {
				record.previousValue = record.currentValue;
				record.currentValue = newValue;
				this._addToChanges(record);
			 }
		  }
		  _addToAdditions(record) {
			 if (this._additionsHead === null) {
				this._additionsHead = this._additionsTail = record;
			 } else {
				this._additionsTail._nextAdded = record;
				this._additionsTail = record;
			 }
		  }
		  _addToChanges(record) {
			 if (this._changesHead === null) {
				this._changesHead = this._changesTail = record;
			 } else {
				this._changesTail._nextChanged = record;
				this._changesTail = record;
			 }
		  }
		  /** @internal */
		  _forEach(obj, fn) {
			 if (obj instanceof Map) {
				obj.forEach(fn);
			 } else {
				Object.keys(obj).forEach((k) => fn(obj[k], k));
			 }
		  }
		};
		var KeyValueChangeRecord_ = class {
		  constructor(key) {
			 this.key = key;
			 this.previousValue = null;
			 this.currentValue = null;
			 this._nextPrevious = null;
			 this._next = null;
			 this._prev = null;
			 this._nextAdded = null;
			 this._nextRemoved = null;
			 this._nextChanged = null;
		  }
		};
		function defaultIterableDiffersFactory() {
		  return new IterableDiffers([new DefaultIterableDifferFactory()]);
		}
		var IterableDiffers = class _IterableDiffers {
		  static {
			 this.\u0275prov = \u0275\u0275defineInjectable({ token: _IterableDiffers, providedIn: "root", factory: defaultIterableDiffersFactory });
		  }
		  constructor(factories) {
			 this.factories = factories;
		  }
		  static create(factories, parent) {
			 if (parent != null) {
				const copied = parent.factories.slice();
				factories = factories.concat(copied);
			 }
			 return new _IterableDiffers(factories);
		  }
		  /**
			* Takes an array of {@link IterableDifferFactory} and returns a provider used to extend the
			* inherited {@link IterableDiffers} instance with the provided factories and return a new
			* {@link IterableDiffers} instance.
			*
			* @usageNotes
			* ### Example
			*
			* The following example shows how to extend an existing list of factories,
			* which will only be applied to the injector for this component and its children.
			* This step is all that's required to make a new {@link IterableDiffer} available.
			*
			* ```
			* @Component({
			*   viewProviders: [
			*     IterableDiffers.extend([new ImmutableListDiffer()])
			*   ]
			* })
			* ```
			*/
		  static extend(factories) {
			 return {
				provide: _IterableDiffers,
				useFactory: (parent) => {
				  return _IterableDiffers.create(factories, parent || defaultIterableDiffersFactory());
				},
				// Dependency technically isn't optional, but we can provide a better error message this way.
				deps: [[_IterableDiffers, new SkipSelf(), new Optional()]]
			 };
		  }
		  find(iterable) {
			 const factory = this.factories.find((f) => f.supports(iterable));
			 if (factory != null) {
				return factory;
			 } else {
				throw new RuntimeError(901, ngDevMode && `Cannot find a differ supporting object '${iterable}' of type '${getTypeNameForDebugging(iterable)}'`);
			 }
		  }
		};
		function getTypeNameForDebugging(type2) {
		  return type2["name"] || typeof type2;
		}
		function defaultKeyValueDiffersFactory() {
		  return new KeyValueDiffers([new DefaultKeyValueDifferFactory()]);
		}
		var KeyValueDiffers = class _KeyValueDiffers {
		  static {
			 this.\u0275prov = \u0275\u0275defineInjectable({ token: _KeyValueDiffers, providedIn: "root", factory: defaultKeyValueDiffersFactory });
		  }
		  constructor(factories) {
			 this.factories = factories;
		  }
		  static create(factories, parent) {
			 if (parent) {
				const copied = parent.factories.slice();
				factories = factories.concat(copied);
			 }
			 return new _KeyValueDiffers(factories);
		  }
		  /**
			* Takes an array of {@link KeyValueDifferFactory} and returns a provider used to extend the
			* inherited {@link KeyValueDiffers} instance with the provided factories and return a new
			* {@link KeyValueDiffers} instance.
			*
			* @usageNotes
			* ### Example
			*
			* The following example shows how to extend an existing list of factories,
			* which will only be applied to the injector for this component and its children.
			* This step is all that's required to make a new {@link KeyValueDiffer} available.
			*
			* ```
			* @Component({
			*   viewProviders: [
			*     KeyValueDiffers.extend([new ImmutableMapDiffer()])
			*   ]
			* })
			* ```
			*/
		  static extend(factories) {
			 return {
				provide: _KeyValueDiffers,
				useFactory: (parent) => {
				  return _KeyValueDiffers.create(factories, parent || defaultKeyValueDiffersFactory());
				},
				// Dependency technically isn't optional, but we can provide a better error message this way.
				deps: [[_KeyValueDiffers, new SkipSelf(), new Optional()]]
			 };
		  }
		  find(kv) {
			 const factory = this.factories.find((f) => f.supports(kv));
			 if (factory) {
				return factory;
			 }
			 throw new RuntimeError(901, ngDevMode && `Cannot find a differ supporting object '${kv}'`);
		  }
		};
		var keyValDiff = [new DefaultKeyValueDifferFactory()];
		var iterableDiff = [new DefaultIterableDifferFactory()];
		var defaultIterableDiffers = new IterableDiffers(iterableDiff);
		var defaultKeyValueDiffers = new KeyValueDiffers(keyValDiff);
		var platformCore = createPlatformFactory(null, "core", []);
		var ApplicationModule = class _ApplicationModule {
		  // Inject ApplicationRef to make it eager...
		  constructor(appRef) {
		  }
		  static {
			 this.\u0275fac = function ApplicationModule_Factory(t) {
				return new (t || _ApplicationModule)(\u0275\u0275inject(ApplicationRef));
			 };
		  }
		  static {
			 this.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({ type: _ApplicationModule });
		  }
		  static {
			 this.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ApplicationModule, [{
			 type: NgModule
		  }], () => [{ type: ApplicationRef }], null);
		})();
		var SCAN_DELAY = 200;
		var OVERSIZED_IMAGE_TOLERANCE = 1200;
		var ImagePerformanceWarning = class _ImagePerformanceWarning {
		  constructor() {
			 this.window = null;
			 this.observer = null;
			 this.options = inject(IMAGE_CONFIG);
			 this.ngZone = inject(NgZone);
		  }
		  start() {
			 if (typeof PerformanceObserver === "undefined" || this.options?.disableImageSizeWarning && this.options?.disableImageLazyLoadWarning) {
				return;
			 }
			 this.observer = this.initPerformanceObserver();
			 const doc = getDocument();
			 const win = doc.defaultView;
			 if (typeof win !== "undefined") {
				this.window = win;
				const waitToScan = () => {
				  setTimeout(this.scanImages.bind(this), SCAN_DELAY);
				};
				this.ngZone.runOutsideAngular(() => {
				  if (doc.readyState === "complete") {
					 waitToScan();
				  } else {
					 this.window?.addEventListener("load", waitToScan, { once: true });
				  }
				});
			 }
		  }
		  ngOnDestroy() {
			 this.observer?.disconnect();
		  }
		  initPerformanceObserver() {
			 if (typeof PerformanceObserver === "undefined") {
				return null;
			 }
			 const observer = new PerformanceObserver((entryList) => {
				const entries = entryList.getEntries();
				if (entries.length === 0)
				  return;
				const lcpElement = entries[entries.length - 1];
				const imgSrc = lcpElement.element?.src ?? "";
				if (imgSrc.startsWith("data:") || imgSrc.startsWith("blob:"))
				  return;
				this.lcpImageUrl = imgSrc;
			 });
			 observer.observe({ type: "largest-contentful-paint", buffered: true });
			 return observer;
		  }
		  scanImages() {
			 const images = getDocument().querySelectorAll("img");
			 let lcpElementFound, lcpElementLoadedCorrectly = false;
			 images.forEach((image) => {
				if (!this.options?.disableImageSizeWarning) {
				  for (const image2 of images) {
					 if (!image2.getAttribute("ng-img") && this.isOversized(image2)) {
						logOversizedImageWarning(image2.src);
					 }
				  }
				}
				if (!this.options?.disableImageLazyLoadWarning && this.lcpImageUrl) {
				  if (image.src === this.lcpImageUrl) {
					 lcpElementFound = true;
					 if (image.loading !== "lazy" || image.getAttribute("ng-img")) {
						lcpElementLoadedCorrectly = true;
					 }
				  }
				}
			 });
			 if (lcpElementFound && !lcpElementLoadedCorrectly && this.lcpImageUrl && !this.options?.disableImageLazyLoadWarning) {
				logLazyLCPWarning(this.lcpImageUrl);
			 }
		  }
		  isOversized(image) {
			 if (!this.window) {
				return false;
			 }
			 const computedStyle = this.window.getComputedStyle(image);
			 let renderedWidth = parseFloat(computedStyle.getPropertyValue("width"));
			 let renderedHeight = parseFloat(computedStyle.getPropertyValue("height"));
			 const boxSizing = computedStyle.getPropertyValue("box-sizing");
			 const objectFit = computedStyle.getPropertyValue("object-fit");
			 if (objectFit === `cover`) {
				return false;
			 }
			 if (boxSizing === "border-box") {
				const paddingTop = computedStyle.getPropertyValue("padding-top");
				const paddingRight = computedStyle.getPropertyValue("padding-right");
				const paddingBottom = computedStyle.getPropertyValue("padding-bottom");
				const paddingLeft = computedStyle.getPropertyValue("padding-left");
				renderedWidth -= parseFloat(paddingRight) + parseFloat(paddingLeft);
				renderedHeight -= parseFloat(paddingTop) + parseFloat(paddingBottom);
			 }
			 const intrinsicWidth = image.naturalWidth;
			 const intrinsicHeight = image.naturalHeight;
			 const recommendedWidth = this.window.devicePixelRatio * renderedWidth;
			 const recommendedHeight = this.window.devicePixelRatio * renderedHeight;
			 const oversizedWidth = intrinsicWidth - recommendedWidth >= OVERSIZED_IMAGE_TOLERANCE;
			 const oversizedHeight = intrinsicHeight - recommendedHeight >= OVERSIZED_IMAGE_TOLERANCE;
			 return oversizedWidth || oversizedHeight;
		  }
		  static {
			 this.\u0275fac = function ImagePerformanceWarning_Factory(t) {
				return new (t || _ImagePerformanceWarning)();
			 };
		  }
		  static {
			 this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _ImagePerformanceWarning, factory: _ImagePerformanceWarning.\u0275fac, providedIn: "root" });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ImagePerformanceWarning, [{
			 type: Injectable,
			 args: [{ providedIn: "root" }]
		  }], null, null);
		})();
		function logLazyLCPWarning(src) {
		  console.warn(formatRuntimeError(-913, `An image with src ${src} is the Largest Contentful Paint (LCP) element but was given a "loading" value of "lazy", which can negatively impact application loading performance. This warning can be addressed by changing the loading value of the LCP image to "eager", or by using the NgOptimizedImage directive's prioritization utilities. For more information about addressing or disabling this warning, see https://angular.io/errors/NG0913`));
		}
		function logOversizedImageWarning(src) {
		  console.warn(formatRuntimeError(-913, `An image with src ${src} has intrinsic file dimensions much larger than its rendered size. This can negatively impact application loading performance. For more information about addressing or disabling this warning, see https://angular.io/errors/NG0913`));
		}
		function internalCreateApplication(config2) {
		  try {
			 const { rootComponent, appProviders, platformProviders } = config2;
			 if ((typeof ngDevMode === "undefined" || ngDevMode) && rootComponent !== void 0) {
				assertStandaloneComponentType(rootComponent);
			 }
			 const platformInjector = createOrReusePlatformInjector(platformProviders);
			 const allAppProviders = [
				provideZoneChangeDetection(),
				...appProviders || []
			 ];
			 const adapter = new EnvironmentNgModuleRefAdapter({
				providers: allAppProviders,
				parent: platformInjector,
				debugName: typeof ngDevMode === "undefined" || ngDevMode ? "Environment Injector" : "",
				// We skip environment initializers because we need to run them inside the NgZone, which
				// happens after we get the NgZone instance from the Injector.
				runEnvironmentInitializers: false
			 });
			 const envInjector = adapter.injector;
			 const ngZone = envInjector.get(NgZone);
			 return ngZone.run(() => {
				envInjector.resolveInjectorInitializers();
				const exceptionHandler = envInjector.get(ErrorHandler, null);
				if ((typeof ngDevMode === "undefined" || ngDevMode) && !exceptionHandler) {
				  throw new RuntimeError(402, "No `ErrorHandler` found in the Dependency Injection tree.");
				}
				let onErrorSubscription;
				ngZone.runOutsideAngular(() => {
				  onErrorSubscription = ngZone.onError.subscribe({
					 next: (error) => {
						exceptionHandler.handleError(error);
					 }
				  });
				});
				const destroyListener = () => envInjector.destroy();
				const onPlatformDestroyListeners = platformInjector.get(PLATFORM_DESTROY_LISTENERS);
				onPlatformDestroyListeners.add(destroyListener);
				envInjector.onDestroy(() => {
				  onErrorSubscription.unsubscribe();
				  onPlatformDestroyListeners.delete(destroyListener);
				});
				return _callAndReportToErrorHandler(exceptionHandler, ngZone, () => {
				  const initStatus = envInjector.get(ApplicationInitStatus);
				  initStatus.runInitializers();
				  return initStatus.donePromise.then(() => {
					 const localeId = envInjector.get(LOCALE_ID, DEFAULT_LOCALE_ID);
					 setLocaleId(localeId || DEFAULT_LOCALE_ID);
					 const appRef = envInjector.get(ApplicationRef);
					 if (rootComponent !== void 0) {
						appRef.bootstrap(rootComponent);
					 }
					 if (typeof ngDevMode === "undefined" || ngDevMode) {
						const imagePerformanceService = envInjector.get(ImagePerformanceWarning);
						imagePerformanceService.start();
					 }
					 return appRef;
				  });
				});
			 });
		  } catch (e) {
			 return Promise.reject(e);
		  }
		}
		var ChangeDetectionSchedulerImpl = class _ChangeDetectionSchedulerImpl {
		  constructor() {
			 this.appRef = inject(ApplicationRef);
			 this.taskService = inject(PendingTasks);
			 this.pendingRenderTaskId = null;
			 this.shouldRefreshViews = false;
		  }
		  notify(type2 = 0) {
			 this.shouldRefreshViews ||= type2 === 0;
			 if (this.pendingRenderTaskId !== null) {
				return;
			 }
			 this.pendingRenderTaskId = this.taskService.add();
			 this.raceTimeoutAndRequestAnimationFrame();
		  }
		  /**
			* Run change detection after the first of setTimeout and requestAnimationFrame resolves.
			*
			* - `requestAnimationFrame` ensures that change detection runs ahead of a browser repaint.
			* This ensures that the create and update passes of a change detection always happen
			* in the same frame.
			* - When the browser is resource-starved, `rAF` can execute _before_ a `setTimeout` because
			* rendering is a very high priority process. This means that `setTimeout` cannot guarantee
			* same-frame create and update pass, when `setTimeout` is used to schedule the update phase.
			* - While `rAF` gives us the desirable same-frame updates, it has two limitations that
			* prevent it from being used alone. First, it does not run in background tabs, which would
			* prevent Angular from initializing an application when opened in a new tab (for example).
			* Second, repeated calls to requestAnimationFrame will execute at the refresh rate of the
			* hardware (~16ms for a 60Hz display). This would cause significant slowdown of tests that
			* are written with several updates and asserts in the form of "update; await stable; assert;".
			* - Both `setTimeout` and `rAF` are able to "coalesce" several events from a single user
			* interaction into a single change detection. Importantly, this reduces view tree traversals when
			* compared to an alternative timing mechanism like `queueMicrotask`, where change detection would
			* then be interleaves between each event.
			*
			* By running change detection after the first of `setTimeout` and `rAF` to execute, we get the
			* best of both worlds.
			*/
		  raceTimeoutAndRequestAnimationFrame() {
			 return __async(this, null, function* () {
				const timeout2 = new Promise((resolve) => setTimeout(resolve));
				const rAF = typeof _global["requestAnimationFrame"] === "function" ? new Promise((resolve) => requestAnimationFrame(() => resolve())) : null;
				yield Promise.race([timeout2, rAF]);
				this.tick();
			 });
		  }
		  tick() {
			 try {
				if (!this.appRef.destroyed) {
				  this.appRef._tick(this.shouldRefreshViews);
				}
			 } finally {
				this.shouldRefreshViews = false;
				const taskId = this.pendingRenderTaskId;
				this.pendingRenderTaskId = null;
				this.taskService.remove(taskId);
			 }
		  }
		  static {
			 this.\u0275fac = function ChangeDetectionSchedulerImpl_Factory(t) {
				return new (t || _ChangeDetectionSchedulerImpl)();
			 };
		  }
		  static {
			 this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _ChangeDetectionSchedulerImpl, factory: _ChangeDetectionSchedulerImpl.\u0275fac, providedIn: "root" });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ChangeDetectionSchedulerImpl, [{
			 type: Injectable,
			 args: [{ providedIn: "root" }]
		  }], null, null);
		})();
		function booleanAttribute(value) {
		  return typeof value === "boolean" ? value : value != null && value !== "false";
		}
		function numberAttribute(value, fallbackValue = NaN) {
		  const isNumberValue = !isNaN(parseFloat(value)) && !isNaN(Number(value));
		  return isNumberValue ? Number(value) : fallbackValue;
		}
		function untracked(nonReactiveReadsFn) {
		  const prevConsumer = setActiveConsumer(null);
		  try {
			 return nonReactiveReadsFn();
		  } finally {
			 setActiveConsumer(prevConsumer);
		  }
		}
		var APP_EFFECT_SCHEDULER = new InjectionToken("", {
		  providedIn: "root",
		  factory: () => inject(EffectScheduler)
		});
		var EffectScheduler = class _EffectScheduler {
		  static {
			 this.\u0275prov = \u0275\u0275defineInjectable({
				token: _EffectScheduler,
				providedIn: "root",
				factory: () => new ZoneAwareEffectScheduler()
			 });
		  }
		};
		var ZoneAwareEffectScheduler = class {
		  constructor() {
			 this.queuedEffectCount = 0;
			 this.queues = /* @__PURE__ */ new Map();
			 this.pendingTasks = inject(PendingTasks);
			 this.taskId = null;
		  }
		  scheduleEffect(handle) {
			 this.enqueue(handle);
			 if (this.taskId === null) {
				const taskId = this.taskId = this.pendingTasks.add();
				queueMicrotask(() => {
				  this.flush();
				  this.pendingTasks.remove(taskId);
				  this.taskId = null;
				});
			 }
		  }
		  enqueue(handle) {
			 const zone = handle.creationZone;
			 if (!this.queues.has(zone)) {
				this.queues.set(zone, /* @__PURE__ */ new Set());
			 }
			 const queue = this.queues.get(zone);
			 if (queue.has(handle)) {
				return;
			 }
			 this.queuedEffectCount++;
			 queue.add(handle);
		  }
		  /**
			* Run all scheduled effects.
			*
			* Execution order of effects within the same zone is guaranteed to be FIFO, but there is no
			* ordering guarantee between effects scheduled in different zones.
			*/
		  flush() {
			 while (this.queuedEffectCount > 0) {
				for (const [zone, queue] of this.queues) {
				  if (zone === null) {
					 this.flushQueue(queue);
				  } else {
					 zone.run(() => this.flushQueue(queue));
				  }
				}
			 }
		  }
		  flushQueue(queue) {
			 for (const handle of queue) {
				queue.delete(handle);
				this.queuedEffectCount--;
				handle.run();
			 }
		  }
		};
		if (typeof ngDevMode !== "undefined" && ngDevMode) {
		  _global.$localize ??= function() {
			 throw new Error("It looks like your application or one of its dependencies is using i18n.\nAngular 9 introduced a copyGlobalForElem `$localize()` function that needs to be loaded.\nPlease run `ng add @angular/localize` from the Angular CLI.\n(For non-CLI projects, add `import '@angular/localize/init';` to your `polyfills.ts` file.\nFor server-side rendering applications add the import to your `main.server.ts` file.)");
		  };
		}

		// node_modules/@angular/elements/fesm2022/elements.mjs
		var scheduler = {
		  /**
			* Schedule a callback to be called after some delay.
			*
			* Returns a function that when executed will cancel the scheduled function.
			*/
		  schedule(taskFn, delay) {
			 const id3 = setTimeout(taskFn, delay);
			 return () => clearTimeout(id3);
		  },
		  /**
			* Schedule a callback to be called before the next render.
			* (If `window.requestAnimationFrame()` is not available, use `scheduler.schedule()` instead.)
			*
			* Returns a function that when executed will cancel the scheduled function.
			*/
		  scheduleBeforeRender(taskFn) {
			 if (typeof window === "undefined") {
				return scheduler.schedule(taskFn, 0);
			 }
			 if (typeof window.requestAnimationFrame === "undefined") {
				const frameMs = 16;
				return scheduler.schedule(taskFn, frameMs);
			 }
			 const id3 = window.requestAnimationFrame(taskFn);
			 return () => window.cancelAnimationFrame(id3);
		  }
		};
		function camelToDashCase(input2) {
		  return input2.replace(/[A-Z]/g, (char) => `-${char.toLowerCase()}`);
		}
		function isElement(node) {
		  return !!node && node.nodeType === Node.ELEMENT_NODE;
		}
		function isFunction2(value) {
		  return typeof value === "function";
		}
		var _matches;
		function matchesSelector(el, selector) {
		  if (!_matches) {
			 const elProto = Element.prototype;
			 _matches = elProto.matches || elProto.matchesSelector || elProto.mozMatchesSelector || elProto.msMatchesSelector || elProto.oMatchesSelector || elProto.webkitMatchesSelector;
		  }
		  return el.nodeType === Node.ELEMENT_NODE ? _matches.call(el, selector) : false;
		}
		function strictEquals(value1, value2) {
		  return value1 === value2 || value1 !== value1 && value2 !== value2;
		}
		function getDefaultAttributeToPropertyInputs(inputs) {
		  const attributeToPropertyInputs = {};
		  inputs.forEach(({ propName, templateName, transform: transform2 }) => {
			 attributeToPropertyInputs[camelToDashCase(templateName)] = [propName, transform2];
		  });
		  return attributeToPropertyInputs;
		}
		function getComponentInputs(component, injector) {
		  const componentFactoryResolver = injector.get(ComponentFactoryResolver$1);
		  const componentFactory = componentFactoryResolver.resolveComponentFactory(component);
		  return componentFactory.inputs;
		}
		function extractProjectableNodes(host, ngContentSelectors) {
		  const nodes = host.childNodes;
		  const projectableNodes = ngContentSelectors.map(() => []);
		  let wildcardIndex = -1;
		  ngContentSelectors.some((selector, i) => {
			 if (selector === "*") {
				wildcardIndex = i;
				return true;
			 }
			 return false;
		  });
		  for (let i = 0, ii = nodes.length; i < ii; ++i) {
			 const node = nodes[i];
			 const ngContentIndex = findMatchingIndex(node, ngContentSelectors, wildcardIndex);
			 if (ngContentIndex !== -1) {
				projectableNodes[ngContentIndex].push(node);
			 }
		  }
		  return projectableNodes;
		}
		function findMatchingIndex(node, selectors, defaultIndex) {
		  let matchingIndex = defaultIndex;
		  if (isElement(node)) {
			 selectors.some((selector, i) => {
				if (selector !== "*" && matchesSelector(node, selector)) {
				  matchingIndex = i;
				  return true;
				}
				return false;
			 });
		  }
		  return matchingIndex;
		}
		var DESTROY_DELAY = 10;
		var ComponentNgElementStrategyFactory = class {
		  constructor(component, injector) {
			 this.componentFactory = injector.get(ComponentFactoryResolver$1).resolveComponentFactory(component);
		  }
		  create(injector) {
			 return new ComponentNgElementStrategy(this.componentFactory, injector);
		  }
		};
		var ComponentNgElementStrategy = class {
		  constructor(componentFactory, injector) {
			 this.componentFactory = componentFactory;
			 this.injector = injector;
			 this.eventEmitters = new ReplaySubject(1);
			 this.events = this.eventEmitters.pipe(switchMap((emitters) => merge(...emitters)));
			 this.componentRef = null;
			 this.viewChangeDetectorRef = null;
			 this.inputChanges = null;
			 this.hasInputChanges = false;
			 this.implementsOnChanges = false;
			 this.scheduledChangeDetectionFn = null;
			 this.scheduledDestroyFn = null;
			 this.initialInputValues = /* @__PURE__ */ new Map();
			 this.unchangedInputs = new Set(this.componentFactory.inputs.map(({ propName }) => propName));
			 this.ngZone = this.injector.get(NgZone);
			 this.elementZone = typeof Zone === "undefined" ? null : this.ngZone.run(() => Zone.current);
		  }
		  /**
			* Initializes a new component if one has not yet been created and cancels any scheduled
			* destruction.
			*/
		  connect(element) {
			 this.runInZone(() => {
				if (this.scheduledDestroyFn !== null) {
				  this.scheduledDestroyFn();
				  this.scheduledDestroyFn = null;
				  return;
				}
				if (this.componentRef === null) {
				  this.initializeComponent(element);
				}
			 });
		  }
		  /**
			* Schedules the component to be destroyed after some small delay in case the element is just
			* being moved across the DOM.
			*/
		  disconnect() {
			 this.runInZone(() => {
				if (this.componentRef === null || this.scheduledDestroyFn !== null) {
				  return;
				}
				this.scheduledDestroyFn = scheduler.schedule(() => {
				  if (this.componentRef !== null) {
					 this.componentRef.destroy();
					 this.componentRef = null;
					 this.viewChangeDetectorRef = null;
				  }
				}, DESTROY_DELAY);
			 });
		  }
		  /**
			* Returns the component property value. If the component has not yet been created, the value is
			* retrieved from the cached initialization values.
			*/
		  getInputValue(property) {
			 return this.runInZone(() => {
				if (this.componentRef === null) {
				  return this.initialInputValues.get(property);
				}
				return this.componentRef.instance[property];
			 });
		  }
		  /**
			* Sets the input value for the property. If the component has not yet been created, the value is
			* cached and set when the component is created.
			*/
		  setInputValue(property, value, transform2) {
			 this.runInZone(() => {
				if (transform2) {
				  value = transform2.call(this.componentRef?.instance, value);
				}
				if (this.componentRef === null) {
				  this.initialInputValues.set(property, value);
				  return;
				}
				if (strictEquals(value, this.getInputValue(property)) && !(value === void 0 && this.unchangedInputs.has(property))) {
				  return;
				}
				this.recordInputChange(property, value);
				this.unchangedInputs.delete(property);
				this.hasInputChanges = true;
				this.componentRef.instance[property] = value;
				this.scheduleDetectChanges();
			 });
		  }
		  /**
			* Creates a new component through the component factory with the provided element host and
			* sets up its initial inputs, listens for outputs changes, and runs an initial change detection.
			*/
		  initializeComponent(element) {
			 const childInjector = Injector.create({ providers: [], parent: this.injector });
			 const projectableNodes = extractProjectableNodes(element, this.componentFactory.ngContentSelectors);
			 this.componentRef = this.componentFactory.create(childInjector, projectableNodes, element);
			 this.viewChangeDetectorRef = this.componentRef.injector.get(ChangeDetectorRef);
			 this.implementsOnChanges = isFunction2(this.componentRef.instance.ngOnChanges);
			 this.initializeInputs();
			 this.initializeOutputs(this.componentRef);
			 this.detectChanges();
			 const applicationRef = this.injector.get(ApplicationRef);
			 applicationRef.attachView(this.componentRef.hostView);
		  }
		  /** Set any stored initial inputs on the component's properties. */
		  initializeInputs() {
			 this.componentFactory.inputs.forEach(({ propName, transform: transform2 }) => {
				if (this.initialInputValues.has(propName)) {
				  this.setInputValue(propName, this.initialInputValues.get(propName), transform2);
				}
			 });
			 this.initialInputValues.clear();
		  }
		  /** Sets up listeners for the component's outputs so that the events stream emits the events. */
		  initializeOutputs(componentRef) {
			 const eventEmitters = this.componentFactory.outputs.map(({ propName, templateName }) => {
				const emitter = componentRef.instance[propName];
				return emitter.pipe(map((value) => ({ name: templateName, value })));
			 });
			 this.eventEmitters.next(eventEmitters);
		  }
		  /** Calls ngOnChanges with all the inputs that have changed since the last call. */
		  callNgOnChanges(componentRef) {
			 if (!this.implementsOnChanges || this.inputChanges === null) {
				return;
			 }
			 const inputChanges = this.inputChanges;
			 this.inputChanges = null;
			 componentRef.instance.ngOnChanges(inputChanges);
		  }
		  /**
			* Marks the component view for check, if necessary.
			* (NOTE: This is required when the `ChangeDetectionStrategy` is set to `OnPush`.)
			*/
		  markViewForCheck(viewChangeDetectorRef) {
			 if (this.hasInputChanges) {
				this.hasInputChanges = false;
				viewChangeDetectorRef.markForCheck();
			 }
		  }
		  /**
			* Schedules change detection to run on the component.
			* Ignores subsequent calls if already scheduled.
			*/
		  scheduleDetectChanges() {
			 if (this.scheduledChangeDetectionFn) {
				return;
			 }
			 this.scheduledChangeDetectionFn = scheduler.scheduleBeforeRender(() => {
				this.scheduledChangeDetectionFn = null;
				this.detectChanges();
			 });
		  }
		  /**
			* Records input changes so that the component receives SimpleChanges in its onChanges function.
			*/
		  recordInputChange(property, currentValue) {
			 if (!this.implementsOnChanges) {
				return;
			 }
			 if (this.inputChanges === null) {
				this.inputChanges = {};
			 }
			 const pendingChange = this.inputChanges[property];
			 if (pendingChange) {
				pendingChange.currentValue = currentValue;
				return;
			 }
			 const isFirstChange = this.unchangedInputs.has(property);
			 const previousValue = isFirstChange ? void 0 : this.getInputValue(property);
			 this.inputChanges[property] = new SimpleChange(previousValue, currentValue, isFirstChange);
		  }
		  /** Runs change detection on the component. */
		  detectChanges() {
			 if (this.componentRef === null) {
				return;
			 }
			 this.callNgOnChanges(this.componentRef);
			 this.markViewForCheck(this.viewChangeDetectorRef);
			 this.componentRef.changeDetectorRef.detectChanges();
		  }
		  /** Runs in the angular zone, if present. */
		  runInZone(fn) {
			 return this.elementZone && Zone.current !== this.elementZone ? this.ngZone.run(fn) : fn();
		  }
		};
		var NgElement = class extends HTMLElement {
		  constructor() {
			 super(...arguments);
			 this.ngElementEventsSubscription = null;
		  }
		};
		function createCustomElement(component, config2) {
		  const inputs = getComponentInputs(component, config2.injector);
		  const strategyFactory = config2.strategyFactory || new ComponentNgElementStrategyFactory(component, config2.injector);
		  const attributeToPropertyInputs = getDefaultAttributeToPropertyInputs(inputs);
		  class NgElementImpl extends NgElement {
			 static {
				this["observedAttributes"] = Object.keys(attributeToPropertyInputs);
			 }
			 get ngElementStrategy() {
				if (!this._ngElementStrategy) {
				  const strategy = this._ngElementStrategy = strategyFactory.create(this.injector || config2.injector);
				  inputs.forEach(({ propName, transform: transform2 }) => {
					 if (!this.hasOwnProperty(propName)) {
						return;
					 }
					 const value = this[propName];
					 delete this[propName];
					 strategy.setInputValue(propName, value, transform2);
				  });
				}
				return this._ngElementStrategy;
			 }
			 constructor(injector) {
				super();
				this.injector = injector;
			 }
			 attributeChangedCallback(attrName, oldValue, newValue, namespace) {
				const [propName, transform2] = attributeToPropertyInputs[attrName];
				this.ngElementStrategy.setInputValue(propName, newValue, transform2);
			 }
			 connectedCallback() {
				let subscribedToEvents = false;
				if (this.ngElementStrategy.events) {
				  this.subscribeToEvents();
				  subscribedToEvents = true;
				}
				this.ngElementStrategy.connect(this);
				if (!subscribedToEvents) {
				  this.subscribeToEvents();
				}
			 }
			 disconnectedCallback() {
				if (this._ngElementStrategy) {
				  this._ngElementStrategy.disconnect();
				}
				if (this.ngElementEventsSubscription) {
				  this.ngElementEventsSubscription.unsubscribe();
				  this.ngElementEventsSubscription = null;
				}
			 }
			 subscribeToEvents() {
				this.ngElementEventsSubscription = this.ngElementStrategy.events.subscribe((e) => {
				  const customEvent = new CustomEvent(e.name, { detail: e.value });
				  this.dispatchEvent(customEvent);
				});
			 }
		  }
		  inputs.forEach(({ propName, transform: transform2 }) => {
			 Object.defineProperty(NgElementImpl.prototype, propName, {
				get() {
				  return this.ngElementStrategy.getInputValue(propName);
				},
				set(newValue) {
				  this.ngElementStrategy.setInputValue(propName, newValue, transform2);
				},
				configurable: true,
				enumerable: true
			 });
		  });
		  return NgElementImpl;
		}
		var VERSION2 = new Version("17.3.12");

		// node_modules/@angular/common/fesm2022/common.mjs
		var _DOM = null;
		function getDOM() {
		  return _DOM;
		}
		function setRootDomAdapter(adapter) {
		  _DOM ??= adapter;
		}
		var DomAdapter = class {
		};
		var PlatformNavigation = class _PlatformNavigation {
		  static {
			 this.\u0275fac = function PlatformNavigation_Factory(t) {
				return new (t || _PlatformNavigation)();
			 };
		  }
		  static {
			 this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
				token: _PlatformNavigation,
				factory: () => (() => window.navigation)(),
				providedIn: "platform"
			 });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlatformNavigation, [{
			 type: Injectable,
			 args: [{
				providedIn: "platform",
				useFactory: () => window.navigation
			 }]
		  }], null, null);
		})();
		var DOCUMENT2 = new InjectionToken(ngDevMode ? "DocumentToken" : "");
		var PlatformLocation = class _PlatformLocation {
		  historyGo(relativePosition) {
			 throw new Error(ngDevMode ? "Not implemented" : "");
		  }
		  static {
			 this.\u0275fac = function PlatformLocation_Factory(t) {
				return new (t || _PlatformLocation)();
			 };
		  }
		  static {
			 this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
				token: _PlatformLocation,
				factory: () => (() => inject(BrowserPlatformLocation))(),
				providedIn: "platform"
			 });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlatformLocation, [{
			 type: Injectable,
			 args: [{
				providedIn: "platform",
				useFactory: () => inject(BrowserPlatformLocation)
			 }]
		  }], null, null);
		})();
		var LOCATION_INITIALIZED = new InjectionToken(ngDevMode ? "Location Initialized" : "");
		var BrowserPlatformLocation = class _BrowserPlatformLocation extends PlatformLocation {
		  constructor() {
			 super();
			 this._doc = inject(DOCUMENT2);
			 this._location = window.location;
			 this._history = window.history;
		  }
		  getBaseHrefFromDOM() {
			 return getDOM().getBaseHref(this._doc);
		  }
		  onPopState(fn) {
			 const window2 = getDOM().getGlobalEventTarget(this._doc, "window");
			 window2.addEventListener("popstate", fn, false);
			 return () => window2.removeEventListener("popstate", fn);
		  }
		  onHashChange(fn) {
			 const window2 = getDOM().getGlobalEventTarget(this._doc, "window");
			 window2.addEventListener("hashchange", fn, false);
			 return () => window2.removeEventListener("hashchange", fn);
		  }
		  get href() {
			 return this._location.href;
		  }
		  get protocol() {
			 return this._location.protocol;
		  }
		  get hostname() {
			 return this._location.hostname;
		  }
		  get port() {
			 return this._location.port;
		  }
		  get pathname() {
			 return this._location.pathname;
		  }
		  get search() {
			 return this._location.search;
		  }
		  get hash() {
			 return this._location.hash;
		  }
		  set pathname(newPath) {
			 this._location.pathname = newPath;
		  }
		  pushState(state, title, url) {
			 this._history.pushState(state, title, url);
		  }
		  replaceState(state, title, url) {
			 this._history.replaceState(state, title, url);
		  }
		  forward() {
			 this._history.forward();
		  }
		  back() {
			 this._history.back();
		  }
		  historyGo(relativePosition = 0) {
			 this._history.go(relativePosition);
		  }
		  getState() {
			 return this._history.state;
		  }
		  static {
			 this.\u0275fac = function BrowserPlatformLocation_Factory(t) {
				return new (t || _BrowserPlatformLocation)();
			 };
		  }
		  static {
			 this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
				token: _BrowserPlatformLocation,
				factory: () => (() => new _BrowserPlatformLocation())(),
				providedIn: "platform"
			 });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BrowserPlatformLocation, [{
			 type: Injectable,
			 args: [{
				providedIn: "platform",
				useFactory: () => new BrowserPlatformLocation()
			 }]
		  }], () => [], null);
		})();
		function joinWithSlash(start2, end) {
		  if (start2.length == 0) {
			 return end;
		  }
		  if (end.length == 0) {
			 return start2;
		  }
		  let slashes = 0;
		  if (start2.endsWith("/")) {
			 slashes++;
		  }
		  if (end.startsWith("/")) {
			 slashes++;
		  }
		  if (slashes == 2) {
			 return start2 + end.substring(1);
		  }
		  if (slashes == 1) {
			 return start2 + end;
		  }
		  return start2 + "/" + end;
		}
		function stripTrailingSlash(url) {
		  const match23 = url.match(/#|\?|$/);
		  const pathEndIdx = match23 && match23.index || url.length;
		  const droppedSlashIdx = pathEndIdx - (url[pathEndIdx - 1] === "/" ? 1 : 0);
		  return url.slice(0, droppedSlashIdx) + url.slice(pathEndIdx);
		}
		function normalizeQueryParams(params) {
		  return params && params[0] !== "?" ? "?" + params : params;
		}
		var LocationStrategy = class _LocationStrategy {
		  historyGo(relativePosition) {
			 throw new Error(ngDevMode ? "Not implemented" : "");
		  }
		  static {
			 this.\u0275fac = function LocationStrategy_Factory(t) {
				return new (t || _LocationStrategy)();
			 };
		  }
		  static {
			 this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
				token: _LocationStrategy,
				factory: () => (() => inject(PathLocationStrategy))(),
				providedIn: "root"
			 });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LocationStrategy, [{
			 type: Injectable,
			 args: [{
				providedIn: "root",
				useFactory: () => inject(PathLocationStrategy)
			 }]
		  }], null, null);
		})();
		var APP_BASE_HREF = new InjectionToken(ngDevMode ? "appBaseHref" : "");
		var PathLocationStrategy = class _PathLocationStrategy extends LocationStrategy {
		  constructor(_platformLocation, href) {
			 super();
			 this._platformLocation = _platformLocation;
			 this._removeListenerFns = [];
			 this._baseHref = href ?? this._platformLocation.getBaseHrefFromDOM() ?? inject(DOCUMENT2).location?.origin ?? "";
		  }
		  /** @nodoc */
		  ngOnDestroy() {
			 while (this._removeListenerFns.length) {
				this._removeListenerFns.pop()();
			 }
		  }
		  onPopState(fn) {
			 this._removeListenerFns.push(this._platformLocation.onPopState(fn), this._platformLocation.onHashChange(fn));
		  }
		  getBaseHref() {
			 return this._baseHref;
		  }
		  prepareExternalUrl(internal) {
			 return joinWithSlash(this._baseHref, internal);
		  }
		  path(includeHash = false) {
			 const pathname = this._platformLocation.pathname + normalizeQueryParams(this._platformLocation.search);
			 const hash = this._platformLocation.hash;
			 return hash && includeHash ? `${pathname}${hash}` : pathname;
		  }
		  pushState(state, title, url, queryParams) {
			 const externalUrl = this.prepareExternalUrl(url + normalizeQueryParams(queryParams));
			 this._platformLocation.pushState(state, title, externalUrl);
		  }
		  replaceState(state, title, url, queryParams) {
			 const externalUrl = this.prepareExternalUrl(url + normalizeQueryParams(queryParams));
			 this._platformLocation.replaceState(state, title, externalUrl);
		  }
		  forward() {
			 this._platformLocation.forward();
		  }
		  back() {
			 this._platformLocation.back();
		  }
		  getState() {
			 return this._platformLocation.getState();
		  }
		  historyGo(relativePosition = 0) {
			 this._platformLocation.historyGo?.(relativePosition);
		  }
		  static {
			 this.\u0275fac = function PathLocationStrategy_Factory(t) {
				return new (t || _PathLocationStrategy)(\u0275\u0275inject(PlatformLocation), \u0275\u0275inject(APP_BASE_HREF, 8));
			 };
		  }
		  static {
			 this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
				token: _PathLocationStrategy,
				factory: _PathLocationStrategy.\u0275fac,
				providedIn: "root"
			 });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PathLocationStrategy, [{
			 type: Injectable,
			 args: [{
				providedIn: "root"
			 }]
		  }], () => [{
			 type: PlatformLocation
		  }, {
			 type: void 0,
			 decorators: [{
				type: Optional
			 }, {
				type: Inject,
				args: [APP_BASE_HREF]
			 }]
		  }], null);
		})();
		var HashLocationStrategy = class _HashLocationStrategy extends LocationStrategy {
		  constructor(_platformLocation, _baseHref) {
			 super();
			 this._platformLocation = _platformLocation;
			 this._baseHref = "";
			 this._removeListenerFns = [];
			 if (_baseHref != null) {
				this._baseHref = _baseHref;
			 }
		  }
		  /** @nodoc */
		  ngOnDestroy() {
			 while (this._removeListenerFns.length) {
				this._removeListenerFns.pop()();
			 }
		  }
		  onPopState(fn) {
			 this._removeListenerFns.push(this._platformLocation.onPopState(fn), this._platformLocation.onHashChange(fn));
		  }
		  getBaseHref() {
			 return this._baseHref;
		  }
		  path(includeHash = false) {
			 const path = this._platformLocation.hash ?? "#";
			 return path.length > 0 ? path.substring(1) : path;
		  }
		  prepareExternalUrl(internal) {
			 const url = joinWithSlash(this._baseHref, internal);
			 return url.length > 0 ? "#" + url : url;
		  }
		  pushState(state, title, path, queryParams) {
			 let url = this.prepareExternalUrl(path + normalizeQueryParams(queryParams));
			 if (url.length == 0) {
				url = this._platformLocation.pathname;
			 }
			 this._platformLocation.pushState(state, title, url);
		  }
		  replaceState(state, title, path, queryParams) {
			 let url = this.prepareExternalUrl(path + normalizeQueryParams(queryParams));
			 if (url.length == 0) {
				url = this._platformLocation.pathname;
			 }
			 this._platformLocation.replaceState(state, title, url);
		  }
		  forward() {
			 this._platformLocation.forward();
		  }
		  back() {
			 this._platformLocation.back();
		  }
		  getState() {
			 return this._platformLocation.getState();
		  }
		  historyGo(relativePosition = 0) {
			 this._platformLocation.historyGo?.(relativePosition);
		  }
		  static {
			 this.\u0275fac = function HashLocationStrategy_Factory(t) {
				return new (t || _HashLocationStrategy)(\u0275\u0275inject(PlatformLocation), \u0275\u0275inject(APP_BASE_HREF, 8));
			 };
		  }
		  static {
			 this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
				token: _HashLocationStrategy,
				factory: _HashLocationStrategy.\u0275fac
			 });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HashLocationStrategy, [{
			 type: Injectable
		  }], () => [{
			 type: PlatformLocation
		  }, {
			 type: void 0,
			 decorators: [{
				type: Optional
			 }, {
				type: Inject,
				args: [APP_BASE_HREF]
			 }]
		  }], null);
		})();
		var Location = class _Location {
		  constructor(locationStrategy) {
			 this._subject = new EventEmitter();
			 this._urlChangeListeners = [];
			 this._urlChangeSubscription = null;
			 this._locationStrategy = locationStrategy;
			 const baseHref = this._locationStrategy.getBaseHref();
			 this._basePath = _stripOrigin(stripTrailingSlash(_stripIndexHtml(baseHref)));
			 this._locationStrategy.onPopState((ev) => {
				this._subject.emit({
				  "url": this.path(true),
				  "pop": true,
				  "state": ev.state,
				  "type": ev.type
				});
			 });
		  }
		  /** @nodoc */
		  ngOnDestroy() {
			 this._urlChangeSubscription?.unsubscribe();
			 this._urlChangeListeners = [];
		  }
		  /**
			* Normalizes the URL path for this location.
			*
			* @param includeHash True to include an anchor fragment in the path.
			*
			* @returns The normalized URL path.
			*/
		  // TODO: vsavkin. Remove the boolean flag and always include hash once the deprecated router is
		  // removed.
		  path(includeHash = false) {
			 return this.normalize(this._locationStrategy.path(includeHash));
		  }
		  /**
			* Reports the current state of the location history.
			* @returns The current value of the `history.state` object.
			*/
		  getState() {
			 return this._locationStrategy.getState();
		  }
		  /**
			* Normalizes the given path and compares to the current normalized path.
			*
			* @param path The given URL path.
			* @param query Query parameters.
			*
			* @returns True if the given URL path is equal to the current normalized path, false
			* otherwise.
			*/
		  isCurrentPathEqualTo(path, query = "") {
			 return this.path() == this.normalize(path + normalizeQueryParams(query));
		  }
		  /**
			* Normalizes a URL path by stripping any trailing slashes.
			*
			* @param url String representing a URL.
			*
			* @returns The normalized URL string.
			*/
		  normalize(url) {
			 return _Location.stripTrailingSlash(_stripBasePath(this._basePath, _stripIndexHtml(url)));
		  }
		  /**
			* Normalizes an external URL path.
			* If the given URL doesn't begin with a leading slash (`'/'`), adds one
			* before normalizing. Adds a hash if `HashLocationStrategy` is
			* in use, or the `APP_BASE_HREF` if the `PathLocationStrategy` is in use.
			*
			* @param url String representing a URL.
			*
			* @returns  A normalized platform-specific URL.
			*/
		  prepareExternalUrl(url) {
			 if (url && url[0] !== "/") {
				url = "/" + url;
			 }
			 return this._locationStrategy.prepareExternalUrl(url);
		  }
		  // TODO: rename this method to pushState
		  /**
			* Changes the browser's URL to a normalized version of a given URL, and pushes a
			* new item onto the platform's history.
			*
			* @param path  URL path to normalize.
			* @param query Query parameters.
			* @param state Location history state.
			*
			*/
		  go(path, query = "", state = null) {
			 this._locationStrategy.pushState(state, "", path, query);
			 this._notifyUrlChangeListeners(this.prepareExternalUrl(path + normalizeQueryParams(query)), state);
		  }
		  /**
			* Changes the browser's URL to a normalized version of the given URL, and replaces
			* the top item on the platform's history stack.
			*
			* @param path  URL path to normalize.
			* @param query Query parameters.
			* @param state Location history state.
			*/
		  replaceState(path, query = "", state = null) {
			 this._locationStrategy.replaceState(state, "", path, query);
			 this._notifyUrlChangeListeners(this.prepareExternalUrl(path + normalizeQueryParams(query)), state);
		  }
		  /**
			* Navigates forward in the platform's history.
			*/
		  forward() {
			 this._locationStrategy.forward();
		  }
		  /**
			* Navigates back in the platform's history.
			*/
		  back() {
			 this._locationStrategy.back();
		  }
		  /**
			* Navigate to a specific page from session history, identified by its relative position to the
			* current page.
			*
			* @param relativePosition  Position of the target page in the history relative to the current
			*     page.
			* A negative value moves backwards, a positive value moves forwards, e.g. `location.historyGo(2)`
			* moves forward two pages and `location.historyGo(-2)` moves back two pages. When we try to go
			* beyond what's stored in the history session, we stay in the current page. Same behaviour occurs
			* when `relativePosition` equals 0.
			* @see https://developer.mozilla.org/en-US/docs/Web/API/History_API#Moving_to_a_specific_point_in_history
			*/
		  historyGo(relativePosition = 0) {
			 this._locationStrategy.historyGo?.(relativePosition);
		  }
		  /**
			* Registers a URL change listener. Use to catch updates performed by the Angular
			* framework that are not detectible through "popstate" or "hashchange" events.
			*
			* @param fn The change handler function, which take a URL and a location history state.
			* @returns A function that, when executed, unregisters a URL change listener.
			*/
		  onUrlChange(fn) {
			 this._urlChangeListeners.push(fn);
			 this._urlChangeSubscription ??= this.subscribe((v) => {
				this._notifyUrlChangeListeners(v.url, v.state);
			 });
			 return () => {
				const fnIndex = this._urlChangeListeners.indexOf(fn);
				this._urlChangeListeners.splice(fnIndex, 1);
				if (this._urlChangeListeners.length === 0) {
				  this._urlChangeSubscription?.unsubscribe();
				  this._urlChangeSubscription = null;
				}
			 };
		  }
		  /** @internal */
		  _notifyUrlChangeListeners(url = "", state) {
			 this._urlChangeListeners.forEach((fn) => fn(url, state));
		  }
		  /**
			* Subscribes to the platform's `popState` events.
			*
			* Note: `Location.go()` does not trigger the `popState` event in the browser. Use
			* `Location.onUrlChange()` to subscribe to URL changes instead.
			*
			* @param value Event that is triggered when the state history changes.
			* @param exception The exception to throw.
			*
			* @see [onpopstate](https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onpopstate)
			*
			* @returns Subscribed events.
			*/
		  subscribe(onNext, onThrow, onReturn) {
			 return this._subject.subscribe({
				next: onNext,
				error: onThrow,
				complete: onReturn
			 });
		  }
		  static {
			 this.normalizeQueryParams = normalizeQueryParams;
		  }
		  static {
			 this.joinWithSlash = joinWithSlash;
		  }
		  static {
			 this.stripTrailingSlash = stripTrailingSlash;
		  }
		  static {
			 this.\u0275fac = function Location_Factory(t) {
				return new (t || _Location)(\u0275\u0275inject(LocationStrategy));
			 };
		  }
		  static {
			 this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
				token: _Location,
				factory: () => createLocation(),
				providedIn: "root"
			 });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Location, [{
			 type: Injectable,
			 args: [{
				providedIn: "root",
				// See #23917
				useFactory: createLocation
			 }]
		  }], () => [{
			 type: LocationStrategy
		  }], null);
		})();
		function createLocation() {
		  return new Location(\u0275\u0275inject(LocationStrategy));
		}
		function _stripBasePath(basePath, url) {
		  if (!basePath || !url.startsWith(basePath)) {
			 return url;
		  }
		  const strippedUrl = url.substring(basePath.length);
		  if (strippedUrl === "" || ["/", ";", "?", "#"].includes(strippedUrl[0])) {
			 return strippedUrl;
		  }
		  return url;
		}
		function _stripIndexHtml(url) {
		  return url.replace(/\/index.html$/, "");
		}
		function _stripOrigin(baseHref) {
		  const isAbsoluteUrl2 = new RegExp("^(https?:)?//").test(baseHref);
		  if (isAbsoluteUrl2) {
			 const [, pathname] = baseHref.split(/\/\/[^\/]+/);
			 return pathname;
		  }
		  return baseHref;
		}
		var CURRENCIES_EN = {
		  "ADP": [void 0, void 0, 0],
		  "AFN": [void 0, "\u060B", 0],
		  "ALL": [void 0, void 0, 0],
		  "AMD": [void 0, "\u058F", 2],
		  "AOA": [void 0, "Kz"],
		  "ARS": [void 0, "$"],
		  "AUD": ["A$", "$"],
		  "AZN": [void 0, "\u20BC"],
		  "BAM": [void 0, "KM"],
		  "BBD": [void 0, "$"],
		  "BDT": [void 0, "\u09F3"],
		  "BHD": [void 0, void 0, 3],
		  "BIF": [void 0, void 0, 0],
		  "BMD": [void 0, "$"],
		  "BND": [void 0, "$"],
		  "BOB": [void 0, "Bs"],
		  "BRL": ["R$"],
		  "BSD": [void 0, "$"],
		  "BWP": [void 0, "P"],
		  "BYN": [void 0, void 0, 2],
		  "BYR": [void 0, void 0, 0],
		  "BZD": [void 0, "$"],
		  "CAD": ["CA$", "$", 2],
		  "CHF": [void 0, void 0, 2],
		  "CLF": [void 0, void 0, 4],
		  "CLP": [void 0, "$", 0],
		  "CNY": ["CN\xA5", "\xA5"],
		  "COP": [void 0, "$", 2],
		  "CRC": [void 0, "\u20A1", 2],
		  "CUC": [void 0, "$"],
		  "CUP": [void 0, "$"],
		  "CZK": [void 0, "K\u010D", 2],
		  "DJF": [void 0, void 0, 0],
		  "DKK": [void 0, "kr", 2],
		  "DOP": [void 0, "$"],
		  "EGP": [void 0, "E\xA3"],
		  "ESP": [void 0, "\u20A7", 0],
		  "EUR": ["\u20AC"],
		  "FJD": [void 0, "$"],
		  "FKP": [void 0, "\xA3"],
		  "GBP": ["\xA3"],
		  "GEL": [void 0, "\u20BE"],
		  "GHS": [void 0, "GH\u20B5"],
		  "GIP": [void 0, "\xA3"],
		  "GNF": [void 0, "FG", 0],
		  "GTQ": [void 0, "Q"],
		  "GYD": [void 0, "$", 2],
		  "HKD": ["HK$", "$"],
		  "HNL": [void 0, "L"],
		  "HRK": [void 0, "kn"],
		  "HUF": [void 0, "Ft", 2],
		  "IDR": [void 0, "Rp", 2],
		  "ILS": ["\u20AA"],
		  "INR": ["\u20B9"],
		  "IQD": [void 0, void 0, 0],
		  "IRR": [void 0, void 0, 0],
		  "ISK": [void 0, "kr", 0],
		  "ITL": [void 0, void 0, 0],
		  "JMD": [void 0, "$"],
		  "JOD": [void 0, void 0, 3],
		  "JPY": ["\xA5", void 0, 0],
		  "KHR": [void 0, "\u17DB"],
		  "KMF": [void 0, "CF", 0],
		  "KPW": [void 0, "\u20A9", 0],
		  "KRW": ["\u20A9", void 0, 0],
		  "KWD": [void 0, void 0, 3],
		  "KYD": [void 0, "$"],
		  "KZT": [void 0, "\u20B8"],
		  "LAK": [void 0, "\u20AD", 0],
		  "LBP": [void 0, "L\xA3", 0],
		  "LKR": [void 0, "Rs"],
		  "LRD": [void 0, "$"],
		  "LTL": [void 0, "Lt"],
		  "LUF": [void 0, void 0, 0],
		  "LVL": [void 0, "Ls"],
		  "LYD": [void 0, void 0, 3],
		  "MGA": [void 0, "Ar", 0],
		  "MGF": [void 0, void 0, 0],
		  "MMK": [void 0, "K", 0],
		  "MNT": [void 0, "\u20AE", 2],
		  "MRO": [void 0, void 0, 0],
		  "MUR": [void 0, "Rs", 2],
		  "MXN": ["MX$", "$"],
		  "MYR": [void 0, "RM"],
		  "NAD": [void 0, "$"],
		  "NGN": [void 0, "\u20A6"],
		  "NIO": [void 0, "C$"],
		  "NOK": [void 0, "kr", 2],
		  "NPR": [void 0, "Rs"],
		  "NZD": ["NZ$", "$"],
		  "OMR": [void 0, void 0, 3],
		  "PHP": ["\u20B1"],
		  "PKR": [void 0, "Rs", 2],
		  "PLN": [void 0, "z\u0142"],
		  "PYG": [void 0, "\u20B2", 0],
		  "RON": [void 0, "lei"],
		  "RSD": [void 0, void 0, 0],
		  "RUB": [void 0, "\u20BD"],
		  "RWF": [void 0, "RF", 0],
		  "SBD": [void 0, "$"],
		  "SEK": [void 0, "kr", 2],
		  "SGD": [void 0, "$"],
		  "SHP": [void 0, "\xA3"],
		  "SLE": [void 0, void 0, 2],
		  "SLL": [void 0, void 0, 0],
		  "SOS": [void 0, void 0, 0],
		  "SRD": [void 0, "$"],
		  "SSP": [void 0, "\xA3"],
		  "STD": [void 0, void 0, 0],
		  "STN": [void 0, "Db"],
		  "SYP": [void 0, "\xA3", 0],
		  "THB": [void 0, "\u0E3F"],
		  "TMM": [void 0, void 0, 0],
		  "TND": [void 0, void 0, 3],
		  "TOP": [void 0, "T$"],
		  "TRL": [void 0, void 0, 0],
		  "TRY": [void 0, "\u20BA"],
		  "TTD": [void 0, "$"],
		  "TWD": ["NT$", "$", 2],
		  "TZS": [void 0, void 0, 2],
		  "UAH": [void 0, "\u20B4"],
		  "UGX": [void 0, void 0, 0],
		  "USD": ["$"],
		  "UYI": [void 0, void 0, 0],
		  "UYU": [void 0, "$"],
		  "UYW": [void 0, void 0, 4],
		  "UZS": [void 0, void 0, 2],
		  "VEF": [void 0, "Bs", 2],
		  "VND": ["\u20AB", void 0, 0],
		  "VUV": [void 0, void 0, 0],
		  "XAF": ["FCFA", void 0, 0],
		  "XCD": ["EC$", "$"],
		  "XOF": ["F\u202FCFA", void 0, 0],
		  "XPF": ["CFPF", void 0, 0],
		  "XXX": ["\xA4"],
		  "YER": [void 0, void 0, 0],
		  "ZAR": [void 0, "R"],
		  "ZMK": [void 0, void 0, 0],
		  "ZMW": [void 0, "ZK"],
		  "ZWD": [void 0, void 0, 0]
		};
		var NumberFormatStyle;
		(function(NumberFormatStyle2) {
		  NumberFormatStyle2[NumberFormatStyle2["Decimal"] = 0] = "Decimal";
		  NumberFormatStyle2[NumberFormatStyle2["Percent"] = 1] = "Percent";
		  NumberFormatStyle2[NumberFormatStyle2["Currency"] = 2] = "Currency";
		  NumberFormatStyle2[NumberFormatStyle2["Scientific"] = 3] = "Scientific";
		})(NumberFormatStyle || (NumberFormatStyle = {}));
		var Plural;
		(function(Plural2) {
		  Plural2[Plural2["Zero"] = 0] = "Zero";
		  Plural2[Plural2["One"] = 1] = "One";
		  Plural2[Plural2["Two"] = 2] = "Two";
		  Plural2[Plural2["Few"] = 3] = "Few";
		  Plural2[Plural2["Many"] = 4] = "Many";
		  Plural2[Plural2["Other"] = 5] = "Other";
		})(Plural || (Plural = {}));
		var FormStyle;
		(function(FormStyle2) {
		  FormStyle2[FormStyle2["Format"] = 0] = "Format";
		  FormStyle2[FormStyle2["Standalone"] = 1] = "Standalone";
		})(FormStyle || (FormStyle = {}));
		var TranslationWidth;
		(function(TranslationWidth2) {
		  TranslationWidth2[TranslationWidth2["Narrow"] = 0] = "Narrow";
		  TranslationWidth2[TranslationWidth2["Abbreviated"] = 1] = "Abbreviated";
		  TranslationWidth2[TranslationWidth2["Wide"] = 2] = "Wide";
		  TranslationWidth2[TranslationWidth2["Short"] = 3] = "Short";
		})(TranslationWidth || (TranslationWidth = {}));
		var FormatWidth;
		(function(FormatWidth2) {
		  FormatWidth2[FormatWidth2["Short"] = 0] = "Short";
		  FormatWidth2[FormatWidth2["Medium"] = 1] = "Medium";
		  FormatWidth2[FormatWidth2["Long"] = 2] = "Long";
		  FormatWidth2[FormatWidth2["Full"] = 3] = "Full";
		})(FormatWidth || (FormatWidth = {}));
		var NumberSymbol = {
		  /**
			* Decimal separator.
			* For `en-US`, the dot character.
			* Example: 2,345`.`67
			*/
		  Decimal: 0,
		  /**
			* Grouping separator, typically for thousands.
			* For `en-US`, the comma character.
			* Example: 2`,`345.67
			*/
		  Group: 1,
		  /**
			* List-item separator.
			* Example: "one, two, and three"
			*/
		  List: 2,
		  /**
			* Sign for percentage (out of 100).
			* Example: 23.4%
			*/
		  PercentSign: 3,
		  /**
			* Sign for positive numbers.
			* Example: +23
			*/
		  PlusSign: 4,
		  /**
			* Sign for negative numbers.
			* Example: -23
			*/
		  MinusSign: 5,
		  /**
			* Computer notation for exponential value (n times a power of 10).
			* Example: 1.2E3
			*/
		  Exponential: 6,
		  /**
			* Human-readable format of exponential.
			* Example: 1.2x103
			*/
		  SuperscriptingExponent: 7,
		  /**
			* Sign for permille (out of 1000).
			* Example: 23.4
			*/
		  PerMille: 8,
		  /**
			* Infinity, can be used with plus and minus.
			* Example: , +, -
			*/
		  Infinity: 9,
		  /**
			* Not a number.
			* Example: NaN
			*/
		  NaN: 10,
		  /**
			* Symbol used between time units.
			* Example: 10:52
			*/
		  TimeSeparator: 11,
		  /**
			* Decimal separator for currency values (fallback to `Decimal`).
			* Example: $2,345.67
			*/
		  CurrencyDecimal: 12,
		  /**
			* Group separator for currency values (fallback to `Group`).
			* Example: $2,345.67
			*/
		  CurrencyGroup: 13
		};
		var WeekDay;
		(function(WeekDay2) {
		  WeekDay2[WeekDay2["Sunday"] = 0] = "Sunday";
		  WeekDay2[WeekDay2["Monday"] = 1] = "Monday";
		  WeekDay2[WeekDay2["Tuesday"] = 2] = "Tuesday";
		  WeekDay2[WeekDay2["Wednesday"] = 3] = "Wednesday";
		  WeekDay2[WeekDay2["Thursday"] = 4] = "Thursday";
		  WeekDay2[WeekDay2["Friday"] = 5] = "Friday";
		  WeekDay2[WeekDay2["Saturday"] = 6] = "Saturday";
		})(WeekDay || (WeekDay = {}));
		function getLocaleId2(locale2) {
		  return findLocaleData(locale2)[LocaleDataIndex.LocaleId];
		}
		function getLocaleDayPeriods(locale2, formStyle, width) {
		  const data = findLocaleData(locale2);
		  const amPmData = [data[LocaleDataIndex.DayPeriodsFormat], data[LocaleDataIndex.DayPeriodsStandalone]];
		  const amPm = getLastDefinedValue(amPmData, formStyle);
		  return getLastDefinedValue(amPm, width);
		}
		function getLocaleDayNames(locale2, formStyle, width) {
		  const data = findLocaleData(locale2);
		  const daysData = [data[LocaleDataIndex.DaysFormat], data[LocaleDataIndex.DaysStandalone]];
		  const days = getLastDefinedValue(daysData, formStyle);
		  return getLastDefinedValue(days, width);
		}
		function getLocaleMonthNames(locale2, formStyle, width) {
		  const data = findLocaleData(locale2);
		  const monthsData = [data[LocaleDataIndex.MonthsFormat], data[LocaleDataIndex.MonthsStandalone]];
		  const months = getLastDefinedValue(monthsData, formStyle);
		  return getLastDefinedValue(months, width);
		}
		function getLocaleEraNames(locale2, width) {
		  const data = findLocaleData(locale2);
		  const erasData = data[LocaleDataIndex.Eras];
		  return getLastDefinedValue(erasData, width);
		}
		function getLocaleDateFormat(locale2, width) {
		  const data = findLocaleData(locale2);
		  return getLastDefinedValue(data[LocaleDataIndex.DateFormat], width);
		}
		function getLocaleTimeFormat(locale2, width) {
		  const data = findLocaleData(locale2);
		  return getLastDefinedValue(data[LocaleDataIndex.TimeFormat], width);
		}
		function getLocaleDateTimeFormat(locale2, width) {
		  const data = findLocaleData(locale2);
		  const dateTimeFormatData = data[LocaleDataIndex.DateTimeFormat];
		  return getLastDefinedValue(dateTimeFormatData, width);
		}
		function getLocaleNumberSymbol(locale2, symbol) {
		  const data = findLocaleData(locale2);
		  const res = data[LocaleDataIndex.NumberSymbols][symbol];
		  if (typeof res === "undefined") {
			 if (symbol === NumberSymbol.CurrencyDecimal) {
				return data[LocaleDataIndex.NumberSymbols][NumberSymbol.Decimal];
			 } else if (symbol === NumberSymbol.CurrencyGroup) {
				return data[LocaleDataIndex.NumberSymbols][NumberSymbol.Group];
			 }
		  }
		  return res;
		}
		function getLocaleNumberFormat(locale2, type2) {
		  const data = findLocaleData(locale2);
		  return data[LocaleDataIndex.NumberFormats][type2];
		}
		function getLocaleCurrencies(locale2) {
		  const data = findLocaleData(locale2);
		  return data[LocaleDataIndex.Currencies];
		}
		var getLocalePluralCase2 = getLocalePluralCase;
		function checkFullData(data) {
		  if (!data[LocaleDataIndex.ExtraData]) {
			 throw new Error(`Missing extra locale data for the locale "${data[LocaleDataIndex.LocaleId]}". Use "registerLocaleData" to load new data. See the "I18n guide" on angular.io to know more.`);
		  }
		}
		function getLocaleExtraDayPeriodRules(locale2) {
		  const data = findLocaleData(locale2);
		  checkFullData(data);
		  const rules = data[LocaleDataIndex.ExtraData][
			 2
			 /* ExtraLocaleDataIndex.ExtraDayPeriodsRules */
		  ] || [];
		  return rules.map((rule) => {
			 if (typeof rule === "string") {
				return extractTime(rule);
			 }
			 return [extractTime(rule[0]), extractTime(rule[1])];
		  });
		}
		function getLocaleExtraDayPeriods(locale2, formStyle, width) {
		  const data = findLocaleData(locale2);
		  checkFullData(data);
		  const dayPeriodsData = [data[LocaleDataIndex.ExtraData][
			 0
			 /* ExtraLocaleDataIndex.ExtraDayPeriodFormats */
		  ], data[LocaleDataIndex.ExtraData][
			 1
			 /* ExtraLocaleDataIndex.ExtraDayPeriodStandalone */
		  ]];
		  const dayPeriods = getLastDefinedValue(dayPeriodsData, formStyle) || [];
		  return getLastDefinedValue(dayPeriods, width) || [];
		}
		function getLastDefinedValue(data, index) {
		  for (let i = index; i > -1; i--) {
			 if (typeof data[i] !== "undefined") {
				return data[i];
			 }
		  }
		  throw new Error("Locale data API: locale data undefined");
		}
		function extractTime(time) {
		  const [h, m] = time.split(":");
		  return {
			 hours: +h,
			 minutes: +m
		  };
		}
		function getCurrencySymbol(code, format2, locale2 = "en") {
		  const currency = getLocaleCurrencies(locale2)[code] || CURRENCIES_EN[code] || [];
		  const symbolNarrow = currency[
			 1
			 /* CurrencyIndex.SymbolNarrow */
		  ];
		  if (format2 === "narrow" && typeof symbolNarrow === "string") {
			 return symbolNarrow;
		  }
		  return currency[
			 0
			 /* CurrencyIndex.Symbol */
		  ] || code;
		}
		var DEFAULT_NB_OF_CURRENCY_DIGITS = 2;
		function getNumberOfCurrencyDigits(code) {
		  let digits;
		  const currency = CURRENCIES_EN[code];
		  if (currency) {
			 digits = currency[
				2
				/* CurrencyIndex.NbOfDigits */
			 ];
		  }
		  return typeof digits === "number" ? digits : DEFAULT_NB_OF_CURRENCY_DIGITS;
		}
		var ISO8601_DATE_REGEX = /^(\d{4,})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
		var NAMED_FORMATS = {};
		var DATE_FORMATS_SPLIT = /((?:[^BEGHLMOSWYZabcdhmswyz']+)|(?:'(?:[^']|'')*')|(?:G{1,5}|y{1,4}|Y{1,4}|M{1,5}|L{1,5}|w{1,2}|W{1}|d{1,2}|E{1,6}|c{1,6}|a{1,5}|b{1,5}|B{1,5}|h{1,2}|H{1,2}|m{1,2}|s{1,2}|S{1,3}|z{1,4}|Z{1,5}|O{1,4}))([\s\S]*)/;
		var ZoneWidth;
		(function(ZoneWidth2) {
		  ZoneWidth2[ZoneWidth2["Short"] = 0] = "Short";
		  ZoneWidth2[ZoneWidth2["ShortGMT"] = 1] = "ShortGMT";
		  ZoneWidth2[ZoneWidth2["Long"] = 2] = "Long";
		  ZoneWidth2[ZoneWidth2["Extended"] = 3] = "Extended";
		})(ZoneWidth || (ZoneWidth = {}));
		var DateType;
		(function(DateType2) {
		  DateType2[DateType2["FullYear"] = 0] = "FullYear";
		  DateType2[DateType2["Month"] = 1] = "Month";
		  DateType2[DateType2["Date"] = 2] = "Date";
		  DateType2[DateType2["Hours"] = 3] = "Hours";
		  DateType2[DateType2["Minutes"] = 4] = "Minutes";
		  DateType2[DateType2["Seconds"] = 5] = "Seconds";
		  DateType2[DateType2["FractionalSeconds"] = 6] = "FractionalSeconds";
		  DateType2[DateType2["Day"] = 7] = "Day";
		})(DateType || (DateType = {}));
		var TranslationType;
		(function(TranslationType2) {
		  TranslationType2[TranslationType2["DayPeriods"] = 0] = "DayPeriods";
		  TranslationType2[TranslationType2["Days"] = 1] = "Days";
		  TranslationType2[TranslationType2["Months"] = 2] = "Months";
		  TranslationType2[TranslationType2["Eras"] = 3] = "Eras";
		})(TranslationType || (TranslationType = {}));
		function formatDate(value, format2, locale2, timezone) {
		  let date2 = toDate(value);
		  const namedFormat = getNamedFormat(locale2, format2);
		  format2 = namedFormat || format2;
		  let parts = [];
		  let match23;
		  while (format2) {
			 match23 = DATE_FORMATS_SPLIT.exec(format2);
			 if (match23) {
				parts = parts.concat(match23.slice(1));
				const part = parts.pop();
				if (!part) {
				  break;
				}
				format2 = part;
			 } else {
				parts.push(format2);
				break;
			 }
		  }
		  let dateTimezoneOffset = date2.getTimezoneOffset();
		  if (timezone) {
			 dateTimezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
			 date2 = convertTimezoneToLocal(date2, timezone, true);
		  }
		  let text = "";
		  parts.forEach((value2) => {
			 const dateFormatter = getDateFormatter(value2);
			 text += dateFormatter ? dateFormatter(date2, locale2, dateTimezoneOffset) : value2 === "''" ? "'" : value2.replace(/(^'|'$)/g, "").replace(/''/g, "'");
		  });
		  return text;
		}
		function createDate(year, month, date2) {
		  const newDate2 = /* @__PURE__ */ new Date(0);
		  newDate2.setFullYear(year, month, date2);
		  newDate2.setHours(0, 0, 0);
		  return newDate2;
		}
		function getNamedFormat(locale2, format2) {
		  const localeId = getLocaleId2(locale2);
		  NAMED_FORMATS[localeId] ??= {};
		  if (NAMED_FORMATS[localeId][format2]) {
			 return NAMED_FORMATS[localeId][format2];
		  }
		  let formatValue2 = "";
		  switch (format2) {
			 case "shortDate":
				formatValue2 = getLocaleDateFormat(locale2, FormatWidth.Short);
				break;
			 case "mediumDate":
				formatValue2 = getLocaleDateFormat(locale2, FormatWidth.Medium);
				break;
			 case "longDate":
				formatValue2 = getLocaleDateFormat(locale2, FormatWidth.Long);
				break;
			 case "fullDate":
				formatValue2 = getLocaleDateFormat(locale2, FormatWidth.Full);
				break;
			 case "shortTime":
				formatValue2 = getLocaleTimeFormat(locale2, FormatWidth.Short);
				break;
			 case "mediumTime":
				formatValue2 = getLocaleTimeFormat(locale2, FormatWidth.Medium);
				break;
			 case "longTime":
				formatValue2 = getLocaleTimeFormat(locale2, FormatWidth.Long);
				break;
			 case "fullTime":
				formatValue2 = getLocaleTimeFormat(locale2, FormatWidth.Full);
				break;
			 case "short":
				const shortTime = getNamedFormat(locale2, "shortTime");
				const shortDate = getNamedFormat(locale2, "shortDate");
				formatValue2 = formatDateTime(getLocaleDateTimeFormat(locale2, FormatWidth.Short), [shortTime, shortDate]);
				break;
			 case "medium":
				const mediumTime = getNamedFormat(locale2, "mediumTime");
				const mediumDate = getNamedFormat(locale2, "mediumDate");
				formatValue2 = formatDateTime(getLocaleDateTimeFormat(locale2, FormatWidth.Medium), [mediumTime, mediumDate]);
				break;
			 case "long":
				const longTime = getNamedFormat(locale2, "longTime");
				const longDate = getNamedFormat(locale2, "longDate");
				formatValue2 = formatDateTime(getLocaleDateTimeFormat(locale2, FormatWidth.Long), [longTime, longDate]);
				break;
			 case "full":
				const fullTime = getNamedFormat(locale2, "fullTime");
				const fullDate = getNamedFormat(locale2, "fullDate");
				formatValue2 = formatDateTime(getLocaleDateTimeFormat(locale2, FormatWidth.Full), [fullTime, fullDate]);
				break;
		  }
		  if (formatValue2) {
			 NAMED_FORMATS[localeId][format2] = formatValue2;
		  }
		  return formatValue2;
		}
		function formatDateTime(str, opt_values) {
		  if (opt_values) {
			 str = str.replace(/\{([^}]+)}/g, function(match23, key) {
				return opt_values != null && key in opt_values ? opt_values[key] : match23;
			 });
		  }
		  return str;
		}
		function padNumber(num, digits, minusSign = "-", trim, negWrap) {
		  let neg = "";
		  if (num < 0 || negWrap && num <= 0) {
			 if (negWrap) {
				num = -num + 1;
			 } else {
				num = -num;
				neg = minusSign;
			 }
		  }
		  let strNum = String(num);
		  while (strNum.length < digits) {
			 strNum = "0" + strNum;
		  }
		  if (trim) {
			 strNum = strNum.slice(strNum.length - digits);
		  }
		  return neg + strNum;
		}
		function formatFractionalSeconds(milliseconds2, digits) {
		  const strMs = padNumber(milliseconds2, 3);
		  return strMs.substring(0, digits);
		}
		function dateGetter(name, size, offset = 0, trim = false, negWrap = false) {
		  return function(date2, locale2) {
			 let part = getDatePart(name, date2);
			 if (offset > 0 || part > -offset) {
				part += offset;
			 }
			 if (name === DateType.Hours) {
				if (part === 0 && offset === -12) {
				  part = 12;
				}
			 } else if (name === DateType.FractionalSeconds) {
				return formatFractionalSeconds(part, size);
			 }
			 const localeMinus = getLocaleNumberSymbol(locale2, NumberSymbol.MinusSign);
			 return padNumber(part, size, localeMinus, trim, negWrap);
		  };
		}
		function getDatePart(part, date2) {
		  switch (part) {
			 case DateType.FullYear:
				return date2.getFullYear();
			 case DateType.Month:
				return date2.getMonth();
			 case DateType.Date:
				return date2.getDate();
			 case DateType.Hours:
				return date2.getHours();
			 case DateType.Minutes:
				return date2.getMinutes();
			 case DateType.Seconds:
				return date2.getSeconds();
			 case DateType.FractionalSeconds:
				return date2.getMilliseconds();
			 case DateType.Day:
				return date2.getDay();
			 default:
				throw new Error(`Unknown DateType value "${part}".`);
		  }
		}
		function dateStrGetter(name, width, form = FormStyle.Format, extended = false) {
		  return function(date2, locale2) {
			 return getDateTranslation(date2, locale2, name, width, form, extended);
		  };
		}
		function getDateTranslation(date2, locale2, name, width, form, extended) {
		  switch (name) {
			 case TranslationType.Months:
				return getLocaleMonthNames(locale2, form, width)[date2.getMonth()];
			 case TranslationType.Days:
				return getLocaleDayNames(locale2, form, width)[date2.getDay()];
			 case TranslationType.DayPeriods:
				const currentHours = date2.getHours();
				const currentMinutes = date2.getMinutes();
				if (extended) {
				  const rules = getLocaleExtraDayPeriodRules(locale2);
				  const dayPeriods = getLocaleExtraDayPeriods(locale2, form, width);
				  const index = rules.findIndex((rule) => {
					 if (Array.isArray(rule)) {
						const [from2, to] = rule;
						const afterFrom = currentHours >= from2.hours && currentMinutes >= from2.minutes;
						const beforeTo = currentHours < to.hours || currentHours === to.hours && currentMinutes < to.minutes;
						if (from2.hours < to.hours) {
						  if (afterFrom && beforeTo) {
							 return true;
						  }
						} else if (afterFrom || beforeTo) {
						  return true;
						}
					 } else {
						if (rule.hours === currentHours && rule.minutes === currentMinutes) {
						  return true;
						}
					 }
					 return false;
				  });
				  if (index !== -1) {
					 return dayPeriods[index];
				  }
				}
				return getLocaleDayPeriods(locale2, form, width)[currentHours < 12 ? 0 : 1];
			 case TranslationType.Eras:
				return getLocaleEraNames(locale2, width)[date2.getFullYear() <= 0 ? 0 : 1];
			 default:
				const unexpected = name;
				throw new Error(`unexpected translation type ${unexpected}`);
		  }
		}
		function timeZoneGetter(width) {
		  return function(date2, locale2, offset) {
			 const zone = -1 * offset;
			 const minusSign = getLocaleNumberSymbol(locale2, NumberSymbol.MinusSign);
			 const hours = zone > 0 ? Math.floor(zone / 60) : Math.ceil(zone / 60);
			 switch (width) {
				case ZoneWidth.Short:
				  return (zone >= 0 ? "+" : "") + padNumber(hours, 2, minusSign) + padNumber(Math.abs(zone % 60), 2, minusSign);
				case ZoneWidth.ShortGMT:
				  return "GMT" + (zone >= 0 ? "+" : "") + padNumber(hours, 1, minusSign);
				case ZoneWidth.Long:
				  return "GMT" + (zone >= 0 ? "+" : "") + padNumber(hours, 2, minusSign) + ":" + padNumber(Math.abs(zone % 60), 2, minusSign);
				case ZoneWidth.Extended:
				  if (offset === 0) {
					 return "Z";
				  } else {
					 return (zone >= 0 ? "+" : "") + padNumber(hours, 2, minusSign) + ":" + padNumber(Math.abs(zone % 60), 2, minusSign);
				  }
				default:
				  throw new Error(`Unknown zone width "${width}"`);
			 }
		  };
		}
		var JANUARY = 0;
		var THURSDAY = 4;
		function getFirstThursdayOfYear(year) {
		  const firstDayOfYear = createDate(year, JANUARY, 1).getDay();
		  return createDate(year, 0, 1 + (firstDayOfYear <= THURSDAY ? THURSDAY : THURSDAY + 7) - firstDayOfYear);
		}
		function getThursdayThisIsoWeek(datetime) {
		  const currentDay = datetime.getDay();
		  const deltaToThursday = currentDay === 0 ? -3 : THURSDAY - currentDay;
		  return createDate(datetime.getFullYear(), datetime.getMonth(), datetime.getDate() + deltaToThursday);
		}
		function weekGetter(size, monthBased = false) {
		  return function(date2, locale2) {
			 let result;
			 if (monthBased) {
				const nbDaysBefore1stDayOfMonth = new Date(date2.getFullYear(), date2.getMonth(), 1).getDay() - 1;
				const today = date2.getDate();
				result = 1 + Math.floor((today + nbDaysBefore1stDayOfMonth) / 7);
			 } else {
				const thisThurs = getThursdayThisIsoWeek(date2);
				const firstThurs = getFirstThursdayOfYear(thisThurs.getFullYear());
				const diff = thisThurs.getTime() - firstThurs.getTime();
				result = 1 + Math.round(diff / 6048e5);
			 }
			 return padNumber(result, size, getLocaleNumberSymbol(locale2, NumberSymbol.MinusSign));
		  };
		}
		function weekNumberingYearGetter(size, trim = false) {
		  return function(date2, locale2) {
			 const thisThurs = getThursdayThisIsoWeek(date2);
			 const weekNumberingYear = thisThurs.getFullYear();
			 return padNumber(weekNumberingYear, size, getLocaleNumberSymbol(locale2, NumberSymbol.MinusSign), trim);
		  };
		}
		var DATE_FORMATS = {};
		function getDateFormatter(format2) {
		  if (DATE_FORMATS[format2]) {
			 return DATE_FORMATS[format2];
		  }
		  let formatter;
		  switch (format2) {
			 case "G":
			 case "GG":
			 case "GGG":
				formatter = dateStrGetter(TranslationType.Eras, TranslationWidth.Abbreviated);
				break;
			 case "GGGG":
				formatter = dateStrGetter(TranslationType.Eras, TranslationWidth.Wide);
				break;
			 case "GGGGG":
				formatter = dateStrGetter(TranslationType.Eras, TranslationWidth.Narrow);
				break;
			 case "y":
				formatter = dateGetter(DateType.FullYear, 1, 0, false, true);
				break;
			 case "yy":
				formatter = dateGetter(DateType.FullYear, 2, 0, true, true);
				break;
			 case "yyy":
				formatter = dateGetter(DateType.FullYear, 3, 0, false, true);
				break;
			 case "yyyy":
				formatter = dateGetter(DateType.FullYear, 4, 0, false, true);
				break;
			 case "Y":
				formatter = weekNumberingYearGetter(1);
				break;
			 case "YY":
				formatter = weekNumberingYearGetter(2, true);
				break;
			 case "YYY":
				formatter = weekNumberingYearGetter(3);
				break;
			 case "YYYY":
				formatter = weekNumberingYearGetter(4);
				break;
			 case "M":
			 case "L":
				formatter = dateGetter(DateType.Month, 1, 1);
				break;
			 case "MM":
			 case "LL":
				formatter = dateGetter(DateType.Month, 2, 1);
				break;
			 case "MMM":
				formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Abbreviated);
				break;
			 case "MMMM":
				formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Wide);
				break;
			 case "MMMMM":
				formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Narrow);
				break;
			 case "LLL":
				formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Abbreviated, FormStyle.Standalone);
				break;
			 case "LLLL":
				formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Wide, FormStyle.Standalone);
				break;
			 case "LLLLL":
				formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Narrow, FormStyle.Standalone);
				break;
			 case "w":
				formatter = weekGetter(1);
				break;
			 case "ww":
				formatter = weekGetter(2);
				break;
			 case "W":
				formatter = weekGetter(1, true);
				break;
			 case "d":
				formatter = dateGetter(DateType.Date, 1);
				break;
			 case "dd":
				formatter = dateGetter(DateType.Date, 2);
				break;
			 case "c":
			 case "cc":
				formatter = dateGetter(DateType.Day, 1);
				break;
			 case "ccc":
				formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Abbreviated, FormStyle.Standalone);
				break;
			 case "cccc":
				formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Wide, FormStyle.Standalone);
				break;
			 case "ccccc":
				formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Narrow, FormStyle.Standalone);
				break;
			 case "cccccc":
				formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Short, FormStyle.Standalone);
				break;
			 case "E":
			 case "EE":
			 case "EEE":
				formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Abbreviated);
				break;
			 case "EEEE":
				formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Wide);
				break;
			 case "EEEEE":
				formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Narrow);
				break;
			 case "EEEEEE":
				formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Short);
				break;
			 case "a":
			 case "aa":
			 case "aaa":
				formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Abbreviated);
				break;
			 case "aaaa":
				formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Wide);
				break;
			 case "aaaaa":
				formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Narrow);
				break;
			 case "b":
			 case "bb":
			 case "bbb":
				formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Abbreviated, FormStyle.Standalone, true);
				break;
			 case "bbbb":
				formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Wide, FormStyle.Standalone, true);
				break;
			 case "bbbbb":
				formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Narrow, FormStyle.Standalone, true);
				break;
			 case "B":
			 case "BB":
			 case "BBB":
				formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Abbreviated, FormStyle.Format, true);
				break;
			 case "BBBB":
				formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Wide, FormStyle.Format, true);
				break;
			 case "BBBBB":
				formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Narrow, FormStyle.Format, true);
				break;
			 case "h":
				formatter = dateGetter(DateType.Hours, 1, -12);
				break;
			 case "hh":
				formatter = dateGetter(DateType.Hours, 2, -12);
				break;
			 case "H":
				formatter = dateGetter(DateType.Hours, 1);
				break;
			 case "HH":
				formatter = dateGetter(DateType.Hours, 2);
				break;
			 case "m":
				formatter = dateGetter(DateType.Minutes, 1);
				break;
			 case "mm":
				formatter = dateGetter(DateType.Minutes, 2);
				break;
			 case "s":
				formatter = dateGetter(DateType.Seconds, 1);
				break;
			 case "ss":
				formatter = dateGetter(DateType.Seconds, 2);
				break;
			 case "S":
				formatter = dateGetter(DateType.FractionalSeconds, 1);
				break;
			 case "SS":
				formatter = dateGetter(DateType.FractionalSeconds, 2);
				break;
			 case "SSS":
				formatter = dateGetter(DateType.FractionalSeconds, 3);
				break;
			 case "Z":
			 case "ZZ":
			 case "ZZZ":
				formatter = timeZoneGetter(ZoneWidth.Short);
				break;
			 case "ZZZZZ":
				formatter = timeZoneGetter(ZoneWidth.Extended);
				break;
			 case "O":
			 case "OO":
			 case "OOO":
			 case "z":
			 case "zz":
			 case "zzz":
				formatter = timeZoneGetter(ZoneWidth.ShortGMT);
				break;
			 case "OOOO":
			 case "ZZZZ":
			 case "zzzz":
				formatter = timeZoneGetter(ZoneWidth.Long);
				break;
			 default:
				return null;
		  }
		  DATE_FORMATS[format2] = formatter;
		  return formatter;
		}
		function timezoneToOffset(timezone, fallback) {
		  timezone = timezone.replace(/:/g, "");
		  const requestedTimezoneOffset = Date.parse("Jan 01, 1970 00:00:00 " + timezone) / 6e4;
		  return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
		}
		function addDateMinutes(date2, minutes) {
		  date2 = new Date(date2.getTime());
		  date2.setMinutes(date2.getMinutes() + minutes);
		  return date2;
		}
		function convertTimezoneToLocal(date2, timezone, reverse) {
		  const reverseValue = reverse ? -1 : 1;
		  const dateTimezoneOffset = date2.getTimezoneOffset();
		  const timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
		  return addDateMinutes(date2, reverseValue * (timezoneOffset - dateTimezoneOffset));
		}
		function toDate(value) {
		  if (isDate(value)) {
			 return value;
		  }
		  if (typeof value === "number" && !isNaN(value)) {
			 return new Date(value);
		  }
		  if (typeof value === "string") {
			 value = value.trim();
			 if (/^(\d{4}(-\d{1,2}(-\d{1,2})?)?)$/.test(value)) {
				const [y, m = 1, d = 1] = value.split("-").map((val) => +val);
				return createDate(y, m - 1, d);
			 }
			 const parsedNb = parseFloat(value);
			 if (!isNaN(value - parsedNb)) {
				return new Date(parsedNb);
			 }
			 let match23;
			 if (match23 = value.match(ISO8601_DATE_REGEX)) {
				return isoStringToDate(match23);
			 }
		  }
		  const date2 = new Date(value);
		  if (!isDate(date2)) {
			 throw new Error(`Unable to convert "${value}" into a date`);
		  }
		  return date2;
		}
		function isoStringToDate(match23) {
		  const date2 = /* @__PURE__ */ new Date(0);
		  let tzHour = 0;
		  let tzMin = 0;
		  const dateSetter = match23[8] ? date2.setUTCFullYear : date2.setFullYear;
		  const timeSetter = match23[8] ? date2.setUTCHours : date2.setHours;
		  if (match23[9]) {
			 tzHour = Number(match23[9] + match23[10]);
			 tzMin = Number(match23[9] + match23[11]);
		  }
		  dateSetter.call(date2, Number(match23[1]), Number(match23[2]) - 1, Number(match23[3]));
		  const h = Number(match23[4] || 0) - tzHour;
		  const m = Number(match23[5] || 0) - tzMin;
		  const s = Number(match23[6] || 0);
		  const ms = Math.floor(parseFloat("0." + (match23[7] || 0)) * 1e3);
		  timeSetter.call(date2, h, m, s, ms);
		  return date2;
		}
		function isDate(value) {
		  return value instanceof Date && !isNaN(value.valueOf());
		}
		var NUMBER_FORMAT_REGEXP = /^(\d+)?\.((\d+)(-(\d+))?)?$/;
		var MAX_DIGITS = 22;
		var DECIMAL_SEP = ".";
		var ZERO_CHAR = "0";
		var PATTERN_SEP = ";";
		var GROUP_SEP = ",";
		var DIGIT_CHAR = "#";
		var CURRENCY_CHAR = "\xA4";
		var PERCENT_CHAR = "%";
		function formatNumberToLocaleString(value, pattern, locale2, groupSymbol, decimalSymbol, digitsInfo, isPercent = false) {
		  let formattedText = "";
		  let isZero = false;
		  if (!isFinite(value)) {
			 formattedText = getLocaleNumberSymbol(locale2, NumberSymbol.Infinity);
		  } else {
			 let parsedNumber = parseNumber(value);
			 if (isPercent) {
				parsedNumber = toPercent(parsedNumber);
			 }
			 let minInt = pattern.minInt;
			 let minFraction = pattern.minFrac;
			 let maxFraction = pattern.maxFrac;
			 if (digitsInfo) {
				const parts = digitsInfo.match(NUMBER_FORMAT_REGEXP);
				if (parts === null) {
				  throw new Error(`${digitsInfo} is not a valid digit info`);
				}
				const minIntPart = parts[1];
				const minFractionPart = parts[3];
				const maxFractionPart = parts[5];
				if (minIntPart != null) {
				  minInt = parseIntAutoRadix(minIntPart);
				}
				if (minFractionPart != null) {
				  minFraction = parseIntAutoRadix(minFractionPart);
				}
				if (maxFractionPart != null) {
				  maxFraction = parseIntAutoRadix(maxFractionPart);
				} else if (minFractionPart != null && minFraction > maxFraction) {
				  maxFraction = minFraction;
				}
			 }
			 roundNumber(parsedNumber, minFraction, maxFraction);
			 let digits = parsedNumber.digits;
			 let integerLen = parsedNumber.integerLen;
			 const exponent = parsedNumber.exponent;
			 let decimals = [];
			 isZero = digits.every((d) => !d);
			 for (; integerLen < minInt; integerLen++) {
				digits.unshift(0);
			 }
			 for (; integerLen < 0; integerLen++) {
				digits.unshift(0);
			 }
			 if (integerLen > 0) {
				decimals = digits.splice(integerLen, digits.length);
			 } else {
				decimals = digits;
				digits = [0];
			 }
			 const groups = [];
			 if (digits.length >= pattern.lgSize) {
				groups.unshift(digits.splice(-pattern.lgSize, digits.length).join(""));
			 }
			 while (digits.length > pattern.gSize) {
				groups.unshift(digits.splice(-pattern.gSize, digits.length).join(""));
			 }
			 if (digits.length) {
				groups.unshift(digits.join(""));
			 }
			 formattedText = groups.join(getLocaleNumberSymbol(locale2, groupSymbol));
			 if (decimals.length) {
				formattedText += getLocaleNumberSymbol(locale2, decimalSymbol) + decimals.join("");
			 }
			 if (exponent) {
				formattedText += getLocaleNumberSymbol(locale2, NumberSymbol.Exponential) + "+" + exponent;
			 }
		  }
		  if (value < 0 && !isZero) {
			 formattedText = pattern.negPre + formattedText + pattern.negSuf;
		  } else {
			 formattedText = pattern.posPre + formattedText + pattern.posSuf;
		  }
		  return formattedText;
		}
		function formatCurrency(value, locale2, currency, currencyCode, digitsInfo) {
		  const format2 = getLocaleNumberFormat(locale2, NumberFormatStyle.Currency);
		  const pattern = parseNumberFormat(format2, getLocaleNumberSymbol(locale2, NumberSymbol.MinusSign));
		  pattern.minFrac = getNumberOfCurrencyDigits(currencyCode);
		  pattern.maxFrac = pattern.minFrac;
		  const res = formatNumberToLocaleString(value, pattern, locale2, NumberSymbol.CurrencyGroup, NumberSymbol.CurrencyDecimal, digitsInfo);
		  return res.replace(CURRENCY_CHAR, currency).replace(CURRENCY_CHAR, "").trim();
		}
		function formatPercent(value, locale2, digitsInfo) {
		  const format2 = getLocaleNumberFormat(locale2, NumberFormatStyle.Percent);
		  const pattern = parseNumberFormat(format2, getLocaleNumberSymbol(locale2, NumberSymbol.MinusSign));
		  const res = formatNumberToLocaleString(value, pattern, locale2, NumberSymbol.Group, NumberSymbol.Decimal, digitsInfo, true);
		  return res.replace(new RegExp(PERCENT_CHAR, "g"), getLocaleNumberSymbol(locale2, NumberSymbol.PercentSign));
		}
		function formatNumber(value, locale2, digitsInfo) {
		  const format2 = getLocaleNumberFormat(locale2, NumberFormatStyle.Decimal);
		  const pattern = parseNumberFormat(format2, getLocaleNumberSymbol(locale2, NumberSymbol.MinusSign));
		  return formatNumberToLocaleString(value, pattern, locale2, NumberSymbol.Group, NumberSymbol.Decimal, digitsInfo);
		}
		function parseNumberFormat(format2, minusSign = "-") {
		  const p = {
			 minInt: 1,
			 minFrac: 0,
			 maxFrac: 0,
			 posPre: "",
			 posSuf: "",
			 negPre: "",
			 negSuf: "",
			 gSize: 0,
			 lgSize: 0
		  };
		  const patternParts = format2.split(PATTERN_SEP);
		  const positive = patternParts[0];
		  const negative = patternParts[1];
		  const positiveParts = positive.indexOf(DECIMAL_SEP) !== -1 ? positive.split(DECIMAL_SEP) : [positive.substring(0, positive.lastIndexOf(ZERO_CHAR) + 1), positive.substring(positive.lastIndexOf(ZERO_CHAR) + 1)], integer = positiveParts[0], fraction = positiveParts[1] || "";
		  p.posPre = integer.substring(0, integer.indexOf(DIGIT_CHAR));
		  for (let i = 0; i < fraction.length; i++) {
			 const ch = fraction.charAt(i);
			 if (ch === ZERO_CHAR) {
				p.minFrac = p.maxFrac = i + 1;
			 } else if (ch === DIGIT_CHAR) {
				p.maxFrac = i + 1;
			 } else {
				p.posSuf += ch;
			 }
		  }
		  const groups = integer.split(GROUP_SEP);
		  p.gSize = groups[1] ? groups[1].length : 0;
		  p.lgSize = groups[2] || groups[1] ? (groups[2] || groups[1]).length : 0;
		  if (negative) {
			 const trunkLen = positive.length - p.posPre.length - p.posSuf.length, pos = negative.indexOf(DIGIT_CHAR);
			 p.negPre = negative.substring(0, pos).replace(/'/g, "");
			 p.negSuf = negative.slice(pos + trunkLen).replace(/'/g, "");
		  } else {
			 p.negPre = minusSign + p.posPre;
			 p.negSuf = p.posSuf;
		  }
		  return p;
		}
		function toPercent(parsedNumber) {
		  if (parsedNumber.digits[0] === 0) {
			 return parsedNumber;
		  }
		  const fractionLen = parsedNumber.digits.length - parsedNumber.integerLen;
		  if (parsedNumber.exponent) {
			 parsedNumber.exponent += 2;
		  } else {
			 if (fractionLen === 0) {
				parsedNumber.digits.push(0, 0);
			 } else if (fractionLen === 1) {
				parsedNumber.digits.push(0);
			 }
			 parsedNumber.integerLen += 2;
		  }
		  return parsedNumber;
		}
		function parseNumber(num) {
		  let numStr = Math.abs(num) + "";
		  let exponent = 0, digits, integerLen;
		  let i, j, zeros;
		  if ((integerLen = numStr.indexOf(DECIMAL_SEP)) > -1) {
			 numStr = numStr.replace(DECIMAL_SEP, "");
		  }
		  if ((i = numStr.search(/e/i)) > 0) {
			 if (integerLen < 0)
				integerLen = i;
			 integerLen += +numStr.slice(i + 1);
			 numStr = numStr.substring(0, i);
		  } else if (integerLen < 0) {
			 integerLen = numStr.length;
		  }
		  for (i = 0; numStr.charAt(i) === ZERO_CHAR; i++) {
		  }
		  if (i === (zeros = numStr.length)) {
			 digits = [0];
			 integerLen = 1;
		  } else {
			 zeros--;
			 while (numStr.charAt(zeros) === ZERO_CHAR)
				zeros--;
			 integerLen -= i;
			 digits = [];
			 for (j = 0; i <= zeros; i++, j++) {
				digits[j] = Number(numStr.charAt(i));
			 }
		  }
		  if (integerLen > MAX_DIGITS) {
			 digits = digits.splice(0, MAX_DIGITS - 1);
			 exponent = integerLen - 1;
			 integerLen = 1;
		  }
		  return {
			 digits,
			 exponent,
			 integerLen
		  };
		}
		function roundNumber(parsedNumber, minFrac, maxFrac) {
		  if (minFrac > maxFrac) {
			 throw new Error(`The minimum number of digits after fraction (${minFrac}) is higher than the maximum (${maxFrac}).`);
		  }
		  let digits = parsedNumber.digits;
		  let fractionLen = digits.length - parsedNumber.integerLen;
		  const fractionSize = Math.min(Math.max(minFrac, fractionLen), maxFrac);
		  let roundAt = fractionSize + parsedNumber.integerLen;
		  let digit = digits[roundAt];
		  if (roundAt > 0) {
			 digits.splice(Math.max(parsedNumber.integerLen, roundAt));
			 for (let j = roundAt; j < digits.length; j++) {
				digits[j] = 0;
			 }
		  } else {
			 fractionLen = Math.max(0, fractionLen);
			 parsedNumber.integerLen = 1;
			 digits.length = Math.max(1, roundAt = fractionSize + 1);
			 digits[0] = 0;
			 for (let i = 1; i < roundAt; i++)
				digits[i] = 0;
		  }
		  if (digit >= 5) {
			 if (roundAt - 1 < 0) {
				for (let k = 0; k > roundAt; k--) {
				  digits.unshift(0);
				  parsedNumber.integerLen++;
				}
				digits.unshift(1);
				parsedNumber.integerLen++;
			 } else {
				digits[roundAt - 1]++;
			 }
		  }
		  for (; fractionLen < Math.max(0, fractionSize); fractionLen++)
			 digits.push(0);
		  let dropTrailingZeros = fractionSize !== 0;
		  const minLen = minFrac + parsedNumber.integerLen;
		  const carry = digits.reduceRight(function(carry2, d, i, digits2) {
			 d = d + carry2;
			 digits2[i] = d < 10 ? d : d - 10;
			 if (dropTrailingZeros) {
				if (digits2[i] === 0 && i >= minLen) {
				  digits2.pop();
				} else {
				  dropTrailingZeros = false;
				}
			 }
			 return d >= 10 ? 1 : 0;
		  }, 0);
		  if (carry) {
			 digits.unshift(carry);
			 parsedNumber.integerLen++;
		  }
		}
		function parseIntAutoRadix(text) {
		  const result = parseInt(text);
		  if (isNaN(result)) {
			 throw new Error("Invalid integer literal when parsing " + text);
		  }
		  return result;
		}
		var NgLocalization = class _NgLocalization {
		  static {
			 this.\u0275fac = function NgLocalization_Factory(t) {
				return new (t || _NgLocalization)();
			 };
		  }
		  static {
			 this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
				token: _NgLocalization,
				factory: function NgLocalization_Factory(t) {
				  let r = null;
				  if (t) {
					 r = new t();
				  } else {
					 r = ((locale2) => new NgLocaleLocalization(locale2))(\u0275\u0275inject(LOCALE_ID));
				  }
				  return r;
				},
				providedIn: "root"
			 });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgLocalization, [{
			 type: Injectable,
			 args: [{
				providedIn: "root",
				useFactory: (locale2) => new NgLocaleLocalization(locale2),
				deps: [LOCALE_ID]
			 }]
		  }], null, null);
		})();
		function getPluralCategory(value, cases, ngLocalization, locale2) {
		  let key = `=${value}`;
		  if (cases.indexOf(key) > -1) {
			 return key;
		  }
		  key = ngLocalization.getPluralCategory(value, locale2);
		  if (cases.indexOf(key) > -1) {
			 return key;
		  }
		  if (cases.indexOf("other") > -1) {
			 return "other";
		  }
		  throw new Error(`No plural message found for value "${value}"`);
		}
		var NgLocaleLocalization = class _NgLocaleLocalization extends NgLocalization {
		  constructor(locale2) {
			 super();
			 this.locale = locale2;
		  }
		  getPluralCategory(value, locale2) {
			 const plural2 = getLocalePluralCase2(locale2 || this.locale)(value);
			 switch (plural2) {
				case Plural.Zero:
				  return "zero";
				case Plural.One:
				  return "one";
				case Plural.Two:
				  return "two";
				case Plural.Few:
				  return "few";
				case Plural.Many:
				  return "many";
				default:
				  return "other";
			 }
		  }
		  static {
			 this.\u0275fac = function NgLocaleLocalization_Factory(t) {
				return new (t || _NgLocaleLocalization)(\u0275\u0275inject(LOCALE_ID));
			 };
		  }
		  static {
			 this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
				token: _NgLocaleLocalization,
				factory: _NgLocaleLocalization.\u0275fac
			 });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgLocaleLocalization, [{
			 type: Injectable
		  }], () => [{
			 type: void 0,
			 decorators: [{
				type: Inject,
				args: [LOCALE_ID]
			 }]
		  }], null);
		})();
		function parseCookieValue(cookieStr, name) {
		  name = encodeURIComponent(name);
		  for (const cookie of cookieStr.split(";")) {
			 const eqIndex = cookie.indexOf("=");
			 const [cookieName, cookieValue] = eqIndex == -1 ? [cookie, ""] : [cookie.slice(0, eqIndex), cookie.slice(eqIndex + 1)];
			 if (cookieName.trim() === name) {
				return decodeURIComponent(cookieValue);
			 }
		  }
		  return null;
		}
		var WS_REGEXP = /\s+/;
		var EMPTY_ARRAY2 = [];
		var NgClass = class _NgClass {
		  constructor(_ngEl, _renderer) {
			 this._ngEl = _ngEl;
			 this._renderer = _renderer;
			 this.initialClasses = EMPTY_ARRAY2;
			 this.stateMap = /* @__PURE__ */ new Map();
		  }
		  set klass(value) {
			 this.initialClasses = value != null ? value.trim().split(WS_REGEXP) : EMPTY_ARRAY2;
		  }
		  set ngClass(value) {
			 this.rawClass = typeof value === "string" ? value.trim().split(WS_REGEXP) : value;
		  }
		  /*
		  The NgClass directive uses the custom change detection algorithm for its inputs. The custom
		  algorithm is necessary since inputs are represented as complex object or arrays that need to be
		  deeply-compared.
			  This algorithm is perf-sensitive since NgClass is used very frequently and its poor performance
		  might negatively impact runtime performance of the entire change detection cycle. The design of
		  this algorithm is making sure that:
		  - there is no unnecessary DOM manipulation (CSS classes are added / removed from the DOM only when
		  needed), even if references to bound objects change;
		  - there is no memory allocation if nothing changes (even relatively modest memory allocation
		  during the change detection cycle can result in GC pauses for some of the CD cycles).
			  The algorithm works by iterating over the set of bound classes, staring with [class] binding and
		  then going over [ngClass] binding. For each CSS class name:
		  - check if it was seen before (this information is tracked in the state map) and if its value
		  changed;
		  - mark it as "touched" - names that are not marked are not present in the latest set of binding
		  and we can remove such class name from the internal data structures;
			  After iteration over all the CSS class names we've got data structure with all the information
		  necessary to synchronize changes to the DOM - it is enough to iterate over the state map, flush
		  changes to the DOM and reset internal data structures so those are ready for the next change
		  detection cycle.
			*/
		  ngDoCheck() {
			 for (const klass of this.initialClasses) {
				this._updateState(klass, true);
			 }
			 const rawClass = this.rawClass;
			 if (Array.isArray(rawClass) || rawClass instanceof Set) {
				for (const klass of rawClass) {
				  this._updateState(klass, true);
				}
			 } else if (rawClass != null) {
				for (const klass of Object.keys(rawClass)) {
				  this._updateState(klass, Boolean(rawClass[klass]));
				}
			 }
			 this._applyStateDiff();
		  }
		  _updateState(klass, nextEnabled) {
			 const state = this.stateMap.get(klass);
			 if (state !== void 0) {
				if (state.enabled !== nextEnabled) {
				  state.changed = true;
				  state.enabled = nextEnabled;
				}
				state.touched = true;
			 } else {
				this.stateMap.set(klass, {
				  enabled: nextEnabled,
				  changed: true,
				  touched: true
				});
			 }
		  }
		  _applyStateDiff() {
			 for (const stateEntry of this.stateMap) {
				const klass = stateEntry[0];
				const state = stateEntry[1];
				if (state.changed) {
				  this._toggleClass(klass, state.enabled);
				  state.changed = false;
				} else if (!state.touched) {
				  if (state.enabled) {
					 this._toggleClass(klass, false);
				  }
				  this.stateMap.delete(klass);
				}
				state.touched = false;
			 }
		  }
		  _toggleClass(klass, enabled) {
			 if (ngDevMode) {
				if (typeof klass !== "string") {
				  throw new Error(`NgClass can only toggle CSS classes expressed as strings, got ${stringify(klass)}`);
				}
			 }
			 klass = klass.trim();
			 if (klass.length > 0) {
				klass.split(WS_REGEXP).forEach((klass2) => {
				  if (enabled) {
					 this._renderer.addClass(this._ngEl.nativeElement, klass2);
				  } else {
					 this._renderer.removeClass(this._ngEl.nativeElement, klass2);
				  }
				});
			 }
		  }
		  static {
			 this.\u0275fac = function NgClass_Factory(t) {
				return new (t || _NgClass)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2));
			 };
		  }
		  static {
			 this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
				type: _NgClass,
				selectors: [["", "ngClass", ""]],
				inputs: {
				  klass: [InputFlags.None, "class", "klass"],
				  ngClass: "ngClass"
				},
				standalone: true
			 });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgClass, [{
			 type: Directive,
			 args: [{
				selector: "[ngClass]",
				standalone: true
			 }]
		  }], () => [{
			 type: ElementRef
		  }, {
			 type: Renderer2
		  }], {
			 klass: [{
				type: Input,
				args: ["class"]
			 }],
			 ngClass: [{
				type: Input,
				args: ["ngClass"]
			 }]
		  });
		})();
		var NgComponentOutlet = class _NgComponentOutlet {
		  constructor(_viewContainerRef) {
			 this._viewContainerRef = _viewContainerRef;
			 this.ngComponentOutlet = null;
			 this._inputsUsed = /* @__PURE__ */ new Map();
		  }
		  _needToReCreateNgModuleInstance(changes) {
			 return changes["ngComponentOutletNgModule"] !== void 0 || changes["ngComponentOutletNgModuleFactory"] !== void 0;
		  }
		  _needToReCreateComponentInstance(changes) {
			 return changes["ngComponentOutlet"] !== void 0 || changes["ngComponentOutletContent"] !== void 0 || changes["ngComponentOutletInjector"] !== void 0 || this._needToReCreateNgModuleInstance(changes);
		  }
		  /** @nodoc */
		  ngOnChanges(changes) {
			 if (this._needToReCreateComponentInstance(changes)) {
				this._viewContainerRef.clear();
				this._inputsUsed.clear();
				this._componentRef = void 0;
				if (this.ngComponentOutlet) {
				  const injector = this.ngComponentOutletInjector || this._viewContainerRef.parentInjector;
				  if (this._needToReCreateNgModuleInstance(changes)) {
					 this._moduleRef?.destroy();
					 if (this.ngComponentOutletNgModule) {
						this._moduleRef = createNgModule(this.ngComponentOutletNgModule, getParentInjector(injector));
					 } else if (this.ngComponentOutletNgModuleFactory) {
						this._moduleRef = this.ngComponentOutletNgModuleFactory.create(getParentInjector(injector));
					 } else {
						this._moduleRef = void 0;
					 }
				  }
				  this._componentRef = this._viewContainerRef.createComponent(this.ngComponentOutlet, {
					 injector,
					 ngModuleRef: this._moduleRef,
					 projectableNodes: this.ngComponentOutletContent
				  });
				}
			 }
		  }
		  /** @nodoc */
		  ngDoCheck() {
			 if (this._componentRef) {
				if (this.ngComponentOutletInputs) {
				  for (const inputName of Object.keys(this.ngComponentOutletInputs)) {
					 this._inputsUsed.set(inputName, true);
				  }
				}
				this._applyInputStateDiff(this._componentRef);
			 }
		  }
		  /** @nodoc */
		  ngOnDestroy() {
			 this._moduleRef?.destroy();
		  }
		  _applyInputStateDiff(componentRef) {
			 for (const [inputName, touched] of this._inputsUsed) {
				if (!touched) {
				  componentRef.setInput(inputName, void 0);
				  this._inputsUsed.delete(inputName);
				} else {
				  componentRef.setInput(inputName, this.ngComponentOutletInputs[inputName]);
				  this._inputsUsed.set(inputName, false);
				}
			 }
		  }
		  static {
			 this.\u0275fac = function NgComponentOutlet_Factory(t) {
				return new (t || _NgComponentOutlet)(\u0275\u0275directiveInject(ViewContainerRef));
			 };
		  }
		  static {
			 this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
				type: _NgComponentOutlet,
				selectors: [["", "ngComponentOutlet", ""]],
				inputs: {
				  ngComponentOutlet: "ngComponentOutlet",
				  ngComponentOutletInputs: "ngComponentOutletInputs",
				  ngComponentOutletInjector: "ngComponentOutletInjector",
				  ngComponentOutletContent: "ngComponentOutletContent",
				  ngComponentOutletNgModule: "ngComponentOutletNgModule",
				  ngComponentOutletNgModuleFactory: "ngComponentOutletNgModuleFactory"
				},
				standalone: true,
				features: [\u0275\u0275NgOnChangesFeature]
			 });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgComponentOutlet, [{
			 type: Directive,
			 args: [{
				selector: "[ngComponentOutlet]",
				standalone: true
			 }]
		  }], () => [{
			 type: ViewContainerRef
		  }], {
			 ngComponentOutlet: [{
				type: Input
			 }],
			 ngComponentOutletInputs: [{
				type: Input
			 }],
			 ngComponentOutletInjector: [{
				type: Input
			 }],
			 ngComponentOutletContent: [{
				type: Input
			 }],
			 ngComponentOutletNgModule: [{
				type: Input
			 }],
			 ngComponentOutletNgModuleFactory: [{
				type: Input
			 }]
		  });
		})();
		function getParentInjector(injector) {
		  const parentNgModule = injector.get(NgModuleRef$1);
		  return parentNgModule.injector;
		}
		var NgForOfContext = class {
		  constructor($implicit, ngForOf, index, count) {
			 this.$implicit = $implicit;
			 this.ngForOf = ngForOf;
			 this.index = index;
			 this.count = count;
		  }
		  get first() {
			 return this.index === 0;
		  }
		  get last() {
			 return this.index === this.count - 1;
		  }
		  get even() {
			 return this.index % 2 === 0;
		  }
		  get odd() {
			 return !this.even;
		  }
		};
		var NgForOf = class _NgForOf {
		  /**
			* The value of the iterable expression, which can be used as a
			* [template input variable](guide/structural-directives#shorthand).
			*/
		  set ngForOf(ngForOf) {
			 this._ngForOf = ngForOf;
			 this._ngForOfDirty = true;
		  }
		  /**
			* Specifies a custom `TrackByFunction` to compute the identity of items in an iterable.
			*
			* If a custom `TrackByFunction` is not provided, `NgForOf` will use the item's [object
			* identity](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is)
			* as the key.
			*
			* `NgForOf` uses the computed key to associate items in an iterable with DOM elements
			* it produces for these items.
			*
			* A custom `TrackByFunction` is useful to provide good user experience in cases when items in an
			* iterable rendered using `NgForOf` have a natural identifier (for example, custom ID or a
			* primary key), and this iterable could be updated with new object instances that still
			* represent the same underlying entity (for example, when data is re-fetched from the server,
			* and the iterable is recreated and re-rendered, but most of the data is still the same).
			*
			* @see {@link TrackByFunction}
			*/
		  set ngForTrackBy(fn) {
			 if ((typeof ngDevMode === "undefined" || ngDevMode) && fn != null && typeof fn !== "function") {
				console.warn(`trackBy must be a function, but received ${JSON.stringify(fn)}. See https://angular.io/api/common/NgForOf#change-propagation for more information.`);
			 }
			 this._trackByFn = fn;
		  }
		  get ngForTrackBy() {
			 return this._trackByFn;
		  }
		  constructor(_viewContainer, _template, _differs) {
			 this._viewContainer = _viewContainer;
			 this._template = _template;
			 this._differs = _differs;
			 this._ngForOf = null;
			 this._ngForOfDirty = true;
			 this._differ = null;
		  }
		  /**
			* A reference to the template that is stamped out for each item in the iterable.
			* @see [template reference variable](guide/template-reference-variables)
			*/
		  set ngForTemplate(value) {
			 if (value) {
				this._template = value;
			 }
		  }
		  /**
			* Applies the changes when needed.
			* @nodoc
			*/
		  ngDoCheck() {
			 if (this._ngForOfDirty) {
				this._ngForOfDirty = false;
				const value = this._ngForOf;
				if (!this._differ && value) {
				  if (typeof ngDevMode === "undefined" || ngDevMode) {
					 try {
						this._differ = this._differs.find(value).create(this.ngForTrackBy);
					 } catch {
						let errorMessage = `Cannot find a differ supporting object '${value}' of type '${getTypeName(value)}'. NgFor only supports binding to Iterables, such as Arrays.`;
						if (typeof value === "object") {
						  errorMessage += " Did you mean to use the keyvalue pipe?";
						}
						throw new RuntimeError(-2200, errorMessage);
					 }
				  } else {
					 this._differ = this._differs.find(value).create(this.ngForTrackBy);
				  }
				}
			 }
			 if (this._differ) {
				const changes = this._differ.diff(this._ngForOf);
				if (changes)
				  this._applyChanges(changes);
			 }
		  }
		  _applyChanges(changes) {
			 const viewContainer = this._viewContainer;
			 changes.forEachOperation((item, adjustedPreviousIndex, currentIndex) => {
				if (item.previousIndex == null) {
				  viewContainer.createEmbeddedView(this._template, new NgForOfContext(item.item, this._ngForOf, -1, -1), currentIndex === null ? void 0 : currentIndex);
				} else if (currentIndex == null) {
				  viewContainer.remove(adjustedPreviousIndex === null ? void 0 : adjustedPreviousIndex);
				} else if (adjustedPreviousIndex !== null) {
				  const view = viewContainer.get(adjustedPreviousIndex);
				  viewContainer.move(view, currentIndex);
				  applyViewChange(view, item);
				}
			 });
			 for (let i = 0, ilen = viewContainer.length; i < ilen; i++) {
				const viewRef = viewContainer.get(i);
				const context2 = viewRef.context;
				context2.index = i;
				context2.count = ilen;
				context2.ngForOf = this._ngForOf;
			 }
			 changes.forEachIdentityChange((record) => {
				const viewRef = viewContainer.get(record.currentIndex);
				applyViewChange(viewRef, record);
			 });
		  }
		  /**
			* Asserts the correct type of the context for the template that `NgForOf` will render.
			*
			* The presence of this method is a signal to the Ivy template type-check compiler that the
			* `NgForOf` structural directive renders its template with a specific context type.
			*/
		  static ngTemplateContextGuard(dir, ctx) {
			 return true;
		  }
		  static {
			 this.\u0275fac = function NgForOf_Factory(t) {
				return new (t || _NgForOf)(\u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(TemplateRef), \u0275\u0275directiveInject(IterableDiffers));
			 };
		  }
		  static {
			 this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
				type: _NgForOf,
				selectors: [["", "ngFor", "", "ngForOf", ""]],
				inputs: {
				  ngForOf: "ngForOf",
				  ngForTrackBy: "ngForTrackBy",
				  ngForTemplate: "ngForTemplate"
				},
				standalone: true
			 });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgForOf, [{
			 type: Directive,
			 args: [{
				selector: "[ngFor][ngForOf]",
				standalone: true
			 }]
		  }], () => [{
			 type: ViewContainerRef
		  }, {
			 type: TemplateRef
		  }, {
			 type: IterableDiffers
		  }], {
			 ngForOf: [{
				type: Input
			 }],
			 ngForTrackBy: [{
				type: Input
			 }],
			 ngForTemplate: [{
				type: Input
			 }]
		  });
		})();
		function applyViewChange(view, record) {
		  view.context.$implicit = record.item;
		}
		function getTypeName(type2) {
		  return type2["name"] || typeof type2;
		}
		var NgIf = class _NgIf {
		  constructor(_viewContainer, templateRef) {
			 this._viewContainer = _viewContainer;
			 this._context = new NgIfContext();
			 this._thenTemplateRef = null;
			 this._elseTemplateRef = null;
			 this._thenViewRef = null;
			 this._elseViewRef = null;
			 this._thenTemplateRef = templateRef;
		  }
		  /**
			* The Boolean expression to evaluate as the condition for showing a template.
			*/
		  set ngIf(condition) {
			 this._context.$implicit = this._context.ngIf = condition;
			 this._updateView();
		  }
		  /**
			* A template to show if the condition expression evaluates to true.
			*/
		  set ngIfThen(templateRef) {
			 assertTemplate("ngIfThen", templateRef);
			 this._thenTemplateRef = templateRef;
			 this._thenViewRef = null;
			 this._updateView();
		  }
		  /**
			* A template to show if the condition expression evaluates to false.
			*/
		  set ngIfElse(templateRef) {
			 assertTemplate("ngIfElse", templateRef);
			 this._elseTemplateRef = templateRef;
			 this._elseViewRef = null;
			 this._updateView();
		  }
		  _updateView() {
			 if (this._context.$implicit) {
				if (!this._thenViewRef) {
				  this._viewContainer.clear();
				  this._elseViewRef = null;
				  if (this._thenTemplateRef) {
					 this._thenViewRef = this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context);
				  }
				}
			 } else {
				if (!this._elseViewRef) {
				  this._viewContainer.clear();
				  this._thenViewRef = null;
				  if (this._elseTemplateRef) {
					 this._elseViewRef = this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context);
				  }
				}
			 }
		  }
		  /**
			* Asserts the correct type of the context for the template that `NgIf` will render.
			*
			* The presence of this method is a signal to the Ivy template type-check compiler that the
			* `NgIf` structural directive renders its template with a specific context type.
			*/
		  static ngTemplateContextGuard(dir, ctx) {
			 return true;
		  }
		  static {
			 this.\u0275fac = function NgIf_Factory(t) {
				return new (t || _NgIf)(\u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(TemplateRef));
			 };
		  }
		  static {
			 this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
				type: _NgIf,
				selectors: [["", "ngIf", ""]],
				inputs: {
				  ngIf: "ngIf",
				  ngIfThen: "ngIfThen",
				  ngIfElse: "ngIfElse"
				},
				standalone: true
			 });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgIf, [{
			 type: Directive,
			 args: [{
				selector: "[ngIf]",
				standalone: true
			 }]
		  }], () => [{
			 type: ViewContainerRef
		  }, {
			 type: TemplateRef
		  }], {
			 ngIf: [{
				type: Input
			 }],
			 ngIfThen: [{
				type: Input
			 }],
			 ngIfElse: [{
				type: Input
			 }]
		  });
		})();
		var NgIfContext = class {
		  constructor() {
			 this.$implicit = null;
			 this.ngIf = null;
		  }
		};
		function assertTemplate(property, templateRef) {
		  const isTemplateRefOrNull = !!(!templateRef || templateRef.createEmbeddedView);
		  if (!isTemplateRefOrNull) {
			 throw new Error(`${property} must be a TemplateRef, but received '${stringify(templateRef)}'.`);
		  }
		}
		var NG_SWITCH_USE_STRICT_EQUALS = true;
		var SwitchView = class {
		  constructor(_viewContainerRef, _templateRef) {
			 this._viewContainerRef = _viewContainerRef;
			 this._templateRef = _templateRef;
			 this._created = false;
		  }
		  create() {
			 this._created = true;
			 this._viewContainerRef.createEmbeddedView(this._templateRef);
		  }
		  destroy() {
			 this._created = false;
			 this._viewContainerRef.clear();
		  }
		  enforceState(created) {
			 if (created && !this._created) {
				this.create();
			 } else if (!created && this._created) {
				this.destroy();
			 }
		  }
		};
		var NgSwitch = class _NgSwitch {
		  constructor() {
			 this._defaultViews = [];
			 this._defaultUsed = false;
			 this._caseCount = 0;
			 this._lastCaseCheckIndex = 0;
			 this._lastCasesMatched = false;
		  }
		  set ngSwitch(newValue) {
			 this._ngSwitch = newValue;
			 if (this._caseCount === 0) {
				this._updateDefaultCases(true);
			 }
		  }
		  /** @internal */
		  _addCase() {
			 return this._caseCount++;
		  }
		  /** @internal */
		  _addDefault(view) {
			 this._defaultViews.push(view);
		  }
		  /** @internal */
		  _matchCase(value) {
			 const matched = NG_SWITCH_USE_STRICT_EQUALS ? value === this._ngSwitch : value == this._ngSwitch;
			 if ((typeof ngDevMode === "undefined" || ngDevMode) && matched !== (value == this._ngSwitch)) {
				console.warn(formatRuntimeError(2001, `As of Angular v17 the NgSwitch directive uses strict equality comparison === instead of == to match different cases. Previously the case value "${stringifyValue(value)}" matched switch expression value "${stringifyValue(this._ngSwitch)}", but this is no longer the case with the stricter equality check. Your comparison results return different results using === vs. == and you should adjust your ngSwitch expression and / or values to conform with the strict equality requirements.`));
			 }
			 this._lastCasesMatched ||= matched;
			 this._lastCaseCheckIndex++;
			 if (this._lastCaseCheckIndex === this._caseCount) {
				this._updateDefaultCases(!this._lastCasesMatched);
				this._lastCaseCheckIndex = 0;
				this._lastCasesMatched = false;
			 }
			 return matched;
		  }
		  _updateDefaultCases(useDefault) {
			 if (this._defaultViews.length > 0 && useDefault !== this._defaultUsed) {
				this._defaultUsed = useDefault;
				for (const defaultView of this._defaultViews) {
				  defaultView.enforceState(useDefault);
				}
			 }
		  }
		  static {
			 this.\u0275fac = function NgSwitch_Factory(t) {
				return new (t || _NgSwitch)();
			 };
		  }
		  static {
			 this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
				type: _NgSwitch,
				selectors: [["", "ngSwitch", ""]],
				inputs: {
				  ngSwitch: "ngSwitch"
				},
				standalone: true
			 });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgSwitch, [{
			 type: Directive,
			 args: [{
				selector: "[ngSwitch]",
				standalone: true
			 }]
		  }], null, {
			 ngSwitch: [{
				type: Input
			 }]
		  });
		})();
		var NgSwitchCase = class _NgSwitchCase {
		  constructor(viewContainer, templateRef, ngSwitch) {
			 this.ngSwitch = ngSwitch;
			 if ((typeof ngDevMode === "undefined" || ngDevMode) && !ngSwitch) {
				throwNgSwitchProviderNotFoundError("ngSwitchCase", "NgSwitchCase");
			 }
			 ngSwitch._addCase();
			 this._view = new SwitchView(viewContainer, templateRef);
		  }
		  /**
			* Performs case matching. For internal use only.
			* @nodoc
			*/
		  ngDoCheck() {
			 this._view.enforceState(this.ngSwitch._matchCase(this.ngSwitchCase));
		  }
		  static {
			 this.\u0275fac = function NgSwitchCase_Factory(t) {
				return new (t || _NgSwitchCase)(\u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(TemplateRef), \u0275\u0275directiveInject(NgSwitch, 9));
			 };
		  }
		  static {
			 this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
				type: _NgSwitchCase,
				selectors: [["", "ngSwitchCase", ""]],
				inputs: {
				  ngSwitchCase: "ngSwitchCase"
				},
				standalone: true
			 });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgSwitchCase, [{
			 type: Directive,
			 args: [{
				selector: "[ngSwitchCase]",
				standalone: true
			 }]
		  }], () => [{
			 type: ViewContainerRef
		  }, {
			 type: TemplateRef
		  }, {
			 type: NgSwitch,
			 decorators: [{
				type: Optional
			 }, {
				type: Host
			 }]
		  }], {
			 ngSwitchCase: [{
				type: Input
			 }]
		  });
		})();
		var NgSwitchDefault = class _NgSwitchDefault {
		  constructor(viewContainer, templateRef, ngSwitch) {
			 if ((typeof ngDevMode === "undefined" || ngDevMode) && !ngSwitch) {
				throwNgSwitchProviderNotFoundError("ngSwitchDefault", "NgSwitchDefault");
			 }
			 ngSwitch._addDefault(new SwitchView(viewContainer, templateRef));
		  }
		  static {
			 this.\u0275fac = function NgSwitchDefault_Factory(t) {
				return new (t || _NgSwitchDefault)(\u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(TemplateRef), \u0275\u0275directiveInject(NgSwitch, 9));
			 };
		  }
		  static {
			 this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
				type: _NgSwitchDefault,
				selectors: [["", "ngSwitchDefault", ""]],
				standalone: true
			 });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgSwitchDefault, [{
			 type: Directive,
			 args: [{
				selector: "[ngSwitchDefault]",
				standalone: true
			 }]
		  }], () => [{
			 type: ViewContainerRef
		  }, {
			 type: TemplateRef
		  }, {
			 type: NgSwitch,
			 decorators: [{
				type: Optional
			 }, {
				type: Host
			 }]
		  }], null);
		})();
		function throwNgSwitchProviderNotFoundError(attrName, directiveName) {
		  throw new RuntimeError(2e3, `An element with the "${attrName}" attribute (matching the "${directiveName}" directive) must be located inside an element with the "ngSwitch" attribute (matching "NgSwitch" directive)`);
		}
		function stringifyValue(value) {
		  return typeof value === "string" ? `'${value}'` : String(value);
		}
		var NgPlural = class _NgPlural {
		  constructor(_localization) {
			 this._localization = _localization;
			 this._caseViews = {};
		  }
		  set ngPlural(value) {
			 this._updateView(value);
		  }
		  addCase(value, switchView) {
			 this._caseViews[value] = switchView;
		  }
		  _updateView(switchValue) {
			 this._clearViews();
			 const cases = Object.keys(this._caseViews);
			 const key = getPluralCategory(switchValue, cases, this._localization);
			 this._activateView(this._caseViews[key]);
		  }
		  _clearViews() {
			 if (this._activeView)
				this._activeView.destroy();
		  }
		  _activateView(view) {
			 if (view) {
				this._activeView = view;
				this._activeView.create();
			 }
		  }
		  static {
			 this.\u0275fac = function NgPlural_Factory(t) {
				return new (t || _NgPlural)(\u0275\u0275directiveInject(NgLocalization));
			 };
		  }
		  static {
			 this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
				type: _NgPlural,
				selectors: [["", "ngPlural", ""]],
				inputs: {
				  ngPlural: "ngPlural"
				},
				standalone: true
			 });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgPlural, [{
			 type: Directive,
			 args: [{
				selector: "[ngPlural]",
				standalone: true
			 }]
		  }], () => [{
			 type: NgLocalization
		  }], {
			 ngPlural: [{
				type: Input
			 }]
		  });
		})();
		var NgPluralCase = class _NgPluralCase {
		  constructor(value, template, viewContainer, ngPlural) {
			 this.value = value;
			 const isANumber = !isNaN(Number(value));
			 ngPlural.addCase(isANumber ? `=${value}` : value, new SwitchView(viewContainer, template));
		  }
		  static {
			 this.\u0275fac = function NgPluralCase_Factory(t) {
				return new (t || _NgPluralCase)(\u0275\u0275injectAttribute("ngPluralCase"), \u0275\u0275directiveInject(TemplateRef), \u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(NgPlural, 1));
			 };
		  }
		  static {
			 this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
				type: _NgPluralCase,
				selectors: [["", "ngPluralCase", ""]],
				standalone: true
			 });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgPluralCase, [{
			 type: Directive,
			 args: [{
				selector: "[ngPluralCase]",
				standalone: true
			 }]
		  }], () => [{
			 type: void 0,
			 decorators: [{
				type: Attribute,
				args: ["ngPluralCase"]
			 }]
		  }, {
			 type: TemplateRef
		  }, {
			 type: ViewContainerRef
		  }, {
			 type: NgPlural,
			 decorators: [{
				type: Host
			 }]
		  }], null);
		})();
		var NgStyle = class _NgStyle {
		  constructor(_ngEl, _differs, _renderer) {
			 this._ngEl = _ngEl;
			 this._differs = _differs;
			 this._renderer = _renderer;
			 this._ngStyle = null;
			 this._differ = null;
		  }
		  set ngStyle(values) {
			 this._ngStyle = values;
			 if (!this._differ && values) {
				this._differ = this._differs.find(values).create();
			 }
		  }
		  ngDoCheck() {
			 if (this._differ) {
				const changes = this._differ.diff(this._ngStyle);
				if (changes) {
				  this._applyChanges(changes);
				}
			 }
		  }
		  _setStyle(nameAndUnit, value) {
			 const [name, unit2] = nameAndUnit.split(".");
			 const flags = name.indexOf("-") === -1 ? void 0 : RendererStyleFlags2.DashCase;
			 if (value != null) {
				this._renderer.setStyle(this._ngEl.nativeElement, name, unit2 ? `${value}${unit2}` : value, flags);
			 } else {
				this._renderer.removeStyle(this._ngEl.nativeElement, name, flags);
			 }
		  }
		  _applyChanges(changes) {
			 changes.forEachRemovedItem((record) => this._setStyle(record.key, null));
			 changes.forEachAddedItem((record) => this._setStyle(record.key, record.currentValue));
			 changes.forEachChangedItem((record) => this._setStyle(record.key, record.currentValue));
		  }
		  static {
			 this.\u0275fac = function NgStyle_Factory(t) {
				return new (t || _NgStyle)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(KeyValueDiffers), \u0275\u0275directiveInject(Renderer2));
			 };
		  }
		  static {
			 this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
				type: _NgStyle,
				selectors: [["", "ngStyle", ""]],
				inputs: {
				  ngStyle: "ngStyle"
				},
				standalone: true
			 });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgStyle, [{
			 type: Directive,
			 args: [{
				selector: "[ngStyle]",
				standalone: true
			 }]
		  }], () => [{
			 type: ElementRef
		  }, {
			 type: KeyValueDiffers
		  }, {
			 type: Renderer2
		  }], {
			 ngStyle: [{
				type: Input,
				args: ["ngStyle"]
			 }]
		  });
		})();
		var NgTemplateOutlet = class _NgTemplateOutlet {
		  constructor(_viewContainerRef) {
			 this._viewContainerRef = _viewContainerRef;
			 this._viewRef = null;
			 this.ngTemplateOutletContext = null;
			 this.ngTemplateOutlet = null;
			 this.ngTemplateOutletInjector = null;
		  }
		  ngOnChanges(changes) {
			 if (this._shouldRecreateView(changes)) {
				const viewContainerRef = this._viewContainerRef;
				if (this._viewRef) {
				  viewContainerRef.remove(viewContainerRef.indexOf(this._viewRef));
				}
				if (!this.ngTemplateOutlet) {
				  this._viewRef = null;
				  return;
				}
				const viewContext = this._createContextForwardProxy();
				this._viewRef = viewContainerRef.createEmbeddedView(this.ngTemplateOutlet, viewContext, {
				  injector: this.ngTemplateOutletInjector ?? void 0
				});
			 }
		  }
		  /**
			* We need to re-create existing embedded view if either is true:
			* - the outlet changed.
			* - the injector changed.
			*/
		  _shouldRecreateView(changes) {
			 return !!changes["ngTemplateOutlet"] || !!changes["ngTemplateOutletInjector"];
		  }
		  /**
			* For a given outlet instance, we create a proxy object that delegates
			* to the user-specified context. This allows changing, or swapping out
			* the context object completely without having to destroy/re-create the view.
			*/
		  _createContextForwardProxy() {
			 return new Proxy({}, {
				set: (_target, prop, newValue) => {
				  if (!this.ngTemplateOutletContext) {
					 return false;
				  }
				  return Reflect.set(this.ngTemplateOutletContext, prop, newValue);
				},
				get: (_target, prop, receiver) => {
				  if (!this.ngTemplateOutletContext) {
					 return void 0;
				  }
				  return Reflect.get(this.ngTemplateOutletContext, prop, receiver);
				}
			 });
		  }
		  static {
			 this.\u0275fac = function NgTemplateOutlet_Factory(t) {
				return new (t || _NgTemplateOutlet)(\u0275\u0275directiveInject(ViewContainerRef));
			 };
		  }
		  static {
			 this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
				type: _NgTemplateOutlet,
				selectors: [["", "ngTemplateOutlet", ""]],
				inputs: {
				  ngTemplateOutletContext: "ngTemplateOutletContext",
				  ngTemplateOutlet: "ngTemplateOutlet",
				  ngTemplateOutletInjector: "ngTemplateOutletInjector"
				},
				standalone: true,
				features: [\u0275\u0275NgOnChangesFeature]
			 });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgTemplateOutlet, [{
			 type: Directive,
			 args: [{
				selector: "[ngTemplateOutlet]",
				standalone: true
			 }]
		  }], () => [{
			 type: ViewContainerRef
		  }], {
			 ngTemplateOutletContext: [{
				type: Input
			 }],
			 ngTemplateOutlet: [{
				type: Input
			 }],
			 ngTemplateOutletInjector: [{
				type: Input
			 }]
		  });
		})();
		var COMMON_DIRECTIVES = [NgClass, NgComponentOutlet, NgForOf, NgIf, NgTemplateOutlet, NgStyle, NgSwitch, NgSwitchCase, NgSwitchDefault, NgPlural, NgPluralCase];
		function invalidPipeArgumentError(type2, value) {
		  return new RuntimeError(2100, ngDevMode && `InvalidPipeArgument: '${value}' for pipe '${stringify(type2)}'`);
		}
		var SubscribableStrategy = class {
		  createSubscription(async, updateLatestValue) {
			 return untracked(() => async.subscribe({
				next: updateLatestValue,
				error: (e) => {
				  throw e;
				}
			 }));
		  }
		  dispose(subscription) {
			 untracked(() => subscription.unsubscribe());
		  }
		};
		var PromiseStrategy = class {
		  createSubscription(async, updateLatestValue) {
			 return async.then(updateLatestValue, (e) => {
				throw e;
			 });
		  }
		  dispose(subscription) {
		  }
		};
		var _promiseStrategy = new PromiseStrategy();
		var _subscribableStrategy = new SubscribableStrategy();
		var AsyncPipe = class _AsyncPipe {
		  constructor(ref) {
			 this._latestValue = null;
			 this.markForCheckOnValueUpdate = true;
			 this._subscription = null;
			 this._obj = null;
			 this._strategy = null;
			 this._ref = ref;
		  }
		  ngOnDestroy() {
			 if (this._subscription) {
				this._dispose();
			 }
			 this._ref = null;
		  }
		  transform(obj) {
			 if (!this._obj) {
				if (obj) {
				  try {
					 this.markForCheckOnValueUpdate = false;
					 this._subscribe(obj);
				  } finally {
					 this.markForCheckOnValueUpdate = true;
				  }
				}
				return this._latestValue;
			 }
			 if (obj !== this._obj) {
				this._dispose();
				return this.transform(obj);
			 }
			 return this._latestValue;
		  }
		  _subscribe(obj) {
			 this._obj = obj;
			 this._strategy = this._selectStrategy(obj);
			 this._subscription = this._strategy.createSubscription(obj, (value) => this._updateLatestValue(obj, value));
		  }
		  _selectStrategy(obj) {
			 if (isPromise2(obj)) {
				return _promiseStrategy;
			 }
			 if (isSubscribable(obj)) {
				return _subscribableStrategy;
			 }
			 throw invalidPipeArgumentError(_AsyncPipe, obj);
		  }
		  _dispose() {
			 this._strategy.dispose(this._subscription);
			 this._latestValue = null;
			 this._subscription = null;
			 this._obj = null;
		  }
		  _updateLatestValue(async, value) {
			 if (async === this._obj) {
				this._latestValue = value;
				if (this.markForCheckOnValueUpdate) {
				  this._ref?.markForCheck();
				}
			 }
		  }
		  static {
			 this.\u0275fac = function AsyncPipe_Factory(t) {
				return new (t || _AsyncPipe)(\u0275\u0275directiveInject(ChangeDetectorRef, 16));
			 };
		  }
		  static {
			 this.\u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
				name: "async",
				type: _AsyncPipe,
				pure: false,
				standalone: true
			 });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AsyncPipe, [{
			 type: Pipe,
			 args: [{
				name: "async",
				pure: false,
				standalone: true
			 }]
		  }], () => [{
			 type: ChangeDetectorRef
		  }], null);
		})();
		var LowerCasePipe = class _LowerCasePipe {
		  transform(value) {
			 if (value == null)
				return null;
			 if (typeof value !== "string") {
				throw invalidPipeArgumentError(_LowerCasePipe, value);
			 }
			 return value.toLowerCase();
		  }
		  static {
			 this.\u0275fac = function LowerCasePipe_Factory(t) {
				return new (t || _LowerCasePipe)();
			 };
		  }
		  static {
			 this.\u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
				name: "lowercase",
				type: _LowerCasePipe,
				pure: true,
				standalone: true
			 });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LowerCasePipe, [{
			 type: Pipe,
			 args: [{
				name: "lowercase",
				standalone: true
			 }]
		  }], null, null);
		})();
		var unicodeWordMatch = /(?:[0-9A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])\S*/g;
		var TitleCasePipe = class _TitleCasePipe {
		  transform(value) {
			 if (value == null)
				return null;
			 if (typeof value !== "string") {
				throw invalidPipeArgumentError(_TitleCasePipe, value);
			 }
			 return value.replace(unicodeWordMatch, (txt) => txt[0].toUpperCase() + txt.slice(1).toLowerCase());
		  }
		  static {
			 this.\u0275fac = function TitleCasePipe_Factory(t) {
				return new (t || _TitleCasePipe)();
			 };
		  }
		  static {
			 this.\u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
				name: "titlecase",
				type: _TitleCasePipe,
				pure: true,
				standalone: true
			 });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TitleCasePipe, [{
			 type: Pipe,
			 args: [{
				name: "titlecase",
				standalone: true
			 }]
		  }], null, null);
		})();
		var UpperCasePipe = class _UpperCasePipe {
		  transform(value) {
			 if (value == null)
				return null;
			 if (typeof value !== "string") {
				throw invalidPipeArgumentError(_UpperCasePipe, value);
			 }
			 return value.toUpperCase();
		  }
		  static {
			 this.\u0275fac = function UpperCasePipe_Factory(t) {
				return new (t || _UpperCasePipe)();
			 };
		  }
		  static {
			 this.\u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
				name: "uppercase",
				type: _UpperCasePipe,
				pure: true,
				standalone: true
			 });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UpperCasePipe, [{
			 type: Pipe,
			 args: [{
				name: "uppercase",
				standalone: true
			 }]
		  }], null, null);
		})();
		var DEFAULT_DATE_FORMAT = "mediumDate";
		var DATE_PIPE_DEFAULT_TIMEZONE = new InjectionToken(ngDevMode ? "DATE_PIPE_DEFAULT_TIMEZONE" : "");
		var DATE_PIPE_DEFAULT_OPTIONS = new InjectionToken(ngDevMode ? "DATE_PIPE_DEFAULT_OPTIONS" : "");
		var DatePipe = class _DatePipe {
		  constructor(locale2, defaultTimezone, defaultOptions2) {
			 this.locale = locale2;
			 this.defaultTimezone = defaultTimezone;
			 this.defaultOptions = defaultOptions2;
		  }
		  transform(value, format2, timezone, locale2) {
			 if (value == null || value === "" || value !== value)
				return null;
			 try {
				const _format = format2 ?? this.defaultOptions?.dateFormat ?? DEFAULT_DATE_FORMAT;
				const _timezone = timezone ?? this.defaultOptions?.timezone ?? this.defaultTimezone ?? void 0;
				return formatDate(value, _format, locale2 || this.locale, _timezone);
			 } catch (error) {
				throw invalidPipeArgumentError(_DatePipe, error.message);
			 }
		  }
		  static {
			 this.\u0275fac = function DatePipe_Factory(t) {
				return new (t || _DatePipe)(\u0275\u0275directiveInject(LOCALE_ID, 16), \u0275\u0275directiveInject(DATE_PIPE_DEFAULT_TIMEZONE, 24), \u0275\u0275directiveInject(DATE_PIPE_DEFAULT_OPTIONS, 24));
			 };
		  }
		  static {
			 this.\u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
				name: "date",
				type: _DatePipe,
				pure: true,
				standalone: true
			 });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatePipe, [{
			 type: Pipe,
			 args: [{
				name: "date",
				standalone: true
			 }]
		  }], () => [{
			 type: void 0,
			 decorators: [{
				type: Inject,
				args: [LOCALE_ID]
			 }]
		  }, {
			 type: void 0,
			 decorators: [{
				type: Inject,
				args: [DATE_PIPE_DEFAULT_TIMEZONE]
			 }, {
				type: Optional
			 }]
		  }, {
			 type: void 0,
			 decorators: [{
				type: Inject,
				args: [DATE_PIPE_DEFAULT_OPTIONS]
			 }, {
				type: Optional
			 }]
		  }], null);
		})();
		var _INTERPOLATION_REGEXP = /#/g;
		var I18nPluralPipe = class _I18nPluralPipe {
		  constructor(_localization) {
			 this._localization = _localization;
		  }
		  /**
			* @param value the number to be formatted
			* @param pluralMap an object that mimics the ICU format, see
			* https://unicode-org.github.io/icu/userguide/format_parse/messages/.
			* @param locale a `string` defining the locale to use (uses the current {@link LOCALE_ID} by
			* default).
			*/
		  transform(value, pluralMap, locale2) {
			 if (value == null)
				return "";
			 if (typeof pluralMap !== "object" || pluralMap === null) {
				throw invalidPipeArgumentError(_I18nPluralPipe, pluralMap);
			 }
			 const key = getPluralCategory(value, Object.keys(pluralMap), this._localization, locale2);
			 return pluralMap[key].replace(_INTERPOLATION_REGEXP, value.toString());
		  }
		  static {
			 this.\u0275fac = function I18nPluralPipe_Factory(t) {
				return new (t || _I18nPluralPipe)(\u0275\u0275directiveInject(NgLocalization, 16));
			 };
		  }
		  static {
			 this.\u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
				name: "i18nPlural",
				type: _I18nPluralPipe,
				pure: true,
				standalone: true
			 });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(I18nPluralPipe, [{
			 type: Pipe,
			 args: [{
				name: "i18nPlural",
				standalone: true
			 }]
		  }], () => [{
			 type: NgLocalization
		  }], null);
		})();
		var I18nSelectPipe = class _I18nSelectPipe {
		  /**
			* @param value a string to be internationalized.
			* @param mapping an object that indicates the text that should be displayed
			* for different values of the provided `value`.
			*/
		  transform(value, mapping) {
			 if (value == null)
				return "";
			 if (typeof mapping !== "object" || typeof value !== "string") {
				throw invalidPipeArgumentError(_I18nSelectPipe, mapping);
			 }
			 if (mapping.hasOwnProperty(value)) {
				return mapping[value];
			 }
			 if (mapping.hasOwnProperty("other")) {
				return mapping["other"];
			 }
			 return "";
		  }
		  static {
			 this.\u0275fac = function I18nSelectPipe_Factory(t) {
				return new (t || _I18nSelectPipe)();
			 };
		  }
		  static {
			 this.\u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
				name: "i18nSelect",
				type: _I18nSelectPipe,
				pure: true,
				standalone: true
			 });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(I18nSelectPipe, [{
			 type: Pipe,
			 args: [{
				name: "i18nSelect",
				standalone: true
			 }]
		  }], null, null);
		})();
		var JsonPipe = class _JsonPipe {
		  /**
			* @param value A value of any type to convert into a JSON-format string.
			*/
		  transform(value) {
			 return JSON.stringify(value, null, 2);
		  }
		  static {
			 this.\u0275fac = function JsonPipe_Factory(t) {
				return new (t || _JsonPipe)();
			 };
		  }
		  static {
			 this.\u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
				name: "json",
				type: _JsonPipe,
				pure: false,
				standalone: true
			 });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(JsonPipe, [{
			 type: Pipe,
			 args: [{
				name: "json",
				pure: false,
				standalone: true
			 }]
		  }], null, null);
		})();
		function makeKeyValuePair(key, value) {
		  return {
			 key,
			 value
		  };
		}
		var KeyValuePipe = class _KeyValuePipe {
		  constructor(differs) {
			 this.differs = differs;
			 this.keyValues = [];
			 this.compareFn = defaultComparator;
		  }
		  transform(input2, compareFn = defaultComparator) {
			 if (!input2 || !(input2 instanceof Map) && typeof input2 !== "object") {
				return null;
			 }
			 this.differ ??= this.differs.find(input2).create();
			 const differChanges = this.differ.diff(input2);
			 const compareFnChanged = compareFn !== this.compareFn;
			 if (differChanges) {
				this.keyValues = [];
				differChanges.forEachItem((r) => {
				  this.keyValues.push(makeKeyValuePair(r.key, r.currentValue));
				});
			 }
			 if (differChanges || compareFnChanged) {
				this.keyValues.sort(compareFn);
				this.compareFn = compareFn;
			 }
			 return this.keyValues;
		  }
		  static {
			 this.\u0275fac = function KeyValuePipe_Factory(t) {
				return new (t || _KeyValuePipe)(\u0275\u0275directiveInject(KeyValueDiffers, 16));
			 };
		  }
		  static {
			 this.\u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
				name: "keyvalue",
				type: _KeyValuePipe,
				pure: false,
				standalone: true
			 });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(KeyValuePipe, [{
			 type: Pipe,
			 args: [{
				name: "keyvalue",
				pure: false,
				standalone: true
			 }]
		  }], () => [{
			 type: KeyValueDiffers
		  }], null);
		})();
		function defaultComparator(keyValueA, keyValueB) {
		  const a = keyValueA.key;
		  const b = keyValueB.key;
		  if (a === b)
			 return 0;
		  if (a === void 0)
			 return 1;
		  if (b === void 0)
			 return -1;
		  if (a === null)
			 return 1;
		  if (b === null)
			 return -1;
		  if (typeof a == "string" && typeof b == "string") {
			 return a < b ? -1 : 1;
		  }
		  if (typeof a == "number" && typeof b == "number") {
			 return a - b;
		  }
		  if (typeof a == "boolean" && typeof b == "boolean") {
			 return a < b ? -1 : 1;
		  }
		  const aString = String(a);
		  const bString = String(b);
		  return aString == bString ? 0 : aString < bString ? -1 : 1;
		}
		var DecimalPipe = class _DecimalPipe {
		  constructor(_locale) {
			 this._locale = _locale;
		  }
		  /**
			* @param value The value to be formatted.
			* @param digitsInfo Sets digit and decimal representation.
			* [See more](#digitsinfo).
			* @param locale Specifies what locale format rules to use.
			* [See more](#locale).
			*/
		  transform(value, digitsInfo, locale2) {
			 if (!isValue(value))
				return null;
			 locale2 ||= this._locale;
			 try {
				const num = strToNumber(value);
				return formatNumber(num, locale2, digitsInfo);
			 } catch (error) {
				throw invalidPipeArgumentError(_DecimalPipe, error.message);
			 }
		  }
		  static {
			 this.\u0275fac = function DecimalPipe_Factory(t) {
				return new (t || _DecimalPipe)(\u0275\u0275directiveInject(LOCALE_ID, 16));
			 };
		  }
		  static {
			 this.\u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
				name: "number",
				type: _DecimalPipe,
				pure: true,
				standalone: true
			 });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DecimalPipe, [{
			 type: Pipe,
			 args: [{
				name: "number",
				standalone: true
			 }]
		  }], () => [{
			 type: void 0,
			 decorators: [{
				type: Inject,
				args: [LOCALE_ID]
			 }]
		  }], null);
		})();
		var PercentPipe = class _PercentPipe {
		  constructor(_locale) {
			 this._locale = _locale;
		  }
		  /**
			*
			* @param value The number to be formatted as a percentage.
			* @param digitsInfo Decimal representation options, specified by a string
			* in the following format:<br>
			* <code>{minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}</code>.
			*   - `minIntegerDigits`: The minimum number of integer digits before the decimal point.
			* Default is `1`.
			*   - `minFractionDigits`: The minimum number of digits after the decimal point.
			* Default is `0`.
			*   - `maxFractionDigits`: The maximum number of digits after the decimal point.
			* Default is `0`.
			* @param locale A locale code for the locale format rules to use.
			* When not supplied, uses the value of `LOCALE_ID`, which is `en-US` by default.
			* See [Setting your app locale](guide/i18n-common-locale-id).
			*/
		  transform(value, digitsInfo, locale2) {
			 if (!isValue(value))
				return null;
			 locale2 ||= this._locale;
			 try {
				const num = strToNumber(value);
				return formatPercent(num, locale2, digitsInfo);
			 } catch (error) {
				throw invalidPipeArgumentError(_PercentPipe, error.message);
			 }
		  }
		  static {
			 this.\u0275fac = function PercentPipe_Factory(t) {
				return new (t || _PercentPipe)(\u0275\u0275directiveInject(LOCALE_ID, 16));
			 };
		  }
		  static {
			 this.\u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
				name: "percent",
				type: _PercentPipe,
				pure: true,
				standalone: true
			 });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PercentPipe, [{
			 type: Pipe,
			 args: [{
				name: "percent",
				standalone: true
			 }]
		  }], () => [{
			 type: void 0,
			 decorators: [{
				type: Inject,
				args: [LOCALE_ID]
			 }]
		  }], null);
		})();
		var CurrencyPipe = class _CurrencyPipe {
		  constructor(_locale, _defaultCurrencyCode = "USD") {
			 this._locale = _locale;
			 this._defaultCurrencyCode = _defaultCurrencyCode;
		  }
		  /**
			*
			* @param value The number to be formatted as currency.
			* @param currencyCode The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code,
			* such as `USD` for the US dollar and `EUR` for the euro. The default currency code can be
			* configured using the `DEFAULT_CURRENCY_CODE` injection token.
			* @param display The format for the currency indicator. One of the following:
			*   - `code`: Show the code (such as `USD`).
			*   - `symbol`(default): Show the symbol (such as `$`).
			*   - `symbol-narrow`: Use the narrow symbol for locales that have two symbols for their
			* currency.
			* For example, the Canadian dollar CAD has the symbol `CA$` and the symbol-narrow `$`. If the
			* locale has no narrow symbol, uses the standard symbol for the locale.
			*   - String: Use the given string value instead of a code or a symbol.
			* For example, an empty string will suppress the currency & symbol.
			*   - Boolean (marked deprecated in v5): `true` for symbol and false for `code`.
			*
			* @param digitsInfo Decimal representation options, specified by a string
			* in the following format:<br>
			* <code>{minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}</code>.
			*   - `minIntegerDigits`: The minimum number of integer digits before the decimal point.
			* Default is `1`.
			*   - `minFractionDigits`: The minimum number of digits after the decimal point.
			* Default is `2`.
			*   - `maxFractionDigits`: The maximum number of digits after the decimal point.
			* Default is `2`.
			* If not provided, the number will be formatted with the proper amount of digits,
			* depending on what the [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) specifies.
			* For example, the Canadian dollar has 2 digits, whereas the Chilean peso has none.
			* @param locale A locale code for the locale format rules to use.
			* When not supplied, uses the value of `LOCALE_ID`, which is `en-US` by default.
			* See [Setting your app locale](guide/i18n-common-locale-id).
			*/
		  transform(value, currencyCode = this._defaultCurrencyCode, display = "symbol", digitsInfo, locale2) {
			 if (!isValue(value))
				return null;
			 locale2 ||= this._locale;
			 if (typeof display === "boolean") {
				if ((typeof ngDevMode === "undefined" || ngDevMode) && console && console.warn) {
				  console.warn(`Warning: the currency pipe has been changed in Angular v5. The symbolDisplay option (third parameter) is now a string instead of a boolean. The accepted values are "code", "symbol" or "symbol-narrow".`);
				}
				display = display ? "symbol" : "code";
			 }
			 let currency = currencyCode || this._defaultCurrencyCode;
			 if (display !== "code") {
				if (display === "symbol" || display === "symbol-narrow") {
				  currency = getCurrencySymbol(currency, display === "symbol" ? "wide" : "narrow", locale2);
				} else {
				  currency = display;
				}
			 }
			 try {
				const num = strToNumber(value);
				return formatCurrency(num, locale2, currency, currencyCode, digitsInfo);
			 } catch (error) {
				throw invalidPipeArgumentError(_CurrencyPipe, error.message);
			 }
		  }
		  static {
			 this.\u0275fac = function CurrencyPipe_Factory(t) {
				return new (t || _CurrencyPipe)(\u0275\u0275directiveInject(LOCALE_ID, 16), \u0275\u0275directiveInject(DEFAULT_CURRENCY_CODE, 16));
			 };
		  }
		  static {
			 this.\u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
				name: "currency",
				type: _CurrencyPipe,
				pure: true,
				standalone: true
			 });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CurrencyPipe, [{
			 type: Pipe,
			 args: [{
				name: "currency",
				standalone: true
			 }]
		  }], () => [{
			 type: void 0,
			 decorators: [{
				type: Inject,
				args: [LOCALE_ID]
			 }]
		  }, {
			 type: void 0,
			 decorators: [{
				type: Inject,
				args: [DEFAULT_CURRENCY_CODE]
			 }]
		  }], null);
		})();
		function isValue(value) {
		  return !(value == null || value === "" || value !== value);
		}
		function strToNumber(value) {
		  if (typeof value === "string" && !isNaN(Number(value) - parseFloat(value))) {
			 return Number(value);
		  }
		  if (typeof value !== "number") {
			 throw new Error(`${value} is not a number`);
		  }
		  return value;
		}
		var SlicePipe = class _SlicePipe {
		  transform(value, start2, end) {
			 if (value == null)
				return null;
			 if (!this.supports(value)) {
				throw invalidPipeArgumentError(_SlicePipe, value);
			 }
			 return value.slice(start2, end);
		  }
		  supports(obj) {
			 return typeof obj === "string" || Array.isArray(obj);
		  }
		  static {
			 this.\u0275fac = function SlicePipe_Factory(t) {
				return new (t || _SlicePipe)();
			 };
		  }
		  static {
			 this.\u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
				name: "slice",
				type: _SlicePipe,
				pure: false,
				standalone: true
			 });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SlicePipe, [{
			 type: Pipe,
			 args: [{
				name: "slice",
				pure: false,
				standalone: true
			 }]
		  }], null, null);
		})();
		var COMMON_PIPES = [AsyncPipe, UpperCasePipe, LowerCasePipe, JsonPipe, SlicePipe, DecimalPipe, PercentPipe, TitleCasePipe, CurrencyPipe, DatePipe, I18nPluralPipe, I18nSelectPipe, KeyValuePipe];
		var CommonModule = class _CommonModule {
		  static {
			 this.\u0275fac = function CommonModule_Factory(t) {
				return new (t || _CommonModule)();
			 };
		  }
		  static {
			 this.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
				type: _CommonModule
			 });
		  }
		  static {
			 this.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CommonModule, [{
			 type: NgModule,
			 args: [{
				imports: [COMMON_DIRECTIVES, COMMON_PIPES],
				exports: [COMMON_DIRECTIVES, COMMON_PIPES]
			 }]
		  }], null, null);
		})();
		var PLATFORM_BROWSER_ID = "browser";
		var PLATFORM_SERVER_ID = "server";
		function isPlatformBrowser2(platformId) {
		  return platformId === PLATFORM_BROWSER_ID;
		}
		function isPlatformServer(platformId) {
		  return platformId === PLATFORM_SERVER_ID;
		}
		var VERSION3 = new Version("17.3.12");
		var ViewportScroller = class _ViewportScroller {
		  static {
			 this.\u0275prov = \u0275\u0275defineInjectable({
				token: _ViewportScroller,
				providedIn: "root",
				factory: () => isPlatformBrowser2(inject(PLATFORM_ID)) ? new BrowserViewportScroller(inject(DOCUMENT2), window) : new NullViewportScroller()
			 });
		  }
		};
		var BrowserViewportScroller = class {
		  constructor(document2, window2) {
			 this.document = document2;
			 this.window = window2;
			 this.offset = () => [0, 0];
		  }
		  /**
			* Configures the top offset used when scrolling to an anchor.
			* @param offset A position in screen coordinates (a tuple with x and y values)
			* or a function that returns the top offset position.
			*
			*/
		  setOffset(offset) {
			 if (Array.isArray(offset)) {
				this.offset = () => offset;
			 } else {
				this.offset = offset;
			 }
		  }
		  /**
			* Retrieves the current scroll position.
			* @returns The position in screen coordinates.
			*/
		  getScrollPosition() {
			 return [this.window.scrollX, this.window.scrollY];
		  }
		  /**
			* Sets the scroll position.
			* @param position The new position in screen coordinates.
			*/
		  scrollToPosition(position) {
			 this.window.scrollTo(position[0], position[1]);
		  }
		  /**
			* Scrolls to an element and attempts to focus the element.
			*
			* Note that the function name here is misleading in that the target string may be an ID for a
			* non-anchor element.
			*
			* @param target The ID of an element or name of the anchor.
			*
			* @see https://html.spec.whatwg.org/#the-indicated-part-of-the-document
			* @see https://html.spec.whatwg.org/#scroll-to-fragid
			*/
		  scrollToAnchor(target) {
			 const elSelected = findAnchorFromDocument(this.document, target);
			 if (elSelected) {
				this.scrollToElement(elSelected);
				elSelected.focus();
			 }
		  }
		  /**
			* Disables automatic scroll restoration provided by the browser.
			*/
		  setHistoryScrollRestoration(scrollRestoration) {
			 this.window.history.scrollRestoration = scrollRestoration;
		  }
		  /**
			* Scrolls to an element using the native offset and the specified offset set on this scroller.
			*
			* The offset can be used when we know that there is a floating header and scrolling naively to an
			* element (ex: `scrollIntoView`) leaves the element hidden behind the floating header.
			*/
		  scrollToElement(el) {
			 const rect = el.getBoundingClientRect();
			 const left2 = rect.left + this.window.pageXOffset;
			 const top2 = rect.top + this.window.pageYOffset;
			 const offset = this.offset();
			 this.window.scrollTo(left2 - offset[0], top2 - offset[1]);
		  }
		};
		function findAnchorFromDocument(document2, target) {
		  const documentResult = document2.getElementById(target) || document2.getElementsByName(target)[0];
		  if (documentResult) {
			 return documentResult;
		  }
		  if (typeof document2.createTreeWalker === "function" && document2.body && typeof document2.body.attachShadow === "function") {
			 const treeWalker = document2.createTreeWalker(document2.body, NodeFilter.SHOW_ELEMENT);
			 let currentNode = treeWalker.currentNode;
			 while (currentNode) {
				const shadowRoot = currentNode.shadowRoot;
				if (shadowRoot) {
				  const result = shadowRoot.getElementById(target) || shadowRoot.querySelector(`[name="${target}"]`);
				  if (result) {
					 return result;
				  }
				}
				currentNode = treeWalker.nextNode();
			 }
		  }
		  return null;
		}
		var NullViewportScroller = class {
		  /**
			* Empty implementation
			*/
		  setOffset(offset) {
		  }
		  /**
			* Empty implementation
			*/
		  getScrollPosition() {
			 return [0, 0];
		  }
		  /**
			* Empty implementation
			*/
		  scrollToPosition(position) {
		  }
		  /**
			* Empty implementation
			*/
		  scrollToAnchor(anchor) {
		  }
		  /**
			* Empty implementation
			*/
		  setHistoryScrollRestoration(scrollRestoration) {
		  }
		};
		var XhrFactory = class {
		};
		var PLACEHOLDER_QUALITY = "20";
		function getUrl(src, win) {
		  return isAbsoluteUrl(src) ? new URL(src) : new URL(src, win.location.href);
		}
		function isAbsoluteUrl(src) {
		  return /^https?:\/\//.test(src);
		}
		function extractHostname(url) {
		  return isAbsoluteUrl(url) ? new URL(url).hostname : url;
		}
		function isValidPath(path) {
		  const isString2 = typeof path === "string";
		  if (!isString2 || path.trim() === "") {
			 return false;
		  }
		  try {
			 const url = new URL(path);
			 return true;
		  } catch {
			 return false;
		  }
		}
		function normalizePath(path) {
		  return path.endsWith("/") ? path.slice(0, -1) : path;
		}
		function normalizeSrc(src) {
		  return src.startsWith("/") ? src.slice(1) : src;
		}
		var noopImageLoader = (config2) => config2.src;
		var IMAGE_LOADER = new InjectionToken(ngDevMode ? "ImageLoader" : "", {
		  providedIn: "root",
		  factory: () => noopImageLoader
		});
		function createImageLoader(buildUrlFn, exampleUrls) {
		  return function provideImageLoader(path) {
			 if (!isValidPath(path)) {
				throwInvalidPathError(path, exampleUrls || []);
			 }
			 path = normalizePath(path);
			 const loaderFn = (config2) => {
				if (isAbsoluteUrl(config2.src)) {
				  throwUnexpectedAbsoluteUrlError(path, config2.src);
				}
				return buildUrlFn(path, __spreadProps(__spreadValues({}, config2), {
				  src: normalizeSrc(config2.src)
				}));
			 };
			 const providers = [{
				provide: IMAGE_LOADER,
				useValue: loaderFn
			 }];
			 return providers;
		  };
		}
		function throwInvalidPathError(path, exampleUrls) {
		  throw new RuntimeError(2959, ngDevMode && `Image loader has detected an invalid path (\`${path}\`). To fix this, supply a path using one of the following formats: ${exampleUrls.join(" or ")}`);
		}
		function throwUnexpectedAbsoluteUrlError(path, url) {
		  throw new RuntimeError(2959, ngDevMode && `Image loader has detected a \`<img>\` tag with an invalid \`ngSrc\` attribute: ${url}. This image loader expects \`ngSrc\` to be a relative URL - however the provided value is an absolute URL. To fix this, provide \`ngSrc\` as a path relative to the base URL configured for this loader (\`${path}\`).`);
		}
		var provideCloudflareLoader = createImageLoader(createCloudflareUrl, ngDevMode ? ["https://<ZONE>/cdn-cgi/image/<OPTIONS>/<SOURCE-IMAGE>"] : void 0);
		function createCloudflareUrl(path, config2) {
		  let params = `format=auto`;
		  if (config2.width) {
			 params += `,width=${config2.width}`;
		  }
		  if (config2.isPlaceholder) {
			 params += `,quality=${PLACEHOLDER_QUALITY}`;
		  }
		  return `${path}/cdn-cgi/image/${params}/${config2.src}`;
		}
		var cloudinaryLoaderInfo = {
		  name: "Cloudinary",
		  testUrl: isCloudinaryUrl
		};
		var CLOUDINARY_LOADER_REGEX = /https?\:\/\/[^\/]+\.cloudinary\.com\/.+/;
		function isCloudinaryUrl(url) {
		  return CLOUDINARY_LOADER_REGEX.test(url);
		}
		var provideCloudinaryLoader = createImageLoader(createCloudinaryUrl, ngDevMode ? ["https://res.cloudinary.com/mysite", "https://mysite.cloudinary.com", "https://subdomain.mysite.com"] : void 0);
		function createCloudinaryUrl(path, config2) {
		  const quality = config2.isPlaceholder ? "q_auto:low" : "q_auto";
		  let params = `f_auto,${quality}`;
		  if (config2.width) {
			 params += `,w_${config2.width}`;
		  }
		  return `${path}/image/upload/${params}/${config2.src}`;
		}
		var imageKitLoaderInfo = {
		  name: "ImageKit",
		  testUrl: isImageKitUrl
		};
		var IMAGE_KIT_LOADER_REGEX = /https?\:\/\/[^\/]+\.imagekit\.io\/.+/;
		function isImageKitUrl(url) {
		  return IMAGE_KIT_LOADER_REGEX.test(url);
		}
		var provideImageKitLoader = createImageLoader(createImagekitUrl, ngDevMode ? ["https://ik.imagekit.io/mysite", "https://subdomain.mysite.com"] : void 0);
		function createImagekitUrl(path, config2) {
		  const {
			 src,
			 width
		  } = config2;
		  const params = [];
		  if (width) {
			 params.push(`w-${width}`);
		  }
		  if (config2.isPlaceholder) {
			 params.push(`q-${PLACEHOLDER_QUALITY}`);
		  }
		  const urlSegments = params.length ? [path, `tr:${params.join(",")}`, src] : [path, src];
		  const url = new URL(urlSegments.join("/"));
		  return url.href;
		}
		var imgixLoaderInfo = {
		  name: "Imgix",
		  testUrl: isImgixUrl
		};
		var IMGIX_LOADER_REGEX = /https?\:\/\/[^\/]+\.imgix\.net\/.+/;
		function isImgixUrl(url) {
		  return IMGIX_LOADER_REGEX.test(url);
		}
		var provideImgixLoader = createImageLoader(createImgixUrl, ngDevMode ? ["https://somepath.imgix.net/"] : void 0);
		function createImgixUrl(path, config2) {
		  const url = new URL(`${path}/${config2.src}`);
		  url.searchParams.set("auto", "format");
		  if (config2.width) {
			 url.searchParams.set("w", config2.width.toString());
		  }
		  if (config2.isPlaceholder) {
			 url.searchParams.set("q", PLACEHOLDER_QUALITY);
		  }
		  return url.href;
		}
		var netlifyLoaderInfo = {
		  name: "Netlify",
		  testUrl: isNetlifyUrl
		};
		var NETLIFY_LOADER_REGEX = /https?\:\/\/[^\/]+\.netlify\.app\/.+/;
		function isNetlifyUrl(url) {
		  return NETLIFY_LOADER_REGEX.test(url);
		}
		function imgDirectiveDetails(ngSrc, includeNgSrc = true) {
		  const ngSrcInfo = includeNgSrc ? `(activated on an <img> element with the \`ngSrc="${ngSrc}"\`) ` : "";
		  return `The NgOptimizedImage directive ${ngSrcInfo}has detected that`;
		}
		function assertDevMode(checkName) {
		  if (!ngDevMode) {
			 throw new RuntimeError(2958, `Unexpected invocation of the ${checkName} in the prod mode. Please make sure that the prod mode is enabled for production builds.`);
		  }
		}
		var LCPImageObserver = class _LCPImageObserver {
		  constructor() {
			 this.images = /* @__PURE__ */ new Map();
			 this.window = null;
			 this.observer = null;
			 assertDevMode("LCP checker");
			 const win = inject(DOCUMENT2).defaultView;
			 if (typeof win !== "undefined" && typeof PerformanceObserver !== "undefined") {
				this.window = win;
				this.observer = this.initPerformanceObserver();
			 }
		  }
		  /**
			* Inits PerformanceObserver and subscribes to LCP events.
			* Based on https://web.dev/lcp/#measure-lcp-in-javascript
			*/
		  initPerformanceObserver() {
			 const observer = new PerformanceObserver((entryList) => {
				const entries = entryList.getEntries();
				if (entries.length === 0)
				  return;
				const lcpElement = entries[entries.length - 1];
				const imgSrc = lcpElement.element?.src ?? "";
				if (imgSrc.startsWith("data:") || imgSrc.startsWith("blob:"))
				  return;
				const img = this.images.get(imgSrc);
				if (!img)
				  return;
				if (!img.priority && !img.alreadyWarnedPriority) {
				  img.alreadyWarnedPriority = true;
				  logMissingPriorityError(imgSrc);
				}
				if (img.modified && !img.alreadyWarnedModified) {
				  img.alreadyWarnedModified = true;
				  logModifiedWarning(imgSrc);
				}
			 });
			 observer.observe({
				type: "largest-contentful-paint",
				buffered: true
			 });
			 return observer;
		  }
		  registerImage(rewrittenSrc, originalNgSrc, isPriority) {
			 if (!this.observer)
				return;
			 const newObservedImageState = {
				priority: isPriority,
				modified: false,
				alreadyWarnedModified: false,
				alreadyWarnedPriority: false
			 };
			 this.images.set(getUrl(rewrittenSrc, this.window).href, newObservedImageState);
		  }
		  unregisterImage(rewrittenSrc) {
			 if (!this.observer)
				return;
			 this.images.delete(getUrl(rewrittenSrc, this.window).href);
		  }
		  updateImage(originalSrc, newSrc) {
			 const originalUrl = getUrl(originalSrc, this.window).href;
			 const img = this.images.get(originalUrl);
			 if (img) {
				img.modified = true;
				this.images.set(getUrl(newSrc, this.window).href, img);
				this.images.delete(originalUrl);
			 }
		  }
		  ngOnDestroy() {
			 if (!this.observer)
				return;
			 this.observer.disconnect();
			 this.images.clear();
		  }
		  static {
			 this.\u0275fac = function LCPImageObserver_Factory(t) {
				return new (t || _LCPImageObserver)();
			 };
		  }
		  static {
			 this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
				token: _LCPImageObserver,
				factory: _LCPImageObserver.\u0275fac,
				providedIn: "root"
			 });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LCPImageObserver, [{
			 type: Injectable,
			 args: [{
				providedIn: "root"
			 }]
		  }], () => [], null);
		})();
		function logMissingPriorityError(ngSrc) {
		  const directiveDetails = imgDirectiveDetails(ngSrc);
		  console.error(formatRuntimeError(2955, `${directiveDetails} this image is the Largest Contentful Paint (LCP) element but was not marked "priority". This image should be marked "priority" in order to prioritize its loading. To fix this, add the "priority" attribute.`));
		}
		function logModifiedWarning(ngSrc) {
		  const directiveDetails = imgDirectiveDetails(ngSrc);
		  console.warn(formatRuntimeError(2964, `${directiveDetails} this image is the Largest Contentful Paint (LCP) element and has had its "ngSrc" attribute modified. This can cause slower loading performance. It is recommended not to modify the "ngSrc" property on any image which could be the LCP element.`));
		}
		var INTERNAL_PRECONNECT_CHECK_BLOCKLIST = /* @__PURE__ */ new Set(["localhost", "127.0.0.1", "0.0.0.0"]);
		var PRECONNECT_CHECK_BLOCKLIST = new InjectionToken(ngDevMode ? "PRECONNECT_CHECK_BLOCKLIST" : "");
		var PreconnectLinkChecker = class _PreconnectLinkChecker {
		  constructor() {
			 this.document = inject(DOCUMENT2);
			 this.preconnectLinks = null;
			 this.alreadySeen = /* @__PURE__ */ new Set();
			 this.window = null;
			 this.blocklist = new Set(INTERNAL_PRECONNECT_CHECK_BLOCKLIST);
			 assertDevMode("preconnect link checker");
			 const win = this.document.defaultView;
			 if (typeof win !== "undefined") {
				this.window = win;
			 }
			 const blocklist = inject(PRECONNECT_CHECK_BLOCKLIST, {
				optional: true
			 });
			 if (blocklist) {
				this.populateBlocklist(blocklist);
			 }
		  }
		  populateBlocklist(origins) {
			 if (Array.isArray(origins)) {
				deepForEach2(origins, (origin) => {
				  this.blocklist.add(extractHostname(origin));
				});
			 } else {
				this.blocklist.add(extractHostname(origins));
			 }
		  }
		  /**
			* Checks that a preconnect resource hint exists in the head for the
			* given src.
			*
			* @param rewrittenSrc src formatted with loader
			* @param originalNgSrc ngSrc value
			*/
		  assertPreconnect(rewrittenSrc, originalNgSrc) {
			 if (!this.window)
				return;
			 const imgUrl = getUrl(rewrittenSrc, this.window);
			 if (this.blocklist.has(imgUrl.hostname) || this.alreadySeen.has(imgUrl.origin))
				return;
			 this.alreadySeen.add(imgUrl.origin);
			 this.preconnectLinks ??= this.queryPreconnectLinks();
			 if (!this.preconnectLinks.has(imgUrl.origin)) {
				console.warn(formatRuntimeError(2956, `${imgDirectiveDetails(originalNgSrc)} there is no preconnect tag present for this image. Preconnecting to the origin(s) that serve priority images ensures that these images are delivered as soon as possible. To fix this, please add the following element into the <head> of the document:
		  <link rel="preconnect" href="${imgUrl.origin}">`));
			 }
		  }
		  queryPreconnectLinks() {
			 const preconnectUrls = /* @__PURE__ */ new Set();
			 const selector = "link[rel=preconnect]";
			 const links = Array.from(this.document.querySelectorAll(selector));
			 for (let link of links) {
				const url = getUrl(link.href, this.window);
				preconnectUrls.add(url.origin);
			 }
			 return preconnectUrls;
		  }
		  ngOnDestroy() {
			 this.preconnectLinks?.clear();
			 this.alreadySeen.clear();
		  }
		  static {
			 this.\u0275fac = function PreconnectLinkChecker_Factory(t) {
				return new (t || _PreconnectLinkChecker)();
			 };
		  }
		  static {
			 this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
				token: _PreconnectLinkChecker,
				factory: _PreconnectLinkChecker.\u0275fac,
				providedIn: "root"
			 });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PreconnectLinkChecker, [{
			 type: Injectable,
			 args: [{
				providedIn: "root"
			 }]
		  }], () => [], null);
		})();
		function deepForEach2(input2, fn) {
		  for (let value of input2) {
			 Array.isArray(value) ? deepForEach2(value, fn) : fn(value);
		  }
		}
		var DEFAULT_PRELOADED_IMAGES_LIMIT = 5;
		var PRELOADED_IMAGES = new InjectionToken("NG_OPTIMIZED_PRELOADED_IMAGES", {
		  providedIn: "root",
		  factory: () => /* @__PURE__ */ new Set()
		});
		var PreloadLinkCreator = class _PreloadLinkCreator {
		  constructor() {
			 this.preloadedImages = inject(PRELOADED_IMAGES);
			 this.document = inject(DOCUMENT2);
		  }
		  /**
			* @description Add a preload `<link>` to the `<head>` of the `index.html` that is served from the
			* server while using Angular Universal and SSR to kick off image loads for high priority images.
			*
			* The `sizes` (passed in from the user) and `srcset` (parsed and formatted from `ngSrcset`)
			* properties used to set the corresponding attributes, `imagesizes` and `imagesrcset`
			* respectively, on the preload `<link>` tag so that the correctly sized image is preloaded from
			* the CDN.
			*
			* {@link https://web.dev/preload-responsive-images/#imagesrcset-and-imagesizes}
			*
			* @param renderer The `Renderer2` passed in from the directive
			* @param src The original src of the image that is set on the `ngSrc` input.
			* @param srcset The parsed and formatted srcset created from the `ngSrcset` input
			* @param sizes The value of the `sizes` attribute passed in to the `<img>` tag
			*/
		  createPreloadLinkTag(renderer, src, srcset, sizes) {
			 if (ngDevMode) {
				if (this.preloadedImages.size >= DEFAULT_PRELOADED_IMAGES_LIMIT) {
				  throw new RuntimeError(2961, ngDevMode && `The \`NgOptimizedImage\` directive has detected that more than ${DEFAULT_PRELOADED_IMAGES_LIMIT} images were marked as priority. This might negatively affect an overall performance of the page. To fix this, remove the "priority" attribute from images with less priority.`);
				}
			 }
			 if (this.preloadedImages.has(src)) {
				return;
			 }
			 this.preloadedImages.add(src);
			 const preload = renderer.createElement("link");
			 renderer.setAttribute(preload, "as", "image");
			 renderer.setAttribute(preload, "href", src);
			 renderer.setAttribute(preload, "rel", "preload");
			 renderer.setAttribute(preload, "fetchpriority", "high");
			 if (sizes) {
				renderer.setAttribute(preload, "imageSizes", sizes);
			 }
			 if (srcset) {
				renderer.setAttribute(preload, "imageSrcset", srcset);
			 }
			 renderer.appendChild(this.document.head, preload);
		  }
		  static {
			 this.\u0275fac = function PreloadLinkCreator_Factory(t) {
				return new (t || _PreloadLinkCreator)();
			 };
		  }
		  static {
			 this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
				token: _PreloadLinkCreator,
				factory: _PreloadLinkCreator.\u0275fac,
				providedIn: "root"
			 });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PreloadLinkCreator, [{
			 type: Injectable,
			 args: [{
				providedIn: "root"
			 }]
		  }], null, null);
		})();
		var BASE64_IMG_MAX_LENGTH_IN_ERROR = 50;
		var VALID_WIDTH_DESCRIPTOR_SRCSET = /^((\s*\d+w\s*(,|$)){1,})$/;
		var VALID_DENSITY_DESCRIPTOR_SRCSET = /^((\s*\d+(\.\d+)?x\s*(,|$)){1,})$/;
		var ABSOLUTE_SRCSET_DENSITY_CAP = 3;
		var RECOMMENDED_SRCSET_DENSITY_CAP = 2;
		var DENSITY_SRCSET_MULTIPLIERS = [1, 2];
		var VIEWPORT_BREAKPOINT_CUTOFF = 640;
		var ASPECT_RATIO_TOLERANCE = 0.1;
		var OVERSIZED_IMAGE_TOLERANCE2 = 1e3;
		var FIXED_SRCSET_WIDTH_LIMIT = 1920;
		var FIXED_SRCSET_HEIGHT_LIMIT = 1080;
		var PLACEHOLDER_BLUR_AMOUNT = 15;
		var DATA_URL_WARN_LIMIT = 4e3;
		var DATA_URL_ERROR_LIMIT = 1e4;
		var BUILT_IN_LOADERS = [imgixLoaderInfo, imageKitLoaderInfo, cloudinaryLoaderInfo, netlifyLoaderInfo];
		var NgOptimizedImage = class _NgOptimizedImage {
		  constructor() {
			 this.imageLoader = inject(IMAGE_LOADER);
			 this.config = processConfig(inject(IMAGE_CONFIG));
			 this.renderer = inject(Renderer2);
			 this.imgElement = inject(ElementRef).nativeElement;
			 this.injector = inject(Injector);
			 this.isServer = isPlatformServer(inject(PLATFORM_ID));
			 this.preloadLinkCreator = inject(PreloadLinkCreator);
			 this.lcpObserver = ngDevMode ? this.injector.get(LCPImageObserver) : null;
			 this._renderedSrc = null;
			 this.priority = false;
			 this.disableOptimizedSrcset = false;
			 this.fill = false;
		  }
		  /** @nodoc */
		  ngOnInit() {
			 performanceMarkFeature("NgOptimizedImage");
			 if (ngDevMode) {
				const ngZone = this.injector.get(NgZone);
				assertNonEmptyInput(this, "ngSrc", this.ngSrc);
				assertValidNgSrcset(this, this.ngSrcset);
				assertNoConflictingSrc(this);
				if (this.ngSrcset) {
				  assertNoConflictingSrcset(this);
				}
				assertNotBase64Image(this);
				assertNotBlobUrl(this);
				if (this.fill) {
				  assertEmptyWidthAndHeight(this);
				  ngZone.runOutsideAngular(() => assertNonZeroRenderedHeight(this, this.imgElement, this.renderer));
				} else {
				  assertNonEmptyWidthAndHeight(this);
				  if (this.height !== void 0) {
					 assertGreaterThanZero(this, this.height, "height");
				  }
				  if (this.width !== void 0) {
					 assertGreaterThanZero(this, this.width, "width");
				  }
				  ngZone.runOutsideAngular(() => assertNoImageDistortion(this, this.imgElement, this.renderer));
				}
				assertValidLoadingInput(this);
				if (!this.ngSrcset) {
				  assertNoComplexSizes(this);
				}
				assertValidPlaceholder(this, this.imageLoader);
				assertNotMissingBuiltInLoader(this.ngSrc, this.imageLoader);
				assertNoNgSrcsetWithoutLoader(this, this.imageLoader);
				assertNoLoaderParamsWithoutLoader(this, this.imageLoader);
				if (this.lcpObserver !== null) {
				  const ngZone2 = this.injector.get(NgZone);
				  ngZone2.runOutsideAngular(() => {
					 this.lcpObserver.registerImage(this.getRewrittenSrc(), this.ngSrc, this.priority);
				  });
				}
				if (this.priority) {
				  const checker = this.injector.get(PreconnectLinkChecker);
				  checker.assertPreconnect(this.getRewrittenSrc(), this.ngSrc);
				}
			 }
			 if (this.placeholder) {
				this.removePlaceholderOnLoad(this.imgElement);
			 }
			 this.setHostAttributes();
		  }
		  setHostAttributes() {
			 if (this.fill) {
				this.sizes ||= "100vw";
			 } else {
				this.setHostAttribute("width", this.width.toString());
				this.setHostAttribute("height", this.height.toString());
			 }
			 this.setHostAttribute("loading", this.getLoadingBehavior());
			 this.setHostAttribute("fetchpriority", this.getFetchPriority());
			 this.setHostAttribute("ng-img", "true");
			 const rewrittenSrcset = this.updateSrcAndSrcset();
			 if (this.sizes) {
				this.setHostAttribute("sizes", this.sizes);
			 }
			 if (this.isServer && this.priority) {
				this.preloadLinkCreator.createPreloadLinkTag(this.renderer, this.getRewrittenSrc(), rewrittenSrcset, this.sizes);
			 }
		  }
		  /** @nodoc */
		  ngOnChanges(changes) {
			 if (ngDevMode) {
				assertNoPostInitInputChange(this, changes, ["ngSrcset", "width", "height", "priority", "fill", "loading", "sizes", "loaderParams", "disableOptimizedSrcset"]);
			 }
			 if (changes["ngSrc"] && !changes["ngSrc"].isFirstChange()) {
				const oldSrc = this._renderedSrc;
				this.updateSrcAndSrcset(true);
				const newSrc = this._renderedSrc;
				if (this.lcpObserver !== null && oldSrc && newSrc && oldSrc !== newSrc) {
				  const ngZone = this.injector.get(NgZone);
				  ngZone.runOutsideAngular(() => {
					 this.lcpObserver?.updateImage(oldSrc, newSrc);
				  });
				}
			 }
		  }
		  callImageLoader(configWithoutCustomParams) {
			 let augmentedConfig = configWithoutCustomParams;
			 if (this.loaderParams) {
				augmentedConfig.loaderParams = this.loaderParams;
			 }
			 return this.imageLoader(augmentedConfig);
		  }
		  getLoadingBehavior() {
			 if (!this.priority && this.loading !== void 0) {
				return this.loading;
			 }
			 return this.priority ? "eager" : "lazy";
		  }
		  getFetchPriority() {
			 return this.priority ? "high" : "auto";
		  }
		  getRewrittenSrc() {
			 if (!this._renderedSrc) {
				const imgConfig = {
				  src: this.ngSrc
				};
				this._renderedSrc = this.callImageLoader(imgConfig);
			 }
			 return this._renderedSrc;
		  }
		  getRewrittenSrcset() {
			 const widthSrcSet = VALID_WIDTH_DESCRIPTOR_SRCSET.test(this.ngSrcset);
			 const finalSrcs = this.ngSrcset.split(",").filter((src) => src !== "").map((srcStr) => {
				srcStr = srcStr.trim();
				const width = widthSrcSet ? parseFloat(srcStr) : parseFloat(srcStr) * this.width;
				return `${this.callImageLoader({
				  src: this.ngSrc,
				  width
				})} ${srcStr}`;
			 });
			 return finalSrcs.join(", ");
		  }
		  getAutomaticSrcset() {
			 if (this.sizes) {
				return this.getResponsiveSrcset();
			 } else {
				return this.getFixedSrcset();
			 }
		  }
		  getResponsiveSrcset() {
			 const {
				breakpoints
			 } = this.config;
			 let filteredBreakpoints = breakpoints;
			 if (this.sizes?.trim() === "100vw") {
				filteredBreakpoints = breakpoints.filter((bp) => bp >= VIEWPORT_BREAKPOINT_CUTOFF);
			 }
			 const finalSrcs = filteredBreakpoints.map((bp) => `${this.callImageLoader({
				src: this.ngSrc,
				width: bp
			 })} ${bp}w`);
			 return finalSrcs.join(", ");
		  }
		  updateSrcAndSrcset(forceSrcRecalc = false) {
			 if (forceSrcRecalc) {
				this._renderedSrc = null;
			 }
			 const rewrittenSrc = this.getRewrittenSrc();
			 this.setHostAttribute("src", rewrittenSrc);
			 let rewrittenSrcset = void 0;
			 if (this.ngSrcset) {
				rewrittenSrcset = this.getRewrittenSrcset();
			 } else if (this.shouldGenerateAutomaticSrcset()) {
				rewrittenSrcset = this.getAutomaticSrcset();
			 }
			 if (rewrittenSrcset) {
				this.setHostAttribute("srcset", rewrittenSrcset);
			 }
			 return rewrittenSrcset;
		  }
		  getFixedSrcset() {
			 const finalSrcs = DENSITY_SRCSET_MULTIPLIERS.map((multiplier) => `${this.callImageLoader({
				src: this.ngSrc,
				width: this.width * multiplier
			 })} ${multiplier}x`);
			 return finalSrcs.join(", ");
		  }
		  shouldGenerateAutomaticSrcset() {
			 let oversizedImage = false;
			 if (!this.sizes) {
				oversizedImage = this.width > FIXED_SRCSET_WIDTH_LIMIT || this.height > FIXED_SRCSET_HEIGHT_LIMIT;
			 }
			 return !this.disableOptimizedSrcset && !this.srcset && this.imageLoader !== noopImageLoader && !oversizedImage;
		  }
		  /**
			* Returns an image url formatted for use with the CSS background-image property. Expects one of:
			* * A base64 encoded image, which is wrapped and passed through.
			* * A boolean. If true, calls the image loader to generate a small placeholder url.
			*/
		  generatePlaceholder(placeholderInput) {
			 const {
				placeholderResolution
			 } = this.config;
			 if (placeholderInput === true) {
				return `url(${this.callImageLoader({
				  src: this.ngSrc,
				  width: placeholderResolution,
				  isPlaceholder: true
				})})`;
			 } else if (typeof placeholderInput === "string" && placeholderInput.startsWith("data:")) {
				return `url(${placeholderInput})`;
			 }
			 return null;
		  }
		  /**
			* Determines if blur should be applied, based on an optional boolean
			* property `blur` within the optional configuration object `placeholderConfig`.
			*/
		  shouldBlurPlaceholder(placeholderConfig) {
			 if (!placeholderConfig || !placeholderConfig.hasOwnProperty("blur")) {
				return true;
			 }
			 return Boolean(placeholderConfig.blur);
		  }
		  removePlaceholderOnLoad(img) {
			 const callback = () => {
				const changeDetectorRef = this.injector.get(ChangeDetectorRef);
				removeLoadListenerFn();
				removeErrorListenerFn();
				this.placeholder = false;
				changeDetectorRef.markForCheck();
			 };
			 const removeLoadListenerFn = this.renderer.listen(img, "load", callback);
			 const removeErrorListenerFn = this.renderer.listen(img, "error", callback);
		  }
		  /** @nodoc */
		  ngOnDestroy() {
			 if (ngDevMode) {
				if (!this.priority && this._renderedSrc !== null && this.lcpObserver !== null) {
				  this.lcpObserver.unregisterImage(this._renderedSrc);
				}
			 }
		  }
		  setHostAttribute(name, value) {
			 this.renderer.setAttribute(this.imgElement, name, value);
		  }
		  static {
			 this.\u0275fac = function NgOptimizedImage_Factory(t) {
				return new (t || _NgOptimizedImage)();
			 };
		  }
		  static {
			 this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
				type: _NgOptimizedImage,
				selectors: [["img", "ngSrc", ""]],
				hostVars: 18,
				hostBindings: function NgOptimizedImage_HostBindings(rf, ctx) {
				  if (rf & 2) {
					 \u0275\u0275styleProp("position", ctx.fill ? "absolute" : null)("width", ctx.fill ? "100%" : null)("height", ctx.fill ? "100%" : null)("inset", ctx.fill ? "0" : null)("background-size", ctx.placeholder ? "cover" : null)("background-position", ctx.placeholder ? "50% 50%" : null)("background-repeat", ctx.placeholder ? "no-repeat" : null)("background-image", ctx.placeholder ? ctx.generatePlaceholder(ctx.placeholder) : null)("filter", ctx.placeholder && ctx.shouldBlurPlaceholder(ctx.placeholderConfig) ? "blur(15px)" : null);
				  }
				},
				inputs: {
				  ngSrc: [InputFlags.HasDecoratorInputTransform, "ngSrc", "ngSrc", unwrapSafeUrl],
				  ngSrcset: "ngSrcset",
				  sizes: "sizes",
				  width: [InputFlags.HasDecoratorInputTransform, "width", "width", numberAttribute],
				  height: [InputFlags.HasDecoratorInputTransform, "height", "height", numberAttribute],
				  loading: "loading",
				  priority: [InputFlags.HasDecoratorInputTransform, "priority", "priority", booleanAttribute],
				  loaderParams: "loaderParams",
				  disableOptimizedSrcset: [InputFlags.HasDecoratorInputTransform, "disableOptimizedSrcset", "disableOptimizedSrcset", booleanAttribute],
				  fill: [InputFlags.HasDecoratorInputTransform, "fill", "fill", booleanAttribute],
				  placeholder: [InputFlags.HasDecoratorInputTransform, "placeholder", "placeholder", booleanOrDataUrlAttribute],
				  placeholderConfig: "placeholderConfig",
				  src: "src",
				  srcset: "srcset"
				},
				standalone: true,
				features: [\u0275\u0275InputTransformsFeature, \u0275\u0275NgOnChangesFeature]
			 });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgOptimizedImage, [{
			 type: Directive,
			 args: [{
				standalone: true,
				selector: "img[ngSrc]",
				host: {
				  "[style.position]": 'fill ? "absolute" : null',
				  "[style.width]": 'fill ? "100%" : null',
				  "[style.height]": 'fill ? "100%" : null',
				  "[style.inset]": 'fill ? "0" : null',
				  "[style.background-size]": 'placeholder ? "cover" : null',
				  "[style.background-position]": 'placeholder ? "50% 50%" : null',
				  "[style.background-repeat]": 'placeholder ? "no-repeat" : null',
				  "[style.background-image]": "placeholder ? generatePlaceholder(placeholder) : null",
				  "[style.filter]": `placeholder && shouldBlurPlaceholder(placeholderConfig) ? "blur(${PLACEHOLDER_BLUR_AMOUNT}px)" : null`
				}
			 }]
		  }], null, {
			 ngSrc: [{
				type: Input,
				args: [{
				  required: true,
				  transform: unwrapSafeUrl
				}]
			 }],
			 ngSrcset: [{
				type: Input
			 }],
			 sizes: [{
				type: Input
			 }],
			 width: [{
				type: Input,
				args: [{
				  transform: numberAttribute
				}]
			 }],
			 height: [{
				type: Input,
				args: [{
				  transform: numberAttribute
				}]
			 }],
			 loading: [{
				type: Input
			 }],
			 priority: [{
				type: Input,
				args: [{
				  transform: booleanAttribute
				}]
			 }],
			 loaderParams: [{
				type: Input
			 }],
			 disableOptimizedSrcset: [{
				type: Input,
				args: [{
				  transform: booleanAttribute
				}]
			 }],
			 fill: [{
				type: Input,
				args: [{
				  transform: booleanAttribute
				}]
			 }],
			 placeholder: [{
				type: Input,
				args: [{
				  transform: booleanOrDataUrlAttribute
				}]
			 }],
			 placeholderConfig: [{
				type: Input
			 }],
			 src: [{
				type: Input
			 }],
			 srcset: [{
				type: Input
			 }]
		  });
		})();
		function processConfig(config2) {
		  let sortedBreakpoints = {};
		  if (config2.breakpoints) {
			 sortedBreakpoints.breakpoints = config2.breakpoints.sort((a, b) => a - b);
		  }
		  return Object.assign({}, IMAGE_CONFIG_DEFAULTS, config2, sortedBreakpoints);
		}
		function assertNoConflictingSrc(dir) {
		  if (dir.src) {
			 throw new RuntimeError(2950, `${imgDirectiveDetails(dir.ngSrc)} both \`src\` and \`ngSrc\` have been set. Supplying both of these attributes breaks lazy loading. The NgOptimizedImage directive sets \`src\` itself based on the value of \`ngSrc\`. To fix this, please remove the \`src\` attribute.`);
		  }
		}
		function assertNoConflictingSrcset(dir) {
		  if (dir.srcset) {
			 throw new RuntimeError(2951, `${imgDirectiveDetails(dir.ngSrc)} both \`srcset\` and \`ngSrcset\` have been set. Supplying both of these attributes breaks lazy loading. The NgOptimizedImage directive sets \`srcset\` itself based on the value of \`ngSrcset\`. To fix this, please remove the \`srcset\` attribute.`);
		  }
		}
		function assertNotBase64Image(dir) {
		  let ngSrc = dir.ngSrc.trim();
		  if (ngSrc.startsWith("data:")) {
			 if (ngSrc.length > BASE64_IMG_MAX_LENGTH_IN_ERROR) {
				ngSrc = ngSrc.substring(0, BASE64_IMG_MAX_LENGTH_IN_ERROR) + "...";
			 }
			 throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc, false)} \`ngSrc\` is a Base64-encoded string (${ngSrc}). NgOptimizedImage does not support Base64-encoded strings. To fix this, disable the NgOptimizedImage directive for this element by removing \`ngSrc\` and using a standard \`src\` attribute instead.`);
		  }
		}
		function assertNoComplexSizes(dir) {
		  let sizes = dir.sizes;
		  if (sizes?.match(/((\)|,)\s|^)\d+px/)) {
			 throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc, false)} \`sizes\` was set to a string including pixel values. For automatic \`srcset\` generation, \`sizes\` must only include responsive values, such as \`sizes="50vw"\` or \`sizes="(min-width: 768px) 50vw, 100vw"\`. To fix this, modify the \`sizes\` attribute, or provide your own \`ngSrcset\` value directly.`);
		  }
		}
		function assertValidPlaceholder(dir, imageLoader) {
		  assertNoPlaceholderConfigWithoutPlaceholder(dir);
		  assertNoRelativePlaceholderWithoutLoader(dir, imageLoader);
		  assertNoOversizedDataUrl(dir);
		}
		function assertNoPlaceholderConfigWithoutPlaceholder(dir) {
		  if (dir.placeholderConfig && !dir.placeholder) {
			 throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc, false)} \`placeholderConfig\` options were provided for an image that does not use the \`placeholder\` attribute, and will have no effect.`);
		  }
		}
		function assertNoRelativePlaceholderWithoutLoader(dir, imageLoader) {
		  if (dir.placeholder === true && imageLoader === noopImageLoader) {
			 throw new RuntimeError(2963, `${imgDirectiveDetails(dir.ngSrc)} the \`placeholder\` attribute is set to true but no image loader is configured (i.e. the default one is being used), which would result in the same image being used for the primary image and its placeholder. To fix this, provide a loader or remove the \`placeholder\` attribute from the image.`);
		  }
		}
		function assertNoOversizedDataUrl(dir) {
		  if (dir.placeholder && typeof dir.placeholder === "string" && dir.placeholder.startsWith("data:")) {
			 if (dir.placeholder.length > DATA_URL_ERROR_LIMIT) {
				throw new RuntimeError(2965, `${imgDirectiveDetails(dir.ngSrc)} the \`placeholder\` attribute is set to a data URL which is longer than ${DATA_URL_ERROR_LIMIT} characters. This is strongly discouraged, as large inline placeholders directly increase the bundle size of Angular and hurt page load performance. To fix this, generate a smaller data URL placeholder.`);
			 }
			 if (dir.placeholder.length > DATA_URL_WARN_LIMIT) {
				console.warn(formatRuntimeError(2965, `${imgDirectiveDetails(dir.ngSrc)} the \`placeholder\` attribute is set to a data URL which is longer than ${DATA_URL_WARN_LIMIT} characters. This is discouraged, as large inline placeholders directly increase the bundle size of Angular and hurt page load performance. For better loading performance, generate a smaller data URL placeholder.`));
			 }
		  }
		}
		function assertNotBlobUrl(dir) {
		  const ngSrc = dir.ngSrc.trim();
		  if (ngSrc.startsWith("blob:")) {
			 throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} \`ngSrc\` was set to a blob URL (${ngSrc}). Blob URLs are not supported by the NgOptimizedImage directive. To fix this, disable the NgOptimizedImage directive for this element by removing \`ngSrc\` and using a regular \`src\` attribute instead.`);
		  }
		}
		function assertNonEmptyInput(dir, name, value) {
		  const isString2 = typeof value === "string";
		  const isEmptyString = isString2 && value.trim() === "";
		  if (!isString2 || isEmptyString) {
			 throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} \`${name}\` has an invalid value (\`${value}\`). To fix this, change the value to a non-empty string.`);
		  }
		}
		function assertValidNgSrcset(dir, value) {
		  if (value == null)
			 return;
		  assertNonEmptyInput(dir, "ngSrcset", value);
		  const stringVal = value;
		  const isValidWidthDescriptor = VALID_WIDTH_DESCRIPTOR_SRCSET.test(stringVal);
		  const isValidDensityDescriptor = VALID_DENSITY_DESCRIPTOR_SRCSET.test(stringVal);
		  if (isValidDensityDescriptor) {
			 assertUnderDensityCap(dir, stringVal);
		  }
		  const isValidSrcset = isValidWidthDescriptor || isValidDensityDescriptor;
		  if (!isValidSrcset) {
			 throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} \`ngSrcset\` has an invalid value (\`${value}\`). To fix this, supply \`ngSrcset\` using a comma-separated list of one or more width descriptors (e.g. "100w, 200w") or density descriptors (e.g. "1x, 2x").`);
		  }
		}
		function assertUnderDensityCap(dir, value) {
		  const underDensityCap = value.split(",").every((num) => num === "" || parseFloat(num) <= ABSOLUTE_SRCSET_DENSITY_CAP);
		  if (!underDensityCap) {
			 throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the \`ngSrcset\` contains an unsupported image density:\`${value}\`. NgOptimizedImage generally recommends a max image density of ${RECOMMENDED_SRCSET_DENSITY_CAP}x but supports image densities up to ${ABSOLUTE_SRCSET_DENSITY_CAP}x. The human eye cannot distinguish between image densities greater than ${RECOMMENDED_SRCSET_DENSITY_CAP}x - which makes them unnecessary for most use cases. Images that will be pinch-zoomed are typically the primary use case for ${ABSOLUTE_SRCSET_DENSITY_CAP}x images. Please remove the high density descriptor and try again.`);
		  }
		}
		function postInitInputChangeError(dir, inputName) {
		  let reason;
		  if (inputName === "width" || inputName === "height") {
			 reason = `Changing \`${inputName}\` may result in different attribute value applied to the underlying image element and cause layout shifts on a page.`;
		  } else {
			 reason = `Changing the \`${inputName}\` would have no effect on the underlying image element, because the resource loading has already occurred.`;
		  }
		  return new RuntimeError(2953, `${imgDirectiveDetails(dir.ngSrc)} \`${inputName}\` was updated after initialization. The NgOptimizedImage directive will not react to this input change. ${reason} To fix this, either switch \`${inputName}\` to a static value or wrap the image element in an *ngIf that is gated on the necessary value.`);
		}
		function assertNoPostInitInputChange(dir, changes, inputs) {
		  inputs.forEach((input2) => {
			 const isUpdated = changes.hasOwnProperty(input2);
			 if (isUpdated && !changes[input2].isFirstChange()) {
				if (input2 === "ngSrc") {
				  dir = {
					 ngSrc: changes[input2].previousValue
				  };
				}
				throw postInitInputChangeError(dir, input2);
			 }
		  });
		}
		function assertGreaterThanZero(dir, inputValue, inputName) {
		  const validNumber = typeof inputValue === "number" && inputValue > 0;
		  const validString = typeof inputValue === "string" && /^\d+$/.test(inputValue.trim()) && parseInt(inputValue) > 0;
		  if (!validNumber && !validString) {
			 throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} \`${inputName}\` has an invalid value. To fix this, provide \`${inputName}\` as a number greater than 0.`);
		  }
		}
		function assertNoImageDistortion(dir, img, renderer) {
		  const removeLoadListenerFn = renderer.listen(img, "load", () => {
			 removeLoadListenerFn();
			 removeErrorListenerFn();
			 const computedStyle = window.getComputedStyle(img);
			 let renderedWidth = parseFloat(computedStyle.getPropertyValue("width"));
			 let renderedHeight = parseFloat(computedStyle.getPropertyValue("height"));
			 const boxSizing = computedStyle.getPropertyValue("box-sizing");
			 if (boxSizing === "border-box") {
				const paddingTop = computedStyle.getPropertyValue("padding-top");
				const paddingRight = computedStyle.getPropertyValue("padding-right");
				const paddingBottom = computedStyle.getPropertyValue("padding-bottom");
				const paddingLeft = computedStyle.getPropertyValue("padding-left");
				renderedWidth -= parseFloat(paddingRight) + parseFloat(paddingLeft);
				renderedHeight -= parseFloat(paddingTop) + parseFloat(paddingBottom);
			 }
			 const renderedAspectRatio = renderedWidth / renderedHeight;
			 const nonZeroRenderedDimensions = renderedWidth !== 0 && renderedHeight !== 0;
			 const intrinsicWidth = img.naturalWidth;
			 const intrinsicHeight = img.naturalHeight;
			 const intrinsicAspectRatio = intrinsicWidth / intrinsicHeight;
			 const suppliedWidth = dir.width;
			 const suppliedHeight = dir.height;
			 const suppliedAspectRatio = suppliedWidth / suppliedHeight;
			 const inaccurateDimensions = Math.abs(suppliedAspectRatio - intrinsicAspectRatio) > ASPECT_RATIO_TOLERANCE;
			 const stylingDistortion = nonZeroRenderedDimensions && Math.abs(intrinsicAspectRatio - renderedAspectRatio) > ASPECT_RATIO_TOLERANCE;
			 if (inaccurateDimensions) {
				console.warn(formatRuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the aspect ratio of the image does not match the aspect ratio indicated by the width and height attributes.
		Intrinsic image size: ${intrinsicWidth}w x ${intrinsicHeight}h (aspect-ratio: ${round(intrinsicAspectRatio)}).
		Supplied width and height attributes: ${suppliedWidth}w x ${suppliedHeight}h (aspect-ratio: ${round(suppliedAspectRatio)}).
		To fix this, update the width and height attributes.`));
			 } else if (stylingDistortion) {
				console.warn(formatRuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the aspect ratio of the rendered image does not match the image's intrinsic aspect ratio.
		Intrinsic image size: ${intrinsicWidth}w x ${intrinsicHeight}h (aspect-ratio: ${round(intrinsicAspectRatio)}).
		Rendered image size: ${renderedWidth}w x ${renderedHeight}h (aspect-ratio: ${round(renderedAspectRatio)}).
		This issue can occur if "width" and "height" attributes are added to an image without updating the corresponding image styling. To fix this, adjust image styling. In most cases, adding "height: auto" or "width: auto" to the image styling will fix this issue.`));
			 } else if (!dir.ngSrcset && nonZeroRenderedDimensions) {
				const recommendedWidth = RECOMMENDED_SRCSET_DENSITY_CAP * renderedWidth;
				const recommendedHeight = RECOMMENDED_SRCSET_DENSITY_CAP * renderedHeight;
				const oversizedWidth = intrinsicWidth - recommendedWidth >= OVERSIZED_IMAGE_TOLERANCE2;
				const oversizedHeight = intrinsicHeight - recommendedHeight >= OVERSIZED_IMAGE_TOLERANCE2;
				if (oversizedWidth || oversizedHeight) {
				  console.warn(formatRuntimeError(2960, `${imgDirectiveDetails(dir.ngSrc)} the intrinsic image is significantly larger than necessary.
		Rendered image size: ${renderedWidth}w x ${renderedHeight}h.
		Intrinsic image size: ${intrinsicWidth}w x ${intrinsicHeight}h.
		Recommended intrinsic image size: ${recommendedWidth}w x ${recommendedHeight}h.
		Note: Recommended intrinsic image size is calculated assuming a maximum DPR of ${RECOMMENDED_SRCSET_DENSITY_CAP}. To improve loading time, resize the image or consider using the "ngSrcset" and "sizes" attributes.`));
				}
			 }
		  });
		  const removeErrorListenerFn = renderer.listen(img, "error", () => {
			 removeLoadListenerFn();
			 removeErrorListenerFn();
		  });
		}
		function assertNonEmptyWidthAndHeight(dir) {
		  let missingAttributes = [];
		  if (dir.width === void 0)
			 missingAttributes.push("width");
		  if (dir.height === void 0)
			 missingAttributes.push("height");
		  if (missingAttributes.length > 0) {
			 throw new RuntimeError(2954, `${imgDirectiveDetails(dir.ngSrc)} these required attributes are missing: ${missingAttributes.map((attr) => `"${attr}"`).join(", ")}. Including "width" and "height" attributes will prevent image-related layout shifts. To fix this, include "width" and "height" attributes on the image tag or turn on "fill" mode with the \`fill\` attribute.`);
		  }
		}
		function assertEmptyWidthAndHeight(dir) {
		  if (dir.width || dir.height) {
			 throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the attributes \`height\` and/or \`width\` are present along with the \`fill\` attribute. Because \`fill\` mode causes an image to fill its containing element, the size attributes have no effect and should be removed.`);
		  }
		}
		function assertNonZeroRenderedHeight(dir, img, renderer) {
		  const removeLoadListenerFn = renderer.listen(img, "load", () => {
			 removeLoadListenerFn();
			 removeErrorListenerFn();
			 const renderedHeight = img.clientHeight;
			 if (dir.fill && renderedHeight === 0) {
				console.warn(formatRuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the height of the fill-mode image is zero. This is likely because the containing element does not have the CSS 'position' property set to one of the following: "relative", "fixed", or "absolute". To fix this problem, make sure the container element has the CSS 'position' property defined and the height of the element is not zero.`));
			 }
		  });
		  const removeErrorListenerFn = renderer.listen(img, "error", () => {
			 removeLoadListenerFn();
			 removeErrorListenerFn();
		  });
		}
		function assertValidLoadingInput(dir) {
		  if (dir.loading && dir.priority) {
			 throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the \`loading\` attribute was used on an image that was marked "priority". Setting \`loading\` on priority images is not allowed because these images will always be eagerly loaded. To fix this, remove the \u201Cloading\u201D attribute from the priority image.`);
		  }
		  const validInputs = ["auto", "eager", "lazy"];
		  if (typeof dir.loading === "string" && !validInputs.includes(dir.loading)) {
			 throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the \`loading\` attribute has an invalid value (\`${dir.loading}\`). To fix this, provide a valid value ("lazy", "eager", or "auto").`);
		  }
		}
		function assertNotMissingBuiltInLoader(ngSrc, imageLoader) {
		  if (imageLoader === noopImageLoader) {
			 let builtInLoaderName = "";
			 for (const loader of BUILT_IN_LOADERS) {
				if (loader.testUrl(ngSrc)) {
				  builtInLoaderName = loader.name;
				  break;
				}
			 }
			 if (builtInLoaderName) {
				console.warn(formatRuntimeError(2962, `NgOptimizedImage: It looks like your images may be hosted on the ${builtInLoaderName} CDN, but your app is not using Angular's built-in loader for that CDN. We recommend switching to use the built-in by calling \`provide${builtInLoaderName}Loader()\` in your \`providers\` and passing it your instance's base URL. If you don't want to use the built-in loader, define a custom loader function using IMAGE_LOADER to silence this warning.`));
			 }
		  }
		}
		function assertNoNgSrcsetWithoutLoader(dir, imageLoader) {
		  if (dir.ngSrcset && imageLoader === noopImageLoader) {
			 console.warn(formatRuntimeError(2963, `${imgDirectiveDetails(dir.ngSrc)} the \`ngSrcset\` attribute is present but no image loader is configured (i.e. the default one is being used), which would result in the same image being used for all configured sizes. To fix this, provide a loader or remove the \`ngSrcset\` attribute from the image.`));
		  }
		}
		function assertNoLoaderParamsWithoutLoader(dir, imageLoader) {
		  if (dir.loaderParams && imageLoader === noopImageLoader) {
			 console.warn(formatRuntimeError(2963, `${imgDirectiveDetails(dir.ngSrc)} the \`loaderParams\` attribute is present but no image loader is configured (i.e. the default one is being used), which means that the loaderParams data will not be consumed and will not affect the URL. To fix this, provide a custom loader or remove the \`loaderParams\` attribute from the image.`));
		  }
		}
		function round(input2) {
		  return Number.isInteger(input2) ? input2 : input2.toFixed(2);
		}
		function unwrapSafeUrl(value) {
		  if (typeof value === "string") {
			 return value;
		  }
		  return unwrapSafeValue(value);
		}
		function booleanOrDataUrlAttribute(value) {
		  if (typeof value === "string" && value.startsWith(`data:`)) {
			 return value;
		  }
		  return booleanAttribute(value);
		}

		// node_modules/@angular/platform-browser/fesm2022/platform-browser.mjs
		var GenericBrowserDomAdapter = class extends DomAdapter {
		  constructor() {
			 super(...arguments);
			 this.supportsDOMEvents = true;
		  }
		};
		var BrowserDomAdapter = class _BrowserDomAdapter extends GenericBrowserDomAdapter {
		  static makeCurrent() {
			 setRootDomAdapter(new _BrowserDomAdapter());
		  }
		  onAndCancel(el, evt, listener) {
			 el.addEventListener(evt, listener);
			 return () => {
				el.removeEventListener(evt, listener);
			 };
		  }
		  dispatchEvent(el, evt) {
			 el.dispatchEvent(evt);
		  }
		  remove(node) {
			 if (node.parentNode) {
				node.parentNode.removeChild(node);
			 }
		  }
		  createElement(tagName, doc) {
			 doc = doc || this.getDefaultDocument();
			 return doc.createElement(tagName);
		  }
		  createHtmlDocument() {
			 return document.implementation.createHTMLDocument("fakeTitle");
		  }
		  getDefaultDocument() {
			 return document;
		  }
		  isElementNode(node) {
			 return node.nodeType === Node.ELEMENT_NODE;
		  }
		  isShadowRoot(node) {
			 return node instanceof DocumentFragment;
		  }
		  /** @deprecated No longer being used in Ivy code. To be removed in version 14. */
		  getGlobalEventTarget(doc, target) {
			 if (target === "window") {
				return window;
			 }
			 if (target === "document") {
				return doc;
			 }
			 if (target === "body") {
				return doc.body;
			 }
			 return null;
		  }
		  getBaseHref(doc) {
			 const href = getBaseElementHref();
			 return href == null ? null : relativePath(href);
		  }
		  resetBaseElement() {
			 baseElement = null;
		  }
		  getUserAgent() {
			 return window.navigator.userAgent;
		  }
		  getCookie(name) {
			 return parseCookieValue(document.cookie, name);
		  }
		};
		var baseElement = null;
		function getBaseElementHref() {
		  baseElement = baseElement || document.querySelector("base");
		  return baseElement ? baseElement.getAttribute("href") : null;
		}
		function relativePath(url) {
		  return new URL(url, document.baseURI).pathname;
		}
		var BrowserGetTestability = class {
		  addToWindow(registry) {
			 _global["getAngularTestability"] = (elem2, findInAncestors = true) => {
				const testability = registry.findTestabilityInTree(elem2, findInAncestors);
				if (testability == null) {
				  throw new RuntimeError(5103, (typeof ngDevMode === "undefined" || ngDevMode) && "Could not find testability for element.");
				}
				return testability;
			 };
			 _global["getAllAngularTestabilities"] = () => registry.getAllTestabilities();
			 _global["getAllAngularRootElements"] = () => registry.getAllRootElements();
			 const whenAllStable = (callback) => {
				const testabilities = _global["getAllAngularTestabilities"]();
				let count = testabilities.length;
				const decrement = function() {
				  count--;
				  if (count == 0) {
					 callback();
				  }
				};
				testabilities.forEach((testability) => {
				  testability.whenStable(decrement);
				});
			 };
			 if (!_global["frameworkStabilizers"]) {
				_global["frameworkStabilizers"] = [];
			 }
			 _global["frameworkStabilizers"].push(whenAllStable);
		  }
		  findTestabilityInTree(registry, elem2, findInAncestors) {
			 if (elem2 == null) {
				return null;
			 }
			 const t = registry.getTestability(elem2);
			 if (t != null) {
				return t;
			 } else if (!findInAncestors) {
				return null;
			 }
			 if (getDOM().isShadowRoot(elem2)) {
				return this.findTestabilityInTree(registry, elem2.host, true);
			 }
			 return this.findTestabilityInTree(registry, elem2.parentElement, true);
		  }
		};
		var BrowserXhr = class _BrowserXhr {
		  build() {
			 return new XMLHttpRequest();
		  }
		  static {
			 this.\u0275fac = function BrowserXhr_Factory(t) {
				return new (t || _BrowserXhr)();
			 };
		  }
		  static {
			 this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
				token: _BrowserXhr,
				factory: _BrowserXhr.\u0275fac
			 });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BrowserXhr, [{
			 type: Injectable
		  }], null, null);
		})();
		var EVENT_MANAGER_PLUGINS = new InjectionToken(ngDevMode ? "EventManagerPlugins" : "");
		var EventManager = class _EventManager {
		  /**
			* Initializes an instance of the event-manager service.
			*/
		  constructor(plugins, _zone) {
			 this._zone = _zone;
			 this._eventNameToPlugin = /* @__PURE__ */ new Map();
			 plugins.forEach((plugin) => {
				plugin.manager = this;
			 });
			 this._plugins = plugins.slice().reverse();
		  }
		  /**
			* Registers a handler for a specific element and event.
			*
			* @param element The HTML element to receive event notifications.
			* @param eventName The name of the event to listen for.
			* @param handler A function to call when the notification occurs. Receives the
			* event object as an argument.
			* @returns  A callback function that can be used to remove the handler.
			*/
		  addEventListener(element, eventName, handler) {
			 const plugin = this._findPluginFor(eventName);
			 return plugin.addEventListener(element, eventName, handler);
		  }
		  /**
			* Retrieves the compilation zone in which event listeners are registered.
			*/
		  getZone() {
			 return this._zone;
		  }
		  /** @internal */
		  _findPluginFor(eventName) {
			 let plugin = this._eventNameToPlugin.get(eventName);
			 if (plugin) {
				return plugin;
			 }
			 const plugins = this._plugins;
			 plugin = plugins.find((plugin2) => plugin2.supports(eventName));
			 if (!plugin) {
				throw new RuntimeError(5101, (typeof ngDevMode === "undefined" || ngDevMode) && `No event manager plugin found for event ${eventName}`);
			 }
			 this._eventNameToPlugin.set(eventName, plugin);
			 return plugin;
		  }
		  static {
			 this.\u0275fac = function EventManager_Factory(t) {
				return new (t || _EventManager)(\u0275\u0275inject(EVENT_MANAGER_PLUGINS), \u0275\u0275inject(NgZone));
			 };
		  }
		  static {
			 this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
				token: _EventManager,
				factory: _EventManager.\u0275fac
			 });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EventManager, [{
			 type: Injectable
		  }], () => [{
			 type: void 0,
			 decorators: [{
				type: Inject,
				args: [EVENT_MANAGER_PLUGINS]
			 }]
		  }, {
			 type: NgZone
		  }], null);
		})();
		var EventManagerPlugin = class {
		  // TODO: remove (has some usage in G3)
		  constructor(_doc) {
			 this._doc = _doc;
		  }
		};
		var APP_ID_ATTRIBUTE_NAME = "ng-app-id";
		var SharedStylesHost = class _SharedStylesHost {
		  constructor(doc, appId, nonce, platformId = {}) {
			 this.doc = doc;
			 this.appId = appId;
			 this.nonce = nonce;
			 this.platformId = platformId;
			 this.styleRef = /* @__PURE__ */ new Map();
			 this.hostNodes = /* @__PURE__ */ new Set();
			 this.styleNodesInDOM = this.collectServerRenderedStyles();
			 this.platformIsServer = isPlatformServer(platformId);
			 this.resetHostNodes();
		  }
		  addStyles(styles) {
			 for (const style of styles) {
				const usageCount = this.changeUsageCount(style, 1);
				if (usageCount === 1) {
				  this.onStyleAdded(style);
				}
			 }
		  }
		  removeStyles(styles) {
			 for (const style of styles) {
				const usageCount = this.changeUsageCount(style, -1);
				if (usageCount <= 0) {
				  this.onStyleRemoved(style);
				}
			 }
		  }
		  ngOnDestroy() {
			 const styleNodesInDOM = this.styleNodesInDOM;
			 if (styleNodesInDOM) {
				styleNodesInDOM.forEach((node) => node.remove());
				styleNodesInDOM.clear();
			 }
			 for (const style of this.getAllStyles()) {
				this.onStyleRemoved(style);
			 }
			 this.resetHostNodes();
		  }
		  addHost(hostNode) {
			 this.hostNodes.add(hostNode);
			 for (const style of this.getAllStyles()) {
				this.addStyleToHost(hostNode, style);
			 }
		  }
		  removeHost(hostNode) {
			 this.hostNodes.delete(hostNode);
		  }
		  getAllStyles() {
			 return this.styleRef.keys();
		  }
		  onStyleAdded(style) {
			 for (const host of this.hostNodes) {
				this.addStyleToHost(host, style);
			 }
		  }
		  onStyleRemoved(style) {
			 const styleRef = this.styleRef;
			 styleRef.get(style)?.elements?.forEach((node) => node.remove());
			 styleRef.delete(style);
		  }
		  collectServerRenderedStyles() {
			 const styles = this.doc.head?.querySelectorAll(`style[${APP_ID_ATTRIBUTE_NAME}="${this.appId}"]`);
			 if (styles?.length) {
				const styleMap = /* @__PURE__ */ new Map();
				styles.forEach((style) => {
				  if (style.textContent != null) {
					 styleMap.set(style.textContent, style);
				  }
				});
				return styleMap;
			 }
			 return null;
		  }
		  changeUsageCount(style, delta) {
			 const map3 = this.styleRef;
			 if (map3.has(style)) {
				const styleRefValue = map3.get(style);
				styleRefValue.usage += delta;
				return styleRefValue.usage;
			 }
			 map3.set(style, {
				usage: delta,
				elements: []
			 });
			 return delta;
		  }
		  getStyleElement(host, style) {
			 const styleNodesInDOM = this.styleNodesInDOM;
			 const styleEl = styleNodesInDOM?.get(style);
			 if (styleEl?.parentNode === host) {
				styleNodesInDOM.delete(style);
				styleEl.removeAttribute(APP_ID_ATTRIBUTE_NAME);
				if (typeof ngDevMode === "undefined" || ngDevMode) {
				  styleEl.setAttribute("ng-style-reused", "");
				}
				return styleEl;
			 } else {
				const styleEl2 = this.doc.createElement("style");
				if (this.nonce) {
				  styleEl2.setAttribute("nonce", this.nonce);
				}
				styleEl2.textContent = style;
				if (this.platformIsServer) {
				  styleEl2.setAttribute(APP_ID_ATTRIBUTE_NAME, this.appId);
				}
				host.appendChild(styleEl2);
				return styleEl2;
			 }
		  }
		  addStyleToHost(host, style) {
			 const styleEl = this.getStyleElement(host, style);
			 const styleRef = this.styleRef;
			 const styleElRef = styleRef.get(style)?.elements;
			 if (styleElRef) {
				styleElRef.push(styleEl);
			 } else {
				styleRef.set(style, {
				  elements: [styleEl],
				  usage: 1
				});
			 }
		  }
		  resetHostNodes() {
			 const hostNodes = this.hostNodes;
			 hostNodes.clear();
			 hostNodes.add(this.doc.head);
		  }
		  static {
			 this.\u0275fac = function SharedStylesHost_Factory(t) {
				return new (t || _SharedStylesHost)(\u0275\u0275inject(DOCUMENT2), \u0275\u0275inject(APP_ID), \u0275\u0275inject(CSP_NONCE, 8), \u0275\u0275inject(PLATFORM_ID));
			 };
		  }
		  static {
			 this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
				token: _SharedStylesHost,
				factory: _SharedStylesHost.\u0275fac
			 });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SharedStylesHost, [{
			 type: Injectable
		  }], () => [{
			 type: Document,
			 decorators: [{
				type: Inject,
				args: [DOCUMENT2]
			 }]
		  }, {
			 type: void 0,
			 decorators: [{
				type: Inject,
				args: [APP_ID]
			 }]
		  }, {
			 type: void 0,
			 decorators: [{
				type: Inject,
				args: [CSP_NONCE]
			 }, {
				type: Optional
			 }]
		  }, {
			 type: void 0,
			 decorators: [{
				type: Inject,
				args: [PLATFORM_ID]
			 }]
		  }], null);
		})();
		var NAMESPACE_URIS = {
		  "svg": "http://www.w3.org/2000/svg",
		  "xhtml": "http://www.w3.org/1999/xhtml",
		  "xlink": "http://www.w3.org/1999/xlink",
		  "xml": "http://www.w3.org/XML/1998/namespace",
		  "xmlns": "http://www.w3.org/2000/xmlns/",
		  "math": "http://www.w3.org/1998/MathML/"
		};
		var COMPONENT_REGEX = /%COMP%/g;
		var COMPONENT_VARIABLE = "%COMP%";
		var HOST_ATTR = `_nghost-${COMPONENT_VARIABLE}`;
		var CONTENT_ATTR = `_ngcontent-${COMPONENT_VARIABLE}`;
		var REMOVE_STYLES_ON_COMPONENT_DESTROY_DEFAULT = true;
		var REMOVE_STYLES_ON_COMPONENT_DESTROY = new InjectionToken(ngDevMode ? "RemoveStylesOnCompDestroy" : "", {
		  providedIn: "root",
		  factory: () => REMOVE_STYLES_ON_COMPONENT_DESTROY_DEFAULT
		});
		function shimContentAttribute(componentShortId) {
		  return CONTENT_ATTR.replace(COMPONENT_REGEX, componentShortId);
		}
		function shimHostAttribute(componentShortId) {
		  return HOST_ATTR.replace(COMPONENT_REGEX, componentShortId);
		}
		function shimStylesContent(compId, styles) {
		  return styles.map((s) => s.replace(COMPONENT_REGEX, compId));
		}
		var DomRendererFactory2 = class _DomRendererFactory2 {
		  constructor(eventManager, sharedStylesHost, appId, removeStylesOnCompDestroy, doc, platformId, ngZone, nonce = null) {
			 this.eventManager = eventManager;
			 this.sharedStylesHost = sharedStylesHost;
			 this.appId = appId;
			 this.removeStylesOnCompDestroy = removeStylesOnCompDestroy;
			 this.doc = doc;
			 this.platformId = platformId;
			 this.ngZone = ngZone;
			 this.nonce = nonce;
			 this.rendererByCompId = /* @__PURE__ */ new Map();
			 this.platformIsServer = isPlatformServer(platformId);
			 this.defaultRenderer = new DefaultDomRenderer2(eventManager, doc, ngZone, this.platformIsServer);
		  }
		  createRenderer(element, type2) {
			 if (!element || !type2) {
				return this.defaultRenderer;
			 }
			 if (this.platformIsServer && type2.encapsulation === ViewEncapsulation$1.ShadowDom) {
				type2 = __spreadProps(__spreadValues({}, type2), {
				  encapsulation: ViewEncapsulation$1.Emulated
				});
			 }
			 const renderer = this.getOrCreateRenderer(element, type2);
			 if (renderer instanceof EmulatedEncapsulationDomRenderer2) {
				renderer.applyToHost(element);
			 } else if (renderer instanceof NoneEncapsulationDomRenderer) {
				renderer.applyStyles();
			 }
			 return renderer;
		  }
		  getOrCreateRenderer(element, type2) {
			 const rendererByCompId = this.rendererByCompId;
			 let renderer = rendererByCompId.get(type2.id);
			 if (!renderer) {
				const doc = this.doc;
				const ngZone = this.ngZone;
				const eventManager = this.eventManager;
				const sharedStylesHost = this.sharedStylesHost;
				const removeStylesOnCompDestroy = this.removeStylesOnCompDestroy;
				const platformIsServer = this.platformIsServer;
				switch (type2.encapsulation) {
				  case ViewEncapsulation$1.Emulated:
					 renderer = new EmulatedEncapsulationDomRenderer2(eventManager, sharedStylesHost, type2, this.appId, removeStylesOnCompDestroy, doc, ngZone, platformIsServer);
					 break;
				  case ViewEncapsulation$1.ShadowDom:
					 return new ShadowDomRenderer(eventManager, sharedStylesHost, element, type2, doc, ngZone, this.nonce, platformIsServer);
				  default:
					 renderer = new NoneEncapsulationDomRenderer(eventManager, sharedStylesHost, type2, removeStylesOnCompDestroy, doc, ngZone, platformIsServer);
					 break;
				}
				rendererByCompId.set(type2.id, renderer);
			 }
			 return renderer;
		  }
		  ngOnDestroy() {
			 this.rendererByCompId.clear();
		  }
		  static {
			 this.\u0275fac = function DomRendererFactory2_Factory(t) {
				return new (t || _DomRendererFactory2)(\u0275\u0275inject(EventManager), \u0275\u0275inject(SharedStylesHost), \u0275\u0275inject(APP_ID), \u0275\u0275inject(REMOVE_STYLES_ON_COMPONENT_DESTROY), \u0275\u0275inject(DOCUMENT2), \u0275\u0275inject(PLATFORM_ID), \u0275\u0275inject(NgZone), \u0275\u0275inject(CSP_NONCE));
			 };
		  }
		  static {
			 this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
				token: _DomRendererFactory2,
				factory: _DomRendererFactory2.\u0275fac
			 });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DomRendererFactory2, [{
			 type: Injectable
		  }], () => [{
			 type: EventManager
		  }, {
			 type: SharedStylesHost
		  }, {
			 type: void 0,
			 decorators: [{
				type: Inject,
				args: [APP_ID]
			 }]
		  }, {
			 type: void 0,
			 decorators: [{
				type: Inject,
				args: [REMOVE_STYLES_ON_COMPONENT_DESTROY]
			 }]
		  }, {
			 type: Document,
			 decorators: [{
				type: Inject,
				args: [DOCUMENT2]
			 }]
		  }, {
			 type: Object,
			 decorators: [{
				type: Inject,
				args: [PLATFORM_ID]
			 }]
		  }, {
			 type: NgZone
		  }, {
			 type: void 0,
			 decorators: [{
				type: Inject,
				args: [CSP_NONCE]
			 }]
		  }], null);
		})();
		var DefaultDomRenderer2 = class {
		  constructor(eventManager, doc, ngZone, platformIsServer) {
			 this.eventManager = eventManager;
			 this.doc = doc;
			 this.ngZone = ngZone;
			 this.platformIsServer = platformIsServer;
			 this.data = /* @__PURE__ */ Object.create(null);
			 this.throwOnSyntheticProps = true;
			 this.destroyNode = null;
		  }
		  destroy() {
		  }
		  createElement(name, namespace) {
			 if (namespace) {
				return this.doc.createElementNS(NAMESPACE_URIS[namespace] || namespace, name);
			 }
			 return this.doc.createElement(name);
		  }
		  createComment(value) {
			 return this.doc.createComment(value);
		  }
		  createText(value) {
			 return this.doc.createTextNode(value);
		  }
		  appendChild(parent, newChild) {
			 const targetParent = isTemplateNode(parent) ? parent.content : parent;
			 targetParent.appendChild(newChild);
		  }
		  insertBefore(parent, newChild, refChild) {
			 if (parent) {
				const targetParent = isTemplateNode(parent) ? parent.content : parent;
				targetParent.insertBefore(newChild, refChild);
			 }
		  }
		  removeChild(parent, oldChild) {
			 if (parent) {
				parent.removeChild(oldChild);
			 }
		  }
		  selectRootElement(selectorOrNode, preserveContent) {
			 let el = typeof selectorOrNode === "string" ? this.doc.querySelector(selectorOrNode) : selectorOrNode;
			 if (!el) {
				throw new RuntimeError(-5104, (typeof ngDevMode === "undefined" || ngDevMode) && `The selector "${selectorOrNode}" did not match any elements`);
			 }
			 if (!preserveContent) {
				el.textContent = "";
			 }
			 return el;
		  }
		  parentNode(node) {
			 return node.parentNode;
		  }
		  nextSibling(node) {
			 return node.nextSibling;
		  }
		  setAttribute(el, name, value, namespace) {
			 if (namespace) {
				name = namespace + ":" + name;
				const namespaceUri = NAMESPACE_URIS[namespace];
				if (namespaceUri) {
				  el.setAttributeNS(namespaceUri, name, value);
				} else {
				  el.setAttribute(name, value);
				}
			 } else {
				el.setAttribute(name, value);
			 }
		  }
		  removeAttribute(el, name, namespace) {
			 if (namespace) {
				const namespaceUri = NAMESPACE_URIS[namespace];
				if (namespaceUri) {
				  el.removeAttributeNS(namespaceUri, name);
				} else {
				  el.removeAttribute(`${namespace}:${name}`);
				}
			 } else {
				el.removeAttribute(name);
			 }
		  }
		  addClass(el, name) {
			 el.classList.add(name);
		  }
		  removeClass(el, name) {
			 el.classList.remove(name);
		  }
		  setStyle(el, style, value, flags) {
			 if (flags & (RendererStyleFlags2.DashCase | RendererStyleFlags2.Important)) {
				el.style.setProperty(style, value, flags & RendererStyleFlags2.Important ? "important" : "");
			 } else {
				el.style[style] = value;
			 }
		  }
		  removeStyle(el, style, flags) {
			 if (flags & RendererStyleFlags2.DashCase) {
				el.style.removeProperty(style);
			 } else {
				el.style[style] = "";
			 }
		  }
		  setProperty(el, name, value) {
			 if (el == null) {
				return;
			 }
			 (typeof ngDevMode === "undefined" || ngDevMode) && this.throwOnSyntheticProps && checkNoSyntheticProp(name, "property");
			 el[name] = value;
		  }
		  setValue(node, value) {
			 node.nodeValue = value;
		  }
		  listen(target, event, callback) {
			 (typeof ngDevMode === "undefined" || ngDevMode) && this.throwOnSyntheticProps && checkNoSyntheticProp(event, "listener");
			 if (typeof target === "string") {
				target = getDOM().getGlobalEventTarget(this.doc, target);
				if (!target) {
				  throw new Error(`Unsupported event target ${target} for event ${event}`);
				}
			 }
			 return this.eventManager.addEventListener(target, event, this.decoratePreventDefault(callback));
		  }
		  decoratePreventDefault(eventHandler) {
			 return (event) => {
				if (event === "__ngUnwrap__") {
				  return eventHandler;
				}
				const allowDefaultBehavior = this.platformIsServer ? this.ngZone.runGuarded(() => eventHandler(event)) : eventHandler(event);
				if (allowDefaultBehavior === false) {
				  event.preventDefault();
				}
				return void 0;
			 };
		  }
		};
		var AT_CHARCODE = (() => "@".charCodeAt(0))();
		function checkNoSyntheticProp(name, nameKind) {
		  if (name.charCodeAt(0) === AT_CHARCODE) {
			 throw new RuntimeError(5105, `Unexpected synthetic ${nameKind} ${name} found. Please make sure that:
		  - Either \`BrowserAnimationsModule\` or \`NoopAnimationsModule\` are imported in your application.
		  - There is corresponding configuration for the animation named \`${name}\` defined in the \`animations\` field of the \`@Component\` decorator (see https://angular.io/api/core/Component#animations).`);
		  }
		}
		function isTemplateNode(node) {
		  return node.tagName === "TEMPLATE" && node.content !== void 0;
		}
		var ShadowDomRenderer = class extends DefaultDomRenderer2 {
		  constructor(eventManager, sharedStylesHost, hostEl, component, doc, ngZone, nonce, platformIsServer) {
			 super(eventManager, doc, ngZone, platformIsServer);
			 this.sharedStylesHost = sharedStylesHost;
			 this.hostEl = hostEl;
			 this.shadowRoot = hostEl.attachShadow({
				mode: "open"
			 });
			 this.sharedStylesHost.addHost(this.shadowRoot);
			 const styles = shimStylesContent(component.id, component.styles);
			 for (const style of styles) {
				const styleEl = document.createElement("style");
				if (nonce) {
				  styleEl.setAttribute("nonce", nonce);
				}
				styleEl.textContent = style;
				this.shadowRoot.appendChild(styleEl);
			 }
		  }
		  nodeOrShadowRoot(node) {
			 return node === this.hostEl ? this.shadowRoot : node;
		  }
		  appendChild(parent, newChild) {
			 return super.appendChild(this.nodeOrShadowRoot(parent), newChild);
		  }
		  insertBefore(parent, newChild, refChild) {
			 return super.insertBefore(this.nodeOrShadowRoot(parent), newChild, refChild);
		  }
		  removeChild(parent, oldChild) {
			 return super.removeChild(this.nodeOrShadowRoot(parent), oldChild);
		  }
		  parentNode(node) {
			 return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(node)));
		  }
		  destroy() {
			 this.sharedStylesHost.removeHost(this.shadowRoot);
		  }
		};
		var NoneEncapsulationDomRenderer = class extends DefaultDomRenderer2 {
		  constructor(eventManager, sharedStylesHost, component, removeStylesOnCompDestroy, doc, ngZone, platformIsServer, compId) {
			 super(eventManager, doc, ngZone, platformIsServer);
			 this.sharedStylesHost = sharedStylesHost;
			 this.removeStylesOnCompDestroy = removeStylesOnCompDestroy;
			 this.styles = compId ? shimStylesContent(compId, component.styles) : component.styles;
		  }
		  applyStyles() {
			 this.sharedStylesHost.addStyles(this.styles);
		  }
		  destroy() {
			 if (!this.removeStylesOnCompDestroy) {
				return;
			 }
			 this.sharedStylesHost.removeStyles(this.styles);
		  }
		};
		var EmulatedEncapsulationDomRenderer2 = class extends NoneEncapsulationDomRenderer {
		  constructor(eventManager, sharedStylesHost, component, appId, removeStylesOnCompDestroy, doc, ngZone, platformIsServer) {
			 const compId = appId + "-" + component.id;
			 super(eventManager, sharedStylesHost, component, removeStylesOnCompDestroy, doc, ngZone, platformIsServer, compId);
			 this.contentAttr = shimContentAttribute(compId);
			 this.hostAttr = shimHostAttribute(compId);
		  }
		  applyToHost(element) {
			 this.applyStyles();
			 this.setAttribute(element, this.hostAttr, "");
		  }
		  createElement(parent, name) {
			 const el = super.createElement(parent, name);
			 super.setAttribute(el, this.contentAttr, "");
			 return el;
		  }
		};
		var DomEventsPlugin = class _DomEventsPlugin extends EventManagerPlugin {
		  constructor(doc) {
			 super(doc);
		  }
		  // This plugin should come last in the list of plugins, because it accepts all
		  // events.
		  supports(eventName) {
			 return true;
		  }
		  addEventListener(element, eventName, handler) {
			 element.addEventListener(eventName, handler, false);
			 return () => this.removeEventListener(element, eventName, handler);
		  }
		  removeEventListener(target, eventName, callback) {
			 return target.removeEventListener(eventName, callback);
		  }
		  static {
			 this.\u0275fac = function DomEventsPlugin_Factory(t) {
				return new (t || _DomEventsPlugin)(\u0275\u0275inject(DOCUMENT2));
			 };
		  }
		  static {
			 this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
				token: _DomEventsPlugin,
				factory: _DomEventsPlugin.\u0275fac
			 });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DomEventsPlugin, [{
			 type: Injectable
		  }], () => [{
			 type: void 0,
			 decorators: [{
				type: Inject,
				args: [DOCUMENT2]
			 }]
		  }], null);
		})();
		var MODIFIER_KEYS = ["alt", "control", "meta", "shift"];
		var _keyMap = {
		  "\b": "Backspace",
		  "	": "Tab",
		  "\x7F": "Delete",
		  "\x1B": "Escape",
		  "Del": "Delete",
		  "Esc": "Escape",
		  "Left": "ArrowLeft",
		  "Right": "ArrowRight",
		  "Up": "ArrowUp",
		  "Down": "ArrowDown",
		  "Menu": "ContextMenu",
		  "Scroll": "ScrollLock",
		  "Win": "OS"
		};
		var MODIFIER_KEY_GETTERS = {
		  "alt": (event) => event.altKey,
		  "control": (event) => event.ctrlKey,
		  "meta": (event) => event.metaKey,
		  "shift": (event) => event.shiftKey
		};
		var KeyEventsPlugin = class _KeyEventsPlugin extends EventManagerPlugin {
		  /**
			* Initializes an instance of the browser plug-in.
			* @param doc The document in which key events will be detected.
			*/
		  constructor(doc) {
			 super(doc);
		  }
		  /**
			* Reports whether a named key event is supported.
			* @param eventName The event name to query.
			* @return True if the named key event is supported.
			*/
		  supports(eventName) {
			 return _KeyEventsPlugin.parseEventName(eventName) != null;
		  }
		  /**
			* Registers a handler for a specific element and key event.
			* @param element The HTML element to receive event notifications.
			* @param eventName The name of the key event to listen for.
			* @param handler A function to call when the notification occurs. Receives the
			* event object as an argument.
			* @returns The key event that was registered.
			*/
		  addEventListener(element, eventName, handler) {
			 const parsedEvent = _KeyEventsPlugin.parseEventName(eventName);
			 const outsideHandler = _KeyEventsPlugin.eventCallback(parsedEvent["fullKey"], handler, this.manager.getZone());
			 return this.manager.getZone().runOutsideAngular(() => {
				return getDOM().onAndCancel(element, parsedEvent["domEventName"], outsideHandler);
			 });
		  }
		  /**
			* Parses the user provided full keyboard event definition and normalizes it for
			* later internal use. It ensures the string is all lowercase, converts special
			* characters to a standard spelling, and orders all the values consistently.
			*
			* @param eventName The name of the key event to listen for.
			* @returns an object with the full, normalized string, and the dom event name
			* or null in the case when the event doesn't match a keyboard event.
			*/
		  static parseEventName(eventName) {
			 const parts = eventName.toLowerCase().split(".");
			 const domEventName = parts.shift();
			 if (parts.length === 0 || !(domEventName === "keydown" || domEventName === "keyup")) {
				return null;
			 }
			 const key = _KeyEventsPlugin._normalizeKey(parts.pop());
			 let fullKey = "";
			 let codeIX = parts.indexOf("code");
			 if (codeIX > -1) {
				parts.splice(codeIX, 1);
				fullKey = "code.";
			 }
			 MODIFIER_KEYS.forEach((modifierName) => {
				const index = parts.indexOf(modifierName);
				if (index > -1) {
				  parts.splice(index, 1);
				  fullKey += modifierName + ".";
				}
			 });
			 fullKey += key;
			 if (parts.length != 0 || key.length === 0) {
				return null;
			 }
			 const result = {};
			 result["domEventName"] = domEventName;
			 result["fullKey"] = fullKey;
			 return result;
		  }
		  /**
			* Determines whether the actual keys pressed match the configured key code string.
			* The `fullKeyCode` event is normalized in the `parseEventName` method when the
			* event is attached to the DOM during the `addEventListener` call. This is unseen
			* by the end user and is normalized for internal consistency and parsing.
			*
			* @param event The keyboard event.
			* @param fullKeyCode The normalized user defined expected key event string
			* @returns boolean.
			*/
		  static matchEventFullKeyCode(event, fullKeyCode) {
			 let keycode = _keyMap[event.key] || event.key;
			 let key = "";
			 if (fullKeyCode.indexOf("code.") > -1) {
				keycode = event.code;
				key = "code.";
			 }
			 if (keycode == null || !keycode)
				return false;
			 keycode = keycode.toLowerCase();
			 if (keycode === " ") {
				keycode = "space";
			 } else if (keycode === ".") {
				keycode = "dot";
			 }
			 MODIFIER_KEYS.forEach((modifierName) => {
				if (modifierName !== keycode) {
				  const modifierGetter = MODIFIER_KEY_GETTERS[modifierName];
				  if (modifierGetter(event)) {
					 key += modifierName + ".";
				  }
				}
			 });
			 key += keycode;
			 return key === fullKeyCode;
		  }
		  /**
			* Configures a handler callback for a key event.
			* @param fullKey The event name that combines all simultaneous keystrokes.
			* @param handler The function that responds to the key event.
			* @param zone The zone in which the event occurred.
			* @returns A callback function.
			*/
		  static eventCallback(fullKey, handler, zone) {
			 return (event) => {
				if (_KeyEventsPlugin.matchEventFullKeyCode(event, fullKey)) {
				  zone.runGuarded(() => handler(event));
				}
			 };
		  }
		  /** @internal */
		  static _normalizeKey(keyName) {
			 return keyName === "esc" ? "escape" : keyName;
		  }
		  static {
			 this.\u0275fac = function KeyEventsPlugin_Factory(t) {
				return new (t || _KeyEventsPlugin)(\u0275\u0275inject(DOCUMENT2));
			 };
		  }
		  static {
			 this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
				token: _KeyEventsPlugin,
				factory: _KeyEventsPlugin.\u0275fac
			 });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(KeyEventsPlugin, [{
			 type: Injectable
		  }], () => [{
			 type: void 0,
			 decorators: [{
				type: Inject,
				args: [DOCUMENT2]
			 }]
		  }], null);
		})();
		function createApplication(options) {
		  return internalCreateApplication(createProvidersConfig(options));
		}
		function createProvidersConfig(options) {
		  return {
			 appProviders: [...BROWSER_MODULE_PROVIDERS, ...options?.providers ?? []],
			 platformProviders: INTERNAL_BROWSER_PLATFORM_PROVIDERS
		  };
		}
		function initDomAdapter() {
		  BrowserDomAdapter.makeCurrent();
		}
		function errorHandler() {
		  return new ErrorHandler();
		}
		function _document() {
		  setDocument(document);
		  return document;
		}
		var INTERNAL_BROWSER_PLATFORM_PROVIDERS = [{
		  provide: PLATFORM_ID,
		  useValue: PLATFORM_BROWSER_ID
		}, {
		  provide: PLATFORM_INITIALIZER,
		  useValue: initDomAdapter,
		  multi: true
		}, {
		  provide: DOCUMENT2,
		  useFactory: _document,
		  deps: []
		}];
		var platformBrowser = createPlatformFactory(platformCore, "browser", INTERNAL_BROWSER_PLATFORM_PROVIDERS);
		var BROWSER_MODULE_PROVIDERS_MARKER = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "BrowserModule Providers Marker" : "");
		var TESTABILITY_PROVIDERS = [{
		  provide: TESTABILITY_GETTER,
		  useClass: BrowserGetTestability,
		  deps: []
		}, {
		  provide: TESTABILITY,
		  useClass: Testability,
		  deps: [NgZone, TestabilityRegistry, TESTABILITY_GETTER]
		}, {
		  provide: Testability,
		  // Also provide as `Testability` for backwards-compatibility.
		  useClass: Testability,
		  deps: [NgZone, TestabilityRegistry, TESTABILITY_GETTER]
		}];
		var BROWSER_MODULE_PROVIDERS = [{
		  provide: INJECTOR_SCOPE,
		  useValue: "root"
		}, {
		  provide: ErrorHandler,
		  useFactory: errorHandler,
		  deps: []
		}, {
		  provide: EVENT_MANAGER_PLUGINS,
		  useClass: DomEventsPlugin,
		  multi: true,
		  deps: [DOCUMENT2, NgZone, PLATFORM_ID]
		}, {
		  provide: EVENT_MANAGER_PLUGINS,
		  useClass: KeyEventsPlugin,
		  multi: true,
		  deps: [DOCUMENT2]
		}, DomRendererFactory2, SharedStylesHost, EventManager, {
		  provide: RendererFactory2,
		  useExisting: DomRendererFactory2
		}, {
		  provide: XhrFactory,
		  useClass: BrowserXhr,
		  deps: []
		}, typeof ngDevMode === "undefined" || ngDevMode ? {
		  provide: BROWSER_MODULE_PROVIDERS_MARKER,
		  useValue: true
		} : []];
		var BrowserModule = class _BrowserModule {
		  constructor(providersAlreadyPresent) {
			 if ((typeof ngDevMode === "undefined" || ngDevMode) && providersAlreadyPresent) {
				throw new RuntimeError(5100, `Providers from the \`BrowserModule\` have already been loaded. If you need access to common directives such as NgIf and NgFor, import the \`CommonModule\` instead.`);
			 }
		  }
		  /**
			* Configures a browser-based app to transition from a server-rendered app, if
			* one is present on the page.
			*
			* @param params An object containing an identifier for the app to transition.
			* The ID must match between the client and server versions of the app.
			* @returns The reconfigured `BrowserModule` to import into the app's root `AppModule`.
			*
			* @deprecated Use {@link APP_ID} instead to set the application ID.
			*/
		  static withServerTransition(params) {
			 return {
				ngModule: _BrowserModule,
				providers: [{
				  provide: APP_ID,
				  useValue: params.appId
				}]
			 };
		  }
		  static {
			 this.\u0275fac = function BrowserModule_Factory(t) {
				return new (t || _BrowserModule)(\u0275\u0275inject(BROWSER_MODULE_PROVIDERS_MARKER, 12));
			 };
		  }
		  static {
			 this.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
				type: _BrowserModule
			 });
		  }
		  static {
			 this.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
				providers: [...BROWSER_MODULE_PROVIDERS, ...TESTABILITY_PROVIDERS],
				imports: [CommonModule, ApplicationModule]
			 });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BrowserModule, [{
			 type: NgModule,
			 args: [{
				providers: [...BROWSER_MODULE_PROVIDERS, ...TESTABILITY_PROVIDERS],
				exports: [CommonModule, ApplicationModule]
			 }]
		  }], () => [{
			 type: void 0,
			 decorators: [{
				type: Optional
			 }, {
				type: SkipSelf
			 }, {
				type: Inject,
				args: [BROWSER_MODULE_PROVIDERS_MARKER]
			 }]
		  }], null);
		})();
		var Meta = class _Meta {
		  constructor(_doc) {
			 this._doc = _doc;
			 this._dom = getDOM();
		  }
		  /**
			* Retrieves or creates a specific `<meta>` tag element in the current HTML document.
			* In searching for an existing tag, Angular attempts to match the `name` or `property` attribute
			* values in the provided tag definition, and verifies that all other attribute values are equal.
			* If an existing element is found, it is returned and is not modified in any way.
			* @param tag The definition of a `<meta>` element to match or create.
			* @param forceCreation True to create a new element without checking whether one already exists.
			* @returns The existing element with the same attributes and values if found,
			* the new element if no match is found, or `null` if the tag parameter is not defined.
			*/
		  addTag(tag, forceCreation = false) {
			 if (!tag)
				return null;
			 return this._getOrCreateElement(tag, forceCreation);
		  }
		  /**
			* Retrieves or creates a set of `<meta>` tag elements in the current HTML document.
			* In searching for an existing tag, Angular attempts to match the `name` or `property` attribute
			* values in the provided tag definition, and verifies that all other attribute values are equal.
			* @param tags An array of tag definitions to match or create.
			* @param forceCreation True to create new elements without checking whether they already exist.
			* @returns The matching elements if found, or the new elements.
			*/
		  addTags(tags, forceCreation = false) {
			 if (!tags)
				return [];
			 return tags.reduce((result, tag) => {
				if (tag) {
				  result.push(this._getOrCreateElement(tag, forceCreation));
				}
				return result;
			 }, []);
		  }
		  /**
			* Retrieves a `<meta>` tag element in the current HTML document.
			* @param attrSelector The tag attribute and value to match against, in the format
			* `"tag_attribute='value string'"`.
			* @returns The matching element, if any.
			*/
		  getTag(attrSelector) {
			 if (!attrSelector)
				return null;
			 return this._doc.querySelector(`meta[${attrSelector}]`) || null;
		  }
		  /**
			* Retrieves a set of `<meta>` tag elements in the current HTML document.
			* @param attrSelector The tag attribute and value to match against, in the format
			* `"tag_attribute='value string'"`.
			* @returns The matching elements, if any.
			*/
		  getTags(attrSelector) {
			 if (!attrSelector)
				return [];
			 const list = this._doc.querySelectorAll(`meta[${attrSelector}]`);
			 return list ? [].slice.call(list) : [];
		  }
		  /**
			* Modifies an existing `<meta>` tag element in the current HTML document.
			* @param tag The tag description with which to replace the existing tag content.
			* @param selector A tag attribute and value to match against, to identify
			* an existing tag. A string in the format `"tag_attribute=`value string`"`.
			* If not supplied, matches a tag with the same `name` or `property` attribute value as the
			* replacement tag.
			* @return The modified element.
			*/
		  updateTag(tag, selector) {
			 if (!tag)
				return null;
			 selector = selector || this._parseSelector(tag);
			 const meta = this.getTag(selector);
			 if (meta) {
				return this._setMetaElementAttributes(tag, meta);
			 }
			 return this._getOrCreateElement(tag, true);
		  }
		  /**
			* Removes an existing `<meta>` tag element from the current HTML document.
			* @param attrSelector A tag attribute and value to match against, to identify
			* an existing tag. A string in the format `"tag_attribute=`value string`"`.
			*/
		  removeTag(attrSelector) {
			 this.removeTagElement(this.getTag(attrSelector));
		  }
		  /**
			* Removes an existing `<meta>` tag element from the current HTML document.
			* @param meta The tag definition to match against to identify an existing tag.
			*/
		  removeTagElement(meta) {
			 if (meta) {
				this._dom.remove(meta);
			 }
		  }
		  _getOrCreateElement(meta, forceCreation = false) {
			 if (!forceCreation) {
				const selector = this._parseSelector(meta);
				const elem2 = this.getTags(selector).filter((elem3) => this._containsAttributes(meta, elem3))[0];
				if (elem2 !== void 0)
				  return elem2;
			 }
			 const element = this._dom.createElement("meta");
			 this._setMetaElementAttributes(meta, element);
			 const head = this._doc.getElementsByTagName("head")[0];
			 head.appendChild(element);
			 return element;
		  }
		  _setMetaElementAttributes(tag, el) {
			 Object.keys(tag).forEach((prop) => el.setAttribute(this._getMetaKeyMap(prop), tag[prop]));
			 return el;
		  }
		  _parseSelector(tag) {
			 const attr = tag.name ? "name" : "property";
			 return `${attr}="${tag[attr]}"`;
		  }
		  _containsAttributes(tag, elem2) {
			 return Object.keys(tag).every((key) => elem2.getAttribute(this._getMetaKeyMap(key)) === tag[key]);
		  }
		  _getMetaKeyMap(prop) {
			 return META_KEYS_MAP[prop] || prop;
		  }
		  static {
			 this.\u0275fac = function Meta_Factory(t) {
				return new (t || _Meta)(\u0275\u0275inject(DOCUMENT2));
			 };
		  }
		  static {
			 this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
				token: _Meta,
				factory: _Meta.\u0275fac,
				providedIn: "root"
			 });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Meta, [{
			 type: Injectable,
			 args: [{
				providedIn: "root"
			 }]
		  }], () => [{
			 type: void 0,
			 decorators: [{
				type: Inject,
				args: [DOCUMENT2]
			 }]
		  }], null);
		})();
		var META_KEYS_MAP = {
		  httpEquiv: "http-equiv"
		};
		var Title = class _Title {
		  constructor(_doc) {
			 this._doc = _doc;
		  }
		  /**
			* Get the title of the current HTML document.
			*/
		  getTitle() {
			 return this._doc.title;
		  }
		  /**
			* Set the title of the current HTML document.
			* @param newTitle
			*/
		  setTitle(newTitle) {
			 this._doc.title = newTitle || "";
		  }
		  static {
			 this.\u0275fac = function Title_Factory(t) {
				return new (t || _Title)(\u0275\u0275inject(DOCUMENT2));
			 };
		  }
		  static {
			 this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
				token: _Title,
				factory: _Title.\u0275fac,
				providedIn: "root"
			 });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Title, [{
			 type: Injectable,
			 args: [{
				providedIn: "root"
			 }]
		  }], () => [{
			 type: void 0,
			 decorators: [{
				type: Inject,
				args: [DOCUMENT2]
			 }]
		  }], null);
		})();
		var EVENT_NAMES = {
		  // pan
		  "pan": true,
		  "panstart": true,
		  "panmove": true,
		  "panend": true,
		  "pancancel": true,
		  "panleft": true,
		  "panright": true,
		  "panup": true,
		  "pandown": true,
		  // pinch
		  "pinch": true,
		  "pinchstart": true,
		  "pinchmove": true,
		  "pinchend": true,
		  "pinchcancel": true,
		  "pinchin": true,
		  "pinchout": true,
		  // press
		  "press": true,
		  "pressup": true,
		  // rotate
		  "rotate": true,
		  "rotatestart": true,
		  "rotatemove": true,
		  "rotateend": true,
		  "rotatecancel": true,
		  // swipe
		  "swipe": true,
		  "swipeleft": true,
		  "swiperight": true,
		  "swipeup": true,
		  "swipedown": true,
		  // tap
		  "tap": true,
		  "doubletap": true
		};
		var HAMMER_GESTURE_CONFIG = new InjectionToken("HammerGestureConfig");
		var HAMMER_LOADER = new InjectionToken("HammerLoader");
		var HammerGestureConfig = class _HammerGestureConfig {
		  constructor() {
			 this.events = [];
			 this.overrides = {};
		  }
		  /**
			* Creates a [HammerJS Manager](https://hammerjs.github.io/api/#hammermanager)
			* and attaches it to a given HTML element.
			* @param element The element that will recognize gestures.
			* @returns A HammerJS event-manager object.
			*/
		  buildHammer(element) {
			 const mc = new Hammer(element, this.options);
			 mc.get("pinch").set({
				enable: true
			 });
			 mc.get("rotate").set({
				enable: true
			 });
			 for (const eventName in this.overrides) {
				mc.get(eventName).set(this.overrides[eventName]);
			 }
			 return mc;
		  }
		  static {
			 this.\u0275fac = function HammerGestureConfig_Factory(t) {
				return new (t || _HammerGestureConfig)();
			 };
		  }
		  static {
			 this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
				token: _HammerGestureConfig,
				factory: _HammerGestureConfig.\u0275fac
			 });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HammerGestureConfig, [{
			 type: Injectable
		  }], null, null);
		})();
		var HammerGesturesPlugin = class _HammerGesturesPlugin extends EventManagerPlugin {
		  constructor(doc, _config, console2, loader) {
			 super(doc);
			 this._config = _config;
			 this.console = console2;
			 this.loader = loader;
			 this._loaderPromise = null;
		  }
		  supports(eventName) {
			 if (!EVENT_NAMES.hasOwnProperty(eventName.toLowerCase()) && !this.isCustomEvent(eventName)) {
				return false;
			 }
			 if (!window.Hammer && !this.loader) {
				if (typeof ngDevMode === "undefined" || ngDevMode) {
				  this.console.warn(`The "${eventName}" event cannot be bound because Hammer.JS is not loaded and no custom loader has been specified.`);
				}
				return false;
			 }
			 return true;
		  }
		  addEventListener(element, eventName, handler) {
			 const zone = this.manager.getZone();
			 eventName = eventName.toLowerCase();
			 if (!window.Hammer && this.loader) {
				this._loaderPromise = this._loaderPromise || zone.runOutsideAngular(() => this.loader());
				let cancelRegistration = false;
				let deregister = () => {
				  cancelRegistration = true;
				};
				zone.runOutsideAngular(() => this._loaderPromise.then(() => {
				  if (!window.Hammer) {
					 if (typeof ngDevMode === "undefined" || ngDevMode) {
						this.console.warn(`The custom HAMMER_LOADER completed, but Hammer.JS is not present.`);
					 }
					 deregister = () => {
					 };
					 return;
				  }
				  if (!cancelRegistration) {
					 deregister = this.addEventListener(element, eventName, handler);
				  }
				}).catch(() => {
				  if (typeof ngDevMode === "undefined" || ngDevMode) {
					 this.console.warn(`The "${eventName}" event cannot be bound because the custom Hammer.JS loader failed.`);
				  }
				  deregister = () => {
				  };
				}));
				return () => {
				  deregister();
				};
			 }
			 return zone.runOutsideAngular(() => {
				const mc = this._config.buildHammer(element);
				const callback = function(eventObj) {
				  zone.runGuarded(function() {
					 handler(eventObj);
				  });
				};
				mc.on(eventName, callback);
				return () => {
				  mc.off(eventName, callback);
				  if (typeof mc.destroy === "function") {
					 mc.destroy();
				  }
				};
			 });
		  }
		  isCustomEvent(eventName) {
			 return this._config.events.indexOf(eventName) > -1;
		  }
		  static {
			 this.\u0275fac = function HammerGesturesPlugin_Factory(t) {
				return new (t || _HammerGesturesPlugin)(\u0275\u0275inject(DOCUMENT2), \u0275\u0275inject(HAMMER_GESTURE_CONFIG), \u0275\u0275inject(Console), \u0275\u0275inject(HAMMER_LOADER, 8));
			 };
		  }
		  static {
			 this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
				token: _HammerGesturesPlugin,
				factory: _HammerGesturesPlugin.\u0275fac
			 });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HammerGesturesPlugin, [{
			 type: Injectable
		  }], () => [{
			 type: void 0,
			 decorators: [{
				type: Inject,
				args: [DOCUMENT2]
			 }]
		  }, {
			 type: HammerGestureConfig,
			 decorators: [{
				type: Inject,
				args: [HAMMER_GESTURE_CONFIG]
			 }]
		  }, {
			 type: Console
		  }, {
			 type: void 0,
			 decorators: [{
				type: Optional
			 }, {
				type: Inject,
				args: [HAMMER_LOADER]
			 }]
		  }], null);
		})();
		var HammerModule = class _HammerModule {
		  static {
			 this.\u0275fac = function HammerModule_Factory(t) {
				return new (t || _HammerModule)();
			 };
		  }
		  static {
			 this.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
				type: _HammerModule
			 });
		  }
		  static {
			 this.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
				providers: [{
				  provide: EVENT_MANAGER_PLUGINS,
				  useClass: HammerGesturesPlugin,
				  multi: true,
				  deps: [DOCUMENT2, HAMMER_GESTURE_CONFIG, Console, [new Optional(), HAMMER_LOADER]]
				}, {
				  provide: HAMMER_GESTURE_CONFIG,
				  useClass: HammerGestureConfig,
				  deps: []
				}]
			 });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HammerModule, [{
			 type: NgModule,
			 args: [{
				providers: [{
				  provide: EVENT_MANAGER_PLUGINS,
				  useClass: HammerGesturesPlugin,
				  multi: true,
				  deps: [DOCUMENT2, HAMMER_GESTURE_CONFIG, Console, [new Optional(), HAMMER_LOADER]]
				}, {
				  provide: HAMMER_GESTURE_CONFIG,
				  useClass: HammerGestureConfig,
				  deps: []
				}]
			 }]
		  }], null, null);
		})();
		var DomSanitizer = class _DomSanitizer {
		  static {
			 this.\u0275fac = function DomSanitizer_Factory(t) {
				return new (t || _DomSanitizer)();
			 };
		  }
		  static {
			 this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
				token: _DomSanitizer,
				factory: function DomSanitizer_Factory(t) {
				  let r = null;
				  if (t) {
					 r = new (t || _DomSanitizer)();
				  } else {
					 r = \u0275\u0275inject(DomSanitizerImpl);
				  }
				  return r;
				},
				providedIn: "root"
			 });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DomSanitizer, [{
			 type: Injectable,
			 args: [{
				providedIn: "root",
				useExisting: forwardRef(() => DomSanitizerImpl)
			 }]
		  }], null, null);
		})();
		var DomSanitizerImpl = class _DomSanitizerImpl extends DomSanitizer {
		  constructor(_doc) {
			 super();
			 this._doc = _doc;
		  }
		  sanitize(ctx, value) {
			 if (value == null)
				return null;
			 switch (ctx) {
				case SecurityContext.NONE:
				  return value;
				case SecurityContext.HTML:
				  if (allowSanitizationBypassAndThrow(
					 value,
					 "HTML"
					 /* BypassType.Html */
				  )) {
					 return unwrapSafeValue(value);
				  }
				  return _sanitizeHtml(this._doc, String(value)).toString();
				case SecurityContext.STYLE:
				  if (allowSanitizationBypassAndThrow(
					 value,
					 "Style"
					 /* BypassType.Style */
				  )) {
					 return unwrapSafeValue(value);
				  }
				  return value;
				case SecurityContext.SCRIPT:
				  if (allowSanitizationBypassAndThrow(
					 value,
					 "Script"
					 /* BypassType.Script */
				  )) {
					 return unwrapSafeValue(value);
				  }
				  throw new RuntimeError(5200, (typeof ngDevMode === "undefined" || ngDevMode) && "unsafe value used in a script context");
				case SecurityContext.URL:
				  if (allowSanitizationBypassAndThrow(
					 value,
					 "URL"
					 /* BypassType.Url */
				  )) {
					 return unwrapSafeValue(value);
				  }
				  return _sanitizeUrl(String(value));
				case SecurityContext.RESOURCE_URL:
				  if (allowSanitizationBypassAndThrow(
					 value,
					 "ResourceURL"
					 /* BypassType.ResourceUrl */
				  )) {
					 return unwrapSafeValue(value);
				  }
				  throw new RuntimeError(5201, (typeof ngDevMode === "undefined" || ngDevMode) && `unsafe value used in a resource URL context (see ${XSS_SECURITY_URL})`);
				default:
				  throw new RuntimeError(5202, (typeof ngDevMode === "undefined" || ngDevMode) && `Unexpected SecurityContext ${ctx} (see ${XSS_SECURITY_URL})`);
			 }
		  }
		  bypassSecurityTrustHtml(value) {
			 return bypassSanitizationTrustHtml(value);
		  }
		  bypassSecurityTrustStyle(value) {
			 return bypassSanitizationTrustStyle(value);
		  }
		  bypassSecurityTrustScript(value) {
			 return bypassSanitizationTrustScript(value);
		  }
		  bypassSecurityTrustUrl(value) {
			 return bypassSanitizationTrustUrl(value);
		  }
		  bypassSecurityTrustResourceUrl(value) {
			 return bypassSanitizationTrustResourceUrl(value);
		  }
		  static {
			 this.\u0275fac = function DomSanitizerImpl_Factory(t) {
				return new (t || _DomSanitizerImpl)(\u0275\u0275inject(DOCUMENT2));
			 };
		  }
		  static {
			 this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
				token: _DomSanitizerImpl,
				factory: _DomSanitizerImpl.\u0275fac,
				providedIn: "root"
			 });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DomSanitizerImpl, [{
			 type: Injectable,
			 args: [{
				providedIn: "root"
			 }]
		  }], () => [{
			 type: void 0,
			 decorators: [{
				type: Inject,
				args: [DOCUMENT2]
			 }]
		  }], null);
		})();
		var HydrationFeatureKind;
		(function(HydrationFeatureKind2) {
		  HydrationFeatureKind2[HydrationFeatureKind2["NoHttpTransferCache"] = 0] = "NoHttpTransferCache";
		  HydrationFeatureKind2[HydrationFeatureKind2["HttpTransferCacheOptions"] = 1] = "HttpTransferCacheOptions";
		})(HydrationFeatureKind || (HydrationFeatureKind = {}));
		var VERSION4 = new Version("17.3.12");

		// node_modules/zone.js/fesm2015/zone.js
		var global2 = globalThis;
		function __symbol__(name) {
		  const symbolPrefix = global2["__Zone_symbol_prefix"] || "__zone_symbol__";
		  return symbolPrefix + name;
		}
		function initZone() {
		  const performance2 = global2["performance"];
		  function mark(name) {
			 performance2 && performance2["mark"] && performance2["mark"](name);
		  }
		  function performanceMeasure(name, label) {
			 performance2 && performance2["measure"] && performance2["measure"](name, label);
		  }
		  mark("Zone");
		  class ZoneImpl {
			 static {
				this.__symbol__ = __symbol__;
			 }
			 static assertZonePatched() {
				if (global2["Promise"] !== patches["ZoneAwarePromise"]) {
				  throw new Error("Zone.js has detected that ZoneAwarePromise `(window|copyGlobalForElem).Promise` has been overwritten.\nMost likely cause is that a Promise polyfill has been loaded after Zone.js (Polyfilling Promise api is not necessary when zone.js is loaded. If you must load one, do so before loading zone.js.)");
				}
			 }
			 static get root() {
				let zone = ZoneImpl.current;
				while (zone.parent) {
				  zone = zone.parent;
				}
				return zone;
			 }
			 static get current() {
				return _currentZoneFrame.zone;
			 }
			 static get currentTask() {
				return _currentTask;
			 }
			 // tslint:disable-next-line:require-internal-with-underscore
			 static __load_patch(name, fn, ignoreDuplicate = false) {
				if (patches.hasOwnProperty(name)) {
				  const checkDuplicate = global2[__symbol__("forceDuplicateZoneCheck")] === true;
				  if (!ignoreDuplicate && checkDuplicate) {
					 throw Error("Already loaded patch: " + name);
				  }
				} else if (!global2["__Zone_disable_" + name]) {
				  const perfName = "Zone:" + name;
				  mark(perfName);
				  patches[name] = fn(global2, ZoneImpl, _api);
				  performanceMeasure(perfName, perfName);
				}
			 }
			 get parent() {
				return this._parent;
			 }
			 get name() {
				return this._name;
			 }
			 constructor(parent, zoneSpec) {
				this._parent = parent;
				this._name = zoneSpec ? zoneSpec.name || "unnamed" : "<root>";
				this._properties = zoneSpec && zoneSpec.properties || {};
				this._zoneDelegate = new _ZoneDelegate(this, this._parent && this._parent._zoneDelegate, zoneSpec);
			 }
			 get(key) {
				const zone = this.getZoneWith(key);
				if (zone)
				  return zone._properties[key];
			 }
			 getZoneWith(key) {
				let current = this;
				while (current) {
				  if (current._properties.hasOwnProperty(key)) {
					 return current;
				  }
				  current = current._parent;
				}
				return null;
			 }
			 fork(zoneSpec) {
				if (!zoneSpec)
				  throw new Error("ZoneSpec required!");
				return this._zoneDelegate.fork(this, zoneSpec);
			 }
			 wrap(callback, source) {
				if (typeof callback !== "function") {
				  throw new Error("Expecting function got: " + callback);
				}
				const _callback = this._zoneDelegate.intercept(this, callback, source);
				const zone = this;
				return function() {
				  return zone.runGuarded(_callback, this, arguments, source);
				};
			 }
			 run(callback, applyThis, applyArgs, source) {
				_currentZoneFrame = { parent: _currentZoneFrame, zone: this };
				try {
				  return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);
				} finally {
				  _currentZoneFrame = _currentZoneFrame.parent;
				}
			 }
			 runGuarded(callback, applyThis = null, applyArgs, source) {
				_currentZoneFrame = { parent: _currentZoneFrame, zone: this };
				try {
				  try {
					 return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);
				  } catch (error) {
					 if (this._zoneDelegate.handleError(this, error)) {
						throw error;
					 }
				  }
				} finally {
				  _currentZoneFrame = _currentZoneFrame.parent;
				}
			 }
			 runTask(task, applyThis, applyArgs) {
				if (task.zone != this) {
				  throw new Error("A task can only be run in the zone of creation! (Creation: " + (task.zone || NO_ZONE).name + "; Execution: " + this.name + ")");
				}
				const zoneTask = task;
				const { type: type2, data: { isPeriodic = false, isRefreshable = false } = {} } = task;
				if (task.state === notScheduled && (type2 === eventTask || type2 === macroTask)) {
				  return;
				}
				const reEntryGuard = task.state != running;
				reEntryGuard && zoneTask._transitionTo(running, scheduled2);
				const previousTask = _currentTask;
				_currentTask = zoneTask;
				_currentZoneFrame = { parent: _currentZoneFrame, zone: this };
				try {
				  if (type2 == macroTask && task.data && !isPeriodic && !isRefreshable) {
					 task.cancelFn = void 0;
				  }
				  try {
					 return this._zoneDelegate.invokeTask(this, zoneTask, applyThis, applyArgs);
				  } catch (error) {
					 if (this._zoneDelegate.handleError(this, error)) {
						throw error;
					 }
				  }
				} finally {
				  const state = task.state;
				  if (state !== notScheduled && state !== unknown) {
					 if (type2 == eventTask || isPeriodic || isRefreshable && state === scheduling) {
						reEntryGuard && zoneTask._transitionTo(scheduled2, running, scheduling);
					 } else {
						const zoneDelegates = zoneTask._zoneDelegates;
						this._updateTaskCount(zoneTask, -1);
						reEntryGuard && zoneTask._transitionTo(notScheduled, running, notScheduled);
						if (isRefreshable) {
						  zoneTask._zoneDelegates = zoneDelegates;
						}
					 }
				  }
				  _currentZoneFrame = _currentZoneFrame.parent;
				  _currentTask = previousTask;
				}
			 }
			 scheduleTask(task) {
				if (task.zone && task.zone !== this) {
				  let newZone = this;
				  while (newZone) {
					 if (newZone === task.zone) {
						throw Error(`can not reschedule task to ${this.name} which is descendants of the original zone ${task.zone.name}`);
					 }
					 newZone = newZone.parent;
				  }
				}
				task._transitionTo(scheduling, notScheduled);
				const zoneDelegates = [];
				task._zoneDelegates = zoneDelegates;
				task._zone = this;
				try {
				  task = this._zoneDelegate.scheduleTask(this, task);
				} catch (err) {
				  task._transitionTo(unknown, scheduling, notScheduled);
				  this._zoneDelegate.handleError(this, err);
				  throw err;
				}
				if (task._zoneDelegates === zoneDelegates) {
				  this._updateTaskCount(task, 1);
				}
				if (task.state == scheduling) {
				  task._transitionTo(scheduled2, scheduling);
				}
				return task;
			 }
			 scheduleMicroTask(source, callback, data, customSchedule) {
				return this.scheduleTask(new ZoneTask(microTask, source, callback, data, customSchedule, void 0));
			 }
			 scheduleMacroTask(source, callback, data, customSchedule, customCancel) {
				return this.scheduleTask(new ZoneTask(macroTask, source, callback, data, customSchedule, customCancel));
			 }
			 scheduleEventTask(source, callback, data, customSchedule, customCancel) {
				return this.scheduleTask(new ZoneTask(eventTask, source, callback, data, customSchedule, customCancel));
			 }
			 cancelTask(task) {
				if (task.zone != this)
				  throw new Error("A task can only be cancelled in the zone of creation! (Creation: " + (task.zone || NO_ZONE).name + "; Execution: " + this.name + ")");
				if (task.state !== scheduled2 && task.state !== running) {
				  return;
				}
				task._transitionTo(canceling, scheduled2, running);
				try {
				  this._zoneDelegate.cancelTask(this, task);
				} catch (err) {
				  task._transitionTo(unknown, canceling);
				  this._zoneDelegate.handleError(this, err);
				  throw err;
				}
				this._updateTaskCount(task, -1);
				task._transitionTo(notScheduled, canceling);
				task.runCount = -1;
				return task;
			 }
			 _updateTaskCount(task, count) {
				const zoneDelegates = task._zoneDelegates;
				if (count == -1) {
				  task._zoneDelegates = null;
				}
				for (let i = 0; i < zoneDelegates.length; i++) {
				  zoneDelegates[i]._updateTaskCount(task.type, count);
				}
			 }
		  }
		  const DELEGATE_ZS = {
			 name: "",
			 onHasTask: (delegate, _2, target, hasTaskState) => delegate.hasTask(target, hasTaskState),
			 onScheduleTask: (delegate, _2, target, task) => delegate.scheduleTask(target, task),
			 onInvokeTask: (delegate, _2, target, task, applyThis, applyArgs) => delegate.invokeTask(target, task, applyThis, applyArgs),
			 onCancelTask: (delegate, _2, target, task) => delegate.cancelTask(target, task)
		  };
		  class _ZoneDelegate {
			 get zone() {
				return this._zone;
			 }
			 constructor(zone, parentDelegate, zoneSpec) {
				this._taskCounts = {
				  "microTask": 0,
				  "macroTask": 0,
				  "eventTask": 0
				};
				this._zone = zone;
				this._parentDelegate = parentDelegate;
				this._forkZS = zoneSpec && (zoneSpec && zoneSpec.onFork ? zoneSpec : parentDelegate._forkZS);
				this._forkDlgt = zoneSpec && (zoneSpec.onFork ? parentDelegate : parentDelegate._forkDlgt);
				this._forkCurrZone = zoneSpec && (zoneSpec.onFork ? this._zone : parentDelegate._forkCurrZone);
				this._interceptZS = zoneSpec && (zoneSpec.onIntercept ? zoneSpec : parentDelegate._interceptZS);
				this._interceptDlgt = zoneSpec && (zoneSpec.onIntercept ? parentDelegate : parentDelegate._interceptDlgt);
				this._interceptCurrZone = zoneSpec && (zoneSpec.onIntercept ? this._zone : parentDelegate._interceptCurrZone);
				this._invokeZS = zoneSpec && (zoneSpec.onInvoke ? zoneSpec : parentDelegate._invokeZS);
				this._invokeDlgt = zoneSpec && (zoneSpec.onInvoke ? parentDelegate : parentDelegate._invokeDlgt);
				this._invokeCurrZone = zoneSpec && (zoneSpec.onInvoke ? this._zone : parentDelegate._invokeCurrZone);
				this._handleErrorZS = zoneSpec && (zoneSpec.onHandleError ? zoneSpec : parentDelegate._handleErrorZS);
				this._handleErrorDlgt = zoneSpec && (zoneSpec.onHandleError ? parentDelegate : parentDelegate._handleErrorDlgt);
				this._handleErrorCurrZone = zoneSpec && (zoneSpec.onHandleError ? this._zone : parentDelegate._handleErrorCurrZone);
				this._scheduleTaskZS = zoneSpec && (zoneSpec.onScheduleTask ? zoneSpec : parentDelegate._scheduleTaskZS);
				this._scheduleTaskDlgt = zoneSpec && (zoneSpec.onScheduleTask ? parentDelegate : parentDelegate._scheduleTaskDlgt);
				this._scheduleTaskCurrZone = zoneSpec && (zoneSpec.onScheduleTask ? this._zone : parentDelegate._scheduleTaskCurrZone);
				this._invokeTaskZS = zoneSpec && (zoneSpec.onInvokeTask ? zoneSpec : parentDelegate._invokeTaskZS);
				this._invokeTaskDlgt = zoneSpec && (zoneSpec.onInvokeTask ? parentDelegate : parentDelegate._invokeTaskDlgt);
				this._invokeTaskCurrZone = zoneSpec && (zoneSpec.onInvokeTask ? this._zone : parentDelegate._invokeTaskCurrZone);
				this._cancelTaskZS = zoneSpec && (zoneSpec.onCancelTask ? zoneSpec : parentDelegate._cancelTaskZS);
				this._cancelTaskDlgt = zoneSpec && (zoneSpec.onCancelTask ? parentDelegate : parentDelegate._cancelTaskDlgt);
				this._cancelTaskCurrZone = zoneSpec && (zoneSpec.onCancelTask ? this._zone : parentDelegate._cancelTaskCurrZone);
				this._hasTaskZS = null;
				this._hasTaskDlgt = null;
				this._hasTaskDlgtOwner = null;
				this._hasTaskCurrZone = null;
				const zoneSpecHasTask = zoneSpec && zoneSpec.onHasTask;
				const parentHasTask = parentDelegate && parentDelegate._hasTaskZS;
				if (zoneSpecHasTask || parentHasTask) {
				  this._hasTaskZS = zoneSpecHasTask ? zoneSpec : DELEGATE_ZS;
				  this._hasTaskDlgt = parentDelegate;
				  this._hasTaskDlgtOwner = this;
				  this._hasTaskCurrZone = this._zone;
				  if (!zoneSpec.onScheduleTask) {
					 this._scheduleTaskZS = DELEGATE_ZS;
					 this._scheduleTaskDlgt = parentDelegate;
					 this._scheduleTaskCurrZone = this._zone;
				  }
				  if (!zoneSpec.onInvokeTask) {
					 this._invokeTaskZS = DELEGATE_ZS;
					 this._invokeTaskDlgt = parentDelegate;
					 this._invokeTaskCurrZone = this._zone;
				  }
				  if (!zoneSpec.onCancelTask) {
					 this._cancelTaskZS = DELEGATE_ZS;
					 this._cancelTaskDlgt = parentDelegate;
					 this._cancelTaskCurrZone = this._zone;
				  }
				}
			 }
			 fork(targetZone, zoneSpec) {
				return this._forkZS ? this._forkZS.onFork(this._forkDlgt, this.zone, targetZone, zoneSpec) : new ZoneImpl(targetZone, zoneSpec);
			 }
			 intercept(targetZone, callback, source) {
				return this._interceptZS ? this._interceptZS.onIntercept(this._interceptDlgt, this._interceptCurrZone, targetZone, callback, source) : callback;
			 }
			 invoke(targetZone, callback, applyThis, applyArgs, source) {
				return this._invokeZS ? this._invokeZS.onInvoke(this._invokeDlgt, this._invokeCurrZone, targetZone, callback, applyThis, applyArgs, source) : callback.apply(applyThis, applyArgs);
			 }
			 handleError(targetZone, error) {
				return this._handleErrorZS ? this._handleErrorZS.onHandleError(this._handleErrorDlgt, this._handleErrorCurrZone, targetZone, error) : true;
			 }
			 scheduleTask(targetZone, task) {
				let returnTask = task;
				if (this._scheduleTaskZS) {
				  if (this._hasTaskZS) {
					 returnTask._zoneDelegates.push(this._hasTaskDlgtOwner);
				  }
				  returnTask = this._scheduleTaskZS.onScheduleTask(this._scheduleTaskDlgt, this._scheduleTaskCurrZone, targetZone, task);
				  if (!returnTask)
					 returnTask = task;
				} else {
				  if (task.scheduleFn) {
					 task.scheduleFn(task);
				  } else if (task.type == microTask) {
					 scheduleMicroTask(task);
				  } else {
					 throw new Error("Task is missing scheduleFn.");
				  }
				}
				return returnTask;
			 }
			 invokeTask(targetZone, task, applyThis, applyArgs) {
				return this._invokeTaskZS ? this._invokeTaskZS.onInvokeTask(this._invokeTaskDlgt, this._invokeTaskCurrZone, targetZone, task, applyThis, applyArgs) : task.callback.apply(applyThis, applyArgs);
			 }
			 cancelTask(targetZone, task) {
				let value;
				if (this._cancelTaskZS) {
				  value = this._cancelTaskZS.onCancelTask(this._cancelTaskDlgt, this._cancelTaskCurrZone, targetZone, task);
				} else {
				  if (!task.cancelFn) {
					 throw Error("Task is not cancelable");
				  }
				  value = task.cancelFn(task);
				}
				return value;
			 }
			 hasTask(targetZone, isEmpty2) {
				try {
				  this._hasTaskZS && this._hasTaskZS.onHasTask(this._hasTaskDlgt, this._hasTaskCurrZone, targetZone, isEmpty2);
				} catch (err) {
				  this.handleError(targetZone, err);
				}
			 }
			 // tslint:disable-next-line:require-internal-with-underscore
			 _updateTaskCount(type2, count) {
				const counts = this._taskCounts;
				const prev = counts[type2];
				const next = counts[type2] = prev + count;
				if (next < 0) {
				  throw new Error("More tasks executed then were scheduled.");
				}
				if (prev == 0 || next == 0) {
				  const isEmpty2 = {
					 microTask: counts["microTask"] > 0,
					 macroTask: counts["macroTask"] > 0,
					 eventTask: counts["eventTask"] > 0,
					 change: type2
				  };
				  this.hasTask(this._zone, isEmpty2);
				}
			 }
		  }
		  class ZoneTask {
			 constructor(type2, source, callback, options, scheduleFn, cancelFn) {
				this._zone = null;
				this.runCount = 0;
				this._zoneDelegates = null;
				this._state = "notScheduled";
				this.type = type2;
				this.source = source;
				this.data = options;
				this.scheduleFn = scheduleFn;
				this.cancelFn = cancelFn;
				if (!callback) {
				  throw new Error("callback is not defined");
				}
				this.callback = callback;
				const self2 = this;
				if (type2 === eventTask && options && options.useG) {
				  this.invoke = ZoneTask.invokeTask;
				} else {
				  this.invoke = function() {
					 return ZoneTask.invokeTask.call(global2, self2, this, arguments);
				  };
				}
			 }
			 static invokeTask(task, target, args) {
				if (!task) {
				  task = this;
				}
				_numberOfNestedTaskFrames++;
				try {
				  task.runCount++;
				  return task.zone.runTask(task, target, args);
				} finally {
				  if (_numberOfNestedTaskFrames == 1) {
					 drainMicroTaskQueue();
				  }
				  _numberOfNestedTaskFrames--;
				}
			 }
			 get zone() {
				return this._zone;
			 }
			 get state() {
				return this._state;
			 }
			 cancelScheduleRequest() {
				this._transitionTo(notScheduled, scheduling);
			 }
			 // tslint:disable-next-line:require-internal-with-underscore
			 _transitionTo(toState, fromState1, fromState2) {
				if (this._state === fromState1 || this._state === fromState2) {
				  this._state = toState;
				  if (toState == notScheduled) {
					 this._zoneDelegates = null;
				  }
				} else {
				  throw new Error(`${this.type} '${this.source}': can not transition to '${toState}', expecting state '${fromState1}'${fromState2 ? " or '" + fromState2 + "'" : ""}, was '${this._state}'.`);
				}
			 }
			 toString() {
				if (this.data && typeof this.data.handleId !== "undefined") {
				  return this.data.handleId.toString();
				} else {
				  return Object.prototype.toString.call(this);
				}
			 }
			 // add toJSON method to prevent cyclic error when
			 // call JSON.stringify(zoneTask)
			 toJSON() {
				return {
				  type: this.type,
				  state: this.state,
				  source: this.source,
				  zone: this.zone.name,
				  runCount: this.runCount
				};
			 }
		  }
		  const symbolSetTimeout = __symbol__("setTimeout");
		  const symbolPromise = __symbol__("Promise");
		  const symbolThen = __symbol__("then");
		  let _microTaskQueue = [];
		  let _isDrainingMicrotaskQueue = false;
		  let nativeMicroTaskQueuePromise;
		  function nativeScheduleMicroTask(func) {
			 if (!nativeMicroTaskQueuePromise) {
				if (global2[symbolPromise]) {
				  nativeMicroTaskQueuePromise = global2[symbolPromise].resolve(0);
				}
			 }
			 if (nativeMicroTaskQueuePromise) {
				let nativeThen = nativeMicroTaskQueuePromise[symbolThen];
				if (!nativeThen) {
				  nativeThen = nativeMicroTaskQueuePromise["then"];
				}
				nativeThen.call(nativeMicroTaskQueuePromise, func);
			 } else {
				global2[symbolSetTimeout](func, 0);
			 }
		  }
		  function scheduleMicroTask(task) {
			 if (_numberOfNestedTaskFrames === 0 && _microTaskQueue.length === 0) {
				nativeScheduleMicroTask(drainMicroTaskQueue);
			 }
			 task && _microTaskQueue.push(task);
		  }
		  function drainMicroTaskQueue() {
			 if (!_isDrainingMicrotaskQueue) {
				_isDrainingMicrotaskQueue = true;
				while (_microTaskQueue.length) {
				  const queue = _microTaskQueue;
				  _microTaskQueue = [];
				  for (let i = 0; i < queue.length; i++) {
					 const task = queue[i];
					 try {
						task.zone.runTask(task, null, null);
					 } catch (error) {
						_api.onUnhandledError(error);
					 }
				  }
				}
				_api.microtaskDrainDone();
				_isDrainingMicrotaskQueue = false;
			 }
		  }
		  const NO_ZONE = { name: "NO ZONE" };
		  const notScheduled = "notScheduled", scheduling = "scheduling", scheduled2 = "scheduled", running = "running", canceling = "canceling", unknown = "unknown";
		  const microTask = "microTask", macroTask = "macroTask", eventTask = "eventTask";
		  const patches = {};
		  const _api = {
			 symbol: __symbol__,
			 currentZoneFrame: () => _currentZoneFrame,
			 onUnhandledError: noop5,
			 microtaskDrainDone: noop5,
			 scheduleMicroTask,
			 showUncaughtError: () => !ZoneImpl[__symbol__("ignoreConsoleErrorUncaughtError")],
			 patchEventTarget: () => [],
			 patchOnProperties: noop5,
			 patchMethod: () => noop5,
			 bindArguments: () => [],
			 patchThen: () => noop5,
			 patchMacroTask: () => noop5,
			 patchEventPrototype: () => noop5,
			 isIEOrEdge: () => false,
			 getGlobalObjects: () => void 0,
			 ObjectDefineProperty: () => noop5,
			 ObjectGetOwnPropertyDescriptor: () => void 0,
			 ObjectCreate: () => void 0,
			 ArraySlice: () => [],
			 patchClass: () => noop5,
			 wrapWithCurrentZone: () => noop5,
			 filterProperties: () => [],
			 attachOriginToPatched: () => noop5,
			 _redefineProperty: () => noop5,
			 patchCallbacks: () => noop5,
			 nativeScheduleMicroTask
		  };
		  let _currentZoneFrame = { parent: null, zone: new ZoneImpl(null, null) };
		  let _currentTask = null;
		  let _numberOfNestedTaskFrames = 0;
		  function noop5() {
		  }
		  performanceMeasure("Zone", "Zone");
		  return ZoneImpl;
		}
		function loadZone() {
		  const global3 = globalThis;
		  const checkDuplicate = global3[__symbol__("forceDuplicateZoneCheck")] === true;
		  if (global3["Zone"] && (checkDuplicate || typeof global3["Zone"].__symbol__ !== "function")) {
			 throw new Error("Zone already loaded.");
		  }
		  global3["Zone"] ??= initZone();
		  return global3["Zone"];
		}
		var ObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
		var ObjectDefineProperty = Object.defineProperty;
		var ObjectGetPrototypeOf = Object.getPrototypeOf;
		var ObjectCreate = Object.create;
		var ArraySlice = Array.prototype.slice;
		var ADD_EVENT_LISTENER_STR = "addEventListener";
		var REMOVE_EVENT_LISTENER_STR = "removeEventListener";
		var ZONE_SYMBOL_ADD_EVENT_LISTENER = __symbol__(ADD_EVENT_LISTENER_STR);
		var ZONE_SYMBOL_REMOVE_EVENT_LISTENER = __symbol__(REMOVE_EVENT_LISTENER_STR);
		var TRUE_STR = "true";
		var FALSE_STR = "false";
		var ZONE_SYMBOL_PREFIX = __symbol__("");
		function wrapWithCurrentZone(callback, source) {
		  return Zone.current.wrap(callback, source);
		}
		function scheduleMacroTaskWithCurrentZone(source, callback, data, customSchedule, customCancel) {
		  return Zone.current.scheduleMacroTask(source, callback, data, customSchedule, customCancel);
		}
		var zoneSymbol = __symbol__;
		var isWindowExists = typeof window !== "undefined";
		var internalWindow = isWindowExists ? window : void 0;
		var _global2 = isWindowExists && internalWindow || globalThis;
		var REMOVE_ATTRIBUTE = "removeAttribute";
		function bindArguments(args, source) {
		  for (let i = args.length - 1; i >= 0; i--) {
			 if (typeof args[i] === "function") {
				args[i] = wrapWithCurrentZone(args[i], source + "_" + i);
			 }
		  }
		  return args;
		}
		function patchPrototype(prototype, fnNames) {
		  const source = prototype.constructor["name"];
		  for (let i = 0; i < fnNames.length; i++) {
			 const name = fnNames[i];
			 const delegate = prototype[name];
			 if (delegate) {
				const prototypeDesc = ObjectGetOwnPropertyDescriptor(prototype, name);
				if (!isPropertyWritable(prototypeDesc)) {
				  continue;
				}
				prototype[name] = ((delegate2) => {
				  const patched = function() {
					 return delegate2.apply(this, bindArguments(arguments, source + "." + name));
				  };
				  attachOriginToPatched(patched, delegate2);
				  return patched;
				})(delegate);
			 }
		  }
		}
		function isPropertyWritable(propertyDesc) {
		  if (!propertyDesc) {
			 return true;
		  }
		  if (propertyDesc.writable === false) {
			 return false;
		  }
		  return !(typeof propertyDesc.get === "function" && typeof propertyDesc.set === "undefined");
		}
		var isWebWorker = typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope;
		var isNode = !("nw" in _global2) && typeof _global2.process !== "undefined" && _global2.process.toString() === "[object process]";
		var isBrowser = !isNode && !isWebWorker && !!(isWindowExists && internalWindow["HTMLElement"]);
		var isMix = typeof _global2.process !== "undefined" && _global2.process.toString() === "[object process]" && !isWebWorker && !!(isWindowExists && internalWindow["HTMLElement"]);
		var zoneSymbolEventNames$1 = {};
		var enableBeforeunloadSymbol = zoneSymbol("enable_beforeunload");
		var wrapFn = function(event) {
		  event = event || _global2.event;
		  if (!event) {
			 return;
		  }
		  let eventNameSymbol = zoneSymbolEventNames$1[event.type];
		  if (!eventNameSymbol) {
			 eventNameSymbol = zoneSymbolEventNames$1[event.type] = zoneSymbol("ON_PROPERTY" + event.type);
		  }
		  const target = this || event.target || _global2;
		  const listener = target[eventNameSymbol];
		  let result;
		  if (isBrowser && target === internalWindow && event.type === "error") {
			 const errorEvent = event;
			 result = listener && listener.call(this, errorEvent.message, errorEvent.filename, errorEvent.lineno, errorEvent.colno, errorEvent.error);
			 if (result === true) {
				event.preventDefault();
			 }
		  } else {
			 result = listener && listener.apply(this, arguments);
			 if (
				// https://github.com/angular/angular/issues/47579
				// https://www.w3.org/TR/2011/WD-html5-20110525/history.html#beforeunloadevent
				// This is the only specific case we should check for. The spec defines that the
				// `returnValue` attribute represents the message to show the user. When the event
				// is created, this attribute must be set to the empty string.
				event.type === "beforeunload" && // To prevent any breaking changes resulting from this change, given that
				// it was already causing a significant number of failures in G3, we have hidden
				// that behavior behind a copyGlobalForElem configuration flag. Consumers can enable this
				// flag explicitly if they want the `beforeunload` event to be handled as defined
				// in the specification.
				_global2[enableBeforeunloadSymbol] && // The IDL event definition is `attribute DOMString returnValue`, so we check whether
				// `typeof result` is a string.
				typeof result === "string"
			 ) {
				event.returnValue = result;
			 } else if (result != void 0 && !result) {
				event.preventDefault();
			 }
		  }
		  return result;
		};
		function patchProperty(obj, prop, prototype) {
		  let desc = ObjectGetOwnPropertyDescriptor(obj, prop);
		  if (!desc && prototype) {
			 const prototypeDesc = ObjectGetOwnPropertyDescriptor(prototype, prop);
			 if (prototypeDesc) {
				desc = { enumerable: true, configurable: true };
			 }
		  }
		  if (!desc || !desc.configurable) {
			 return;
		  }
		  const onPropPatchedSymbol = zoneSymbol("on" + prop + "patched");
		  if (obj.hasOwnProperty(onPropPatchedSymbol) && obj[onPropPatchedSymbol]) {
			 return;
		  }
		  delete desc.writable;
		  delete desc.value;
		  const originalDescGet = desc.get;
		  const originalDescSet = desc.set;
		  const eventName = prop.slice(2);
		  let eventNameSymbol = zoneSymbolEventNames$1[eventName];
		  if (!eventNameSymbol) {
			 eventNameSymbol = zoneSymbolEventNames$1[eventName] = zoneSymbol("ON_PROPERTY" + eventName);
		  }
		  desc.set = function(newValue) {
			 let target = this;
			 if (!target && obj === _global2) {
				target = _global2;
			 }
			 if (!target) {
				return;
			 }
			 const previousValue = target[eventNameSymbol];
			 if (typeof previousValue === "function") {
				target.removeEventListener(eventName, wrapFn);
			 }
			 originalDescSet && originalDescSet.call(target, null);
			 target[eventNameSymbol] = newValue;
			 if (typeof newValue === "function") {
				target.addEventListener(eventName, wrapFn, false);
			 }
		  };
		  desc.get = function() {
			 let target = this;
			 if (!target && obj === _global2) {
				target = _global2;
			 }
			 if (!target) {
				return null;
			 }
			 const listener = target[eventNameSymbol];
			 if (listener) {
				return listener;
			 } else if (originalDescGet) {
				let value = originalDescGet.call(this);
				if (value) {
				  desc.set.call(this, value);
				  if (typeof target[REMOVE_ATTRIBUTE] === "function") {
					 target.removeAttribute(prop);
				  }
				  return value;
				}
			 }
			 return null;
		  };
		  ObjectDefineProperty(obj, prop, desc);
		  obj[onPropPatchedSymbol] = true;
		}
		function patchOnProperties(obj, properties, prototype) {
		  if (properties) {
			 for (let i = 0; i < properties.length; i++) {
				patchProperty(obj, "on" + properties[i], prototype);
			 }
		  } else {
			 const onProperties = [];
			 for (const prop in obj) {
				if (prop.slice(0, 2) == "on") {
				  onProperties.push(prop);
				}
			 }
			 for (let j = 0; j < onProperties.length; j++) {
				patchProperty(obj, onProperties[j], prototype);
			 }
		  }
		}
		var originalInstanceKey = zoneSymbol("originalInstance");
		function patchClass(className) {
		  const OriginalClass = _global2[className];
		  if (!OriginalClass)
			 return;
		  _global2[zoneSymbol(className)] = OriginalClass;
		  _global2[className] = function() {
			 const a = bindArguments(arguments, className);
			 switch (a.length) {
				case 0:
				  this[originalInstanceKey] = new OriginalClass();
				  break;
				case 1:
				  this[originalInstanceKey] = new OriginalClass(a[0]);
				  break;
				case 2:
				  this[originalInstanceKey] = new OriginalClass(a[0], a[1]);
				  break;
				case 3:
				  this[originalInstanceKey] = new OriginalClass(a[0], a[1], a[2]);
				  break;
				case 4:
				  this[originalInstanceKey] = new OriginalClass(a[0], a[1], a[2], a[3]);
				  break;
				default:
				  throw new Error("Arg list too long.");
			 }
		  };
		  attachOriginToPatched(_global2[className], OriginalClass);
		  const instance = new OriginalClass(function() {
		  });
		  let prop;
		  for (prop in instance) {
			 if (className === "XMLHttpRequest" && prop === "responseBlob")
				continue;
			 (function(prop2) {
				if (typeof instance[prop2] === "function") {
				  _global2[className].prototype[prop2] = function() {
					 return this[originalInstanceKey][prop2].apply(this[originalInstanceKey], arguments);
				  };
				} else {
				  ObjectDefineProperty(_global2[className].prototype, prop2, {
					 set: function(fn) {
						if (typeof fn === "function") {
						  this[originalInstanceKey][prop2] = wrapWithCurrentZone(fn, className + "." + prop2);
						  attachOriginToPatched(this[originalInstanceKey][prop2], fn);
						} else {
						  this[originalInstanceKey][prop2] = fn;
						}
					 },
					 get: function() {
						return this[originalInstanceKey][prop2];
					 }
				  });
				}
			 })(prop);
		  }
		  for (prop in OriginalClass) {
			 if (prop !== "prototype" && OriginalClass.hasOwnProperty(prop)) {
				_global2[className][prop] = OriginalClass[prop];
			 }
		  }
		}
		function patchMethod(target, name, patchFn) {
		  let proto = target;
		  while (proto && !proto.hasOwnProperty(name)) {
			 proto = ObjectGetPrototypeOf(proto);
		  }
		  if (!proto && target[name]) {
			 proto = target;
		  }
		  const delegateName = zoneSymbol(name);
		  let delegate = null;
		  if (proto && (!(delegate = proto[delegateName]) || !proto.hasOwnProperty(delegateName))) {
			 delegate = proto[delegateName] = proto[name];
			 const desc = proto && ObjectGetOwnPropertyDescriptor(proto, name);
			 if (isPropertyWritable(desc)) {
				const patchDelegate = patchFn(delegate, delegateName, name);
				proto[name] = function() {
				  return patchDelegate(this, arguments);
				};
				attachOriginToPatched(proto[name], delegate);
			 }
		  }
		  return delegate;
		}
		function patchMacroTask(obj, funcName, metaCreator) {
		  let setNative = null;
		  function scheduleTask(task) {
			 const data = task.data;
			 data.args[data.cbIdx] = function() {
				task.invoke.apply(this, arguments);
			 };
			 setNative.apply(data.target, data.args);
			 return task;
		  }
		  setNative = patchMethod(obj, funcName, (delegate) => function(self2, args) {
			 const meta = metaCreator(self2, args);
			 if (meta.cbIdx >= 0 && typeof args[meta.cbIdx] === "function") {
				return scheduleMacroTaskWithCurrentZone(meta.name, args[meta.cbIdx], meta, scheduleTask);
			 } else {
				return delegate.apply(self2, args);
			 }
		  });
		}
		function attachOriginToPatched(patched, original) {
		  patched[zoneSymbol("OriginalDelegate")] = original;
		}
		var isDetectedIEOrEdge = false;
		var ieOrEdge = false;
		function isIE() {
		  try {
			 const ua = internalWindow.navigator.userAgent;
			 if (ua.indexOf("MSIE ") !== -1 || ua.indexOf("Trident/") !== -1) {
				return true;
			 }
		  } catch (error) {
		  }
		  return false;
		}
		function isIEOrEdge() {
		  if (isDetectedIEOrEdge) {
			 return ieOrEdge;
		  }
		  isDetectedIEOrEdge = true;
		  try {
			 const ua = internalWindow.navigator.userAgent;
			 if (ua.indexOf("MSIE ") !== -1 || ua.indexOf("Trident/") !== -1 || ua.indexOf("Edge/") !== -1) {
				ieOrEdge = true;
			 }
		  } catch (error) {
		  }
		  return ieOrEdge;
		}
		function isFunction3(value) {
		  return typeof value === "function";
		}
		function isNumber(value) {
		  return typeof value === "number";
		}
		var passiveSupported = false;
		if (typeof window !== "undefined") {
		  try {
			 const options = Object.defineProperty({}, "passive", {
				get: function() {
				  passiveSupported = true;
				}
			 });
			 window.addEventListener("test", options, options);
			 window.removeEventListener("test", options, options);
		  } catch (err) {
			 passiveSupported = false;
		  }
		}
		var OPTIMIZED_ZONE_EVENT_TASK_DATA = {
		  useG: true
		};
		var zoneSymbolEventNames = {};
		var globalSources = {};
		var EVENT_NAME_SYMBOL_REGX = new RegExp("^" + ZONE_SYMBOL_PREFIX + "(\\w+)(true|false)$");
		var IMMEDIATE_PROPAGATION_SYMBOL = zoneSymbol("propagationStopped");
		function prepareEventNames(eventName, eventNameToString) {
		  const falseEventName = (eventNameToString ? eventNameToString(eventName) : eventName) + FALSE_STR;
		  const trueEventName = (eventNameToString ? eventNameToString(eventName) : eventName) + TRUE_STR;
		  const symbol = ZONE_SYMBOL_PREFIX + falseEventName;
		  const symbolCapture = ZONE_SYMBOL_PREFIX + trueEventName;
		  zoneSymbolEventNames[eventName] = {};
		  zoneSymbolEventNames[eventName][FALSE_STR] = symbol;
		  zoneSymbolEventNames[eventName][TRUE_STR] = symbolCapture;
		}
		function patchEventTarget(_global3, api, apis, patchOptions) {
		  const ADD_EVENT_LISTENER = patchOptions && patchOptions.add || ADD_EVENT_LISTENER_STR;
		  const REMOVE_EVENT_LISTENER = patchOptions && patchOptions.rm || REMOVE_EVENT_LISTENER_STR;
		  const LISTENERS_EVENT_LISTENER = patchOptions && patchOptions.listeners || "eventListeners";
		  const REMOVE_ALL_LISTENERS_EVENT_LISTENER = patchOptions && patchOptions.rmAll || "removeAllListeners";
		  const zoneSymbolAddEventListener = zoneSymbol(ADD_EVENT_LISTENER);
		  const ADD_EVENT_LISTENER_SOURCE = "." + ADD_EVENT_LISTENER + ":";
		  const PREPEND_EVENT_LISTENER = "prependListener";
		  const PREPEND_EVENT_LISTENER_SOURCE = "." + PREPEND_EVENT_LISTENER + ":";
		  const invokeTask = function(task, target, event) {
			 if (task.isRemoved) {
				return;
			 }
			 const delegate = task.callback;
			 if (typeof delegate === "object" && delegate.handleEvent) {
				task.callback = (event2) => delegate.handleEvent(event2);
				task.originalDelegate = delegate;
			 }
			 let error;
			 try {
				task.invoke(task, target, [event]);
			 } catch (err) {
				error = err;
			 }
			 const options = task.options;
			 if (options && typeof options === "object" && options.once) {
				const delegate2 = task.originalDelegate ? task.originalDelegate : task.callback;
				target[REMOVE_EVENT_LISTENER].call(target, event.type, delegate2, options);
			 }
			 return error;
		  };
		  function globalCallback(context2, event, isCapture) {
			 event = event || _global3.event;
			 if (!event) {
				return;
			 }
			 const target = context2 || event.target || _global3;
			 const tasks = target[zoneSymbolEventNames[event.type][isCapture ? TRUE_STR : FALSE_STR]];
			 if (tasks) {
				const errors = [];
				if (tasks.length === 1) {
				  const err = invokeTask(tasks[0], target, event);
				  err && errors.push(err);
				} else {
				  const copyTasks = tasks.slice();
				  for (let i = 0; i < copyTasks.length; i++) {
					 if (event && event[IMMEDIATE_PROPAGATION_SYMBOL] === true) {
						break;
					 }
					 const err = invokeTask(copyTasks[i], target, event);
					 err && errors.push(err);
				  }
				}
				if (errors.length === 1) {
				  throw errors[0];
				} else {
				  for (let i = 0; i < errors.length; i++) {
					 const err = errors[i];
					 api.nativeScheduleMicroTask(() => {
						throw err;
					 });
				  }
				}
			 }
		  }
		  const globalZoneAwareCallback = function(event) {
			 return globalCallback(this, event, false);
		  };
		  const globalZoneAwareCaptureCallback = function(event) {
			 return globalCallback(this, event, true);
		  };
		  function patchEventTargetMethods(obj, patchOptions2) {
			 if (!obj) {
				return false;
			 }
			 let useGlobalCallback = true;
			 if (patchOptions2 && patchOptions2.useG !== void 0) {
				useGlobalCallback = patchOptions2.useG;
			 }
			 const validateHandler = patchOptions2 && patchOptions2.vh;
			 let checkDuplicate = true;
			 if (patchOptions2 && patchOptions2.chkDup !== void 0) {
				checkDuplicate = patchOptions2.chkDup;
			 }
			 let returnTarget = false;
			 if (patchOptions2 && patchOptions2.rt !== void 0) {
				returnTarget = patchOptions2.rt;
			 }
			 let proto = obj;
			 while (proto && !proto.hasOwnProperty(ADD_EVENT_LISTENER)) {
				proto = ObjectGetPrototypeOf(proto);
			 }
			 if (!proto && obj[ADD_EVENT_LISTENER]) {
				proto = obj;
			 }
			 if (!proto) {
				return false;
			 }
			 if (proto[zoneSymbolAddEventListener]) {
				return false;
			 }
			 const eventNameToString = patchOptions2 && patchOptions2.eventNameToString;
			 const taskData = {};
			 const nativeAddEventListener = proto[zoneSymbolAddEventListener] = proto[ADD_EVENT_LISTENER];
			 const nativeRemoveEventListener = proto[zoneSymbol(REMOVE_EVENT_LISTENER)] = proto[REMOVE_EVENT_LISTENER];
			 const nativeListeners = proto[zoneSymbol(LISTENERS_EVENT_LISTENER)] = proto[LISTENERS_EVENT_LISTENER];
			 const nativeRemoveAllListeners = proto[zoneSymbol(REMOVE_ALL_LISTENERS_EVENT_LISTENER)] = proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER];
			 let nativePrependEventListener;
			 if (patchOptions2 && patchOptions2.prepend) {
				nativePrependEventListener = proto[zoneSymbol(patchOptions2.prepend)] = proto[patchOptions2.prepend];
			 }
			 function buildEventListenerOptions(options, passive) {
				if (!passiveSupported && typeof options === "object" && options) {
				  return !!options.capture;
				}
				if (!passiveSupported || !passive) {
				  return options;
				}
				if (typeof options === "boolean") {
				  return { capture: options, passive: true };
				}
				if (!options) {
				  return { passive: true };
				}
				if (typeof options === "object" && options.passive !== false) {
				  return __spreadProps(__spreadValues({}, options), { passive: true });
				}
				return options;
			 }
			 const customScheduleGlobal = function(task) {
				if (taskData.isExisting) {
				  return;
				}
				return nativeAddEventListener.call(taskData.target, taskData.eventName, taskData.capture ? globalZoneAwareCaptureCallback : globalZoneAwareCallback, taskData.options);
			 };
			 const customCancelGlobal = function(task) {
				if (!task.isRemoved) {
				  const symbolEventNames = zoneSymbolEventNames[task.eventName];
				  let symbolEventName;
				  if (symbolEventNames) {
					 symbolEventName = symbolEventNames[task.capture ? TRUE_STR : FALSE_STR];
				  }
				  const existingTasks = symbolEventName && task.target[symbolEventName];
				  if (existingTasks) {
					 for (let i = 0; i < existingTasks.length; i++) {
						const existingTask = existingTasks[i];
						if (existingTask === task) {
						  existingTasks.splice(i, 1);
						  task.isRemoved = true;
						  if (task.removeAbortListener) {
							 task.removeAbortListener();
							 task.removeAbortListener = null;
						  }
						  if (existingTasks.length === 0) {
							 task.allRemoved = true;
							 task.target[symbolEventName] = null;
						  }
						  break;
						}
					 }
				  }
				}
				if (!task.allRemoved) {
				  return;
				}
				return nativeRemoveEventListener.call(task.target, task.eventName, task.capture ? globalZoneAwareCaptureCallback : globalZoneAwareCallback, task.options);
			 };
			 const customScheduleNonGlobal = function(task) {
				return nativeAddEventListener.call(taskData.target, taskData.eventName, task.invoke, taskData.options);
			 };
			 const customSchedulePrepend = function(task) {
				return nativePrependEventListener.call(taskData.target, taskData.eventName, task.invoke, taskData.options);
			 };
			 const customCancelNonGlobal = function(task) {
				return nativeRemoveEventListener.call(task.target, task.eventName, task.invoke, task.options);
			 };
			 const customSchedule = useGlobalCallback ? customScheduleGlobal : customScheduleNonGlobal;
			 const customCancel = useGlobalCallback ? customCancelGlobal : customCancelNonGlobal;
			 const compareTaskCallbackVsDelegate = function(task, delegate) {
				const typeOfDelegate = typeof delegate;
				return typeOfDelegate === "function" && task.callback === delegate || typeOfDelegate === "object" && task.originalDelegate === delegate;
			 };
			 const compare = patchOptions2 && patchOptions2.diff ? patchOptions2.diff : compareTaskCallbackVsDelegate;
			 const unpatchedEvents = Zone[zoneSymbol("UNPATCHED_EVENTS")];
			 const passiveEvents = _global3[zoneSymbol("PASSIVE_EVENTS")];
			 function copyEventListenerOptions(options) {
				if (typeof options === "object" && options !== null) {
				  const newOptions = __spreadValues({}, options);
				  if (options.signal) {
					 newOptions.signal = options.signal;
				  }
				  return newOptions;
				}
				return options;
			 }
			 const makeAddListener = function(nativeListener, addSource, customScheduleFn, customCancelFn, returnTarget2 = false, prepend = false) {
				return function() {
				  const target = this || _global3;
				  let eventName = arguments[0];
				  if (patchOptions2 && patchOptions2.transferEventName) {
					 eventName = patchOptions2.transferEventName(eventName);
				  }
				  let delegate = arguments[1];
				  if (!delegate) {
					 return nativeListener.apply(this, arguments);
				  }
				  if (isNode && eventName === "uncaughtException") {
					 return nativeListener.apply(this, arguments);
				  }
				  let isHandleEvent = false;
				  if (typeof delegate !== "function") {
					 if (!delegate.handleEvent) {
						return nativeListener.apply(this, arguments);
					 }
					 isHandleEvent = true;
				  }
				  if (validateHandler && !validateHandler(nativeListener, delegate, target, arguments)) {
					 return;
				  }
				  const passive = passiveSupported && !!passiveEvents && passiveEvents.indexOf(eventName) !== -1;
				  const options = copyEventListenerOptions(buildEventListenerOptions(arguments[2], passive));
				  const signal2 = options?.signal;
				  if (signal2?.aborted) {
					 return;
				  }
				  if (unpatchedEvents) {
					 for (let i = 0; i < unpatchedEvents.length; i++) {
						if (eventName === unpatchedEvents[i]) {
						  if (passive) {
							 return nativeListener.call(target, eventName, delegate, options);
						  } else {
							 return nativeListener.apply(this, arguments);
						  }
						}
					 }
				  }
				  const capture = !options ? false : typeof options === "boolean" ? true : options.capture;
				  const once = options && typeof options === "object" ? options.once : false;
				  const zone = Zone.current;
				  let symbolEventNames = zoneSymbolEventNames[eventName];
				  if (!symbolEventNames) {
					 prepareEventNames(eventName, eventNameToString);
					 symbolEventNames = zoneSymbolEventNames[eventName];
				  }
				  const symbolEventName = symbolEventNames[capture ? TRUE_STR : FALSE_STR];
				  let existingTasks = target[symbolEventName];
				  let isExisting = false;
				  if (existingTasks) {
					 isExisting = true;
					 if (checkDuplicate) {
						for (let i = 0; i < existingTasks.length; i++) {
						  if (compare(existingTasks[i], delegate)) {
							 return;
						  }
						}
					 }
				  } else {
					 existingTasks = target[symbolEventName] = [];
				  }
				  let source;
				  const constructorName = target.constructor["name"];
				  const targetSource = globalSources[constructorName];
				  if (targetSource) {
					 source = targetSource[eventName];
				  }
				  if (!source) {
					 source = constructorName + addSource + (eventNameToString ? eventNameToString(eventName) : eventName);
				  }
				  taskData.options = options;
				  if (once) {
					 taskData.options.once = false;
				  }
				  taskData.target = target;
				  taskData.capture = capture;
				  taskData.eventName = eventName;
				  taskData.isExisting = isExisting;
				  const data = useGlobalCallback ? OPTIMIZED_ZONE_EVENT_TASK_DATA : void 0;
				  if (data) {
					 data.taskData = taskData;
				  }
				  if (signal2) {
					 taskData.options.signal = void 0;
				  }
				  const task = zone.scheduleEventTask(source, delegate, data, customScheduleFn, customCancelFn);
				  if (signal2) {
					 taskData.options.signal = signal2;
					 const onAbort = () => task.zone.cancelTask(task);
					 nativeListener.call(signal2, "abort", onAbort, { once: true });
					 task.removeAbortListener = () => signal2.removeEventListener("abort", onAbort);
				  }
				  taskData.target = null;
				  if (data) {
					 data.taskData = null;
				  }
				  if (once) {
					 taskData.options.once = true;
				  }
				  if (!(!passiveSupported && typeof task.options === "boolean")) {
					 task.options = options;
				  }
				  task.target = target;
				  task.capture = capture;
				  task.eventName = eventName;
				  if (isHandleEvent) {
					 task.originalDelegate = delegate;
				  }
				  if (!prepend) {
					 existingTasks.push(task);
				  } else {
					 existingTasks.unshift(task);
				  }
				  if (returnTarget2) {
					 return target;
				  }
				};
			 };
			 proto[ADD_EVENT_LISTENER] = makeAddListener(nativeAddEventListener, ADD_EVENT_LISTENER_SOURCE, customSchedule, customCancel, returnTarget);
			 if (nativePrependEventListener) {
				proto[PREPEND_EVENT_LISTENER] = makeAddListener(nativePrependEventListener, PREPEND_EVENT_LISTENER_SOURCE, customSchedulePrepend, customCancel, returnTarget, true);
			 }
			 proto[REMOVE_EVENT_LISTENER] = function() {
				const target = this || _global3;
				let eventName = arguments[0];
				if (patchOptions2 && patchOptions2.transferEventName) {
				  eventName = patchOptions2.transferEventName(eventName);
				}
				const options = arguments[2];
				const capture = !options ? false : typeof options === "boolean" ? true : options.capture;
				const delegate = arguments[1];
				if (!delegate) {
				  return nativeRemoveEventListener.apply(this, arguments);
				}
				if (validateHandler && !validateHandler(nativeRemoveEventListener, delegate, target, arguments)) {
				  return;
				}
				const symbolEventNames = zoneSymbolEventNames[eventName];
				let symbolEventName;
				if (symbolEventNames) {
				  symbolEventName = symbolEventNames[capture ? TRUE_STR : FALSE_STR];
				}
				const existingTasks = symbolEventName && target[symbolEventName];
				if (existingTasks) {
				  for (let i = 0; i < existingTasks.length; i++) {
					 const existingTask = existingTasks[i];
					 if (compare(existingTask, delegate)) {
						existingTasks.splice(i, 1);
						existingTask.isRemoved = true;
						if (existingTasks.length === 0) {
						  existingTask.allRemoved = true;
						  target[symbolEventName] = null;
						  if (!capture && typeof eventName === "string") {
							 const onPropertySymbol = ZONE_SYMBOL_PREFIX + "ON_PROPERTY" + eventName;
							 target[onPropertySymbol] = null;
						  }
						}
						existingTask.zone.cancelTask(existingTask);
						if (returnTarget) {
						  return target;
						}
						return;
					 }
				  }
				}
				return nativeRemoveEventListener.apply(this, arguments);
			 };
			 proto[LISTENERS_EVENT_LISTENER] = function() {
				const target = this || _global3;
				let eventName = arguments[0];
				if (patchOptions2 && patchOptions2.transferEventName) {
				  eventName = patchOptions2.transferEventName(eventName);
				}
				const listeners = [];
				const tasks = findEventTasks(target, eventNameToString ? eventNameToString(eventName) : eventName);
				for (let i = 0; i < tasks.length; i++) {
				  const task = tasks[i];
				  let delegate = task.originalDelegate ? task.originalDelegate : task.callback;
				  listeners.push(delegate);
				}
				return listeners;
			 };
			 proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER] = function() {
				const target = this || _global3;
				let eventName = arguments[0];
				if (!eventName) {
				  const keys = Object.keys(target);
				  for (let i = 0; i < keys.length; i++) {
					 const prop = keys[i];
					 const match23 = EVENT_NAME_SYMBOL_REGX.exec(prop);
					 let evtName = match23 && match23[1];
					 if (evtName && evtName !== "removeListener") {
						this[REMOVE_ALL_LISTENERS_EVENT_LISTENER].call(this, evtName);
					 }
				  }
				  this[REMOVE_ALL_LISTENERS_EVENT_LISTENER].call(this, "removeListener");
				} else {
				  if (patchOptions2 && patchOptions2.transferEventName) {
					 eventName = patchOptions2.transferEventName(eventName);
				  }
				  const symbolEventNames = zoneSymbolEventNames[eventName];
				  if (symbolEventNames) {
					 const symbolEventName = symbolEventNames[FALSE_STR];
					 const symbolCaptureEventName = symbolEventNames[TRUE_STR];
					 const tasks = target[symbolEventName];
					 const captureTasks = target[symbolCaptureEventName];
					 if (tasks) {
						const removeTasks = tasks.slice();
						for (let i = 0; i < removeTasks.length; i++) {
						  const task = removeTasks[i];
						  let delegate = task.originalDelegate ? task.originalDelegate : task.callback;
						  this[REMOVE_EVENT_LISTENER].call(this, eventName, delegate, task.options);
						}
					 }
					 if (captureTasks) {
						const removeTasks = captureTasks.slice();
						for (let i = 0; i < removeTasks.length; i++) {
						  const task = removeTasks[i];
						  let delegate = task.originalDelegate ? task.originalDelegate : task.callback;
						  this[REMOVE_EVENT_LISTENER].call(this, eventName, delegate, task.options);
						}
					 }
				  }
				}
				if (returnTarget) {
				  return this;
				}
			 };
			 attachOriginToPatched(proto[ADD_EVENT_LISTENER], nativeAddEventListener);
			 attachOriginToPatched(proto[REMOVE_EVENT_LISTENER], nativeRemoveEventListener);
			 if (nativeRemoveAllListeners) {
				attachOriginToPatched(proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER], nativeRemoveAllListeners);
			 }
			 if (nativeListeners) {
				attachOriginToPatched(proto[LISTENERS_EVENT_LISTENER], nativeListeners);
			 }
			 return true;
		  }
		  let results = [];
		  for (let i = 0; i < apis.length; i++) {
			 results[i] = patchEventTargetMethods(apis[i], patchOptions);
		  }
		  return results;
		}
		function findEventTasks(target, eventName) {
		  if (!eventName) {
			 const foundTasks = [];
			 for (let prop in target) {
				const match23 = EVENT_NAME_SYMBOL_REGX.exec(prop);
				let evtName = match23 && match23[1];
				if (evtName && (!eventName || evtName === eventName)) {
				  const tasks = target[prop];
				  if (tasks) {
					 for (let i = 0; i < tasks.length; i++) {
						foundTasks.push(tasks[i]);
					 }
				  }
				}
			 }
			 return foundTasks;
		  }
		  let symbolEventName = zoneSymbolEventNames[eventName];
		  if (!symbolEventName) {
			 prepareEventNames(eventName);
			 symbolEventName = zoneSymbolEventNames[eventName];
		  }
		  const captureFalseTasks = target[symbolEventName[FALSE_STR]];
		  const captureTrueTasks = target[symbolEventName[TRUE_STR]];
		  if (!captureFalseTasks) {
			 return captureTrueTasks ? captureTrueTasks.slice() : [];
		  } else {
			 return captureTrueTasks ? captureFalseTasks.concat(captureTrueTasks) : captureFalseTasks.slice();
		  }
		}
		function patchEventPrototype(global3, api) {
		  const Event = global3["Event"];
		  if (Event && Event.prototype) {
			 api.patchMethod(Event.prototype, "stopImmediatePropagation", (delegate) => function(self2, args) {
				self2[IMMEDIATE_PROPAGATION_SYMBOL] = true;
				delegate && delegate.apply(self2, args);
			 });
		  }
		}
		function patchQueueMicrotask(global3, api) {
		  api.patchMethod(global3, "queueMicrotask", (delegate) => {
			 return function(self2, args) {
				Zone.current.scheduleMicroTask("queueMicrotask", args[0]);
			 };
		  });
		}
		var taskSymbol = zoneSymbol("zoneTask");
		function patchTimer(window2, setName, cancelName, nameSuffix) {
		  let setNative = null;
		  let clearNative = null;
		  setName += nameSuffix;
		  cancelName += nameSuffix;
		  const tasksByHandleId = {};
		  function scheduleTask(task) {
			 const data = task.data;
			 data.args[0] = function() {
				return task.invoke.apply(this, arguments);
			 };
			 const handleOrId = setNative.apply(window2, data.args);
			 if (isNumber(handleOrId)) {
				data.handleId = handleOrId;
			 } else {
				data.handle = handleOrId;
				data.isRefreshable = isFunction3(handleOrId.refresh);
			 }
			 return task;
		  }
		  function clearTask(task) {
			 const { handle, handleId } = task.data;
			 return clearNative.call(window2, handle ?? handleId);
		  }
		  setNative = patchMethod(window2, setName, (delegate) => function(self2, args) {
			 if (isFunction3(args[0])) {
				const options = {
				  isRefreshable: false,
				  isPeriodic: nameSuffix === "Interval",
				  delay: nameSuffix === "Timeout" || nameSuffix === "Interval" ? args[1] || 0 : void 0,
				  args
				};
				const callback = args[0];
				args[0] = function timer2() {
				  try {
					 return callback.apply(this, arguments);
				  } finally {
					 const { handle: handle2, handleId: handleId2, isPeriodic: isPeriodic2, isRefreshable: isRefreshable2 } = options;
					 if (!isPeriodic2 && !isRefreshable2) {
						if (handleId2) {
						  delete tasksByHandleId[handleId2];
						} else if (handle2) {
						  handle2[taskSymbol] = null;
						}
					 }
				  }
				};
				const task = scheduleMacroTaskWithCurrentZone(setName, args[0], options, scheduleTask, clearTask);
				if (!task) {
				  return task;
				}
				const { handleId, handle, isRefreshable, isPeriodic } = task.data;
				if (handleId) {
				  tasksByHandleId[handleId] = task;
				} else if (handle) {
				  handle[taskSymbol] = task;
				  if (isRefreshable && !isPeriodic) {
					 const originalRefresh = handle.refresh;
					 handle.refresh = function() {
						const { zone, state } = task;
						if (state === "notScheduled") {
						  task._state = "scheduled";
						  zone._updateTaskCount(task, 1);
						} else if (state === "running") {
						  task._state = "scheduling";
						}
						return originalRefresh.call(this);
					 };
				  }
				}
				return handle ?? handleId ?? task;
			 } else {
				return delegate.apply(window2, args);
			 }
		  });
		  clearNative = patchMethod(window2, cancelName, (delegate) => function(self2, args) {
			 const id3 = args[0];
			 let task;
			 if (isNumber(id3)) {
				task = tasksByHandleId[id3];
				delete tasksByHandleId[id3];
			 } else {
				task = id3?.[taskSymbol];
				if (task) {
				  id3[taskSymbol] = null;
				} else {
				  task = id3;
				}
			 }
			 if (task?.type) {
				if (task.cancelFn) {
				  task.zone.cancelTask(task);
				}
			 } else {
				delegate.apply(window2, args);
			 }
		  });
		}
		function patchCustomElements(_global3, api) {
		  const { isBrowser: isBrowser2, isMix: isMix2 } = api.getGlobalObjects();
		  if (!isBrowser2 && !isMix2 || !_global3["customElements"] || !("customElements" in _global3)) {
			 return;
		  }
		  const callbacks = [
			 "connectedCallback",
			 "disconnectedCallback",
			 "adoptedCallback",
			 "attributeChangedCallback",
			 "formAssociatedCallback",
			 "formDisabledCallback",
			 "formResetCallback",
			 "formStateRestoreCallback"
		  ];
		  api.patchCallbacks(api, _global3.customElements, "customElements", "define", callbacks);
		}
		function eventTargetPatch(_global3, api) {
		  if (Zone[api.symbol("patchEventTarget")]) {
			 return;
		  }
		  const { eventNames, zoneSymbolEventNames: zoneSymbolEventNames2, TRUE_STR: TRUE_STR2, FALSE_STR: FALSE_STR2, ZONE_SYMBOL_PREFIX: ZONE_SYMBOL_PREFIX2 } = api.getGlobalObjects();
		  for (let i = 0; i < eventNames.length; i++) {
			 const eventName = eventNames[i];
			 const falseEventName = eventName + FALSE_STR2;
			 const trueEventName = eventName + TRUE_STR2;
			 const symbol = ZONE_SYMBOL_PREFIX2 + falseEventName;
			 const symbolCapture = ZONE_SYMBOL_PREFIX2 + trueEventName;
			 zoneSymbolEventNames2[eventName] = {};
			 zoneSymbolEventNames2[eventName][FALSE_STR2] = symbol;
			 zoneSymbolEventNames2[eventName][TRUE_STR2] = symbolCapture;
		  }
		  const EVENT_TARGET = _global3["EventTarget"];
		  if (!EVENT_TARGET || !EVENT_TARGET.prototype) {
			 return;
		  }
		  api.patchEventTarget(_global3, api, [EVENT_TARGET && EVENT_TARGET.prototype]);
		  return true;
		}
		function patchEvent(global3, api) {
		  api.patchEventPrototype(global3, api);
		}
		function filterProperties(target, onProperties, ignoreProperties) {
		  if (!ignoreProperties || ignoreProperties.length === 0) {
			 return onProperties;
		  }
		  const tip = ignoreProperties.filter((ip) => ip.target === target);
		  if (!tip || tip.length === 0) {
			 return onProperties;
		  }
		  const targetIgnoreProperties = tip[0].ignoreProperties;
		  return onProperties.filter((op) => targetIgnoreProperties.indexOf(op) === -1);
		}
		function patchFilteredProperties(target, onProperties, ignoreProperties, prototype) {
		  if (!target) {
			 return;
		  }
		  const filteredProperties = filterProperties(target, onProperties, ignoreProperties);
		  patchOnProperties(target, filteredProperties, prototype);
		}
		function getOnEventNames(target) {
		  return Object.getOwnPropertyNames(target).filter((name) => name.startsWith("on") && name.length > 2).map((name) => name.substring(2));
		}
		function propertyDescriptorPatch(api, _global3) {
		  if (isNode && !isMix) {
			 return;
		  }
		  if (Zone[api.symbol("patchEvents")]) {
			 return;
		  }
		  const ignoreProperties = _global3["__Zone_ignore_on_properties"];
		  let patchTargets = [];
		  if (isBrowser) {
			 const internalWindow2 = window;
			 patchTargets = patchTargets.concat([
				"Document",
				"SVGElement",
				"Element",
				"HTMLElement",
				"HTMLBodyElement",
				"HTMLMediaElement",
				"HTMLFrameSetElement",
				"HTMLFrameElement",
				"HTMLIFrameElement",
				"HTMLMarqueeElement",
				"Worker"
			 ]);
			 const ignoreErrorProperties = isIE() ? [{ target: internalWindow2, ignoreProperties: ["error"] }] : [];
			 patchFilteredProperties(internalWindow2, getOnEventNames(internalWindow2), ignoreProperties ? ignoreProperties.concat(ignoreErrorProperties) : ignoreProperties, ObjectGetPrototypeOf(internalWindow2));
		  }
		  patchTargets = patchTargets.concat([
			 "XMLHttpRequest",
			 "XMLHttpRequestEventTarget",
			 "IDBIndex",
			 "IDBRequest",
			 "IDBOpenDBRequest",
			 "IDBDatabase",
			 "IDBTransaction",
			 "IDBCursor",
			 "WebSocket"
		  ]);
		  for (let i = 0; i < patchTargets.length; i++) {
			 const target = _global3[patchTargets[i]];
			 target && target.prototype && patchFilteredProperties(target.prototype, getOnEventNames(target.prototype), ignoreProperties);
		  }
		}
		function patchBrowser(Zone2) {
		  Zone2.__load_patch("legacy", (global3) => {
			 const legacyPatch = global3[Zone2.__symbol__("legacyPatch")];
			 if (legacyPatch) {
				legacyPatch();
			 }
		  });
		  Zone2.__load_patch("timers", (global3) => {
			 const set3 = "set";
			 const clear = "clear";
			 patchTimer(global3, set3, clear, "Timeout");
			 patchTimer(global3, set3, clear, "Interval");
			 patchTimer(global3, set3, clear, "Immediate");
		  });
		  Zone2.__load_patch("requestAnimationFrame", (global3) => {
			 patchTimer(global3, "request", "cancel", "AnimationFrame");
			 patchTimer(global3, "mozRequest", "mozCancel", "AnimationFrame");
			 patchTimer(global3, "webkitRequest", "webkitCancel", "AnimationFrame");
		  });
		  Zone2.__load_patch("blocking", (global3, Zone3) => {
			 const blockingMethods = ["alert", "prompt", "confirm"];
			 for (let i = 0; i < blockingMethods.length; i++) {
				const name = blockingMethods[i];
				patchMethod(global3, name, (delegate, symbol, name2) => {
				  return function(s, args) {
					 return Zone3.current.run(delegate, global3, args, name2);
				  };
				});
			 }
		  });
		  Zone2.__load_patch("EventTarget", (global3, Zone3, api) => {
			 patchEvent(global3, api);
			 eventTargetPatch(global3, api);
			 const XMLHttpRequestEventTarget = global3["XMLHttpRequestEventTarget"];
			 if (XMLHttpRequestEventTarget && XMLHttpRequestEventTarget.prototype) {
				api.patchEventTarget(global3, api, [XMLHttpRequestEventTarget.prototype]);
			 }
		  });
		  Zone2.__load_patch("MutationObserver", (global3, Zone3, api) => {
			 patchClass("MutationObserver");
			 patchClass("WebKitMutationObserver");
		  });
		  Zone2.__load_patch("IntersectionObserver", (global3, Zone3, api) => {
			 patchClass("IntersectionObserver");
		  });
		  Zone2.__load_patch("FileReader", (global3, Zone3, api) => {
			 patchClass("FileReader");
		  });
		  Zone2.__load_patch("on_property", (global3, Zone3, api) => {
			 propertyDescriptorPatch(api, global3);
		  });
		  Zone2.__load_patch("customElements", (global3, Zone3, api) => {
			 patchCustomElements(global3, api);
		  });
		  Zone2.__load_patch("XHR", (global3, Zone3) => {
			 patchXHR(global3);
			 const XHR_TASK = zoneSymbol("xhrTask");
			 const XHR_SYNC = zoneSymbol("xhrSync");
			 const XHR_LISTENER = zoneSymbol("xhrListener");
			 const XHR_SCHEDULED = zoneSymbol("xhrScheduled");
			 const XHR_URL = zoneSymbol("xhrURL");
			 const XHR_ERROR_BEFORE_SCHEDULED = zoneSymbol("xhrErrorBeforeScheduled");
			 function patchXHR(window2) {
				const XMLHttpRequest2 = window2["XMLHttpRequest"];
				if (!XMLHttpRequest2) {
				  return;
				}
				const XMLHttpRequestPrototype = XMLHttpRequest2.prototype;
				function findPendingTask(target) {
				  return target[XHR_TASK];
				}
				let oriAddListener = XMLHttpRequestPrototype[ZONE_SYMBOL_ADD_EVENT_LISTENER];
				let oriRemoveListener = XMLHttpRequestPrototype[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];
				if (!oriAddListener) {
				  const XMLHttpRequestEventTarget = window2["XMLHttpRequestEventTarget"];
				  if (XMLHttpRequestEventTarget) {
					 const XMLHttpRequestEventTargetPrototype = XMLHttpRequestEventTarget.prototype;
					 oriAddListener = XMLHttpRequestEventTargetPrototype[ZONE_SYMBOL_ADD_EVENT_LISTENER];
					 oriRemoveListener = XMLHttpRequestEventTargetPrototype[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];
				  }
				}
				const READY_STATE_CHANGE = "readystatechange";
				const SCHEDULED2 = "scheduled";
				function scheduleTask(task) {
				  const data = task.data;
				  const target = data.target;
				  target[XHR_SCHEDULED] = false;
				  target[XHR_ERROR_BEFORE_SCHEDULED] = false;
				  const listener = target[XHR_LISTENER];
				  if (!oriAddListener) {
					 oriAddListener = target[ZONE_SYMBOL_ADD_EVENT_LISTENER];
					 oriRemoveListener = target[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];
				  }
				  if (listener) {
					 oriRemoveListener.call(target, READY_STATE_CHANGE, listener);
				  }
				  const newListener = target[XHR_LISTENER] = () => {
					 if (target.readyState === target.DONE) {
						if (!data.aborted && target[XHR_SCHEDULED] && task.state === SCHEDULED2) {
						  const loadTasks = target[Zone3.__symbol__("loadfalse")];
						  if (target.status !== 0 && loadTasks && loadTasks.length > 0) {
							 const oriInvoke = task.invoke;
							 task.invoke = function() {
								const loadTasks2 = target[Zone3.__symbol__("loadfalse")];
								for (let i = 0; i < loadTasks2.length; i++) {
								  if (loadTasks2[i] === task) {
									 loadTasks2.splice(i, 1);
								  }
								}
								if (!data.aborted && task.state === SCHEDULED2) {
								  oriInvoke.call(task);
								}
							 };
							 loadTasks.push(task);
						  } else {
							 task.invoke();
						  }
						} else if (!data.aborted && target[XHR_SCHEDULED] === false) {
						  target[XHR_ERROR_BEFORE_SCHEDULED] = true;
						}
					 }
				  };
				  oriAddListener.call(target, READY_STATE_CHANGE, newListener);
				  const storedTask = target[XHR_TASK];
				  if (!storedTask) {
					 target[XHR_TASK] = task;
				  }
				  sendNative.apply(target, data.args);
				  target[XHR_SCHEDULED] = true;
				  return task;
				}
				function placeholderCallback() {
				}
				function clearTask(task) {
				  const data = task.data;
				  data.aborted = true;
				  return abortNative.apply(data.target, data.args);
				}
				const openNative = patchMethod(XMLHttpRequestPrototype, "open", () => function(self2, args) {
				  self2[XHR_SYNC] = args[2] == false;
				  self2[XHR_URL] = args[1];
				  return openNative.apply(self2, args);
				});
				const XMLHTTPREQUEST_SOURCE = "XMLHttpRequest.send";
				const fetchTaskAborting = zoneSymbol("fetchTaskAborting");
				const fetchTaskScheduling = zoneSymbol("fetchTaskScheduling");
				const sendNative = patchMethod(XMLHttpRequestPrototype, "send", () => function(self2, args) {
				  if (Zone3.current[fetchTaskScheduling] === true) {
					 return sendNative.apply(self2, args);
				  }
				  if (self2[XHR_SYNC]) {
					 return sendNative.apply(self2, args);
				  } else {
					 const options = {
						target: self2,
						url: self2[XHR_URL],
						isPeriodic: false,
						args,
						aborted: false
					 };
					 const task = scheduleMacroTaskWithCurrentZone(XMLHTTPREQUEST_SOURCE, placeholderCallback, options, scheduleTask, clearTask);
					 if (self2 && self2[XHR_ERROR_BEFORE_SCHEDULED] === true && !options.aborted && task.state === SCHEDULED2) {
						task.invoke();
					 }
				  }
				});
				const abortNative = patchMethod(XMLHttpRequestPrototype, "abort", () => function(self2, args) {
				  const task = findPendingTask(self2);
				  if (task && typeof task.type == "string") {
					 if (task.cancelFn == null || task.data && task.data.aborted) {
						return;
					 }
					 task.zone.cancelTask(task);
				  } else if (Zone3.current[fetchTaskAborting] === true) {
					 return abortNative.apply(self2, args);
				  }
				});
			 }
		  });
		  Zone2.__load_patch("geolocation", (global3) => {
			 if (global3["navigator"] && global3["navigator"].geolocation) {
				patchPrototype(global3["navigator"].geolocation, ["getCurrentPosition", "watchPosition"]);
			 }
		  });
		  Zone2.__load_patch("PromiseRejectionEvent", (global3, Zone3) => {
			 function findPromiseRejectionHandler(evtName) {
				return function(e) {
				  const eventTasks = findEventTasks(global3, evtName);
				  eventTasks.forEach((eventTask) => {
					 const PromiseRejectionEvent = global3["PromiseRejectionEvent"];
					 if (PromiseRejectionEvent) {
						const evt = new PromiseRejectionEvent(evtName, {
						  promise: e.promise,
						  reason: e.rejection
						});
						eventTask.invoke(evt);
					 }
				  });
				};
			 }
			 if (global3["PromiseRejectionEvent"]) {
				Zone3[zoneSymbol("unhandledPromiseRejectionHandler")] = findPromiseRejectionHandler("unhandledrejection");
				Zone3[zoneSymbol("rejectionHandledHandler")] = findPromiseRejectionHandler("rejectionhandled");
			 }
		  });
		  Zone2.__load_patch("queueMicrotask", (global3, Zone3, api) => {
			 patchQueueMicrotask(global3, api);
		  });
		}
		function patchPromise(Zone2) {
		  Zone2.__load_patch("ZoneAwarePromise", (global3, Zone3, api) => {
			 const ObjectGetOwnPropertyDescriptor2 = Object.getOwnPropertyDescriptor;
			 const ObjectDefineProperty2 = Object.defineProperty;
			 function readableObjectToString(obj) {
				if (obj && obj.toString === Object.prototype.toString) {
				  const className = obj.constructor && obj.constructor.name;
				  return (className ? className : "") + ": " + JSON.stringify(obj);
				}
				return obj ? obj.toString() : Object.prototype.toString.call(obj);
			 }
			 const __symbol__2 = api.symbol;
			 const _uncaughtPromiseErrors = [];
			 const isDisableWrappingUncaughtPromiseRejection = global3[__symbol__2("DISABLE_WRAPPING_UNCAUGHT_PROMISE_REJECTION")] !== false;
			 const symbolPromise = __symbol__2("Promise");
			 const symbolThen = __symbol__2("then");
			 const creationTrace = "__creationTrace__";
			 api.onUnhandledError = (e) => {
				if (api.showUncaughtError()) {
				  const rejection = e && e.rejection;
				  if (rejection) {
					 console.error("Unhandled Promise rejection:", rejection instanceof Error ? rejection.message : rejection, "; Zone:", e.zone.name, "; Task:", e.task && e.task.source, "; Value:", rejection, rejection instanceof Error ? rejection.stack : void 0);
				  } else {
					 console.error(e);
				  }
				}
			 };
			 api.microtaskDrainDone = () => {
				while (_uncaughtPromiseErrors.length) {
				  const uncaughtPromiseError = _uncaughtPromiseErrors.shift();
				  try {
					 uncaughtPromiseError.zone.runGuarded(() => {
						if (uncaughtPromiseError.throwOriginal) {
						  throw uncaughtPromiseError.rejection;
						}
						throw uncaughtPromiseError;
					 });
				  } catch (error) {
					 handleUnhandledRejection(error);
				  }
				}
			 };
			 const UNHANDLED_PROMISE_REJECTION_HANDLER_SYMBOL = __symbol__2("unhandledPromiseRejectionHandler");
			 function handleUnhandledRejection(e) {
				api.onUnhandledError(e);
				try {
				  const handler = Zone3[UNHANDLED_PROMISE_REJECTION_HANDLER_SYMBOL];
				  if (typeof handler === "function") {
					 handler.call(this, e);
				  }
				} catch (err) {
				}
			 }
			 function isThenable(value) {
				return value && value.then;
			 }
			 function forwardResolution(value) {
				return value;
			 }
			 function forwardRejection(rejection) {
				return ZoneAwarePromise.reject(rejection);
			 }
			 const symbolState = __symbol__2("state");
			 const symbolValue = __symbol__2("value");
			 const symbolFinally = __symbol__2("finally");
			 const symbolParentPromiseValue = __symbol__2("parentPromiseValue");
			 const symbolParentPromiseState = __symbol__2("parentPromiseState");
			 const source = "Promise.then";
			 const UNRESOLVED = null;
			 const RESOLVED = true;
			 const REJECTED = false;
			 const REJECTED_NO_CATCH = 0;
			 function makeResolver(promise, state) {
				return (v) => {
				  try {
					 resolvePromise(promise, state, v);
				  } catch (err) {
					 resolvePromise(promise, false, err);
				  }
				};
			 }
			 const once = function() {
				let wasCalled = false;
				return function wrapper(wrappedFunction) {
				  return function() {
					 if (wasCalled) {
						return;
					 }
					 wasCalled = true;
					 wrappedFunction.apply(null, arguments);
				  };
				};
			 };
			 const TYPE_ERROR = "Promise resolved with itself";
			 const CURRENT_TASK_TRACE_SYMBOL = __symbol__2("currentTaskTrace");
			 function resolvePromise(promise, state, value) {
				const onceWrapper = once();
				if (promise === value) {
				  throw new TypeError(TYPE_ERROR);
				}
				if (promise[symbolState] === UNRESOLVED) {
				  let then = null;
				  try {
					 if (typeof value === "object" || typeof value === "function") {
						then = value && value.then;
					 }
				  } catch (err) {
					 onceWrapper(() => {
						resolvePromise(promise, false, err);
					 })();
					 return promise;
				  }
				  if (state !== REJECTED && value instanceof ZoneAwarePromise && value.hasOwnProperty(symbolState) && value.hasOwnProperty(symbolValue) && value[symbolState] !== UNRESOLVED) {
					 clearRejectedNoCatch(value);
					 resolvePromise(promise, value[symbolState], value[symbolValue]);
				  } else if (state !== REJECTED && typeof then === "function") {
					 try {
						then.call(value, onceWrapper(makeResolver(promise, state)), onceWrapper(makeResolver(promise, false)));
					 } catch (err) {
						onceWrapper(() => {
						  resolvePromise(promise, false, err);
						})();
					 }
				  } else {
					 promise[symbolState] = state;
					 const queue = promise[symbolValue];
					 promise[symbolValue] = value;
					 if (promise[symbolFinally] === symbolFinally) {
						if (state === RESOLVED) {
						  promise[symbolState] = promise[symbolParentPromiseState];
						  promise[symbolValue] = promise[symbolParentPromiseValue];
						}
					 }
					 if (state === REJECTED && value instanceof Error) {
						const trace = Zone3.currentTask && Zone3.currentTask.data && Zone3.currentTask.data[creationTrace];
						if (trace) {
						  ObjectDefineProperty2(value, CURRENT_TASK_TRACE_SYMBOL, {
							 configurable: true,
							 enumerable: false,
							 writable: true,
							 value: trace
						  });
						}
					 }
					 for (let i = 0; i < queue.length; ) {
						scheduleResolveOrReject(promise, queue[i++], queue[i++], queue[i++], queue[i++]);
					 }
					 if (queue.length == 0 && state == REJECTED) {
						promise[symbolState] = REJECTED_NO_CATCH;
						let uncaughtPromiseError = value;
						try {
						  throw new Error("Uncaught (in promise): " + readableObjectToString(value) + (value && value.stack ? "\n" + value.stack : ""));
						} catch (err) {
						  uncaughtPromiseError = err;
						}
						if (isDisableWrappingUncaughtPromiseRejection) {
						  uncaughtPromiseError.throwOriginal = true;
						}
						uncaughtPromiseError.rejection = value;
						uncaughtPromiseError.promise = promise;
						uncaughtPromiseError.zone = Zone3.current;
						uncaughtPromiseError.task = Zone3.currentTask;
						_uncaughtPromiseErrors.push(uncaughtPromiseError);
						api.scheduleMicroTask();
					 }
				  }
				}
				return promise;
			 }
			 const REJECTION_HANDLED_HANDLER = __symbol__2("rejectionHandledHandler");
			 function clearRejectedNoCatch(promise) {
				if (promise[symbolState] === REJECTED_NO_CATCH) {
				  try {
					 const handler = Zone3[REJECTION_HANDLED_HANDLER];
					 if (handler && typeof handler === "function") {
						handler.call(this, { rejection: promise[symbolValue], promise });
					 }
				  } catch (err) {
				  }
				  promise[symbolState] = REJECTED;
				  for (let i = 0; i < _uncaughtPromiseErrors.length; i++) {
					 if (promise === _uncaughtPromiseErrors[i].promise) {
						_uncaughtPromiseErrors.splice(i, 1);
					 }
				  }
				}
			 }
			 function scheduleResolveOrReject(promise, zone, chainPromise, onFulfilled, onRejected) {
				clearRejectedNoCatch(promise);
				const promiseState = promise[symbolState];
				const delegate = promiseState ? typeof onFulfilled === "function" ? onFulfilled : forwardResolution : typeof onRejected === "function" ? onRejected : forwardRejection;
				zone.scheduleMicroTask(source, () => {
				  try {
					 const parentPromiseValue = promise[symbolValue];
					 const isFinallyPromise = !!chainPromise && symbolFinally === chainPromise[symbolFinally];
					 if (isFinallyPromise) {
						chainPromise[symbolParentPromiseValue] = parentPromiseValue;
						chainPromise[symbolParentPromiseState] = promiseState;
					 }
					 const value = zone.run(delegate, void 0, isFinallyPromise && delegate !== forwardRejection && delegate !== forwardResolution ? [] : [parentPromiseValue]);
					 resolvePromise(chainPromise, true, value);
				  } catch (error) {
					 resolvePromise(chainPromise, false, error);
				  }
				}, chainPromise);
			 }
			 const ZONE_AWARE_PROMISE_TO_STRING = "function ZoneAwarePromise() { [native code] }";
			 const noop5 = function() {
			 };
			 const AggregateError = global3.AggregateError;
			 class ZoneAwarePromise {
				static toString() {
				  return ZONE_AWARE_PROMISE_TO_STRING;
				}
				static resolve(value) {
				  if (value instanceof ZoneAwarePromise) {
					 return value;
				  }
				  return resolvePromise(new this(null), RESOLVED, value);
				}
				static reject(error) {
				  return resolvePromise(new this(null), REJECTED, error);
				}
				static withResolvers() {
				  const result = {};
				  result.promise = new ZoneAwarePromise((res, rej) => {
					 result.resolve = res;
					 result.reject = rej;
				  });
				  return result;
				}
				static any(values) {
				  if (!values || typeof values[Symbol.iterator] !== "function") {
					 return Promise.reject(new AggregateError([], "All promises were rejected"));
				  }
				  const promises = [];
				  let count = 0;
				  try {
					 for (let v of values) {
						count++;
						promises.push(ZoneAwarePromise.resolve(v));
					 }
				  } catch (err) {
					 return Promise.reject(new AggregateError([], "All promises were rejected"));
				  }
				  if (count === 0) {
					 return Promise.reject(new AggregateError([], "All promises were rejected"));
				  }
				  let finished = false;
				  const errors = [];
				  return new ZoneAwarePromise((resolve, reject) => {
					 for (let i = 0; i < promises.length; i++) {
						promises[i].then((v) => {
						  if (finished) {
							 return;
						  }
						  finished = true;
						  resolve(v);
						}, (err) => {
						  errors.push(err);
						  count--;
						  if (count === 0) {
							 finished = true;
							 reject(new AggregateError(errors, "All promises were rejected"));
						  }
						});
					 }
				  });
				}
				static race(values) {
				  let resolve;
				  let reject;
				  let promise = new this((res, rej) => {
					 resolve = res;
					 reject = rej;
				  });
				  function onResolve(value) {
					 resolve(value);
				  }
				  function onReject(error) {
					 reject(error);
				  }
				  for (let value of values) {
					 if (!isThenable(value)) {
						value = this.resolve(value);
					 }
					 value.then(onResolve, onReject);
				  }
				  return promise;
				}
				static all(values) {
				  return ZoneAwarePromise.allWithCallback(values);
				}
				static allSettled(values) {
				  const P = this && this.prototype instanceof ZoneAwarePromise ? this : ZoneAwarePromise;
				  return P.allWithCallback(values, {
					 thenCallback: (value) => ({ status: "fulfilled", value }),
					 errorCallback: (err) => ({ status: "rejected", reason: err })
				  });
				}
				static allWithCallback(values, callback) {
				  let resolve;
				  let reject;
				  let promise = new this((res, rej) => {
					 resolve = res;
					 reject = rej;
				  });
				  let unresolvedCount = 2;
				  let valueIndex = 0;
				  const resolvedValues = [];
				  for (let value of values) {
					 if (!isThenable(value)) {
						value = this.resolve(value);
					 }
					 const curValueIndex = valueIndex;
					 try {
						value.then((value2) => {
						  resolvedValues[curValueIndex] = callback ? callback.thenCallback(value2) : value2;
						  unresolvedCount--;
						  if (unresolvedCount === 0) {
							 resolve(resolvedValues);
						  }
						}, (err) => {
						  if (!callback) {
							 reject(err);
						  } else {
							 resolvedValues[curValueIndex] = callback.errorCallback(err);
							 unresolvedCount--;
							 if (unresolvedCount === 0) {
								resolve(resolvedValues);
							 }
						  }
						});
					 } catch (thenErr) {
						reject(thenErr);
					 }
					 unresolvedCount++;
					 valueIndex++;
				  }
				  unresolvedCount -= 2;
				  if (unresolvedCount === 0) {
					 resolve(resolvedValues);
				  }
				  return promise;
				}
				constructor(executor) {
				  const promise = this;
				  if (!(promise instanceof ZoneAwarePromise)) {
					 throw new Error("Must be an instanceof Promise.");
				  }
				  promise[symbolState] = UNRESOLVED;
				  promise[symbolValue] = [];
				  try {
					 const onceWrapper = once();
					 executor && executor(onceWrapper(makeResolver(promise, RESOLVED)), onceWrapper(makeResolver(promise, REJECTED)));
				  } catch (error) {
					 resolvePromise(promise, false, error);
				  }
				}
				get [Symbol.toStringTag]() {
				  return "Promise";
				}
				get [Symbol.species]() {
				  return ZoneAwarePromise;
				}
				then(onFulfilled, onRejected) {
				  let C2 = this.constructor?.[Symbol.species];
				  if (!C2 || typeof C2 !== "function") {
					 C2 = this.constructor || ZoneAwarePromise;
				  }
				  const chainPromise = new C2(noop5);
				  const zone = Zone3.current;
				  if (this[symbolState] == UNRESOLVED) {
					 this[symbolValue].push(zone, chainPromise, onFulfilled, onRejected);
				  } else {
					 scheduleResolveOrReject(this, zone, chainPromise, onFulfilled, onRejected);
				  }
				  return chainPromise;
				}
				catch(onRejected) {
				  return this.then(null, onRejected);
				}
				finally(onFinally) {
				  let C2 = this.constructor?.[Symbol.species];
				  if (!C2 || typeof C2 !== "function") {
					 C2 = ZoneAwarePromise;
				  }
				  const chainPromise = new C2(noop5);
				  chainPromise[symbolFinally] = symbolFinally;
				  const zone = Zone3.current;
				  if (this[symbolState] == UNRESOLVED) {
					 this[symbolValue].push(zone, chainPromise, onFinally, onFinally);
				  } else {
					 scheduleResolveOrReject(this, zone, chainPromise, onFinally, onFinally);
				  }
				  return chainPromise;
				}
			 }
			 ZoneAwarePromise["resolve"] = ZoneAwarePromise.resolve;
			 ZoneAwarePromise["reject"] = ZoneAwarePromise.reject;
			 ZoneAwarePromise["race"] = ZoneAwarePromise.race;
			 ZoneAwarePromise["all"] = ZoneAwarePromise.all;
			 const NativePromise = global3[symbolPromise] = global3["Promise"];
			 global3["Promise"] = ZoneAwarePromise;
			 const symbolThenPatched = __symbol__2("thenPatched");
			 function patchThen(Ctor) {
				const proto = Ctor.prototype;
				const prop = ObjectGetOwnPropertyDescriptor2(proto, "then");
				if (prop && (prop.writable === false || !prop.configurable)) {
				  return;
				}
				const originalThen = proto.then;
				proto[symbolThen] = originalThen;
				Ctor.prototype.then = function(onResolve, onReject) {
				  const wrapped = new ZoneAwarePromise((resolve, reject) => {
					 originalThen.call(this, resolve, reject);
				  });
				  return wrapped.then(onResolve, onReject);
				};
				Ctor[symbolThenPatched] = true;
			 }
			 api.patchThen = patchThen;
			 function zoneify(fn) {
				return function(self2, args) {
				  let resultPromise = fn.apply(self2, args);
				  if (resultPromise instanceof ZoneAwarePromise) {
					 return resultPromise;
				  }
				  let ctor = resultPromise.constructor;
				  if (!ctor[symbolThenPatched]) {
					 patchThen(ctor);
				  }
				  return resultPromise;
				};
			 }
			 if (NativePromise) {
				patchThen(NativePromise);
				patchMethod(global3, "fetch", (delegate) => zoneify(delegate));
			 }
			 Promise[Zone3.__symbol__("uncaughtPromiseErrors")] = _uncaughtPromiseErrors;
			 return ZoneAwarePromise;
		  });
		}
		function patchToString(Zone2) {
		  Zone2.__load_patch("toString", (global3) => {
			 const originalFunctionToString = Function.prototype.toString;
			 const ORIGINAL_DELEGATE_SYMBOL = zoneSymbol("OriginalDelegate");
			 const PROMISE_SYMBOL = zoneSymbol("Promise");
			 const ERROR_SYMBOL = zoneSymbol("Error");
			 const newFunctionToString = function toString() {
				if (typeof this === "function") {
				  const originalDelegate = this[ORIGINAL_DELEGATE_SYMBOL];
				  if (originalDelegate) {
					 if (typeof originalDelegate === "function") {
						return originalFunctionToString.call(originalDelegate);
					 } else {
						return Object.prototype.toString.call(originalDelegate);
					 }
				  }
				  if (this === Promise) {
					 const nativePromise = global3[PROMISE_SYMBOL];
					 if (nativePromise) {
						return originalFunctionToString.call(nativePromise);
					 }
				  }
				  if (this === Error) {
					 const nativeError = global3[ERROR_SYMBOL];
					 if (nativeError) {
						return originalFunctionToString.call(nativeError);
					 }
				  }
				}
				return originalFunctionToString.call(this);
			 };
			 newFunctionToString[ORIGINAL_DELEGATE_SYMBOL] = originalFunctionToString;
			 Function.prototype.toString = newFunctionToString;
			 const originalObjectToString = Object.prototype.toString;
			 const PROMISE_OBJECT_TO_STRING = "[object Promise]";
			 Object.prototype.toString = function() {
				if (typeof Promise === "function" && this instanceof Promise) {
				  return PROMISE_OBJECT_TO_STRING;
				}
				return originalObjectToString.call(this);
			 };
		  });
		}
		function patchCallbacks(api, target, targetName, method, callbacks) {
		  const symbol = Zone.__symbol__(method);
		  if (target[symbol]) {
			 return;
		  }
		  const nativeDelegate = target[symbol] = target[method];
		  target[method] = function(name, opts, options) {
			 if (opts && opts.prototype) {
				callbacks.forEach(function(callback) {
				  const source = `${targetName}.${method}::` + callback;
				  const prototype = opts.prototype;
				  try {
					 if (prototype.hasOwnProperty(callback)) {
						const descriptor = api.ObjectGetOwnPropertyDescriptor(prototype, callback);
						if (descriptor && descriptor.value) {
						  descriptor.value = api.wrapWithCurrentZone(descriptor.value, source);
						  api._redefineProperty(opts.prototype, callback, descriptor);
						} else if (prototype[callback]) {
						  prototype[callback] = api.wrapWithCurrentZone(prototype[callback], source);
						}
					 } else if (prototype[callback]) {
						prototype[callback] = api.wrapWithCurrentZone(prototype[callback], source);
					 }
				  } catch {
				  }
				});
			 }
			 return nativeDelegate.call(target, name, opts, options);
		  };
		  api.attachOriginToPatched(target[method], nativeDelegate);
		}
		function patchUtil(Zone2) {
		  Zone2.__load_patch("util", (global3, Zone3, api) => {
			 const eventNames = getOnEventNames(global3);
			 api.patchOnProperties = patchOnProperties;
			 api.patchMethod = patchMethod;
			 api.bindArguments = bindArguments;
			 api.patchMacroTask = patchMacroTask;
			 const SYMBOL_BLACK_LISTED_EVENTS = Zone3.__symbol__("BLACK_LISTED_EVENTS");
			 const SYMBOL_UNPATCHED_EVENTS = Zone3.__symbol__("UNPATCHED_EVENTS");
			 if (global3[SYMBOL_UNPATCHED_EVENTS]) {
				global3[SYMBOL_BLACK_LISTED_EVENTS] = global3[SYMBOL_UNPATCHED_EVENTS];
			 }
			 if (global3[SYMBOL_BLACK_LISTED_EVENTS]) {
				Zone3[SYMBOL_BLACK_LISTED_EVENTS] = Zone3[SYMBOL_UNPATCHED_EVENTS] = global3[SYMBOL_BLACK_LISTED_EVENTS];
			 }
			 api.patchEventPrototype = patchEventPrototype;
			 api.patchEventTarget = patchEventTarget;
			 api.isIEOrEdge = isIEOrEdge;
			 api.ObjectDefineProperty = ObjectDefineProperty;
			 api.ObjectGetOwnPropertyDescriptor = ObjectGetOwnPropertyDescriptor;
			 api.ObjectCreate = ObjectCreate;
			 api.ArraySlice = ArraySlice;
			 api.patchClass = patchClass;
			 api.wrapWithCurrentZone = wrapWithCurrentZone;
			 api.filterProperties = filterProperties;
			 api.attachOriginToPatched = attachOriginToPatched;
			 api._redefineProperty = Object.defineProperty;
			 api.patchCallbacks = patchCallbacks;
			 api.getGlobalObjects = () => ({
				globalSources,
				zoneSymbolEventNames,
				eventNames,
				isBrowser,
				isMix,
				isNode,
				TRUE_STR,
				FALSE_STR,
				ZONE_SYMBOL_PREFIX,
				ADD_EVENT_LISTENER_STR,
				REMOVE_EVENT_LISTENER_STR
			 });
		  });
		}
		function patchCommon(Zone2) {
		  patchPromise(Zone2);
		  patchToString(Zone2);
		  patchUtil(Zone2);
		}
		var Zone$1 = loadZone();
		patchCommon(Zone$1);
		patchBrowser(Zone$1);

		// node_modules/d3-array/src/ascending.js
		function ascending(a, b) {
		  return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
		}

		// node_modules/d3-array/src/descending.js
		function descending(a, b) {
		  return a == null || b == null ? NaN : b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
		}

		// node_modules/d3-array/src/bisector.js
		function bisector(f) {
		  let compare1, compare2, delta;
		  if (f.length !== 2) {
			 compare1 = ascending;
			 compare2 = (d, x) => ascending(f(d), x);
			 delta = (d, x) => f(d) - x;
		  } else {
			 compare1 = f === ascending || f === descending ? f : zero;
			 compare2 = f;
			 delta = f;
		  }
		  function left2(a, x, lo = 0, hi = a.length) {
			 if (lo < hi) {
				if (compare1(x, x) !== 0)
				  return hi;
				do {
				  const mid = lo + hi >>> 1;
				  if (compare2(a[mid], x) < 0)
					 lo = mid + 1;
				  else
					 hi = mid;
				} while (lo < hi);
			 }
			 return lo;
		  }
		  function right2(a, x, lo = 0, hi = a.length) {
			 if (lo < hi) {
				if (compare1(x, x) !== 0)
				  return hi;
				do {
				  const mid = lo + hi >>> 1;
				  if (compare2(a[mid], x) <= 0)
					 lo = mid + 1;
				  else
					 hi = mid;
				} while (lo < hi);
			 }
			 return lo;
		  }
		  function center2(a, x, lo = 0, hi = a.length) {
			 const i = left2(a, x, lo, hi - 1);
			 return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
		  }
		  return { left: left2, center: center2, right: right2 };
		}
		function zero() {
		  return 0;
		}

		// node_modules/d3-array/src/number.js
		function number(x) {
		  return x === null ? NaN : +x;
		}

		// node_modules/d3-array/src/bisect.js
		var ascendingBisect = bisector(ascending);
		var bisectRight = ascendingBisect.right;
		var bisectLeft = ascendingBisect.left;
		var bisectCenter = bisector(number).center;
		var bisect_default = bisectRight;

		// node_modules/internmap/src/index.js
		var InternMap = class extends Map {
		  constructor(entries, key = keyof) {
			 super();
			 Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
			 if (entries != null)
				for (const [key2, value] of entries)
				  this.set(key2, value);
		  }
		  get(key) {
			 return super.get(intern_get(this, key));
		  }
		  has(key) {
			 return super.has(intern_get(this, key));
		  }
		  set(key, value) {
			 return super.set(intern_set(this, key), value);
		  }
		  delete(key) {
			 return super.delete(intern_delete(this, key));
		  }
		};
		function intern_get({ _intern, _key }, value) {
		  const key = _key(value);
		  return _intern.has(key) ? _intern.get(key) : value;
		}
		function intern_set({ _intern, _key }, value) {
		  const key = _key(value);
		  if (_intern.has(key))
			 return _intern.get(key);
		  _intern.set(key, value);
		  return value;
		}
		function intern_delete({ _intern, _key }, value) {
		  const key = _key(value);
		  if (_intern.has(key)) {
			 value = _intern.get(key);
			 _intern.delete(key);
		  }
		  return value;
		}
		function keyof(value) {
		  return value !== null && typeof value === "object" ? value.valueOf() : value;
		}

		// node_modules/d3-array/src/ticks.js
		var e10 = Math.sqrt(50);
		var e5 = Math.sqrt(10);
		var e2 = Math.sqrt(2);
		function tickSpec(start2, stop, count) {
		  const step = (stop - start2) / Math.max(0, count), power = Math.floor(Math.log10(step)), error = step / Math.pow(10, power), factor = error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1;
		  let i1, i2, inc;
		  if (power < 0) {
			 inc = Math.pow(10, -power) / factor;
			 i1 = Math.round(start2 * inc);
			 i2 = Math.round(stop * inc);
			 if (i1 / inc < start2)
				++i1;
			 if (i2 / inc > stop)
				--i2;
			 inc = -inc;
		  } else {
			 inc = Math.pow(10, power) * factor;
			 i1 = Math.round(start2 / inc);
			 i2 = Math.round(stop / inc);
			 if (i1 * inc < start2)
				++i1;
			 if (i2 * inc > stop)
				--i2;
		  }
		  if (i2 < i1 && 0.5 <= count && count < 2)
			 return tickSpec(start2, stop, count * 2);
		  return [i1, i2, inc];
		}
		function tickIncrement(start2, stop, count) {
		  stop = +stop, start2 = +start2, count = +count;
		  return tickSpec(start2, stop, count)[2];
		}
		function tickStep(start2, stop, count) {
		  stop = +stop, start2 = +start2, count = +count;
		  const reverse = stop < start2, inc = reverse ? tickIncrement(stop, start2, count) : tickIncrement(start2, stop, count);
		  return (reverse ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
		}

		// node_modules/d3-axis/src/identity.js
		function identity_default(x) {
		  return x;
		}

		// node_modules/d3-axis/src/axis.js
		var top = 1;
		var right = 2;
		var bottom = 3;
		var left = 4;
		var epsilon = 1e-6;
		function translateX(x) {
		  return "translate(" + x + ",0)";
		}
		function translateY(y) {
		  return "translate(0," + y + ")";
		}
		function number2(scale) {
		  return (d) => +scale(d);
		}
		function center(scale, offset) {
		  offset = Math.max(0, scale.bandwidth() - offset * 2) / 2;
		  if (scale.round())
			 offset = Math.round(offset);
		  return (d) => +scale(d) + offset;
		}
		function entering() {
		  return !this.__axis;
		}
		function axis(orient, scale) {
		  var tickArguments = [], tickValues = null, tickFormat = null, tickSizeInner = 6, tickSizeOuter = 6, tickPadding = 3, offset = typeof window !== "undefined" && window.devicePixelRatio > 1 ? 0 : 0.5, k = orient === top || orient === left ? -1 : 1, x = orient === left || orient === right ? "x" : "y", transform2 = orient === top || orient === bottom ? translateX : translateY;
		  function axis2(context2) {
			 var values = tickValues == null ? scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain() : tickValues, format2 = tickFormat == null ? scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity_default : tickFormat, spacing = Math.max(tickSizeInner, 0) + tickPadding, range = scale.range(), range0 = +range[0] + offset, range1 = +range[range.length - 1] + offset, position = (scale.bandwidth ? center : number2)(scale.copy(), offset), selection2 = context2.selection ? context2.selection() : context2, path = selection2.selectAll(".domain").data([null]), tick = selection2.selectAll(".tick").data(values, scale).order(), tickExit = tick.exit(), tickEnter = tick.enter().append("g").attr("class", "tick"), line = tick.select("line"), text = tick.select("text");
			 path = path.merge(path.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor"));
			 tick = tick.merge(tickEnter);
			 line = line.merge(tickEnter.append("line").attr("stroke", "currentColor").attr(x + "2", k * tickSizeInner));
			 text = text.merge(tickEnter.append("text").attr("fill", "currentColor").attr(x, k * spacing).attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));
			 if (context2 !== selection2) {
				path = path.transition(context2);
				tick = tick.transition(context2);
				line = line.transition(context2);
				text = text.transition(context2);
				tickExit = tickExit.transition(context2).attr("opacity", epsilon).attr("transform", function(d) {
				  return isFinite(d = position(d)) ? transform2(d + offset) : this.getAttribute("transform");
				});
				tickEnter.attr("opacity", epsilon).attr("transform", function(d) {
				  var p = this.parentNode.__axis;
				  return transform2((p && isFinite(p = p(d)) ? p : position(d)) + offset);
				});
			 }
			 tickExit.remove();
			 path.attr("d", orient === left || orient === right ? tickSizeOuter ? "M" + k * tickSizeOuter + "," + range0 + "H" + offset + "V" + range1 + "H" + k * tickSizeOuter : "M" + offset + "," + range0 + "V" + range1 : tickSizeOuter ? "M" + range0 + "," + k * tickSizeOuter + "V" + offset + "H" + range1 + "V" + k * tickSizeOuter : "M" + range0 + "," + offset + "H" + range1);
			 tick.attr("opacity", 1).attr("transform", function(d) {
				return transform2(position(d) + offset);
			 });
			 line.attr(x + "2", k * tickSizeInner);
			 text.attr(x, k * spacing).text(format2);
			 selection2.filter(entering).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");
			 selection2.each(function() {
				this.__axis = position;
			 });
		  }
		  axis2.scale = function(_2) {
			 return arguments.length ? (scale = _2, axis2) : scale;
		  };
		  axis2.ticks = function() {
			 return tickArguments = Array.from(arguments), axis2;
		  };
		  axis2.tickArguments = function(_2) {
			 return arguments.length ? (tickArguments = _2 == null ? [] : Array.from(_2), axis2) : tickArguments.slice();
		  };
		  axis2.tickValues = function(_2) {
			 return arguments.length ? (tickValues = _2 == null ? null : Array.from(_2), axis2) : tickValues && tickValues.slice();
		  };
		  axis2.tickFormat = function(_2) {
			 return arguments.length ? (tickFormat = _2, axis2) : tickFormat;
		  };
		  axis2.tickSize = function(_2) {
			 return arguments.length ? (tickSizeInner = tickSizeOuter = +_2, axis2) : tickSizeInner;
		  };
		  axis2.tickSizeInner = function(_2) {
			 return arguments.length ? (tickSizeInner = +_2, axis2) : tickSizeInner;
		  };
		  axis2.tickSizeOuter = function(_2) {
			 return arguments.length ? (tickSizeOuter = +_2, axis2) : tickSizeOuter;
		  };
		  axis2.tickPadding = function(_2) {
			 return arguments.length ? (tickPadding = +_2, axis2) : tickPadding;
		  };
		  axis2.offset = function(_2) {
			 return arguments.length ? (offset = +_2, axis2) : offset;
		  };
		  return axis2;
		}
		function axisTop(scale) {
		  return axis(top, scale);
		}
		function axisBottom(scale) {
		  return axis(bottom, scale);
		}

		// node_modules/d3-dispatch/src/dispatch.js
		var noop3 = { value: () => {
		} };
		function dispatch() {
		  for (var i = 0, n = arguments.length, _2 = {}, t; i < n; ++i) {
			 if (!(t = arguments[i] + "") || t in _2 || /[\s.]/.test(t))
				throw new Error("illegal type: " + t);
			 _2[t] = [];
		  }
		  return new Dispatch(_2);
		}
		function Dispatch(_2) {
		  this._ = _2;
		}
		function parseTypenames(typenames, types) {
		  return typenames.trim().split(/^|\s+/).map(function(t) {
			 var name = "", i = t.indexOf(".");
			 if (i >= 0)
				name = t.slice(i + 1), t = t.slice(0, i);
			 if (t && !types.hasOwnProperty(t))
				throw new Error("unknown type: " + t);
			 return { type: t, name };
		  });
		}
		Dispatch.prototype = dispatch.prototype = {
		  constructor: Dispatch,
		  on: function(typename, callback) {
			 var _2 = this._, T = parseTypenames(typename + "", _2), t, i = -1, n = T.length;
			 if (arguments.length < 2) {
				while (++i < n)
				  if ((t = (typename = T[i]).type) && (t = get(_2[t], typename.name)))
					 return t;
				return;
			 }
			 if (callback != null && typeof callback !== "function")
				throw new Error("invalid callback: " + callback);
			 while (++i < n) {
				if (t = (typename = T[i]).type)
				  _2[t] = set(_2[t], typename.name, callback);
				else if (callback == null)
				  for (t in _2)
					 _2[t] = set(_2[t], typename.name, null);
			 }
			 return this;
		  },
		  copy: function() {
			 var copy2 = {}, _2 = this._;
			 for (var t in _2)
				copy2[t] = _2[t].slice();
			 return new Dispatch(copy2);
		  },
		  call: function(type2, that) {
			 if ((n = arguments.length - 2) > 0)
				for (var args = new Array(n), i = 0, n, t; i < n; ++i)
				  args[i] = arguments[i + 2];
			 if (!this._.hasOwnProperty(type2))
				throw new Error("unknown type: " + type2);
			 for (t = this._[type2], i = 0, n = t.length; i < n; ++i)
				t[i].value.apply(that, args);
		  },
		  apply: function(type2, that, args) {
			 if (!this._.hasOwnProperty(type2))
				throw new Error("unknown type: " + type2);
			 for (var t = this._[type2], i = 0, n = t.length; i < n; ++i)
				t[i].value.apply(that, args);
		  }
		};
		function get(type2, name) {
		  for (var i = 0, n = type2.length, c2; i < n; ++i) {
			 if ((c2 = type2[i]).name === name) {
				return c2.value;
			 }
		  }
		}
		function set(type2, name, callback) {
		  for (var i = 0, n = type2.length; i < n; ++i) {
			 if (type2[i].name === name) {
				type2[i] = noop3, type2 = type2.slice(0, i).concat(type2.slice(i + 1));
				break;
			 }
		  }
		  if (callback != null)
			 type2.push({ name, value: callback });
		  return type2;
		}
		var dispatch_default = dispatch;

		// node_modules/d3-selection/src/namespaces.js
		var xhtml = "http://www.w3.org/1999/xhtml";
		var namespaces_default = {
		  svg: "http://www.w3.org/2000/svg",
		  xhtml,
		  xlink: "http://www.w3.org/1999/xlink",
		  xml: "http://www.w3.org/XML/1998/namespace",
		  xmlns: "http://www.w3.org/2000/xmlns/"
		};

		// node_modules/d3-selection/src/namespace.js
		function namespace_default(name) {
		  var prefix = name += "", i = prefix.indexOf(":");
		  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns")
			 name = name.slice(i + 1);
		  return namespaces_default.hasOwnProperty(prefix) ? { space: namespaces_default[prefix], local: name } : name;
		}

		// node_modules/d3-selection/src/creator.js
		function creatorInherit(name) {
		  return function() {
			 var document2 = this.ownerDocument, uri = this.namespaceURI;
			 return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name) : document2.createElementNS(uri, name);
		  };
		}
		function creatorFixed(fullname) {
		  return function() {
			 return this.ownerDocument.createElementNS(fullname.space, fullname.local);
		  };
		}
		function creator_default(name) {
		  var fullname = namespace_default(name);
		  return (fullname.local ? creatorFixed : creatorInherit)(fullname);
		}

		// node_modules/d3-selection/src/selector.js
		function none() {
		}
		function selector_default(selector) {
		  return selector == null ? none : function() {
			 return this.querySelector(selector);
		  };
		}

		// node_modules/d3-selection/src/selection/select.js
		function select_default(select) {
		  if (typeof select !== "function")
			 select = selector_default(select);
		  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
			 for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
				if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
				  if ("__data__" in node)
					 subnode.__data__ = node.__data__;
				  subgroup[i] = subnode;
				}
			 }
		  }
		  return new Selection(subgroups, this._parents);
		}

		// node_modules/d3-selection/src/array.js
		function array(x) {
		  return x == null ? [] : Array.isArray(x) ? x : Array.from(x);
		}

		// node_modules/d3-selection/src/selectorAll.js
		function empty() {
		  return [];
		}
		function selectorAll_default(selector) {
		  return selector == null ? empty : function() {
			 return this.querySelectorAll(selector);
		  };
		}

		// node_modules/d3-selection/src/selection/selectAll.js
		function arrayAll(select) {
		  return function() {
			 return array(select.apply(this, arguments));
		  };
		}
		function selectAll_default(select) {
		  if (typeof select === "function")
			 select = arrayAll(select);
		  else
			 select = selectorAll_default(select);
		  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
			 for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
				if (node = group[i]) {
				  subgroups.push(select.call(node, node.__data__, i, group));
				  parents.push(node);
				}
			 }
		  }
		  return new Selection(subgroups, parents);
		}

		// node_modules/d3-selection/src/matcher.js
		function matcher_default(selector) {
		  return function() {
			 return this.matches(selector);
		  };
		}
		function childMatcher(selector) {
		  return function(node) {
			 return node.matches(selector);
		  };
		}

		// node_modules/d3-selection/src/selection/selectChild.js
		var find = Array.prototype.find;
		function childFind(match23) {
		  return function() {
			 return find.call(this.children, match23);
		  };
		}
		function childFirst() {
		  return this.firstElementChild;
		}
		function selectChild_default(match23) {
		  return this.select(match23 == null ? childFirst : childFind(typeof match23 === "function" ? match23 : childMatcher(match23)));
		}

		// node_modules/d3-selection/src/selection/selectChildren.js
		var filter = Array.prototype.filter;
		function children() {
		  return Array.from(this.children);
		}
		function childrenFilter(match23) {
		  return function() {
			 return filter.call(this.children, match23);
		  };
		}
		function selectChildren_default(match23) {
		  return this.selectAll(match23 == null ? children : childrenFilter(typeof match23 === "function" ? match23 : childMatcher(match23)));
		}

		// node_modules/d3-selection/src/selection/filter.js
		function filter_default(match23) {
		  if (typeof match23 !== "function")
			 match23 = matcher_default(match23);
		  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
			 for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
				if ((node = group[i]) && match23.call(node, node.__data__, i, group)) {
				  subgroup.push(node);
				}
			 }
		  }
		  return new Selection(subgroups, this._parents);
		}

		// node_modules/d3-selection/src/selection/sparse.js
		function sparse_default(update) {
		  return new Array(update.length);
		}

		// node_modules/d3-selection/src/selection/enter.js
		function enter_default() {
		  return new Selection(this._enter || this._groups.map(sparse_default), this._parents);
		}
		function EnterNode(parent, datum2) {
		  this.ownerDocument = parent.ownerDocument;
		  this.namespaceURI = parent.namespaceURI;
		  this._next = null;
		  this._parent = parent;
		  this.__data__ = datum2;
		}
		EnterNode.prototype = {
		  constructor: EnterNode,
		  appendChild: function(child) {
			 return this._parent.insertBefore(child, this._next);
		  },
		  insertBefore: function(child, next) {
			 return this._parent.insertBefore(child, next);
		  },
		  querySelector: function(selector) {
			 return this._parent.querySelector(selector);
		  },
		  querySelectorAll: function(selector) {
			 return this._parent.querySelectorAll(selector);
		  }
		};

		// node_modules/d3-selection/src/constant.js
		function constant_default(x) {
		  return function() {
			 return x;
		  };
		}

		// node_modules/d3-selection/src/selection/data.js
		function bindIndex(parent, group, enter, update, exit, data) {
		  var i = 0, node, groupLength = group.length, dataLength = data.length;
		  for (; i < dataLength; ++i) {
			 if (node = group[i]) {
				node.__data__ = data[i];
				update[i] = node;
			 } else {
				enter[i] = new EnterNode(parent, data[i]);
			 }
		  }
		  for (; i < groupLength; ++i) {
			 if (node = group[i]) {
				exit[i] = node;
			 }
		  }
		}
		function bindKey(parent, group, enter, update, exit, data, key) {
		  var i, node, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
		  for (i = 0; i < groupLength; ++i) {
			 if (node = group[i]) {
				keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + "";
				if (nodeByKeyValue.has(keyValue)) {
				  exit[i] = node;
				} else {
				  nodeByKeyValue.set(keyValue, node);
				}
			 }
		  }
		  for (i = 0; i < dataLength; ++i) {
			 keyValue = key.call(parent, data[i], i, data) + "";
			 if (node = nodeByKeyValue.get(keyValue)) {
				update[i] = node;
				node.__data__ = data[i];
				nodeByKeyValue.delete(keyValue);
			 } else {
				enter[i] = new EnterNode(parent, data[i]);
			 }
		  }
		  for (i = 0; i < groupLength; ++i) {
			 if ((node = group[i]) && nodeByKeyValue.get(keyValues[i]) === node) {
				exit[i] = node;
			 }
		  }
		}
		function datum(node) {
		  return node.__data__;
		}
		function data_default(value, key) {
		  if (!arguments.length)
			 return Array.from(this, datum);
		  var bind2 = key ? bindKey : bindIndex, parents = this._parents, groups = this._groups;
		  if (typeof value !== "function")
			 value = constant_default(value);
		  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
			 var parent = parents[j], group = groups[j], groupLength = group.length, data = arraylike(value.call(parent, parent && parent.__data__, j, parents)), dataLength = data.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);
			 bind2(parent, group, enterGroup, updateGroup, exitGroup, data, key);
			 for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
				if (previous = enterGroup[i0]) {
				  if (i0 >= i1)
					 i1 = i0 + 1;
				  while (!(next = updateGroup[i1]) && ++i1 < dataLength)
					 ;
				  previous._next = next || null;
				}
			 }
		  }
		  update = new Selection(update, parents);
		  update._enter = enter;
		  update._exit = exit;
		  return update;
		}
		function arraylike(data) {
		  return typeof data === "object" && "length" in data ? data : Array.from(data);
		}

		// node_modules/d3-selection/src/selection/exit.js
		function exit_default() {
		  return new Selection(this._exit || this._groups.map(sparse_default), this._parents);
		}

		// node_modules/d3-selection/src/selection/join.js
		function join_default(onenter, onupdate, onexit) {
		  var enter = this.enter(), update = this, exit = this.exit();
		  if (typeof onenter === "function") {
			 enter = onenter(enter);
			 if (enter)
				enter = enter.selection();
		  } else {
			 enter = enter.append(onenter + "");
		  }
		  if (onupdate != null) {
			 update = onupdate(update);
			 if (update)
				update = update.selection();
		  }
		  if (onexit == null)
			 exit.remove();
		  else
			 onexit(exit);
		  return enter && update ? enter.merge(update).order() : update;
		}

		// node_modules/d3-selection/src/selection/merge.js
		function merge_default(context2) {
		  var selection2 = context2.selection ? context2.selection() : context2;
		  for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
			 for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge3 = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
				if (node = group0[i] || group1[i]) {
				  merge3[i] = node;
				}
			 }
		  }
		  for (; j < m0; ++j) {
			 merges[j] = groups0[j];
		  }
		  return new Selection(merges, this._parents);
		}

		// node_modules/d3-selection/src/selection/order.js
		function order_default() {
		  for (var groups = this._groups, j = -1, m = groups.length; ++j < m; ) {
			 for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
				if (node = group[i]) {
				  if (next && node.compareDocumentPosition(next) ^ 4)
					 next.parentNode.insertBefore(node, next);
				  next = node;
				}
			 }
		  }
		  return this;
		}

		// node_modules/d3-selection/src/selection/sort.js
		function sort_default(compare) {
		  if (!compare)
			 compare = ascending2;
		  function compareNode(a, b) {
			 return a && b ? compare(a.__data__, b.__data__) : !a - !b;
		  }
		  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
			 for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
				if (node = group[i]) {
				  sortgroup[i] = node;
				}
			 }
			 sortgroup.sort(compareNode);
		  }
		  return new Selection(sortgroups, this._parents).order();
		}
		function ascending2(a, b) {
		  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
		}

		// node_modules/d3-selection/src/selection/call.js
		function call_default() {
		  var callback = arguments[0];
		  arguments[0] = this;
		  callback.apply(null, arguments);
		  return this;
		}

		// node_modules/d3-selection/src/selection/nodes.js
		function nodes_default() {
		  return Array.from(this);
		}

		// node_modules/d3-selection/src/selection/node.js
		function node_default() {
		  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
			 for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
				var node = group[i];
				if (node)
				  return node;
			 }
		  }
		  return null;
		}

		// node_modules/d3-selection/src/selection/size.js
		function size_default() {
		  let size = 0;
		  for (const node of this)
			 ++size;
		  return size;
		}

		// node_modules/d3-selection/src/selection/empty.js
		function empty_default() {
		  return !this.node();
		}

		// node_modules/d3-selection/src/selection/each.js
		function each_default(callback) {
		  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
			 for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
				if (node = group[i])
				  callback.call(node, node.__data__, i, group);
			 }
		  }
		  return this;
		}

		// node_modules/d3-selection/src/selection/attr.js
		function attrRemove(name) {
		  return function() {
			 this.removeAttribute(name);
		  };
		}
		function attrRemoveNS(fullname) {
		  return function() {
			 this.removeAttributeNS(fullname.space, fullname.local);
		  };
		}
		function attrConstant(name, value) {
		  return function() {
			 this.setAttribute(name, value);
		  };
		}
		function attrConstantNS(fullname, value) {
		  return function() {
			 this.setAttributeNS(fullname.space, fullname.local, value);
		  };
		}
		function attrFunction(name, value) {
		  return function() {
			 var v = value.apply(this, arguments);
			 if (v == null)
				this.removeAttribute(name);
			 else
				this.setAttribute(name, v);
		  };
		}
		function attrFunctionNS(fullname, value) {
		  return function() {
			 var v = value.apply(this, arguments);
			 if (v == null)
				this.removeAttributeNS(fullname.space, fullname.local);
			 else
				this.setAttributeNS(fullname.space, fullname.local, v);
		  };
		}
		function attr_default(name, value) {
		  var fullname = namespace_default(name);
		  if (arguments.length < 2) {
			 var node = this.node();
			 return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
		  }
		  return this.each((value == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value === "function" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value));
		}

		// node_modules/d3-selection/src/window.js
		function window_default(node) {
		  return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;
		}

		// node_modules/d3-selection/src/selection/style.js
		function styleRemove(name) {
		  return function() {
			 this.style.removeProperty(name);
		  };
		}
		function styleConstant(name, value, priority) {
		  return function() {
			 this.style.setProperty(name, value, priority);
		  };
		}
		function styleFunction(name, value, priority) {
		  return function() {
			 var v = value.apply(this, arguments);
			 if (v == null)
				this.style.removeProperty(name);
			 else
				this.style.setProperty(name, v, priority);
		  };
		}
		function style_default(name, value, priority) {
		  return arguments.length > 1 ? this.each((value == null ? styleRemove : typeof value === "function" ? styleFunction : styleConstant)(name, value, priority == null ? "" : priority)) : styleValue(this.node(), name);
		}
		function styleValue(node, name) {
		  return node.style.getPropertyValue(name) || window_default(node).getComputedStyle(node, null).getPropertyValue(name);
		}

		// node_modules/d3-selection/src/selection/property.js
		function propertyRemove(name) {
		  return function() {
			 delete this[name];
		  };
		}
		function propertyConstant(name, value) {
		  return function() {
			 this[name] = value;
		  };
		}
		function propertyFunction(name, value) {
		  return function() {
			 var v = value.apply(this, arguments);
			 if (v == null)
				delete this[name];
			 else
				this[name] = v;
		  };
		}
		function property_default(name, value) {
		  return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];
		}

		// node_modules/d3-selection/src/selection/classed.js
		function classArray(string) {
		  return string.trim().split(/^|\s+/);
		}
		function classList(node) {
		  return node.classList || new ClassList(node);
		}
		function ClassList(node) {
		  this._node = node;
		  this._names = classArray(node.getAttribute("class") || "");
		}
		ClassList.prototype = {
		  add: function(name) {
			 var i = this._names.indexOf(name);
			 if (i < 0) {
				this._names.push(name);
				this._node.setAttribute("class", this._names.join(" "));
			 }
		  },
		  remove: function(name) {
			 var i = this._names.indexOf(name);
			 if (i >= 0) {
				this._names.splice(i, 1);
				this._node.setAttribute("class", this._names.join(" "));
			 }
		  },
		  contains: function(name) {
			 return this._names.indexOf(name) >= 0;
		  }
		};
		function classedAdd(node, names) {
		  var list = classList(node), i = -1, n = names.length;
		  while (++i < n)
			 list.add(names[i]);
		}
		function classedRemove(node, names) {
		  var list = classList(node), i = -1, n = names.length;
		  while (++i < n)
			 list.remove(names[i]);
		}
		function classedTrue(names) {
		  return function() {
			 classedAdd(this, names);
		  };
		}
		function classedFalse(names) {
		  return function() {
			 classedRemove(this, names);
		  };
		}
		function classedFunction(names, value) {
		  return function() {
			 (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
		  };
		}
		function classed_default(name, value) {
		  var names = classArray(name + "");
		  if (arguments.length < 2) {
			 var list = classList(this.node()), i = -1, n = names.length;
			 while (++i < n)
				if (!list.contains(names[i]))
				  return false;
			 return true;
		  }
		  return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
		}

		// node_modules/d3-selection/src/selection/text.js
		function textRemove() {
		  this.textContent = "";
		}
		function textConstant(value) {
		  return function() {
			 this.textContent = value;
		  };
		}
		function textFunction(value) {
		  return function() {
			 var v = value.apply(this, arguments);
			 this.textContent = v == null ? "" : v;
		  };
		}
		function text_default(value) {
		  return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction : textConstant)(value)) : this.node().textContent;
		}

		// node_modules/d3-selection/src/selection/html.js
		function htmlRemove() {
		  this.innerHTML = "";
		}
		function htmlConstant(value) {
		  return function() {
			 this.innerHTML = value;
		  };
		}
		function htmlFunction(value) {
		  return function() {
			 var v = value.apply(this, arguments);
			 this.innerHTML = v == null ? "" : v;
		  };
		}
		function html_default(value) {
		  return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
		}

		// node_modules/d3-selection/src/selection/raise.js
		function raise() {
		  if (this.nextSibling)
			 this.parentNode.appendChild(this);
		}
		function raise_default() {
		  return this.each(raise);
		}

		// node_modules/d3-selection/src/selection/lower.js
		function lower() {
		  if (this.previousSibling)
			 this.parentNode.insertBefore(this, this.parentNode.firstChild);
		}
		function lower_default() {
		  return this.each(lower);
		}

		// node_modules/d3-selection/src/selection/append.js
		function append_default(name) {
		  var create2 = typeof name === "function" ? name : creator_default(name);
		  return this.select(function() {
			 return this.appendChild(create2.apply(this, arguments));
		  });
		}

		// node_modules/d3-selection/src/selection/insert.js
		function constantNull() {
		  return null;
		}
		function insert_default(name, before) {
		  var create2 = typeof name === "function" ? name : creator_default(name), select = before == null ? constantNull : typeof before === "function" ? before : selector_default(before);
		  return this.select(function() {
			 return this.insertBefore(create2.apply(this, arguments), select.apply(this, arguments) || null);
		  });
		}

		// node_modules/d3-selection/src/selection/remove.js
		function remove2() {
		  var parent = this.parentNode;
		  if (parent)
			 parent.removeChild(this);
		}
		function remove_default() {
		  return this.each(remove2);
		}

		// node_modules/d3-selection/src/selection/clone.js
		function selection_cloneShallow() {
		  var clone2 = this.cloneNode(false), parent = this.parentNode;
		  return parent ? parent.insertBefore(clone2, this.nextSibling) : clone2;
		}
		function selection_cloneDeep() {
		  var clone2 = this.cloneNode(true), parent = this.parentNode;
		  return parent ? parent.insertBefore(clone2, this.nextSibling) : clone2;
		}
		function clone_default(deep) {
		  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
		}

		// node_modules/d3-selection/src/selection/datum.js
		function datum_default(value) {
		  return arguments.length ? this.property("__data__", value) : this.node().__data__;
		}

		// node_modules/d3-selection/src/selection/on.js
		function contextListener(listener) {
		  return function(event) {
			 listener.call(this, event, this.__data__);
		  };
		}
		function parseTypenames2(typenames) {
		  return typenames.trim().split(/^|\s+/).map(function(t) {
			 var name = "", i = t.indexOf(".");
			 if (i >= 0)
				name = t.slice(i + 1), t = t.slice(0, i);
			 return { type: t, name };
		  });
		}
		function onRemove(typename) {
		  return function() {
			 var on = this.__on;
			 if (!on)
				return;
			 for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
				if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
				  this.removeEventListener(o.type, o.listener, o.options);
				} else {
				  on[++i] = o;
				}
			 }
			 if (++i)
				on.length = i;
			 else
				delete this.__on;
		  };
		}
		function onAdd(typename, value, options) {
		  return function() {
			 var on = this.__on, o, listener = contextListener(value);
			 if (on)
				for (var j = 0, m = on.length; j < m; ++j) {
				  if ((o = on[j]).type === typename.type && o.name === typename.name) {
					 this.removeEventListener(o.type, o.listener, o.options);
					 this.addEventListener(o.type, o.listener = listener, o.options = options);
					 o.value = value;
					 return;
				  }
				}
			 this.addEventListener(typename.type, listener, options);
			 o = { type: typename.type, name: typename.name, value, listener, options };
			 if (!on)
				this.__on = [o];
			 else
				on.push(o);
		  };
		}
		function on_default(typename, value, options) {
		  var typenames = parseTypenames2(typename + ""), i, n = typenames.length, t;
		  if (arguments.length < 2) {
			 var on = this.node().__on;
			 if (on)
				for (var j = 0, m = on.length, o; j < m; ++j) {
				  for (i = 0, o = on[j]; i < n; ++i) {
					 if ((t = typenames[i]).type === o.type && t.name === o.name) {
						return o.value;
					 }
				  }
				}
			 return;
		  }
		  on = value ? onAdd : onRemove;
		  for (i = 0; i < n; ++i)
			 this.each(on(typenames[i], value, options));
		  return this;
		}

		// node_modules/d3-selection/src/selection/dispatch.js
		function dispatchEvent(node, type2, params) {
		  var window2 = window_default(node), event = window2.CustomEvent;
		  if (typeof event === "function") {
			 event = new event(type2, params);
		  } else {
			 event = window2.document.createEvent("Event");
			 if (params)
				event.initEvent(type2, params.bubbles, params.cancelable), event.detail = params.detail;
			 else
				event.initEvent(type2, false, false);
		  }
		  node.dispatchEvent(event);
		}
		function dispatchConstant(type2, params) {
		  return function() {
			 return dispatchEvent(this, type2, params);
		  };
		}
		function dispatchFunction(type2, params) {
		  return function() {
			 return dispatchEvent(this, type2, params.apply(this, arguments));
		  };
		}
		function dispatch_default2(type2, params) {
		  return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type2, params));
		}

		// node_modules/d3-selection/src/selection/iterator.js
		function* iterator_default() {
		  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
			 for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
				if (node = group[i])
				  yield node;
			 }
		  }
		}

		// node_modules/d3-selection/src/selection/index.js
		var root = [null];
		function Selection(groups, parents) {
		  this._groups = groups;
		  this._parents = parents;
		}
		function selection() {
		  return new Selection([[document.documentElement]], root);
		}
		function selection_selection() {
		  return this;
		}
		Selection.prototype = selection.prototype = {
		  constructor: Selection,
		  select: select_default,
		  selectAll: selectAll_default,
		  selectChild: selectChild_default,
		  selectChildren: selectChildren_default,
		  filter: filter_default,
		  data: data_default,
		  enter: enter_default,
		  exit: exit_default,
		  join: join_default,
		  merge: merge_default,
		  selection: selection_selection,
		  order: order_default,
		  sort: sort_default,
		  call: call_default,
		  nodes: nodes_default,
		  node: node_default,
		  size: size_default,
		  empty: empty_default,
		  each: each_default,
		  attr: attr_default,
		  style: style_default,
		  property: property_default,
		  classed: classed_default,
		  text: text_default,
		  html: html_default,
		  raise: raise_default,
		  lower: lower_default,
		  append: append_default,
		  insert: insert_default,
		  remove: remove_default,
		  clone: clone_default,
		  datum: datum_default,
		  on: on_default,
		  dispatch: dispatch_default2,
		  [Symbol.iterator]: iterator_default
		};
		var selection_default = selection;

		// node_modules/d3-selection/src/select.js
		function select_default2(selector) {
		  return typeof selector === "string" ? new Selection([[document.querySelector(selector)]], [document.documentElement]) : new Selection([[selector]], root);
		}

		// node_modules/d3-selection/src/sourceEvent.js
		function sourceEvent_default(event) {
		  let sourceEvent;
		  while (sourceEvent = event.sourceEvent)
			 event = sourceEvent;
		  return event;
		}

		// node_modules/d3-selection/src/pointer.js
		function pointer_default(event, node) {
		  event = sourceEvent_default(event);
		  if (node === void 0)
			 node = event.currentTarget;
		  if (node) {
			 var svg = node.ownerSVGElement || node;
			 if (svg.createSVGPoint) {
				var point = svg.createSVGPoint();
				point.x = event.clientX, point.y = event.clientY;
				point = point.matrixTransform(node.getScreenCTM().inverse());
				return [point.x, point.y];
			 }
			 if (node.getBoundingClientRect) {
				var rect = node.getBoundingClientRect();
				return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
			 }
		  }
		  return [event.pageX, event.pageY];
		}

		// node_modules/d3-selection/src/selectAll.js
		function selectAll_default2(selector) {
		  return typeof selector === "string" ? new Selection([document.querySelectorAll(selector)], [document.documentElement]) : new Selection([array(selector)], root);
		}

		// node_modules/d3-drag/src/noevent.js
		var nonpassive = { passive: false };
		var nonpassivecapture = { capture: true, passive: false };
		function nopropagation(event) {
		  event.stopImmediatePropagation();
		}
		function noevent_default(event) {
		  event.preventDefault();
		  event.stopImmediatePropagation();
		}

		// node_modules/d3-drag/src/nodrag.js
		function nodrag_default(view) {
		  var root2 = view.document.documentElement, selection2 = select_default2(view).on("dragstart.drag", noevent_default, nonpassivecapture);
		  if ("onselectstart" in root2) {
			 selection2.on("selectstart.drag", noevent_default, nonpassivecapture);
		  } else {
			 root2.__noselect = root2.style.MozUserSelect;
			 root2.style.MozUserSelect = "none";
		  }
		}
		function yesdrag(view, noclick) {
		  var root2 = view.document.documentElement, selection2 = select_default2(view).on("dragstart.drag", null);
		  if (noclick) {
			 selection2.on("click.drag", noevent_default, nonpassivecapture);
			 setTimeout(function() {
				selection2.on("click.drag", null);
			 }, 0);
		  }
		  if ("onselectstart" in root2) {
			 selection2.on("selectstart.drag", null);
		  } else {
			 root2.style.MozUserSelect = root2.__noselect;
			 delete root2.__noselect;
		  }
		}

		// node_modules/d3-drag/src/constant.js
		var constant_default2 = (x) => () => x;

		// node_modules/d3-drag/src/event.js
		function DragEvent(type2, {
		  sourceEvent,
		  subject,
		  target,
		  identifier,
		  active,
		  x,
		  y,
		  dx,
		  dy,
		  dispatch: dispatch2
		}) {
		  Object.defineProperties(this, {
			 type: { value: type2, enumerable: true, configurable: true },
			 sourceEvent: { value: sourceEvent, enumerable: true, configurable: true },
			 subject: { value: subject, enumerable: true, configurable: true },
			 target: { value: target, enumerable: true, configurable: true },
			 identifier: { value: identifier, enumerable: true, configurable: true },
			 active: { value: active, enumerable: true, configurable: true },
			 x: { value: x, enumerable: true, configurable: true },
			 y: { value: y, enumerable: true, configurable: true },
			 dx: { value: dx, enumerable: true, configurable: true },
			 dy: { value: dy, enumerable: true, configurable: true },
			 _: { value: dispatch2 }
		  });
		}
		DragEvent.prototype.on = function() {
		  var value = this._.on.apply(this._, arguments);
		  return value === this._ ? this : value;
		};

		// node_modules/d3-drag/src/drag.js
		function defaultFilter(event) {
		  return !event.ctrlKey && !event.button;
		}
		function defaultContainer() {
		  return this.parentNode;
		}
		function defaultSubject(event, d) {
		  return d == null ? { x: event.x, y: event.y } : d;
		}
		function defaultTouchable() {
		  return navigator.maxTouchPoints || "ontouchstart" in this;
		}
		function drag_default() {
		  var filter2 = defaultFilter, container = defaultContainer, subject = defaultSubject, touchable = defaultTouchable, gestures = {}, listeners = dispatch_default("start", "drag", "end"), active = 0, mousedownx, mousedowny, mousemoving, touchending, clickDistance2 = 0;
		  function drag(selection2) {
			 selection2.on("mousedown.drag", mousedowned).filter(touchable).on("touchstart.drag", touchstarted).on("touchmove.drag", touchmoved, nonpassive).on("touchend.drag touchcancel.drag", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
		  }
		  function mousedowned(event, d) {
			 if (touchending || !filter2.call(this, event, d))
				return;
			 var gesture = beforestart(this, container.call(this, event, d), event, d, "mouse");
			 if (!gesture)
				return;
			 select_default2(event.view).on("mousemove.drag", mousemoved, nonpassivecapture).on("mouseup.drag", mouseupped, nonpassivecapture);
			 nodrag_default(event.view);
			 nopropagation(event);
			 mousemoving = false;
			 mousedownx = event.clientX;
			 mousedowny = event.clientY;
			 gesture("start", event);
		  }
		  function mousemoved(event) {
			 noevent_default(event);
			 if (!mousemoving) {
				var dx = event.clientX - mousedownx, dy = event.clientY - mousedowny;
				mousemoving = dx * dx + dy * dy > clickDistance2;
			 }
			 gestures.mouse("drag", event);
		  }
		  function mouseupped(event) {
			 select_default2(event.view).on("mousemove.drag mouseup.drag", null);
			 yesdrag(event.view, mousemoving);
			 noevent_default(event);
			 gestures.mouse("end", event);
		  }
		  function touchstarted(event, d) {
			 if (!filter2.call(this, event, d))
				return;
			 var touches = event.changedTouches, c2 = container.call(this, event, d), n = touches.length, i, gesture;
			 for (i = 0; i < n; ++i) {
				if (gesture = beforestart(this, c2, event, d, touches[i].identifier, touches[i])) {
				  nopropagation(event);
				  gesture("start", event, touches[i]);
				}
			 }
		  }
		  function touchmoved(event) {
			 var touches = event.changedTouches, n = touches.length, i, gesture;
			 for (i = 0; i < n; ++i) {
				if (gesture = gestures[touches[i].identifier]) {
				  noevent_default(event);
				  gesture("drag", event, touches[i]);
				}
			 }
		  }
		  function touchended(event) {
			 var touches = event.changedTouches, n = touches.length, i, gesture;
			 if (touchending)
				clearTimeout(touchending);
			 touchending = setTimeout(function() {
				touchending = null;
			 }, 500);
			 for (i = 0; i < n; ++i) {
				if (gesture = gestures[touches[i].identifier]) {
				  nopropagation(event);
				  gesture("end", event, touches[i]);
				}
			 }
		  }
		  function beforestart(that, container2, event, d, identifier, touch) {
			 var dispatch2 = listeners.copy(), p = pointer_default(touch || event, container2), dx, dy, s;
			 if ((s = subject.call(that, new DragEvent("beforestart", {
				sourceEvent: event,
				target: drag,
				identifier,
				active,
				x: p[0],
				y: p[1],
				dx: 0,
				dy: 0,
				dispatch: dispatch2
			 }), d)) == null)
				return;
			 dx = s.x - p[0] || 0;
			 dy = s.y - p[1] || 0;
			 return function gesture(type2, event2, touch2) {
				var p0 = p, n;
				switch (type2) {
				  case "start":
					 gestures[identifier] = gesture, n = active++;
					 break;
				  case "end":
					 delete gestures[identifier], --active;
				  case "drag":
					 p = pointer_default(touch2 || event2, container2), n = active;
					 break;
				}
				dispatch2.call(
				  type2,
				  that,
				  new DragEvent(type2, {
					 sourceEvent: event2,
					 subject: s,
					 target: drag,
					 identifier,
					 active: n,
					 x: p[0] + dx,
					 y: p[1] + dy,
					 dx: p[0] - p0[0],
					 dy: p[1] - p0[1],
					 dispatch: dispatch2
				  }),
				  d
				);
			 };
		  }
		  drag.filter = function(_2) {
			 return arguments.length ? (filter2 = typeof _2 === "function" ? _2 : constant_default2(!!_2), drag) : filter2;
		  };
		  drag.container = function(_2) {
			 return arguments.length ? (container = typeof _2 === "function" ? _2 : constant_default2(_2), drag) : container;
		  };
		  drag.subject = function(_2) {
			 return arguments.length ? (subject = typeof _2 === "function" ? _2 : constant_default2(_2), drag) : subject;
		  };
		  drag.touchable = function(_2) {
			 return arguments.length ? (touchable = typeof _2 === "function" ? _2 : constant_default2(!!_2), drag) : touchable;
		  };
		  drag.on = function() {
			 var value = listeners.on.apply(listeners, arguments);
			 return value === listeners ? drag : value;
		  };
		  drag.clickDistance = function(_2) {
			 return arguments.length ? (clickDistance2 = (_2 = +_2) * _2, drag) : Math.sqrt(clickDistance2);
		  };
		  return drag;
		}

		// node_modules/d3-color/src/define.js
		function define_default(constructor, factory, prototype) {
		  constructor.prototype = factory.prototype = prototype;
		  prototype.constructor = constructor;
		}
		function extend(parent, definition) {
		  var prototype = Object.create(parent.prototype);
		  for (var key in definition)
			 prototype[key] = definition[key];
		  return prototype;
		}

		// node_modules/d3-color/src/color.js
		function Color() {
		}
		var darker = 0.7;
		var brighter = 1 / darker;
		var reI = "\\s*([+-]?\\d+)\\s*";
		var reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
		var reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
		var reHex = /^#([0-9a-f]{3,8})$/;
		var reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`);
		var reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`);
		var reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`);
		var reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`);
		var reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`);
		var reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
		var named = {
		  aliceblue: 15792383,
		  antiquewhite: 16444375,
		  aqua: 65535,
		  aquamarine: 8388564,
		  azure: 15794175,
		  beige: 16119260,
		  bisque: 16770244,
		  black: 0,
		  blanchedalmond: 16772045,
		  blue: 255,
		  blueviolet: 9055202,
		  brown: 10824234,
		  burlywood: 14596231,
		  cadetblue: 6266528,
		  chartreuse: 8388352,
		  chocolate: 13789470,
		  coral: 16744272,
		  cornflowerblue: 6591981,
		  cornsilk: 16775388,
		  crimson: 14423100,
		  cyan: 65535,
		  darkblue: 139,
		  darkcyan: 35723,
		  darkgoldenrod: 12092939,
		  darkgray: 11119017,
		  darkgreen: 25600,
		  darkgrey: 11119017,
		  darkkhaki: 12433259,
		  darkmagenta: 9109643,
		  darkolivegreen: 5597999,
		  darkorange: 16747520,
		  darkorchid: 10040012,
		  darkred: 9109504,
		  darksalmon: 15308410,
		  darkseagreen: 9419919,
		  darkslateblue: 4734347,
		  darkslategray: 3100495,
		  darkslategrey: 3100495,
		  darkturquoise: 52945,
		  darkviolet: 9699539,
		  deeppink: 16716947,
		  deepskyblue: 49151,
		  dimgray: 6908265,
		  dimgrey: 6908265,
		  dodgerblue: 2003199,
		  firebrick: 11674146,
		  floralwhite: 16775920,
		  forestgreen: 2263842,
		  fuchsia: 16711935,
		  gainsboro: 14474460,
		  ghostwhite: 16316671,
		  gold: 16766720,
		  goldenrod: 14329120,
		  gray: 8421504,
		  green: 32768,
		  greenyellow: 11403055,
		  grey: 8421504,
		  honeydew: 15794160,
		  hotpink: 16738740,
		  indianred: 13458524,
		  indigo: 4915330,
		  ivory: 16777200,
		  khaki: 15787660,
		  lavender: 15132410,
		  lavenderblush: 16773365,
		  lawngreen: 8190976,
		  lemonchiffon: 16775885,
		  lightblue: 11393254,
		  lightcoral: 15761536,
		  lightcyan: 14745599,
		  lightgoldenrodyellow: 16448210,
		  lightgray: 13882323,
		  lightgreen: 9498256,
		  lightgrey: 13882323,
		  lightpink: 16758465,
		  lightsalmon: 16752762,
		  lightseagreen: 2142890,
		  lightskyblue: 8900346,
		  lightslategray: 7833753,
		  lightslategrey: 7833753,
		  lightsteelblue: 11584734,
		  lightyellow: 16777184,
		  lime: 65280,
		  limegreen: 3329330,
		  linen: 16445670,
		  magenta: 16711935,
		  maroon: 8388608,
		  mediumaquamarine: 6737322,
		  mediumblue: 205,
		  mediumorchid: 12211667,
		  mediumpurple: 9662683,
		  mediumseagreen: 3978097,
		  mediumslateblue: 8087790,
		  mediumspringgreen: 64154,
		  mediumturquoise: 4772300,
		  mediumvioletred: 13047173,
		  midnightblue: 1644912,
		  mintcream: 16121850,
		  mistyrose: 16770273,
		  moccasin: 16770229,
		  navajowhite: 16768685,
		  navy: 128,
		  oldlace: 16643558,
		  olive: 8421376,
		  olivedrab: 7048739,
		  orange: 16753920,
		  orangered: 16729344,
		  orchid: 14315734,
		  palegoldenrod: 15657130,
		  palegreen: 10025880,
		  paleturquoise: 11529966,
		  palevioletred: 14381203,
		  papayawhip: 16773077,
		  peachpuff: 16767673,
		  peru: 13468991,
		  pink: 16761035,
		  plum: 14524637,
		  powderblue: 11591910,
		  purple: 8388736,
		  rebeccapurple: 6697881,
		  red: 16711680,
		  rosybrown: 12357519,
		  royalblue: 4286945,
		  saddlebrown: 9127187,
		  salmon: 16416882,
		  sandybrown: 16032864,
		  seagreen: 3050327,
		  seashell: 16774638,
		  sienna: 10506797,
		  silver: 12632256,
		  skyblue: 8900331,
		  slateblue: 6970061,
		  slategray: 7372944,
		  slategrey: 7372944,
		  snow: 16775930,
		  springgreen: 65407,
		  steelblue: 4620980,
		  tan: 13808780,
		  teal: 32896,
		  thistle: 14204888,
		  tomato: 16737095,
		  turquoise: 4251856,
		  violet: 15631086,
		  wheat: 16113331,
		  white: 16777215,
		  whitesmoke: 16119285,
		  yellow: 16776960,
		  yellowgreen: 10145074
		};
		define_default(Color, color, {
		  copy(channels) {
			 return Object.assign(new this.constructor(), this, channels);
		  },
		  displayable() {
			 return this.rgb().displayable();
		  },
		  hex: color_formatHex,
		  // Deprecated! Use color.formatHex.
		  formatHex: color_formatHex,
		  formatHex8: color_formatHex8,
		  formatHsl: color_formatHsl,
		  formatRgb: color_formatRgb,
		  toString: color_formatRgb
		});
		function color_formatHex() {
		  return this.rgb().formatHex();
		}
		function color_formatHex8() {
		  return this.rgb().formatHex8();
		}
		function color_formatHsl() {
		  return hslConvert(this).formatHsl();
		}
		function color_formatRgb() {
		  return this.rgb().formatRgb();
		}
		function color(format2) {
		  var m, l;
		  format2 = (format2 + "").trim().toLowerCase();
		  return (m = reHex.exec(format2)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format2)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format2)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format2)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format2)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
		}
		function rgbn(n) {
		  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
		}
		function rgba(r, g, b, a) {
		  if (a <= 0)
			 r = g = b = NaN;
		  return new Rgb(r, g, b, a);
		}
		function rgbConvert(o) {
		  if (!(o instanceof Color))
			 o = color(o);
		  if (!o)
			 return new Rgb();
		  o = o.rgb();
		  return new Rgb(o.r, o.g, o.b, o.opacity);
		}
		function rgb(r, g, b, opacity) {
		  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
		}
		function Rgb(r, g, b, opacity) {
		  this.r = +r;
		  this.g = +g;
		  this.b = +b;
		  this.opacity = +opacity;
		}
		define_default(Rgb, rgb, extend(Color, {
		  brighter(k) {
			 k = k == null ? brighter : Math.pow(brighter, k);
			 return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
		  },
		  darker(k) {
			 k = k == null ? darker : Math.pow(darker, k);
			 return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
		  },
		  rgb() {
			 return this;
		  },
		  clamp() {
			 return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
		  },
		  displayable() {
			 return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
		  },
		  hex: rgb_formatHex,
		  // Deprecated! Use color.formatHex.
		  formatHex: rgb_formatHex,
		  formatHex8: rgb_formatHex8,
		  formatRgb: rgb_formatRgb,
		  toString: rgb_formatRgb
		}));
		function rgb_formatHex() {
		  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
		}
		function rgb_formatHex8() {
		  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
		}
		function rgb_formatRgb() {
		  const a = clampa(this.opacity);
		  return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
		}
		function clampa(opacity) {
		  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
		}
		function clampi(value) {
		  return Math.max(0, Math.min(255, Math.round(value) || 0));
		}
		function hex(value) {
		  value = clampi(value);
		  return (value < 16 ? "0" : "") + value.toString(16);
		}
		function hsla(h, s, l, a) {
		  if (a <= 0)
			 h = s = l = NaN;
		  else if (l <= 0 || l >= 1)
			 h = s = NaN;
		  else if (s <= 0)
			 h = NaN;
		  return new Hsl(h, s, l, a);
		}
		function hslConvert(o) {
		  if (o instanceof Hsl)
			 return new Hsl(o.h, o.s, o.l, o.opacity);
		  if (!(o instanceof Color))
			 o = color(o);
		  if (!o)
			 return new Hsl();
		  if (o instanceof Hsl)
			 return o;
		  o = o.rgb();
		  var r = o.r / 255, g = o.g / 255, b = o.b / 255, min3 = Math.min(r, g, b), max3 = Math.max(r, g, b), h = NaN, s = max3 - min3, l = (max3 + min3) / 2;
		  if (s) {
			 if (r === max3)
				h = (g - b) / s + (g < b) * 6;
			 else if (g === max3)
				h = (b - r) / s + 2;
			 else
				h = (r - g) / s + 4;
			 s /= l < 0.5 ? max3 + min3 : 2 - max3 - min3;
			 h *= 60;
		  } else {
			 s = l > 0 && l < 1 ? 0 : h;
		  }
		  return new Hsl(h, s, l, o.opacity);
		}
		function hsl(h, s, l, opacity) {
		  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
		}
		function Hsl(h, s, l, opacity) {
		  this.h = +h;
		  this.s = +s;
		  this.l = +l;
		  this.opacity = +opacity;
		}
		define_default(Hsl, hsl, extend(Color, {
		  brighter(k) {
			 k = k == null ? brighter : Math.pow(brighter, k);
			 return new Hsl(this.h, this.s, this.l * k, this.opacity);
		  },
		  darker(k) {
			 k = k == null ? darker : Math.pow(darker, k);
			 return new Hsl(this.h, this.s, this.l * k, this.opacity);
		  },
		  rgb() {
			 var h = this.h % 360 + (this.h < 0) * 360, s = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
			 return new Rgb(
				hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
				hsl2rgb(h, m1, m2),
				hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
				this.opacity
			 );
		  },
		  clamp() {
			 return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
		  },
		  displayable() {
			 return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
		  },
		  formatHsl() {
			 const a = clampa(this.opacity);
			 return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
		  }
		}));
		function clamph(value) {
		  value = (value || 0) % 360;
		  return value < 0 ? value + 360 : value;
		}
		function clampt(value) {
		  return Math.max(0, Math.min(1, value || 0));
		}
		function hsl2rgb(h, m1, m2) {
		  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
		}

		// node_modules/d3-color/src/math.js
		var radians = Math.PI / 180;
		var degrees = 180 / Math.PI;

		// node_modules/d3-color/src/cubehelix.js
		var A = -0.14861;
		var B = 1.78277;
		var C = -0.29227;
		var D = -0.90649;
		var E = 1.97294;
		var ED = E * D;
		var EB = E * B;
		var BC_DA = B * C - D * A;
		function cubehelixConvert(o) {
		  if (o instanceof Cubehelix)
			 return new Cubehelix(o.h, o.s, o.l, o.opacity);
		  if (!(o instanceof Rgb))
			 o = rgbConvert(o);
		  var r = o.r / 255, g = o.g / 255, b = o.b / 255, l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB), bl = b - l, k = (E * (g - l) - C * bl) / D, s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), h = s ? Math.atan2(k, bl) * degrees - 120 : NaN;
		  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
		}
		function cubehelix(h, s, l, opacity) {
		  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
		}
		function Cubehelix(h, s, l, opacity) {
		  this.h = +h;
		  this.s = +s;
		  this.l = +l;
		  this.opacity = +opacity;
		}
		define_default(Cubehelix, cubehelix, extend(Color, {
		  brighter(k) {
			 k = k == null ? brighter : Math.pow(brighter, k);
			 return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
		  },
		  darker(k) {
			 k = k == null ? darker : Math.pow(darker, k);
			 return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
		  },
		  rgb() {
			 var h = isNaN(this.h) ? 0 : (this.h + 120) * radians, l = +this.l, a = isNaN(this.s) ? 0 : this.s * l * (1 - l), cosh2 = Math.cos(h), sinh2 = Math.sin(h);
			 return new Rgb(
				255 * (l + a * (A * cosh2 + B * sinh2)),
				255 * (l + a * (C * cosh2 + D * sinh2)),
				255 * (l + a * (E * cosh2)),
				this.opacity
			 );
		  }
		}));

		// node_modules/d3-interpolate/src/basis.js
		function basis(t12, v0, v1, v2, v3) {
		  var t2 = t12 * t12, t3 = t2 * t12;
		  return ((1 - 3 * t12 + 3 * t2 - t3) * v0 + (4 - 6 * t2 + 3 * t3) * v1 + (1 + 3 * t12 + 3 * t2 - 3 * t3) * v2 + t3 * v3) / 6;
		}
		function basis_default(values) {
		  var n = values.length - 1;
		  return function(t) {
			 var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values[i], v2 = values[i + 1], v0 = i > 0 ? values[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
			 return basis((t - i / n) * n, v0, v1, v2, v3);
		  };
		}

		// node_modules/d3-interpolate/src/basisClosed.js
		function basisClosed_default(values) {
		  var n = values.length;
		  return function(t) {
			 var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values[(i + n - 1) % n], v1 = values[i % n], v2 = values[(i + 1) % n], v3 = values[(i + 2) % n];
			 return basis((t - i / n) * n, v0, v1, v2, v3);
		  };
		}

		// node_modules/d3-interpolate/src/constant.js
		var constant_default3 = (x) => () => x;

		// node_modules/d3-interpolate/src/color.js
		function linear(a, d) {
		  return function(t) {
			 return a + t * d;
		  };
		}
		function exponential(a, b, y) {
		  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
			 return Math.pow(a + t * b, y);
		  };
		}
		function hue(a, b) {
		  var d = b - a;
		  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant_default3(isNaN(a) ? b : a);
		}
		function gamma(y) {
		  return (y = +y) === 1 ? nogamma : function(a, b) {
			 return b - a ? exponential(a, b, y) : constant_default3(isNaN(a) ? b : a);
		  };
		}
		function nogamma(a, b) {
		  var d = b - a;
		  return d ? linear(a, d) : constant_default3(isNaN(a) ? b : a);
		}

		// node_modules/d3-interpolate/src/rgb.js
		var rgb_default = function rgbGamma(y) {
		  var color2 = gamma(y);
		  function rgb2(start2, end) {
			 var r = color2((start2 = rgb(start2)).r, (end = rgb(end)).r), g = color2(start2.g, end.g), b = color2(start2.b, end.b), opacity = nogamma(start2.opacity, end.opacity);
			 return function(t) {
				start2.r = r(t);
				start2.g = g(t);
				start2.b = b(t);
				start2.opacity = opacity(t);
				return start2 + "";
			 };
		  }
		  rgb2.gamma = rgbGamma;
		  return rgb2;
		}(1);
		function rgbSpline(spline) {
		  return function(colors) {
			 var n = colors.length, r = new Array(n), g = new Array(n), b = new Array(n), i, color2;
			 for (i = 0; i < n; ++i) {
				color2 = rgb(colors[i]);
				r[i] = color2.r || 0;
				g[i] = color2.g || 0;
				b[i] = color2.b || 0;
			 }
			 r = spline(r);
			 g = spline(g);
			 b = spline(b);
			 color2.opacity = 1;
			 return function(t) {
				color2.r = r(t);
				color2.g = g(t);
				color2.b = b(t);
				return color2 + "";
			 };
		  };
		}
		var rgbBasis = rgbSpline(basis_default);
		var rgbBasisClosed = rgbSpline(basisClosed_default);

		// node_modules/d3-interpolate/src/numberArray.js
		function numberArray_default(a, b) {
		  if (!b)
			 b = [];
		  var n = a ? Math.min(b.length, a.length) : 0, c2 = b.slice(), i;
		  return function(t) {
			 for (i = 0; i < n; ++i)
				c2[i] = a[i] * (1 - t) + b[i] * t;
			 return c2;
		  };
		}
		function isNumberArray(x) {
		  return ArrayBuffer.isView(x) && !(x instanceof DataView);
		}

		// node_modules/d3-interpolate/src/array.js
		function genericArray(a, b) {
		  var nb2 = b ? b.length : 0, na = a ? Math.min(nb2, a.length) : 0, x = new Array(na), c2 = new Array(nb2), i;
		  for (i = 0; i < na; ++i)
			 x[i] = value_default(a[i], b[i]);
		  for (; i < nb2; ++i)
			 c2[i] = b[i];
		  return function(t) {
			 for (i = 0; i < na; ++i)
				c2[i] = x[i](t);
			 return c2;
		  };
		}

		// node_modules/d3-interpolate/src/date.js
		function date_default(a, b) {
		  var d = /* @__PURE__ */ new Date();
		  return a = +a, b = +b, function(t) {
			 return d.setTime(a * (1 - t) + b * t), d;
		  };
		}

		// node_modules/d3-interpolate/src/number.js
		function number_default(a, b) {
		  return a = +a, b = +b, function(t) {
			 return a * (1 - t) + b * t;
		  };
		}

		// node_modules/d3-interpolate/src/object.js
		function object_default(a, b) {
		  var i = {}, c2 = {}, k;
		  if (a === null || typeof a !== "object")
			 a = {};
		  if (b === null || typeof b !== "object")
			 b = {};
		  for (k in b) {
			 if (k in a) {
				i[k] = value_default(a[k], b[k]);
			 } else {
				c2[k] = b[k];
			 }
		  }
		  return function(t) {
			 for (k in i)
				c2[k] = i[k](t);
			 return c2;
		  };
		}

		// node_modules/d3-interpolate/src/string.js
		var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
		var reB = new RegExp(reA.source, "g");
		function zero2(b) {
		  return function() {
			 return b;
		  };
		}
		function one(b) {
		  return function(t) {
			 return b(t) + "";
		  };
		}
		function string_default(a, b) {
		  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
		  a = a + "", b = b + "";
		  while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
			 if ((bs = bm.index) > bi) {
				bs = b.slice(bi, bs);
				if (s[i])
				  s[i] += bs;
				else
				  s[++i] = bs;
			 }
			 if ((am = am[0]) === (bm = bm[0])) {
				if (s[i])
				  s[i] += bm;
				else
				  s[++i] = bm;
			 } else {
				s[++i] = null;
				q.push({ i, x: number_default(am, bm) });
			 }
			 bi = reB.lastIndex;
		  }
		  if (bi < b.length) {
			 bs = b.slice(bi);
			 if (s[i])
				s[i] += bs;
			 else
				s[++i] = bs;
		  }
		  return s.length < 2 ? q[0] ? one(q[0].x) : zero2(b) : (b = q.length, function(t) {
			 for (var i2 = 0, o; i2 < b; ++i2)
				s[(o = q[i2]).i] = o.x(t);
			 return s.join("");
		  });
		}

		// node_modules/d3-interpolate/src/value.js
		function value_default(a, b) {
		  var t = typeof b, c2;
		  return b == null || t === "boolean" ? constant_default3(b) : (t === "number" ? number_default : t === "string" ? (c2 = color(b)) ? (b = c2, rgb_default) : string_default : b instanceof color ? rgb_default : b instanceof Date ? date_default : isNumberArray(b) ? numberArray_default : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object_default : number_default)(a, b);
		}

		// node_modules/d3-interpolate/src/round.js
		function round_default(a, b) {
		  return a = +a, b = +b, function(t) {
			 return Math.round(a * (1 - t) + b * t);
		  };
		}

		// node_modules/d3-interpolate/src/transform/decompose.js
		var degrees2 = 180 / Math.PI;
		var identity2 = {
		  translateX: 0,
		  translateY: 0,
		  rotate: 0,
		  skewX: 0,
		  scaleX: 1,
		  scaleY: 1
		};
		function decompose_default(a, b, c2, d, e, f) {
		  var scaleX, scaleY, skewX;
		  if (scaleX = Math.sqrt(a * a + b * b))
			 a /= scaleX, b /= scaleX;
		  if (skewX = a * c2 + b * d)
			 c2 -= a * skewX, d -= b * skewX;
		  if (scaleY = Math.sqrt(c2 * c2 + d * d))
			 c2 /= scaleY, d /= scaleY, skewX /= scaleY;
		  if (a * d < b * c2)
			 a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
		  return {
			 translateX: e,
			 translateY: f,
			 rotate: Math.atan2(b, a) * degrees2,
			 skewX: Math.atan(skewX) * degrees2,
			 scaleX,
			 scaleY
		  };
		}

		// node_modules/d3-interpolate/src/transform/parse.js
		var svgNode;
		function parseCss(value) {
		  const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
		  return m.isIdentity ? identity2 : decompose_default(m.a, m.b, m.c, m.d, m.e, m.f);
		}
		function parseSvg(value) {
		  if (value == null)
			 return identity2;
		  if (!svgNode)
			 svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
		  svgNode.setAttribute("transform", value);
		  if (!(value = svgNode.transform.baseVal.consolidate()))
			 return identity2;
		  value = value.matrix;
		  return decompose_default(value.a, value.b, value.c, value.d, value.e, value.f);
		}

		// node_modules/d3-interpolate/src/transform/index.js
		function interpolateTransform(parse2, pxComma, pxParen, degParen) {
		  function pop(s) {
			 return s.length ? s.pop() + " " : "";
		  }
		  function translate2(xa, ya, xb, yb, s, q) {
			 if (xa !== xb || ya !== yb) {
				var i = s.push("translate(", null, pxComma, null, pxParen);
				q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
			 } else if (xb || yb) {
				s.push("translate(" + xb + pxComma + yb + pxParen);
			 }
		  }
		  function rotate(a, b, s, q) {
			 if (a !== b) {
				if (a - b > 180)
				  b += 360;
				else if (b - a > 180)
				  a += 360;
				q.push({ i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: number_default(a, b) });
			 } else if (b) {
				s.push(pop(s) + "rotate(" + b + degParen);
			 }
		  }
		  function skewX(a, b, s, q) {
			 if (a !== b) {
				q.push({ i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: number_default(a, b) });
			 } else if (b) {
				s.push(pop(s) + "skewX(" + b + degParen);
			 }
		  }
		  function scale(xa, ya, xb, yb, s, q) {
			 if (xa !== xb || ya !== yb) {
				var i = s.push(pop(s) + "scale(", null, ",", null, ")");
				q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
			 } else if (xb !== 1 || yb !== 1) {
				s.push(pop(s) + "scale(" + xb + "," + yb + ")");
			 }
		  }
		  return function(a, b) {
			 var s = [], q = [];
			 a = parse2(a), b = parse2(b);
			 translate2(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
			 rotate(a.rotate, b.rotate, s, q);
			 skewX(a.skewX, b.skewX, s, q);
			 scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
			 a = b = null;
			 return function(t) {
				var i = -1, n = q.length, o;
				while (++i < n)
				  s[(o = q[i]).i] = o.x(t);
				return s.join("");
			 };
		  };
		}
		var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
		var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

		// node_modules/d3-interpolate/src/zoom.js
		var epsilon2 = 1e-12;
		function cosh(x) {
		  return ((x = Math.exp(x)) + 1 / x) / 2;
		}
		function sinh(x) {
		  return ((x = Math.exp(x)) - 1 / x) / 2;
		}
		function tanh(x) {
		  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
		}
		var zoom_default = function zoomRho(rho, rho2, rho4) {
		  function zoom(p0, p1) {
			 var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
			 if (d2 < epsilon2) {
				S = Math.log(w1 / w0) / rho;
				i = function(t) {
				  return [
					 ux0 + t * dx,
					 uy0 + t * dy,
					 w0 * Math.exp(rho * t * S)
				  ];
				};
			 } else {
				var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
				S = (r1 - r0) / rho;
				i = function(t) {
				  var s = t * S, coshr0 = cosh(r0), u2 = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
				  return [
					 ux0 + u2 * dx,
					 uy0 + u2 * dy,
					 w0 * coshr0 / cosh(rho * s + r0)
				  ];
				};
			 }
			 i.duration = S * 1e3 * rho / Math.SQRT2;
			 return i;
		  }
		  zoom.rho = function(_2) {
			 var _1 = Math.max(1e-3, +_2), _22 = _1 * _1, _4 = _22 * _22;
			 return zoomRho(_1, _22, _4);
		  };
		  return zoom;
		}(Math.SQRT2, 2, 4);

		// node_modules/d3-interpolate/src/cubehelix.js
		function cubehelix2(hue2) {
		  return function cubehelixGamma(y) {
			 y = +y;
			 function cubehelix3(start2, end) {
				var h = hue2((start2 = cubehelix(start2)).h, (end = cubehelix(end)).h), s = nogamma(start2.s, end.s), l = nogamma(start2.l, end.l), opacity = nogamma(start2.opacity, end.opacity);
				return function(t) {
				  start2.h = h(t);
				  start2.s = s(t);
				  start2.l = l(Math.pow(t, y));
				  start2.opacity = opacity(t);
				  return start2 + "";
				};
			 }
			 cubehelix3.gamma = cubehelixGamma;
			 return cubehelix3;
		  }(1);
		}
		var cubehelix_default = cubehelix2(hue);
		var cubehelixLong = cubehelix2(nogamma);

		// node_modules/d3-timer/src/timer.js
		var frame = 0;
		var timeout = 0;
		var interval = 0;
		var pokeDelay = 1e3;
		var taskHead;
		var taskTail;
		var clockLast = 0;
		var clockNow = 0;
		var clockSkew = 0;
		var clock = typeof performance === "object" && performance.now ? performance : Date;
		var setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
		  setTimeout(f, 17);
		};
		function now() {
		  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
		}
		function clearNow() {
		  clockNow = 0;
		}
		function Timer() {
		  this._call = this._time = this._next = null;
		}
		Timer.prototype = timer.prototype = {
		  constructor: Timer,
		  restart: function(callback, delay, time) {
			 if (typeof callback !== "function")
				throw new TypeError("callback is not a function");
			 time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
			 if (!this._next && taskTail !== this) {
				if (taskTail)
				  taskTail._next = this;
				else
				  taskHead = this;
				taskTail = this;
			 }
			 this._call = callback;
			 this._time = time;
			 sleep();
		  },
		  stop: function() {
			 if (this._call) {
				this._call = null;
				this._time = Infinity;
				sleep();
			 }
		  }
		};
		function timer(callback, delay, time) {
		  var t = new Timer();
		  t.restart(callback, delay, time);
		  return t;
		}
		function timerFlush() {
		  now();
		  ++frame;
		  var t = taskHead, e;
		  while (t) {
			 if ((e = clockNow - t._time) >= 0)
				t._call.call(void 0, e);
			 t = t._next;
		  }
		  --frame;
		}
		function wake() {
		  clockNow = (clockLast = clock.now()) + clockSkew;
		  frame = timeout = 0;
		  try {
			 timerFlush();
		  } finally {
			 frame = 0;
			 nap();
			 clockNow = 0;
		  }
		}
		function poke() {
		  var now2 = clock.now(), delay = now2 - clockLast;
		  if (delay > pokeDelay)
			 clockSkew -= delay, clockLast = now2;
		}
		function nap() {
		  var t02, t12 = taskHead, t2, time = Infinity;
		  while (t12) {
			 if (t12._call) {
				if (time > t12._time)
				  time = t12._time;
				t02 = t12, t12 = t12._next;
			 } else {
				t2 = t12._next, t12._next = null;
				t12 = t02 ? t02._next = t2 : taskHead = t2;
			 }
		  }
		  taskTail = t02;
		  sleep(time);
		}
		function sleep(time) {
		  if (frame)
			 return;
		  if (timeout)
			 timeout = clearTimeout(timeout);
		  var delay = time - clockNow;
		  if (delay > 24) {
			 if (time < Infinity)
				timeout = setTimeout(wake, time - clock.now() - clockSkew);
			 if (interval)
				interval = clearInterval(interval);
		  } else {
			 if (!interval)
				clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
			 frame = 1, setFrame(wake);
		  }
		}

		// node_modules/d3-timer/src/timeout.js
		function timeout_default(callback, delay, time) {
		  var t = new Timer();
		  delay = delay == null ? 0 : +delay;
		  t.restart((elapsed) => {
			 t.stop();
			 callback(elapsed + delay);
		  }, delay, time);
		  return t;
		}

		// node_modules/d3-transition/src/transition/schedule.js
		var emptyOn = dispatch_default("start", "end", "cancel", "interrupt");
		var emptyTween = [];
		var CREATED = 0;
		var SCHEDULED = 1;
		var STARTING = 2;
		var STARTED = 3;
		var RUNNING = 4;
		var ENDING = 5;
		var ENDED = 6;
		function schedule_default(node, name, id3, index, group, timing) {
		  var schedules = node.__transition;
		  if (!schedules)
			 node.__transition = {};
		  else if (id3 in schedules)
			 return;
		  create(node, id3, {
			 name,
			 index,
			 // For context during callback.
			 group,
			 // For context during callback.
			 on: emptyOn,
			 tween: emptyTween,
			 time: timing.time,
			 delay: timing.delay,
			 duration: timing.duration,
			 ease: timing.ease,
			 timer: null,
			 state: CREATED
		  });
		}
		function init(node, id3) {
		  var schedule = get2(node, id3);
		  if (schedule.state > CREATED)
			 throw new Error("too late; already scheduled");
		  return schedule;
		}
		function set2(node, id3) {
		  var schedule = get2(node, id3);
		  if (schedule.state > STARTED)
			 throw new Error("too late; already running");
		  return schedule;
		}
		function get2(node, id3) {
		  var schedule = node.__transition;
		  if (!schedule || !(schedule = schedule[id3]))
			 throw new Error("transition not found");
		  return schedule;
		}
		function create(node, id3, self2) {
		  var schedules = node.__transition, tween;
		  schedules[id3] = self2;
		  self2.timer = timer(schedule, 0, self2.time);
		  function schedule(elapsed) {
			 self2.state = SCHEDULED;
			 self2.timer.restart(start2, self2.delay, self2.time);
			 if (self2.delay <= elapsed)
				start2(elapsed - self2.delay);
		  }
		  function start2(elapsed) {
			 var i, j, n, o;
			 if (self2.state !== SCHEDULED)
				return stop();
			 for (i in schedules) {
				o = schedules[i];
				if (o.name !== self2.name)
				  continue;
				if (o.state === STARTED)
				  return timeout_default(start2);
				if (o.state === RUNNING) {
				  o.state = ENDED;
				  o.timer.stop();
				  o.on.call("interrupt", node, node.__data__, o.index, o.group);
				  delete schedules[i];
				} else if (+i < id3) {
				  o.state = ENDED;
				  o.timer.stop();
				  o.on.call("cancel", node, node.__data__, o.index, o.group);
				  delete schedules[i];
				}
			 }
			 timeout_default(function() {
				if (self2.state === STARTED) {
				  self2.state = RUNNING;
				  self2.timer.restart(tick, self2.delay, self2.time);
				  tick(elapsed);
				}
			 });
			 self2.state = STARTING;
			 self2.on.call("start", node, node.__data__, self2.index, self2.group);
			 if (self2.state !== STARTING)
				return;
			 self2.state = STARTED;
			 tween = new Array(n = self2.tween.length);
			 for (i = 0, j = -1; i < n; ++i) {
				if (o = self2.tween[i].value.call(node, node.__data__, self2.index, self2.group)) {
				  tween[++j] = o;
				}
			 }
			 tween.length = j + 1;
		  }
		  function tick(elapsed) {
			 var t = elapsed < self2.duration ? self2.ease.call(null, elapsed / self2.duration) : (self2.timer.restart(stop), self2.state = ENDING, 1), i = -1, n = tween.length;
			 while (++i < n) {
				tween[i].call(node, t);
			 }
			 if (self2.state === ENDING) {
				self2.on.call("end", node, node.__data__, self2.index, self2.group);
				stop();
			 }
		  }
		  function stop() {
			 self2.state = ENDED;
			 self2.timer.stop();
			 delete schedules[id3];
			 for (var i in schedules)
				return;
			 delete node.__transition;
		  }
		}

		// node_modules/d3-transition/src/interrupt.js
		function interrupt_default(node, name) {
		  var schedules = node.__transition, schedule, active, empty2 = true, i;
		  if (!schedules)
			 return;
		  name = name == null ? null : name + "";
		  for (i in schedules) {
			 if ((schedule = schedules[i]).name !== name) {
				empty2 = false;
				continue;
			 }
			 active = schedule.state > STARTING && schedule.state < ENDING;
			 schedule.state = ENDED;
			 schedule.timer.stop();
			 schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
			 delete schedules[i];
		  }
		  if (empty2)
			 delete node.__transition;
		}

		// node_modules/d3-transition/src/selection/interrupt.js
		function interrupt_default2(name) {
		  return this.each(function() {
			 interrupt_default(this, name);
		  });
		}

		// node_modules/d3-transition/src/transition/tween.js
		function tweenRemove(id3, name) {
		  var tween0, tween1;
		  return function() {
			 var schedule = set2(this, id3), tween = schedule.tween;
			 if (tween !== tween0) {
				tween1 = tween0 = tween;
				for (var i = 0, n = tween1.length; i < n; ++i) {
				  if (tween1[i].name === name) {
					 tween1 = tween1.slice();
					 tween1.splice(i, 1);
					 break;
				  }
				}
			 }
			 schedule.tween = tween1;
		  };
		}
		function tweenFunction(id3, name, value) {
		  var tween0, tween1;
		  if (typeof value !== "function")
			 throw new Error();
		  return function() {
			 var schedule = set2(this, id3), tween = schedule.tween;
			 if (tween !== tween0) {
				tween1 = (tween0 = tween).slice();
				for (var t = { name, value }, i = 0, n = tween1.length; i < n; ++i) {
				  if (tween1[i].name === name) {
					 tween1[i] = t;
					 break;
				  }
				}
				if (i === n)
				  tween1.push(t);
			 }
			 schedule.tween = tween1;
		  };
		}
		function tween_default(name, value) {
		  var id3 = this._id;
		  name += "";
		  if (arguments.length < 2) {
			 var tween = get2(this.node(), id3).tween;
			 for (var i = 0, n = tween.length, t; i < n; ++i) {
				if ((t = tween[i]).name === name) {
				  return t.value;
				}
			 }
			 return null;
		  }
		  return this.each((value == null ? tweenRemove : tweenFunction)(id3, name, value));
		}
		function tweenValue(transition2, name, value) {
		  var id3 = transition2._id;
		  transition2.each(function() {
			 var schedule = set2(this, id3);
			 (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
		  });
		  return function(node) {
			 return get2(node, id3).value[name];
		  };
		}

		// node_modules/d3-transition/src/transition/interpolate.js
		function interpolate_default(a, b) {
		  var c2;
		  return (typeof b === "number" ? number_default : b instanceof color ? rgb_default : (c2 = color(b)) ? (b = c2, rgb_default) : string_default)(a, b);
		}

		// node_modules/d3-transition/src/transition/attr.js
		function attrRemove2(name) {
		  return function() {
			 this.removeAttribute(name);
		  };
		}
		function attrRemoveNS2(fullname) {
		  return function() {
			 this.removeAttributeNS(fullname.space, fullname.local);
		  };
		}
		function attrConstant2(name, interpolate, value1) {
		  var string00, string1 = value1 + "", interpolate0;
		  return function() {
			 var string0 = this.getAttribute(name);
			 return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
		  };
		}
		function attrConstantNS2(fullname, interpolate, value1) {
		  var string00, string1 = value1 + "", interpolate0;
		  return function() {
			 var string0 = this.getAttributeNS(fullname.space, fullname.local);
			 return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
		  };
		}
		function attrFunction2(name, interpolate, value) {
		  var string00, string10, interpolate0;
		  return function() {
			 var string0, value1 = value(this), string1;
			 if (value1 == null)
				return void this.removeAttribute(name);
			 string0 = this.getAttribute(name);
			 string1 = value1 + "";
			 return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
		  };
		}
		function attrFunctionNS2(fullname, interpolate, value) {
		  var string00, string10, interpolate0;
		  return function() {
			 var string0, value1 = value(this), string1;
			 if (value1 == null)
				return void this.removeAttributeNS(fullname.space, fullname.local);
			 string0 = this.getAttributeNS(fullname.space, fullname.local);
			 string1 = value1 + "";
			 return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
		  };
		}
		function attr_default2(name, value) {
		  var fullname = namespace_default(name), i = fullname === "transform" ? interpolateTransformSvg : interpolate_default;
		  return this.attrTween(name, typeof value === "function" ? (fullname.local ? attrFunctionNS2 : attrFunction2)(fullname, i, tweenValue(this, "attr." + name, value)) : value == null ? (fullname.local ? attrRemoveNS2 : attrRemove2)(fullname) : (fullname.local ? attrConstantNS2 : attrConstant2)(fullname, i, value));
		}

		// node_modules/d3-transition/src/transition/attrTween.js
		function attrInterpolate(name, i) {
		  return function(t) {
			 this.setAttribute(name, i.call(this, t));
		  };
		}
		function attrInterpolateNS(fullname, i) {
		  return function(t) {
			 this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
		  };
		}
		function attrTweenNS(fullname, value) {
		  var t02, i0;
		  function tween() {
			 var i = value.apply(this, arguments);
			 if (i !== i0)
				t02 = (i0 = i) && attrInterpolateNS(fullname, i);
			 return t02;
		  }
		  tween._value = value;
		  return tween;
		}
		function attrTween(name, value) {
		  var t02, i0;
		  function tween() {
			 var i = value.apply(this, arguments);
			 if (i !== i0)
				t02 = (i0 = i) && attrInterpolate(name, i);
			 return t02;
		  }
		  tween._value = value;
		  return tween;
		}
		function attrTween_default(name, value) {
		  var key = "attr." + name;
		  if (arguments.length < 2)
			 return (key = this.tween(key)) && key._value;
		  if (value == null)
			 return this.tween(key, null);
		  if (typeof value !== "function")
			 throw new Error();
		  var fullname = namespace_default(name);
		  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
		}

		// node_modules/d3-transition/src/transition/delay.js
		function delayFunction(id3, value) {
		  return function() {
			 init(this, id3).delay = +value.apply(this, arguments);
		  };
		}
		function delayConstant(id3, value) {
		  return value = +value, function() {
			 init(this, id3).delay = value;
		  };
		}
		function delay_default(value) {
		  var id3 = this._id;
		  return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id3, value)) : get2(this.node(), id3).delay;
		}

		// node_modules/d3-transition/src/transition/duration.js
		function durationFunction(id3, value) {
		  return function() {
			 set2(this, id3).duration = +value.apply(this, arguments);
		  };
		}
		function durationConstant(id3, value) {
		  return value = +value, function() {
			 set2(this, id3).duration = value;
		  };
		}
		function duration_default(value) {
		  var id3 = this._id;
		  return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id3, value)) : get2(this.node(), id3).duration;
		}

		// node_modules/d3-transition/src/transition/ease.js
		function easeConstant(id3, value) {
		  if (typeof value !== "function")
			 throw new Error();
		  return function() {
			 set2(this, id3).ease = value;
		  };
		}
		function ease_default(value) {
		  var id3 = this._id;
		  return arguments.length ? this.each(easeConstant(id3, value)) : get2(this.node(), id3).ease;
		}

		// node_modules/d3-transition/src/transition/easeVarying.js
		function easeVarying(id3, value) {
		  return function() {
			 var v = value.apply(this, arguments);
			 if (typeof v !== "function")
				throw new Error();
			 set2(this, id3).ease = v;
		  };
		}
		function easeVarying_default(value) {
		  if (typeof value !== "function")
			 throw new Error();
		  return this.each(easeVarying(this._id, value));
		}

		// node_modules/d3-transition/src/transition/filter.js
		function filter_default2(match23) {
		  if (typeof match23 !== "function")
			 match23 = matcher_default(match23);
		  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
			 for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
				if ((node = group[i]) && match23.call(node, node.__data__, i, group)) {
				  subgroup.push(node);
				}
			 }
		  }
		  return new Transition(subgroups, this._parents, this._name, this._id);
		}

		// node_modules/d3-transition/src/transition/merge.js
		function merge_default2(transition2) {
		  if (transition2._id !== this._id)
			 throw new Error();
		  for (var groups0 = this._groups, groups1 = transition2._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
			 for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge3 = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
				if (node = group0[i] || group1[i]) {
				  merge3[i] = node;
				}
			 }
		  }
		  for (; j < m0; ++j) {
			 merges[j] = groups0[j];
		  }
		  return new Transition(merges, this._parents, this._name, this._id);
		}

		// node_modules/d3-transition/src/transition/on.js
		function start(name) {
		  return (name + "").trim().split(/^|\s+/).every(function(t) {
			 var i = t.indexOf(".");
			 if (i >= 0)
				t = t.slice(0, i);
			 return !t || t === "start";
		  });
		}
		function onFunction(id3, name, listener) {
		  var on0, on1, sit = start(name) ? init : set2;
		  return function() {
			 var schedule = sit(this, id3), on = schedule.on;
			 if (on !== on0)
				(on1 = (on0 = on).copy()).on(name, listener);
			 schedule.on = on1;
		  };
		}
		function on_default2(name, listener) {
		  var id3 = this._id;
		  return arguments.length < 2 ? get2(this.node(), id3).on.on(name) : this.each(onFunction(id3, name, listener));
		}

		// node_modules/d3-transition/src/transition/remove.js
		function removeFunction(id3) {
		  return function() {
			 var parent = this.parentNode;
			 for (var i in this.__transition)
				if (+i !== id3)
				  return;
			 if (parent)
				parent.removeChild(this);
		  };
		}
		function remove_default2() {
		  return this.on("end.remove", removeFunction(this._id));
		}

		// node_modules/d3-transition/src/transition/select.js
		function select_default3(select) {
		  var name = this._name, id3 = this._id;
		  if (typeof select !== "function")
			 select = selector_default(select);
		  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
			 for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
				if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
				  if ("__data__" in node)
					 subnode.__data__ = node.__data__;
				  subgroup[i] = subnode;
				  schedule_default(subgroup[i], name, id3, i, subgroup, get2(node, id3));
				}
			 }
		  }
		  return new Transition(subgroups, this._parents, name, id3);
		}

		// node_modules/d3-transition/src/transition/selectAll.js
		function selectAll_default3(select) {
		  var name = this._name, id3 = this._id;
		  if (typeof select !== "function")
			 select = selectorAll_default(select);
		  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
			 for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
				if (node = group[i]) {
				  for (var children2 = select.call(node, node.__data__, i, group), child, inherit2 = get2(node, id3), k = 0, l = children2.length; k < l; ++k) {
					 if (child = children2[k]) {
						schedule_default(child, name, id3, k, children2, inherit2);
					 }
				  }
				  subgroups.push(children2);
				  parents.push(node);
				}
			 }
		  }
		  return new Transition(subgroups, parents, name, id3);
		}

		// node_modules/d3-transition/src/transition/selection.js
		var Selection2 = selection_default.prototype.constructor;
		function selection_default2() {
		  return new Selection2(this._groups, this._parents);
		}

		// node_modules/d3-transition/src/transition/style.js
		function styleNull(name, interpolate) {
		  var string00, string10, interpolate0;
		  return function() {
			 var string0 = styleValue(this, name), string1 = (this.style.removeProperty(name), styleValue(this, name));
			 return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate(string00 = string0, string10 = string1);
		  };
		}
		function styleRemove2(name) {
		  return function() {
			 this.style.removeProperty(name);
		  };
		}
		function styleConstant2(name, interpolate, value1) {
		  var string00, string1 = value1 + "", interpolate0;
		  return function() {
			 var string0 = styleValue(this, name);
			 return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
		  };
		}
		function styleFunction2(name, interpolate, value) {
		  var string00, string10, interpolate0;
		  return function() {
			 var string0 = styleValue(this, name), value1 = value(this), string1 = value1 + "";
			 if (value1 == null)
				string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
			 return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
		  };
		}
		function styleMaybeRemove(id3, name) {
		  var on0, on1, listener0, key = "style." + name, event = "end." + key, remove4;
		  return function() {
			 var schedule = set2(this, id3), on = schedule.on, listener = schedule.value[key] == null ? remove4 || (remove4 = styleRemove2(name)) : void 0;
			 if (on !== on0 || listener0 !== listener)
				(on1 = (on0 = on).copy()).on(event, listener0 = listener);
			 schedule.on = on1;
		  };
		}
		function style_default2(name, value, priority) {
		  var i = (name += "") === "transform" ? interpolateTransformCss : interpolate_default;
		  return value == null ? this.styleTween(name, styleNull(name, i)).on("end.style." + name, styleRemove2(name)) : typeof value === "function" ? this.styleTween(name, styleFunction2(name, i, tweenValue(this, "style." + name, value))).each(styleMaybeRemove(this._id, name)) : this.styleTween(name, styleConstant2(name, i, value), priority).on("end.style." + name, null);
		}

		// node_modules/d3-transition/src/transition/styleTween.js
		function styleInterpolate(name, i, priority) {
		  return function(t) {
			 this.style.setProperty(name, i.call(this, t), priority);
		  };
		}
		function styleTween(name, value, priority) {
		  var t, i0;
		  function tween() {
			 var i = value.apply(this, arguments);
			 if (i !== i0)
				t = (i0 = i) && styleInterpolate(name, i, priority);
			 return t;
		  }
		  tween._value = value;
		  return tween;
		}
		function styleTween_default(name, value, priority) {
		  var key = "style." + (name += "");
		  if (arguments.length < 2)
			 return (key = this.tween(key)) && key._value;
		  if (value == null)
			 return this.tween(key, null);
		  if (typeof value !== "function")
			 throw new Error();
		  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
		}

		// node_modules/d3-transition/src/transition/text.js
		function textConstant2(value) {
		  return function() {
			 this.textContent = value;
		  };
		}
		function textFunction2(value) {
		  return function() {
			 var value1 = value(this);
			 this.textContent = value1 == null ? "" : value1;
		  };
		}
		function text_default2(value) {
		  return this.tween("text", typeof value === "function" ? textFunction2(tweenValue(this, "text", value)) : textConstant2(value == null ? "" : value + ""));
		}

		// node_modules/d3-transition/src/transition/textTween.js
		function textInterpolate(i) {
		  return function(t) {
			 this.textContent = i.call(this, t);
		  };
		}
		function textTween(value) {
		  var t02, i0;
		  function tween() {
			 var i = value.apply(this, arguments);
			 if (i !== i0)
				t02 = (i0 = i) && textInterpolate(i);
			 return t02;
		  }
		  tween._value = value;
		  return tween;
		}
		function textTween_default(value) {
		  var key = "text";
		  if (arguments.length < 1)
			 return (key = this.tween(key)) && key._value;
		  if (value == null)
			 return this.tween(key, null);
		  if (typeof value !== "function")
			 throw new Error();
		  return this.tween(key, textTween(value));
		}

		// node_modules/d3-transition/src/transition/transition.js
		function transition_default() {
		  var name = this._name, id0 = this._id, id1 = newId();
		  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
			 for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
				if (node = group[i]) {
				  var inherit2 = get2(node, id0);
				  schedule_default(node, name, id1, i, group, {
					 time: inherit2.time + inherit2.delay + inherit2.duration,
					 delay: 0,
					 duration: inherit2.duration,
					 ease: inherit2.ease
				  });
				}
			 }
		  }
		  return new Transition(groups, this._parents, name, id1);
		}

		// node_modules/d3-transition/src/transition/end.js
		function end_default() {
		  var on0, on1, that = this, id3 = that._id, size = that.size();
		  return new Promise(function(resolve, reject) {
			 var cancel = { value: reject }, end = { value: function() {
				if (--size === 0)
				  resolve();
			 } };
			 that.each(function() {
				var schedule = set2(this, id3), on = schedule.on;
				if (on !== on0) {
				  on1 = (on0 = on).copy();
				  on1._.cancel.push(cancel);
				  on1._.interrupt.push(cancel);
				  on1._.end.push(end);
				}
				schedule.on = on1;
			 });
			 if (size === 0)
				resolve();
		  });
		}

		// node_modules/d3-transition/src/transition/index.js
		var id = 0;
		function Transition(groups, parents, name, id3) {
		  this._groups = groups;
		  this._parents = parents;
		  this._name = name;
		  this._id = id3;
		}
		function transition(name) {
		  return selection_default().transition(name);
		}
		function newId() {
		  return ++id;
		}
		var selection_prototype = selection_default.prototype;
		Transition.prototype = transition.prototype = {
		  constructor: Transition,
		  select: select_default3,
		  selectAll: selectAll_default3,
		  selectChild: selection_prototype.selectChild,
		  selectChildren: selection_prototype.selectChildren,
		  filter: filter_default2,
		  merge: merge_default2,
		  selection: selection_default2,
		  transition: transition_default,
		  call: selection_prototype.call,
		  nodes: selection_prototype.nodes,
		  node: selection_prototype.node,
		  size: selection_prototype.size,
		  empty: selection_prototype.empty,
		  each: selection_prototype.each,
		  on: on_default2,
		  attr: attr_default2,
		  attrTween: attrTween_default,
		  style: style_default2,
		  styleTween: styleTween_default,
		  text: text_default2,
		  textTween: textTween_default,
		  remove: remove_default2,
		  tween: tween_default,
		  delay: delay_default,
		  duration: duration_default,
		  ease: ease_default,
		  easeVarying: easeVarying_default,
		  end: end_default,
		  [Symbol.iterator]: selection_prototype[Symbol.iterator]
		};

		// node_modules/d3-ease/src/linear.js
		var linear2 = (t) => +t;

		// node_modules/d3-ease/src/cubic.js
		function cubicInOut(t) {
		  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
		}

		// node_modules/d3-transition/src/selection/transition.js
		var defaultTiming = {
		  time: null,
		  // Set on use.
		  delay: 0,
		  duration: 250,
		  ease: cubicInOut
		};
		function inherit(node, id3) {
		  var timing;
		  while (!(timing = node.__transition) || !(timing = timing[id3])) {
			 if (!(node = node.parentNode)) {
				throw new Error(`transition ${id3} not found`);
			 }
		  }
		  return timing;
		}
		function transition_default2(name) {
		  var id3, timing;
		  if (name instanceof Transition) {
			 id3 = name._id, name = name._name;
		  } else {
			 id3 = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
		  }
		  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
			 for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
				if (node = group[i]) {
				  schedule_default(node, name, id3, i, group, timing || inherit(node, id3));
				}
			 }
		  }
		  return new Transition(groups, this._parents, name, id3);
		}

		// node_modules/d3-transition/src/selection/index.js
		selection_default.prototype.interrupt = interrupt_default2;
		selection_default.prototype.transition = transition_default2;

		// node_modules/d3-brush/src/brush.js
		var { abs, max, min } = Math;
		function number1(e) {
		  return [+e[0], +e[1]];
		}
		function number22(e) {
		  return [number1(e[0]), number1(e[1])];
		}
		var X = {
		  name: "x",
		  handles: ["w", "e"].map(type),
		  input: function(x, e) {
			 return x == null ? null : [[+x[0], e[0][1]], [+x[1], e[1][1]]];
		  },
		  output: function(xy) {
			 return xy && [xy[0][0], xy[1][0]];
		  }
		};
		var Y = {
		  name: "y",
		  handles: ["n", "s"].map(type),
		  input: function(y, e) {
			 return y == null ? null : [[e[0][0], +y[0]], [e[1][0], +y[1]]];
		  },
		  output: function(xy) {
			 return xy && [xy[0][1], xy[1][1]];
		  }
		};
		var XY = {
		  name: "xy",
		  handles: ["n", "w", "e", "s", "nw", "ne", "sw", "se"].map(type),
		  input: function(xy) {
			 return xy == null ? null : number22(xy);
		  },
		  output: function(xy) {
			 return xy;
		  }
		};
		function type(t) {
		  return { type: t };
		}

		// node_modules/d3-scale/src/init.js
		function initRange(domain, range) {
		  switch (arguments.length) {
			 case 0:
				break;
			 case 1:
				this.range(domain);
				break;
			 default:
				this.range(range).domain(domain);
				break;
		  }
		  return this;
		}

		// node_modules/d3-scale/src/ordinal.js
		var implicit = Symbol("implicit");
		function ordinal() {
		  var index = new InternMap(), domain = [], range = [], unknown = implicit;
		  function scale(d) {
			 let i = index.get(d);
			 if (i === void 0) {
				if (unknown !== implicit)
				  return unknown;
				index.set(d, i = domain.push(d) - 1);
			 }
			 return range[i % range.length];
		  }
		  scale.domain = function(_2) {
			 if (!arguments.length)
				return domain.slice();
			 domain = [], index = new InternMap();
			 for (const value of _2) {
				if (index.has(value))
				  continue;
				index.set(value, domain.push(value) - 1);
			 }
			 return scale;
		  };
		  scale.range = function(_2) {
			 return arguments.length ? (range = Array.from(_2), scale) : range.slice();
		  };
		  scale.unknown = function(_2) {
			 return arguments.length ? (unknown = _2, scale) : unknown;
		  };
		  scale.copy = function() {
			 return ordinal(domain, range).unknown(unknown);
		  };
		  initRange.apply(scale, arguments);
		  return scale;
		}

		// node_modules/d3-scale/src/constant.js
		function constants(x) {
		  return function() {
			 return x;
		  };
		}

		// node_modules/d3-scale/src/number.js
		function number3(x) {
		  return +x;
		}

		// node_modules/d3-scale/src/continuous.js
		var unit = [0, 1];
		function identity3(x) {
		  return x;
		}
		function normalize(a, b) {
		  return (b -= a = +a) ? function(x) {
			 return (x - a) / b;
		  } : constants(isNaN(b) ? NaN : 0.5);
		}
		function clamper(a, b) {
		  var t;
		  if (a > b)
			 t = a, a = b, b = t;
		  return function(x) {
			 return Math.max(a, Math.min(b, x));
		  };
		}
		function bimap(domain, range, interpolate) {
		  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
		  if (d1 < d0)
			 d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
		  else
			 d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
		  return function(x) {
			 return r0(d0(x));
		  };
		}
		function polymap(domain, range, interpolate) {
		  var j = Math.min(domain.length, range.length) - 1, d = new Array(j), r = new Array(j), i = -1;
		  if (domain[j] < domain[0]) {
			 domain = domain.slice().reverse();
			 range = range.slice().reverse();
		  }
		  while (++i < j) {
			 d[i] = normalize(domain[i], domain[i + 1]);
			 r[i] = interpolate(range[i], range[i + 1]);
		  }
		  return function(x) {
			 var i2 = bisect_default(domain, x, 1, j) - 1;
			 return r[i2](d[i2](x));
		  };
		}
		function copy(source, target) {
		  return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
		}
		function transformer() {
		  var domain = unit, range = unit, interpolate = value_default, transform2, untransform, unknown, clamp = identity3, piecewise, output, input2;
		  function rescale() {
			 var n = Math.min(domain.length, range.length);
			 if (clamp !== identity3)
				clamp = clamper(domain[0], domain[n - 1]);
			 piecewise = n > 2 ? polymap : bimap;
			 output = input2 = null;
			 return scale;
		  }
		  function scale(x) {
			 return x == null || isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform2), range, interpolate)))(transform2(clamp(x)));
		  }
		  scale.invert = function(y) {
			 return clamp(untransform((input2 || (input2 = piecewise(range, domain.map(transform2), number_default)))(y)));
		  };
		  scale.domain = function(_2) {
			 return arguments.length ? (domain = Array.from(_2, number3), rescale()) : domain.slice();
		  };
		  scale.range = function(_2) {
			 return arguments.length ? (range = Array.from(_2), rescale()) : range.slice();
		  };
		  scale.rangeRound = function(_2) {
			 return range = Array.from(_2), interpolate = round_default, rescale();
		  };
		  scale.clamp = function(_2) {
			 return arguments.length ? (clamp = _2 ? true : identity3, rescale()) : clamp !== identity3;
		  };
		  scale.interpolate = function(_2) {
			 return arguments.length ? (interpolate = _2, rescale()) : interpolate;
		  };
		  scale.unknown = function(_2) {
			 return arguments.length ? (unknown = _2, scale) : unknown;
		  };
		  return function(t, u2) {
			 transform2 = t, untransform = u2;
			 return rescale();
		  };
		}
		function continuous() {
		  return transformer()(identity3, identity3);
		}

		// node_modules/d3-scale/src/nice.js
		function nice(domain, interval2) {
		  domain = domain.slice();
		  var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], t;
		  if (x1 < x0) {
			 t = i0, i0 = i1, i1 = t;
			 t = x0, x0 = x1, x1 = t;
		  }
		  domain[i0] = interval2.floor(x0);
		  domain[i1] = interval2.ceil(x1);
		  return domain;
		}

		// node_modules/d3-time/src/interval.js
		var t0 = /* @__PURE__ */ new Date();
		var t1 = /* @__PURE__ */ new Date();
		function timeInterval(floori, offseti, count, field) {
		  function interval2(date2) {
			 return floori(date2 = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+date2)), date2;
		  }
		  interval2.floor = (date2) => {
			 return floori(date2 = /* @__PURE__ */ new Date(+date2)), date2;
		  };
		  interval2.ceil = (date2) => {
			 return floori(date2 = new Date(date2 - 1)), offseti(date2, 1), floori(date2), date2;
		  };
		  interval2.round = (date2) => {
			 const d0 = interval2(date2), d1 = interval2.ceil(date2);
			 return date2 - d0 < d1 - date2 ? d0 : d1;
		  };
		  interval2.offset = (date2, step) => {
			 return offseti(date2 = /* @__PURE__ */ new Date(+date2), step == null ? 1 : Math.floor(step)), date2;
		  };
		  interval2.range = (start2, stop, step) => {
			 const range = [];
			 start2 = interval2.ceil(start2);
			 step = step == null ? 1 : Math.floor(step);
			 if (!(start2 < stop) || !(step > 0))
				return range;
			 let previous;
			 do
				range.push(previous = /* @__PURE__ */ new Date(+start2)), offseti(start2, step), floori(start2);
			 while (previous < start2 && start2 < stop);
			 return range;
		  };
		  interval2.filter = (test) => {
			 return timeInterval((date2) => {
				if (date2 >= date2)
				  while (floori(date2), !test(date2))
					 date2.setTime(date2 - 1);
			 }, (date2, step) => {
				if (date2 >= date2) {
				  if (step < 0)
					 while (++step <= 0) {
						while (offseti(date2, -1), !test(date2)) {
						}
					 }
				  else
					 while (--step >= 0) {
						while (offseti(date2, 1), !test(date2)) {
						}
					 }
				}
			 });
		  };
		  if (count) {
			 interval2.count = (start2, end) => {
				t0.setTime(+start2), t1.setTime(+end);
				floori(t0), floori(t1);
				return Math.floor(count(t0, t1));
			 };
			 interval2.every = (step) => {
				step = Math.floor(step);
				return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval2 : interval2.filter(field ? (d) => field(d) % step === 0 : (d) => interval2.count(0, d) % step === 0);
			 };
		  }
		  return interval2;
		}

		// node_modules/d3-time/src/millisecond.js
		var millisecond = timeInterval(() => {
		}, (date2, step) => {
		  date2.setTime(+date2 + step);
		}, (start2, end) => {
		  return end - start2;
		});
		millisecond.every = (k) => {
		  k = Math.floor(k);
		  if (!isFinite(k) || !(k > 0))
			 return null;
		  if (!(k > 1))
			 return millisecond;
		  return timeInterval((date2) => {
			 date2.setTime(Math.floor(date2 / k) * k);
		  }, (date2, step) => {
			 date2.setTime(+date2 + step * k);
		  }, (start2, end) => {
			 return (end - start2) / k;
		  });
		};
		var milliseconds = millisecond.range;

		// node_modules/d3-time/src/duration.js
		var durationSecond = 1e3;
		var durationMinute = durationSecond * 60;
		var durationHour = durationMinute * 60;
		var durationDay = durationHour * 24;
		var durationWeek = durationDay * 7;
		var durationMonth = durationDay * 30;
		var durationYear = durationDay * 365;

		// node_modules/d3-time/src/second.js
		var second = timeInterval((date2) => {
		  date2.setTime(date2 - date2.getMilliseconds());
		}, (date2, step) => {
		  date2.setTime(+date2 + step * durationSecond);
		}, (start2, end) => {
		  return (end - start2) / durationSecond;
		}, (date2) => {
		  return date2.getUTCSeconds();
		});
		var seconds = second.range;

		// node_modules/d3-time/src/minute.js
		var timeMinute = timeInterval((date2) => {
		  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond);
		}, (date2, step) => {
		  date2.setTime(+date2 + step * durationMinute);
		}, (start2, end) => {
		  return (end - start2) / durationMinute;
		}, (date2) => {
		  return date2.getMinutes();
		});
		var timeMinutes = timeMinute.range;
		var utcMinute = timeInterval((date2) => {
		  date2.setUTCSeconds(0, 0);
		}, (date2, step) => {
		  date2.setTime(+date2 + step * durationMinute);
		}, (start2, end) => {
		  return (end - start2) / durationMinute;
		}, (date2) => {
		  return date2.getUTCMinutes();
		});
		var utcMinutes = utcMinute.range;

		// node_modules/d3-time/src/hour.js
		var timeHour = timeInterval((date2) => {
		  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond - date2.getMinutes() * durationMinute);
		}, (date2, step) => {
		  date2.setTime(+date2 + step * durationHour);
		}, (start2, end) => {
		  return (end - start2) / durationHour;
		}, (date2) => {
		  return date2.getHours();
		});
		var timeHours = timeHour.range;
		var utcHour = timeInterval((date2) => {
		  date2.setUTCMinutes(0, 0, 0);
		}, (date2, step) => {
		  date2.setTime(+date2 + step * durationHour);
		}, (start2, end) => {
		  return (end - start2) / durationHour;
		}, (date2) => {
		  return date2.getUTCHours();
		});
		var utcHours = utcHour.range;

		// node_modules/d3-time/src/day.js
		var timeDay = timeInterval(
		  (date2) => date2.setHours(0, 0, 0, 0),
		  (date2, step) => date2.setDate(date2.getDate() + step),
		  (start2, end) => (end - start2 - (end.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute) / durationDay,
		  (date2) => date2.getDate() - 1
		);
		var timeDays = timeDay.range;
		var utcDay = timeInterval((date2) => {
		  date2.setUTCHours(0, 0, 0, 0);
		}, (date2, step) => {
		  date2.setUTCDate(date2.getUTCDate() + step);
		}, (start2, end) => {
		  return (end - start2) / durationDay;
		}, (date2) => {
		  return date2.getUTCDate() - 1;
		});
		var utcDays = utcDay.range;
		var unixDay = timeInterval((date2) => {
		  date2.setUTCHours(0, 0, 0, 0);
		}, (date2, step) => {
		  date2.setUTCDate(date2.getUTCDate() + step);
		}, (start2, end) => {
		  return (end - start2) / durationDay;
		}, (date2) => {
		  return Math.floor(date2 / durationDay);
		});
		var unixDays = unixDay.range;

		// node_modules/d3-time/src/week.js
		function timeWeekday(i) {
		  return timeInterval((date2) => {
			 date2.setDate(date2.getDate() - (date2.getDay() + 7 - i) % 7);
			 date2.setHours(0, 0, 0, 0);
		  }, (date2, step) => {
			 date2.setDate(date2.getDate() + step * 7);
		  }, (start2, end) => {
			 return (end - start2 - (end.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute) / durationWeek;
		  });
		}
		var timeSunday = timeWeekday(0);
		var timeMonday = timeWeekday(1);
		var timeTuesday = timeWeekday(2);
		var timeWednesday = timeWeekday(3);
		var timeThursday = timeWeekday(4);
		var timeFriday = timeWeekday(5);
		var timeSaturday = timeWeekday(6);
		var timeSundays = timeSunday.range;
		var timeMondays = timeMonday.range;
		var timeTuesdays = timeTuesday.range;
		var timeWednesdays = timeWednesday.range;
		var timeThursdays = timeThursday.range;
		var timeFridays = timeFriday.range;
		var timeSaturdays = timeSaturday.range;
		function utcWeekday(i) {
		  return timeInterval((date2) => {
			 date2.setUTCDate(date2.getUTCDate() - (date2.getUTCDay() + 7 - i) % 7);
			 date2.setUTCHours(0, 0, 0, 0);
		  }, (date2, step) => {
			 date2.setUTCDate(date2.getUTCDate() + step * 7);
		  }, (start2, end) => {
			 return (end - start2) / durationWeek;
		  });
		}
		var utcSunday = utcWeekday(0);
		var utcMonday = utcWeekday(1);
		var utcTuesday = utcWeekday(2);
		var utcWednesday = utcWeekday(3);
		var utcThursday = utcWeekday(4);
		var utcFriday = utcWeekday(5);
		var utcSaturday = utcWeekday(6);
		var utcSundays = utcSunday.range;
		var utcMondays = utcMonday.range;
		var utcTuesdays = utcTuesday.range;
		var utcWednesdays = utcWednesday.range;
		var utcThursdays = utcThursday.range;
		var utcFridays = utcFriday.range;
		var utcSaturdays = utcSaturday.range;

		// node_modules/d3-time/src/month.js
		var timeMonth = timeInterval((date2) => {
		  date2.setDate(1);
		  date2.setHours(0, 0, 0, 0);
		}, (date2, step) => {
		  date2.setMonth(date2.getMonth() + step);
		}, (start2, end) => {
		  return end.getMonth() - start2.getMonth() + (end.getFullYear() - start2.getFullYear()) * 12;
		}, (date2) => {
		  return date2.getMonth();
		});
		var timeMonths = timeMonth.range;
		var utcMonth = timeInterval((date2) => {
		  date2.setUTCDate(1);
		  date2.setUTCHours(0, 0, 0, 0);
		}, (date2, step) => {
		  date2.setUTCMonth(date2.getUTCMonth() + step);
		}, (start2, end) => {
		  return end.getUTCMonth() - start2.getUTCMonth() + (end.getUTCFullYear() - start2.getUTCFullYear()) * 12;
		}, (date2) => {
		  return date2.getUTCMonth();
		});
		var utcMonths = utcMonth.range;

		// node_modules/d3-time/src/year.js
		var timeYear = timeInterval((date2) => {
		  date2.setMonth(0, 1);
		  date2.setHours(0, 0, 0, 0);
		}, (date2, step) => {
		  date2.setFullYear(date2.getFullYear() + step);
		}, (start2, end) => {
		  return end.getFullYear() - start2.getFullYear();
		}, (date2) => {
		  return date2.getFullYear();
		});
		timeYear.every = (k) => {
		  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : timeInterval((date2) => {
			 date2.setFullYear(Math.floor(date2.getFullYear() / k) * k);
			 date2.setMonth(0, 1);
			 date2.setHours(0, 0, 0, 0);
		  }, (date2, step) => {
			 date2.setFullYear(date2.getFullYear() + step * k);
		  });
		};
		var timeYears = timeYear.range;
		var utcYear = timeInterval((date2) => {
		  date2.setUTCMonth(0, 1);
		  date2.setUTCHours(0, 0, 0, 0);
		}, (date2, step) => {
		  date2.setUTCFullYear(date2.getUTCFullYear() + step);
		}, (start2, end) => {
		  return end.getUTCFullYear() - start2.getUTCFullYear();
		}, (date2) => {
		  return date2.getUTCFullYear();
		});
		utcYear.every = (k) => {
		  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : timeInterval((date2) => {
			 date2.setUTCFullYear(Math.floor(date2.getUTCFullYear() / k) * k);
			 date2.setUTCMonth(0, 1);
			 date2.setUTCHours(0, 0, 0, 0);
		  }, (date2, step) => {
			 date2.setUTCFullYear(date2.getUTCFullYear() + step * k);
		  });
		};
		var utcYears = utcYear.range;

		// node_modules/d3-time/src/ticks.js
		function ticker(year, month, week, day, hour, minute) {
		  const tickIntervals = [
			 [second, 1, durationSecond],
			 [second, 5, 5 * durationSecond],
			 [second, 15, 15 * durationSecond],
			 [second, 30, 30 * durationSecond],
			 [minute, 1, durationMinute],
			 [minute, 5, 5 * durationMinute],
			 [minute, 15, 15 * durationMinute],
			 [minute, 30, 30 * durationMinute],
			 [hour, 1, durationHour],
			 [hour, 3, 3 * durationHour],
			 [hour, 6, 6 * durationHour],
			 [hour, 12, 12 * durationHour],
			 [day, 1, durationDay],
			 [day, 2, 2 * durationDay],
			 [week, 1, durationWeek],
			 [month, 1, durationMonth],
			 [month, 3, 3 * durationMonth],
			 [year, 1, durationYear]
		  ];
		  function ticks2(start2, stop, count) {
			 const reverse = stop < start2;
			 if (reverse)
				[start2, stop] = [stop, start2];
			 const interval2 = count && typeof count.range === "function" ? count : tickInterval(start2, stop, count);
			 const ticks3 = interval2 ? interval2.range(start2, +stop + 1) : [];
			 return reverse ? ticks3.reverse() : ticks3;
		  }
		  function tickInterval(start2, stop, count) {
			 const target = Math.abs(stop - start2) / count;
			 const i = bisector(([, , step2]) => step2).right(tickIntervals, target);
			 if (i === tickIntervals.length)
				return year.every(tickStep(start2 / durationYear, stop / durationYear, count));
			 if (i === 0)
				return millisecond.every(Math.max(tickStep(start2, stop, count), 1));
			 const [t, step] = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
			 return t.every(step);
		  }
		  return [ticks2, tickInterval];
		}
		var [utcTicks, utcTickInterval] = ticker(utcYear, utcMonth, utcSunday, unixDay, utcHour, utcMinute);
		var [timeTicks, timeTickInterval] = ticker(timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute);

		// node_modules/d3-time-format/src/locale.js
		function localDate(d) {
		  if (0 <= d.y && d.y < 100) {
			 var date2 = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
			 date2.setFullYear(d.y);
			 return date2;
		  }
		  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
		}
		function utcDate(d) {
		  if (0 <= d.y && d.y < 100) {
			 var date2 = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
			 date2.setUTCFullYear(d.y);
			 return date2;
		  }
		  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
		}
		function newDate(y, m, d) {
		  return { y, m, d, H: 0, M: 0, S: 0, L: 0 };
		}
		function formatLocale(locale2) {
		  var locale_dateTime = locale2.dateTime, locale_date = locale2.date, locale_time = locale2.time, locale_periods = locale2.periods, locale_weekdays = locale2.days, locale_shortWeekdays = locale2.shortDays, locale_months = locale2.months, locale_shortMonths = locale2.shortMonths;
		  var periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);
		  var formats = {
			 "a": formatShortWeekday,
			 "A": formatWeekday,
			 "b": formatShortMonth,
			 "B": formatMonth,
			 "c": null,
			 "d": formatDayOfMonth,
			 "e": formatDayOfMonth,
			 "f": formatMicroseconds,
			 "g": formatYearISO,
			 "G": formatFullYearISO,
			 "H": formatHour24,
			 "I": formatHour12,
			 "j": formatDayOfYear,
			 "L": formatMilliseconds,
			 "m": formatMonthNumber,
			 "M": formatMinutes,
			 "p": formatPeriod,
			 "q": formatQuarter,
			 "Q": formatUnixTimestamp,
			 "s": formatUnixTimestampSeconds,
			 "S": formatSeconds,
			 "u": formatWeekdayNumberMonday,
			 "U": formatWeekNumberSunday,
			 "V": formatWeekNumberISO,
			 "w": formatWeekdayNumberSunday,
			 "W": formatWeekNumberMonday,
			 "x": null,
			 "X": null,
			 "y": formatYear,
			 "Y": formatFullYear,
			 "Z": formatZone,
			 "%": formatLiteralPercent
		  };
		  var utcFormats = {
			 "a": formatUTCShortWeekday,
			 "A": formatUTCWeekday,
			 "b": formatUTCShortMonth,
			 "B": formatUTCMonth,
			 "c": null,
			 "d": formatUTCDayOfMonth,
			 "e": formatUTCDayOfMonth,
			 "f": formatUTCMicroseconds,
			 "g": formatUTCYearISO,
			 "G": formatUTCFullYearISO,
			 "H": formatUTCHour24,
			 "I": formatUTCHour12,
			 "j": formatUTCDayOfYear,
			 "L": formatUTCMilliseconds,
			 "m": formatUTCMonthNumber,
			 "M": formatUTCMinutes,
			 "p": formatUTCPeriod,
			 "q": formatUTCQuarter,
			 "Q": formatUnixTimestamp,
			 "s": formatUnixTimestampSeconds,
			 "S": formatUTCSeconds,
			 "u": formatUTCWeekdayNumberMonday,
			 "U": formatUTCWeekNumberSunday,
			 "V": formatUTCWeekNumberISO,
			 "w": formatUTCWeekdayNumberSunday,
			 "W": formatUTCWeekNumberMonday,
			 "x": null,
			 "X": null,
			 "y": formatUTCYear,
			 "Y": formatUTCFullYear,
			 "Z": formatUTCZone,
			 "%": formatLiteralPercent
		  };
		  var parses = {
			 "a": parseShortWeekday,
			 "A": parseWeekday,
			 "b": parseShortMonth,
			 "B": parseMonth,
			 "c": parseLocaleDateTime,
			 "d": parseDayOfMonth,
			 "e": parseDayOfMonth,
			 "f": parseMicroseconds,
			 "g": parseYear,
			 "G": parseFullYear,
			 "H": parseHour24,
			 "I": parseHour24,
			 "j": parseDayOfYear,
			 "L": parseMilliseconds,
			 "m": parseMonthNumber,
			 "M": parseMinutes,
			 "p": parsePeriod,
			 "q": parseQuarter,
			 "Q": parseUnixTimestamp,
			 "s": parseUnixTimestampSeconds,
			 "S": parseSeconds,
			 "u": parseWeekdayNumberMonday,
			 "U": parseWeekNumberSunday,
			 "V": parseWeekNumberISO,
			 "w": parseWeekdayNumberSunday,
			 "W": parseWeekNumberMonday,
			 "x": parseLocaleDate,
			 "X": parseLocaleTime,
			 "y": parseYear,
			 "Y": parseFullYear,
			 "Z": parseZone,
			 "%": parseLiteralPercent
		  };
		  formats.x = newFormat(locale_date, formats);
		  formats.X = newFormat(locale_time, formats);
		  formats.c = newFormat(locale_dateTime, formats);
		  utcFormats.x = newFormat(locale_date, utcFormats);
		  utcFormats.X = newFormat(locale_time, utcFormats);
		  utcFormats.c = newFormat(locale_dateTime, utcFormats);
		  function newFormat(specifier, formats2) {
			 return function(date2) {
				var string = [], i = -1, j = 0, n = specifier.length, c2, pad2, format2;
				if (!(date2 instanceof Date))
				  date2 = /* @__PURE__ */ new Date(+date2);
				while (++i < n) {
				  if (specifier.charCodeAt(i) === 37) {
					 string.push(specifier.slice(j, i));
					 if ((pad2 = pads[c2 = specifier.charAt(++i)]) != null)
						c2 = specifier.charAt(++i);
					 else
						pad2 = c2 === "e" ? " " : "0";
					 if (format2 = formats2[c2])
						c2 = format2(date2, pad2);
					 string.push(c2);
					 j = i + 1;
				  }
				}
				string.push(specifier.slice(j, i));
				return string.join("");
			 };
		  }
		  function newParse(specifier, Z) {
			 return function(string) {
				var d = newDate(1900, void 0, 1), i = parseSpecifier(d, specifier, string += "", 0), week, day;
				if (i != string.length)
				  return null;
				if ("Q" in d)
				  return new Date(d.Q);
				if ("s" in d)
				  return new Date(d.s * 1e3 + ("L" in d ? d.L : 0));
				if (Z && !("Z" in d))
				  d.Z = 0;
				if ("p" in d)
				  d.H = d.H % 12 + d.p * 12;
				if (d.m === void 0)
				  d.m = "q" in d ? d.q : 0;
				if ("V" in d) {
				  if (d.V < 1 || d.V > 53)
					 return null;
				  if (!("w" in d))
					 d.w = 1;
				  if ("Z" in d) {
					 week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();
					 week = day > 4 || day === 0 ? utcMonday.ceil(week) : utcMonday(week);
					 week = utcDay.offset(week, (d.V - 1) * 7);
					 d.y = week.getUTCFullYear();
					 d.m = week.getUTCMonth();
					 d.d = week.getUTCDate() + (d.w + 6) % 7;
				  } else {
					 week = localDate(newDate(d.y, 0, 1)), day = week.getDay();
					 week = day > 4 || day === 0 ? timeMonday.ceil(week) : timeMonday(week);
					 week = timeDay.offset(week, (d.V - 1) * 7);
					 d.y = week.getFullYear();
					 d.m = week.getMonth();
					 d.d = week.getDate() + (d.w + 6) % 7;
				  }
				} else if ("W" in d || "U" in d) {
				  if (!("w" in d))
					 d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
				  day = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
				  d.m = 0;
				  d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
				}
				if ("Z" in d) {
				  d.H += d.Z / 100 | 0;
				  d.M += d.Z % 100;
				  return utcDate(d);
				}
				return localDate(d);
			 };
		  }
		  function parseSpecifier(d, specifier, string, j) {
			 var i = 0, n = specifier.length, m = string.length, c2, parse2;
			 while (i < n) {
				if (j >= m)
				  return -1;
				c2 = specifier.charCodeAt(i++);
				if (c2 === 37) {
				  c2 = specifier.charAt(i++);
				  parse2 = parses[c2 in pads ? specifier.charAt(i++) : c2];
				  if (!parse2 || (j = parse2(d, string, j)) < 0)
					 return -1;
				} else if (c2 != string.charCodeAt(j++)) {
				  return -1;
				}
			 }
			 return j;
		  }
		  function parsePeriod(d, string, i) {
			 var n = periodRe.exec(string.slice(i));
			 return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
		  }
		  function parseShortWeekday(d, string, i) {
			 var n = shortWeekdayRe.exec(string.slice(i));
			 return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
		  }
		  function parseWeekday(d, string, i) {
			 var n = weekdayRe.exec(string.slice(i));
			 return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
		  }
		  function parseShortMonth(d, string, i) {
			 var n = shortMonthRe.exec(string.slice(i));
			 return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
		  }
		  function parseMonth(d, string, i) {
			 var n = monthRe.exec(string.slice(i));
			 return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
		  }
		  function parseLocaleDateTime(d, string, i) {
			 return parseSpecifier(d, locale_dateTime, string, i);
		  }
		  function parseLocaleDate(d, string, i) {
			 return parseSpecifier(d, locale_date, string, i);
		  }
		  function parseLocaleTime(d, string, i) {
			 return parseSpecifier(d, locale_time, string, i);
		  }
		  function formatShortWeekday(d) {
			 return locale_shortWeekdays[d.getDay()];
		  }
		  function formatWeekday(d) {
			 return locale_weekdays[d.getDay()];
		  }
		  function formatShortMonth(d) {
			 return locale_shortMonths[d.getMonth()];
		  }
		  function formatMonth(d) {
			 return locale_months[d.getMonth()];
		  }
		  function formatPeriod(d) {
			 return locale_periods[+(d.getHours() >= 12)];
		  }
		  function formatQuarter(d) {
			 return 1 + ~~(d.getMonth() / 3);
		  }
		  function formatUTCShortWeekday(d) {
			 return locale_shortWeekdays[d.getUTCDay()];
		  }
		  function formatUTCWeekday(d) {
			 return locale_weekdays[d.getUTCDay()];
		  }
		  function formatUTCShortMonth(d) {
			 return locale_shortMonths[d.getUTCMonth()];
		  }
		  function formatUTCMonth(d) {
			 return locale_months[d.getUTCMonth()];
		  }
		  function formatUTCPeriod(d) {
			 return locale_periods[+(d.getUTCHours() >= 12)];
		  }
		  function formatUTCQuarter(d) {
			 return 1 + ~~(d.getUTCMonth() / 3);
		  }
		  return {
			 format: function(specifier) {
				var f = newFormat(specifier += "", formats);
				f.toString = function() {
				  return specifier;
				};
				return f;
			 },
			 parse: function(specifier) {
				var p = newParse(specifier += "", false);
				p.toString = function() {
				  return specifier;
				};
				return p;
			 },
			 utcFormat: function(specifier) {
				var f = newFormat(specifier += "", utcFormats);
				f.toString = function() {
				  return specifier;
				};
				return f;
			 },
			 utcParse: function(specifier) {
				var p = newParse(specifier += "", true);
				p.toString = function() {
				  return specifier;
				};
				return p;
			 }
		  };
		}
		var pads = { "-": "", "_": " ", "0": "0" };
		var numberRe = /^\s*\d+/;
		var percentRe = /^%/;
		var requoteRe = /[\\^$*+?|[\]().{}]/g;
		function pad(value, fill, width) {
		  var sign = value < 0 ? "-" : "", string = (sign ? -value : value) + "", length = string.length;
		  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
		}
		function requote(s) {
		  return s.replace(requoteRe, "\\$&");
		}
		function formatRe(names) {
		  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
		}
		function formatLookup(names) {
		  return new Map(names.map((name, i) => [name.toLowerCase(), i]));
		}
		function parseWeekdayNumberSunday(d, string, i) {
		  var n = numberRe.exec(string.slice(i, i + 1));
		  return n ? (d.w = +n[0], i + n[0].length) : -1;
		}
		function parseWeekdayNumberMonday(d, string, i) {
		  var n = numberRe.exec(string.slice(i, i + 1));
		  return n ? (d.u = +n[0], i + n[0].length) : -1;
		}
		function parseWeekNumberSunday(d, string, i) {
		  var n = numberRe.exec(string.slice(i, i + 2));
		  return n ? (d.U = +n[0], i + n[0].length) : -1;
		}
		function parseWeekNumberISO(d, string, i) {
		  var n = numberRe.exec(string.slice(i, i + 2));
		  return n ? (d.V = +n[0], i + n[0].length) : -1;
		}
		function parseWeekNumberMonday(d, string, i) {
		  var n = numberRe.exec(string.slice(i, i + 2));
		  return n ? (d.W = +n[0], i + n[0].length) : -1;
		}
		function parseFullYear(d, string, i) {
		  var n = numberRe.exec(string.slice(i, i + 4));
		  return n ? (d.y = +n[0], i + n[0].length) : -1;
		}
		function parseYear(d, string, i) {
		  var n = numberRe.exec(string.slice(i, i + 2));
		  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3), i + n[0].length) : -1;
		}
		function parseZone(d, string, i) {
		  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
		  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
		}
		function parseQuarter(d, string, i) {
		  var n = numberRe.exec(string.slice(i, i + 1));
		  return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
		}
		function parseMonthNumber(d, string, i) {
		  var n = numberRe.exec(string.slice(i, i + 2));
		  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
		}
		function parseDayOfMonth(d, string, i) {
		  var n = numberRe.exec(string.slice(i, i + 2));
		  return n ? (d.d = +n[0], i + n[0].length) : -1;
		}
		function parseDayOfYear(d, string, i) {
		  var n = numberRe.exec(string.slice(i, i + 3));
		  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
		}
		function parseHour24(d, string, i) {
		  var n = numberRe.exec(string.slice(i, i + 2));
		  return n ? (d.H = +n[0], i + n[0].length) : -1;
		}
		function parseMinutes(d, string, i) {
		  var n = numberRe.exec(string.slice(i, i + 2));
		  return n ? (d.M = +n[0], i + n[0].length) : -1;
		}
		function parseSeconds(d, string, i) {
		  var n = numberRe.exec(string.slice(i, i + 2));
		  return n ? (d.S = +n[0], i + n[0].length) : -1;
		}
		function parseMilliseconds(d, string, i) {
		  var n = numberRe.exec(string.slice(i, i + 3));
		  return n ? (d.L = +n[0], i + n[0].length) : -1;
		}
		function parseMicroseconds(d, string, i) {
		  var n = numberRe.exec(string.slice(i, i + 6));
		  return n ? (d.L = Math.floor(n[0] / 1e3), i + n[0].length) : -1;
		}
		function parseLiteralPercent(d, string, i) {
		  var n = percentRe.exec(string.slice(i, i + 1));
		  return n ? i + n[0].length : -1;
		}
		function parseUnixTimestamp(d, string, i) {
		  var n = numberRe.exec(string.slice(i));
		  return n ? (d.Q = +n[0], i + n[0].length) : -1;
		}
		function parseUnixTimestampSeconds(d, string, i) {
		  var n = numberRe.exec(string.slice(i));
		  return n ? (d.s = +n[0], i + n[0].length) : -1;
		}
		function formatDayOfMonth(d, p) {
		  return pad(d.getDate(), p, 2);
		}
		function formatHour24(d, p) {
		  return pad(d.getHours(), p, 2);
		}
		function formatHour12(d, p) {
		  return pad(d.getHours() % 12 || 12, p, 2);
		}
		function formatDayOfYear(d, p) {
		  return pad(1 + timeDay.count(timeYear(d), d), p, 3);
		}
		function formatMilliseconds(d, p) {
		  return pad(d.getMilliseconds(), p, 3);
		}
		function formatMicroseconds(d, p) {
		  return formatMilliseconds(d, p) + "000";
		}
		function formatMonthNumber(d, p) {
		  return pad(d.getMonth() + 1, p, 2);
		}
		function formatMinutes(d, p) {
		  return pad(d.getMinutes(), p, 2);
		}
		function formatSeconds(d, p) {
		  return pad(d.getSeconds(), p, 2);
		}
		function formatWeekdayNumberMonday(d) {
		  var day = d.getDay();
		  return day === 0 ? 7 : day;
		}
		function formatWeekNumberSunday(d, p) {
		  return pad(timeSunday.count(timeYear(d) - 1, d), p, 2);
		}
		function dISO(d) {
		  var day = d.getDay();
		  return day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);
		}
		function formatWeekNumberISO(d, p) {
		  d = dISO(d);
		  return pad(timeThursday.count(timeYear(d), d) + (timeYear(d).getDay() === 4), p, 2);
		}
		function formatWeekdayNumberSunday(d) {
		  return d.getDay();
		}
		function formatWeekNumberMonday(d, p) {
		  return pad(timeMonday.count(timeYear(d) - 1, d), p, 2);
		}
		function formatYear(d, p) {
		  return pad(d.getFullYear() % 100, p, 2);
		}
		function formatYearISO(d, p) {
		  d = dISO(d);
		  return pad(d.getFullYear() % 100, p, 2);
		}
		function formatFullYear(d, p) {
		  return pad(d.getFullYear() % 1e4, p, 4);
		}
		function formatFullYearISO(d, p) {
		  var day = d.getDay();
		  d = day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);
		  return pad(d.getFullYear() % 1e4, p, 4);
		}
		function formatZone(d) {
		  var z = d.getTimezoneOffset();
		  return (z > 0 ? "-" : (z *= -1, "+")) + pad(z / 60 | 0, "0", 2) + pad(z % 60, "0", 2);
		}
		function formatUTCDayOfMonth(d, p) {
		  return pad(d.getUTCDate(), p, 2);
		}
		function formatUTCHour24(d, p) {
		  return pad(d.getUTCHours(), p, 2);
		}
		function formatUTCHour12(d, p) {
		  return pad(d.getUTCHours() % 12 || 12, p, 2);
		}
		function formatUTCDayOfYear(d, p) {
		  return pad(1 + utcDay.count(utcYear(d), d), p, 3);
		}
		function formatUTCMilliseconds(d, p) {
		  return pad(d.getUTCMilliseconds(), p, 3);
		}
		function formatUTCMicroseconds(d, p) {
		  return formatUTCMilliseconds(d, p) + "000";
		}
		function formatUTCMonthNumber(d, p) {
		  return pad(d.getUTCMonth() + 1, p, 2);
		}
		function formatUTCMinutes(d, p) {
		  return pad(d.getUTCMinutes(), p, 2);
		}
		function formatUTCSeconds(d, p) {
		  return pad(d.getUTCSeconds(), p, 2);
		}
		function formatUTCWeekdayNumberMonday(d) {
		  var dow = d.getUTCDay();
		  return dow === 0 ? 7 : dow;
		}
		function formatUTCWeekNumberSunday(d, p) {
		  return pad(utcSunday.count(utcYear(d) - 1, d), p, 2);
		}
		function UTCdISO(d) {
		  var day = d.getUTCDay();
		  return day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
		}
		function formatUTCWeekNumberISO(d, p) {
		  d = UTCdISO(d);
		  return pad(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);
		}
		function formatUTCWeekdayNumberSunday(d) {
		  return d.getUTCDay();
		}
		function formatUTCWeekNumberMonday(d, p) {
		  return pad(utcMonday.count(utcYear(d) - 1, d), p, 2);
		}
		function formatUTCYear(d, p) {
		  return pad(d.getUTCFullYear() % 100, p, 2);
		}
		function formatUTCYearISO(d, p) {
		  d = UTCdISO(d);
		  return pad(d.getUTCFullYear() % 100, p, 2);
		}
		function formatUTCFullYear(d, p) {
		  return pad(d.getUTCFullYear() % 1e4, p, 4);
		}
		function formatUTCFullYearISO(d, p) {
		  var day = d.getUTCDay();
		  d = day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
		  return pad(d.getUTCFullYear() % 1e4, p, 4);
		}
		function formatUTCZone() {
		  return "+0000";
		}
		function formatLiteralPercent() {
		  return "%";
		}
		function formatUnixTimestamp(d) {
		  return +d;
		}
		function formatUnixTimestampSeconds(d) {
		  return Math.floor(+d / 1e3);
		}

		// node_modules/d3-time-format/src/defaultLocale.js
		var locale;
		var timeFormat;
		var timeParse;
		var utcFormat;
		var utcParse;
		defaultLocale({
		  dateTime: "%x, %X",
		  date: "%-m/%-d/%Y",
		  time: "%-I:%M:%S %p",
		  periods: ["AM", "PM"],
		  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
		  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
		  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
		  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
		});
		function defaultLocale(definition) {
		  locale = formatLocale(definition);
		  timeFormat = locale.format;
		  timeParse = locale.parse;
		  utcFormat = locale.utcFormat;
		  utcParse = locale.utcParse;
		  return locale;
		}

		// node_modules/d3-scale/src/time.js
		function date(t) {
		  return new Date(t);
		}
		function number4(t) {
		  return t instanceof Date ? +t : +/* @__PURE__ */ new Date(+t);
		}
		function calendar(ticks2, tickInterval, year, month, week, day, hour, minute, second2, format2) {
		  var scale = continuous(), invert = scale.invert, domain = scale.domain;
		  var formatMillisecond = format2(".%L"), formatSecond = format2(":%S"), formatMinute = format2("%I:%M"), formatHour = format2("%I %p"), formatDay = format2("%a %d"), formatWeek = format2("%b %d"), formatMonth = format2("%B"), formatYear2 = format2("%Y");
		  function tickFormat(date2) {
			 return (second2(date2) < date2 ? formatMillisecond : minute(date2) < date2 ? formatSecond : hour(date2) < date2 ? formatMinute : day(date2) < date2 ? formatHour : month(date2) < date2 ? week(date2) < date2 ? formatDay : formatWeek : year(date2) < date2 ? formatMonth : formatYear2)(date2);
		  }
		  scale.invert = function(y) {
			 return new Date(invert(y));
		  };
		  scale.domain = function(_2) {
			 return arguments.length ? domain(Array.from(_2, number4)) : domain().map(date);
		  };
		  scale.ticks = function(interval2) {
			 var d = domain();
			 return ticks2(d[0], d[d.length - 1], interval2 == null ? 10 : interval2);
		  };
		  scale.tickFormat = function(count, specifier) {
			 return specifier == null ? tickFormat : format2(specifier);
		  };
		  scale.nice = function(interval2) {
			 var d = domain();
			 if (!interval2 || typeof interval2.range !== "function")
				interval2 = tickInterval(d[0], d[d.length - 1], interval2 == null ? 10 : interval2);
			 return interval2 ? domain(nice(d, interval2)) : scale;
		  };
		  scale.copy = function() {
			 return copy(scale, calendar(ticks2, tickInterval, year, month, week, day, hour, minute, second2, format2));
		  };
		  return scale;
		}

		// node_modules/d3-scale/src/utcTime.js
		function utcTime() {
		  return initRange.apply(calendar(utcTicks, utcTickInterval, utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute, second, utcFormat).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
		}

		// node_modules/d3-scale-chromatic/src/colors.js
		function colors_default(specifier) {
		  var n = specifier.length / 6 | 0, colors = new Array(n), i = 0;
		  while (i < n)
			 colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
		  return colors;
		}

		// node_modules/d3-scale-chromatic/src/categorical/category10.js
		var category10_default = colors_default("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

		// node_modules/d3-scale-chromatic/src/sequential-multi/rainbow.js
		var warm = cubehelixLong(cubehelix(-100, 0.75, 0.35), cubehelix(80, 1.5, 0.8));
		var cool = cubehelixLong(cubehelix(260, 0.75, 0.35), cubehelix(80, 1.5, 0.8));
		var c = cubehelix();
		function rainbow_default(t) {
		  if (t < 0 || t > 1)
			 t -= Math.floor(t);
		  var ts = Math.abs(t - 0.5);
		  c.h = 360 * t - 100;
		  c.s = 1.5 - 1.5 * ts;
		  c.l = 0.8 - 0.9 * ts;
		  return c + "";
		}

		// node_modules/d3-zoom/src/constant.js
		var constant_default5 = (x) => () => x;

		// node_modules/d3-zoom/src/event.js
		function ZoomEvent(type2, {
		  sourceEvent,
		  target,
		  transform: transform2,
		  dispatch: dispatch2
		}) {
		  Object.defineProperties(this, {
			 type: { value: type2, enumerable: true, configurable: true },
			 sourceEvent: { value: sourceEvent, enumerable: true, configurable: true },
			 target: { value: target, enumerable: true, configurable: true },
			 transform: { value: transform2, enumerable: true, configurable: true },
			 _: { value: dispatch2 }
		  });
		}

		// node_modules/d3-zoom/src/transform.js
		function Transform(k, x, y) {
		  this.k = k;
		  this.x = x;
		  this.y = y;
		}
		Transform.prototype = {
		  constructor: Transform,
		  scale: function(k) {
			 return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
		  },
		  translate: function(x, y) {
			 return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
		  },
		  apply: function(point) {
			 return [point[0] * this.k + this.x, point[1] * this.k + this.y];
		  },
		  applyX: function(x) {
			 return x * this.k + this.x;
		  },
		  applyY: function(y) {
			 return y * this.k + this.y;
		  },
		  invert: function(location2) {
			 return [(location2[0] - this.x) / this.k, (location2[1] - this.y) / this.k];
		  },
		  invertX: function(x) {
			 return (x - this.x) / this.k;
		  },
		  invertY: function(y) {
			 return (y - this.y) / this.k;
		  },
		  rescaleX: function(x) {
			 return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
		  },
		  rescaleY: function(y) {
			 return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
		  },
		  toString: function() {
			 return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
		  }
		};
		var identity4 = new Transform(1, 0, 0);
		transform.prototype = Transform.prototype;
		function transform(node) {
		  while (!node.__zoom)
			 if (!(node = node.parentNode))
				return identity4;
		  return node.__zoom;
		}

		// node_modules/d3-zoom/src/noevent.js
		function nopropagation3(event) {
		  event.stopImmediatePropagation();
		}
		function noevent_default3(event) {
		  event.preventDefault();
		  event.stopImmediatePropagation();
		}

		// node_modules/d3-zoom/src/zoom.js
		function defaultFilter2(event) {
		  return (!event.ctrlKey || event.type === "wheel") && !event.button;
		}
		function defaultExtent() {
		  var e = this;
		  if (e instanceof SVGElement) {
			 e = e.ownerSVGElement || e;
			 if (e.hasAttribute("viewBox")) {
				e = e.viewBox.baseVal;
				return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
			 }
			 return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
		  }
		  return [[0, 0], [e.clientWidth, e.clientHeight]];
		}
		function defaultTransform() {
		  return this.__zoom || identity4;
		}
		function defaultWheelDelta(event) {
		  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 2e-3) * (event.ctrlKey ? 10 : 1);
		}
		function defaultTouchable2() {
		  return navigator.maxTouchPoints || "ontouchstart" in this;
		}
		function defaultConstrain(transform2, extent, translateExtent) {
		  var dx0 = transform2.invertX(extent[0][0]) - translateExtent[0][0], dx1 = transform2.invertX(extent[1][0]) - translateExtent[1][0], dy0 = transform2.invertY(extent[0][1]) - translateExtent[0][1], dy1 = transform2.invertY(extent[1][1]) - translateExtent[1][1];
		  return transform2.translate(
			 dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
			 dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
		  );
		}
		function zoom_default2() {
		  var filter2 = defaultFilter2, extent = defaultExtent, constrain = defaultConstrain, wheelDelta = defaultWheelDelta, touchable = defaultTouchable2, scaleExtent = [0, Infinity], translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]], duration = 250, interpolate = zoom_default, listeners = dispatch_default("start", "zoom", "end"), touchstarting, touchfirst, touchending, touchDelay = 500, wheelDelay = 150, clickDistance2 = 0, tapDistance = 10;
		  function zoom(selection2) {
			 selection2.property("__zoom", defaultTransform).on("wheel.zoom", wheeled, { passive: false }).on("mousedown.zoom", mousedowned).on("dblclick.zoom", dblclicked).filter(touchable).on("touchstart.zoom", touchstarted).on("touchmove.zoom", touchmoved).on("touchend.zoom touchcancel.zoom", touchended).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
		  }
		  zoom.transform = function(collection, transform2, point, event) {
			 var selection2 = collection.selection ? collection.selection() : collection;
			 selection2.property("__zoom", defaultTransform);
			 if (collection !== selection2) {
				schedule(collection, transform2, point, event);
			 } else {
				selection2.interrupt().each(function() {
				  gesture(this, arguments).event(event).start().zoom(null, typeof transform2 === "function" ? transform2.apply(this, arguments) : transform2).end();
				});
			 }
		  };
		  zoom.scaleBy = function(selection2, k, p, event) {
			 zoom.scaleTo(selection2, function() {
				var k0 = this.__zoom.k, k1 = typeof k === "function" ? k.apply(this, arguments) : k;
				return k0 * k1;
			 }, p, event);
		  };
		  zoom.scaleTo = function(selection2, k, p, event) {
			 zoom.transform(selection2, function() {
				var e = extent.apply(this, arguments), t02 = this.__zoom, p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p, p1 = t02.invert(p0), k1 = typeof k === "function" ? k.apply(this, arguments) : k;
				return constrain(translate2(scale(t02, k1), p0, p1), e, translateExtent);
			 }, p, event);
		  };
		  zoom.translateBy = function(selection2, x, y, event) {
			 zoom.transform(selection2, function() {
				return constrain(this.__zoom.translate(
				  typeof x === "function" ? x.apply(this, arguments) : x,
				  typeof y === "function" ? y.apply(this, arguments) : y
				), extent.apply(this, arguments), translateExtent);
			 }, null, event);
		  };
		  zoom.translateTo = function(selection2, x, y, p, event) {
			 zoom.transform(selection2, function() {
				var e = extent.apply(this, arguments), t = this.__zoom, p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p;
				return constrain(identity4.translate(p0[0], p0[1]).scale(t.k).translate(
				  typeof x === "function" ? -x.apply(this, arguments) : -x,
				  typeof y === "function" ? -y.apply(this, arguments) : -y
				), e, translateExtent);
			 }, p, event);
		  };
		  function scale(transform2, k) {
			 k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
			 return k === transform2.k ? transform2 : new Transform(k, transform2.x, transform2.y);
		  }
		  function translate2(transform2, p0, p1) {
			 var x = p0[0] - p1[0] * transform2.k, y = p0[1] - p1[1] * transform2.k;
			 return x === transform2.x && y === transform2.y ? transform2 : new Transform(transform2.k, x, y);
		  }
		  function centroid(extent2) {
			 return [(+extent2[0][0] + +extent2[1][0]) / 2, (+extent2[0][1] + +extent2[1][1]) / 2];
		  }
		  function schedule(transition2, transform2, point, event) {
			 transition2.on("start.zoom", function() {
				gesture(this, arguments).event(event).start();
			 }).on("interrupt.zoom end.zoom", function() {
				gesture(this, arguments).event(event).end();
			 }).tween("zoom", function() {
				var that = this, args = arguments, g = gesture(that, args).event(event), e = extent.apply(that, args), p = point == null ? centroid(e) : typeof point === "function" ? point.apply(that, args) : point, w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]), a = that.__zoom, b = typeof transform2 === "function" ? transform2.apply(that, args) : transform2, i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
				return function(t) {
				  if (t === 1)
					 t = b;
				  else {
					 var l = i(t), k = w / l[2];
					 t = new Transform(k, p[0] - l[0] * k, p[1] - l[1] * k);
				  }
				  g.zoom(null, t);
				};
			 });
		  }
		  function gesture(that, args, clean) {
			 return !clean && that.__zooming || new Gesture(that, args);
		  }
		  function Gesture(that, args) {
			 this.that = that;
			 this.args = args;
			 this.active = 0;
			 this.sourceEvent = null;
			 this.extent = extent.apply(that, args);
			 this.taps = 0;
		  }
		  Gesture.prototype = {
			 event: function(event) {
				if (event)
				  this.sourceEvent = event;
				return this;
			 },
			 start: function() {
				if (++this.active === 1) {
				  this.that.__zooming = this;
				  this.emit("start");
				}
				return this;
			 },
			 zoom: function(key, transform2) {
				if (this.mouse && key !== "mouse")
				  this.mouse[1] = transform2.invert(this.mouse[0]);
				if (this.touch0 && key !== "touch")
				  this.touch0[1] = transform2.invert(this.touch0[0]);
				if (this.touch1 && key !== "touch")
				  this.touch1[1] = transform2.invert(this.touch1[0]);
				this.that.__zoom = transform2;
				this.emit("zoom");
				return this;
			 },
			 end: function() {
				if (--this.active === 0) {
				  delete this.that.__zooming;
				  this.emit("end");
				}
				return this;
			 },
			 emit: function(type2) {
				var d = select_default2(this.that).datum();
				listeners.call(
				  type2,
				  this.that,
				  new ZoomEvent(type2, {
					 sourceEvent: this.sourceEvent,
					 target: zoom,
					 type: type2,
					 transform: this.that.__zoom,
					 dispatch: listeners
				  }),
				  d
				);
			 }
		  };
		  function wheeled(event, ...args) {
			 if (!filter2.apply(this, arguments))
				return;
			 var g = gesture(this, args).event(event), t = this.__zoom, k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))), p = pointer_default(event);
			 if (g.wheel) {
				if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
				  g.mouse[1] = t.invert(g.mouse[0] = p);
				}
				clearTimeout(g.wheel);
			 } else if (t.k === k)
				return;
			 else {
				g.mouse = [p, t.invert(p)];
				interrupt_default(this);
				g.start();
			 }
			 noevent_default3(event);
			 g.wheel = setTimeout(wheelidled, wheelDelay);
			 g.zoom("mouse", constrain(translate2(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));
			 function wheelidled() {
				g.wheel = null;
				g.end();
			 }
		  }
		  function mousedowned(event, ...args) {
			 if (touchending || !filter2.apply(this, arguments))
				return;
			 var currentTarget = event.currentTarget, g = gesture(this, args, true).event(event), v = select_default2(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true), p = pointer_default(event, currentTarget), x0 = event.clientX, y0 = event.clientY;
			 nodrag_default(event.view);
			 nopropagation3(event);
			 g.mouse = [p, this.__zoom.invert(p)];
			 interrupt_default(this);
			 g.start();
			 function mousemoved(event2) {
				noevent_default3(event2);
				if (!g.moved) {
				  var dx = event2.clientX - x0, dy = event2.clientY - y0;
				  g.moved = dx * dx + dy * dy > clickDistance2;
				}
				g.event(event2).zoom("mouse", constrain(translate2(g.that.__zoom, g.mouse[0] = pointer_default(event2, currentTarget), g.mouse[1]), g.extent, translateExtent));
			 }
			 function mouseupped(event2) {
				v.on("mousemove.zoom mouseup.zoom", null);
				yesdrag(event2.view, g.moved);
				noevent_default3(event2);
				g.event(event2).end();
			 }
		  }
		  function dblclicked(event, ...args) {
			 if (!filter2.apply(this, arguments))
				return;
			 var t02 = this.__zoom, p0 = pointer_default(event.changedTouches ? event.changedTouches[0] : event, this), p1 = t02.invert(p0), k1 = t02.k * (event.shiftKey ? 0.5 : 2), t12 = constrain(translate2(scale(t02, k1), p0, p1), extent.apply(this, args), translateExtent);
			 noevent_default3(event);
			 if (duration > 0)
				select_default2(this).transition().duration(duration).call(schedule, t12, p0, event);
			 else
				select_default2(this).call(zoom.transform, t12, p0, event);
		  }
		  function touchstarted(event, ...args) {
			 if (!filter2.apply(this, arguments))
				return;
			 var touches = event.touches, n = touches.length, g = gesture(this, args, event.changedTouches.length === n).event(event), started, i, t, p;
			 nopropagation3(event);
			 for (i = 0; i < n; ++i) {
				t = touches[i], p = pointer_default(t, this);
				p = [p, this.__zoom.invert(p), t.identifier];
				if (!g.touch0)
				  g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
				else if (!g.touch1 && g.touch0[2] !== p[2])
				  g.touch1 = p, g.taps = 0;
			 }
			 if (touchstarting)
				touchstarting = clearTimeout(touchstarting);
			 if (started) {
				if (g.taps < 2)
				  touchfirst = p[0], touchstarting = setTimeout(function() {
					 touchstarting = null;
				  }, touchDelay);
				interrupt_default(this);
				g.start();
			 }
		  }
		  function touchmoved(event, ...args) {
			 if (!this.__zooming)
				return;
			 var g = gesture(this, args).event(event), touches = event.changedTouches, n = touches.length, i, t, p, l;
			 noevent_default3(event);
			 for (i = 0; i < n; ++i) {
				t = touches[i], p = pointer_default(t, this);
				if (g.touch0 && g.touch0[2] === t.identifier)
				  g.touch0[0] = p;
				else if (g.touch1 && g.touch1[2] === t.identifier)
				  g.touch1[0] = p;
			 }
			 t = g.that.__zoom;
			 if (g.touch1) {
				var p0 = g.touch0[0], l0 = g.touch0[1], p1 = g.touch1[0], l1 = g.touch1[1], dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp, dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
				t = scale(t, Math.sqrt(dp / dl));
				p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
				l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
			 } else if (g.touch0)
				p = g.touch0[0], l = g.touch0[1];
			 else
				return;
			 g.zoom("touch", constrain(translate2(t, p, l), g.extent, translateExtent));
		  }
		  function touchended(event, ...args) {
			 if (!this.__zooming)
				return;
			 var g = gesture(this, args).event(event), touches = event.changedTouches, n = touches.length, i, t;
			 nopropagation3(event);
			 if (touchending)
				clearTimeout(touchending);
			 touchending = setTimeout(function() {
				touchending = null;
			 }, touchDelay);
			 for (i = 0; i < n; ++i) {
				t = touches[i];
				if (g.touch0 && g.touch0[2] === t.identifier)
				  delete g.touch0;
				else if (g.touch1 && g.touch1[2] === t.identifier)
				  delete g.touch1;
			 }
			 if (g.touch1 && !g.touch0)
				g.touch0 = g.touch1, delete g.touch1;
			 if (g.touch0)
				g.touch0[1] = this.__zoom.invert(g.touch0[0]);
			 else {
				g.end();
				if (g.taps === 2) {
				  t = pointer_default(t, this);
				  if (Math.hypot(touchfirst[0] - t[0], touchfirst[1] - t[1]) < tapDistance) {
					 var p = select_default2(this).on("dblclick.zoom");
					 if (p)
						p.apply(this, arguments);
				  }
				}
			 }
		  }
		  zoom.wheelDelta = function(_2) {
			 return arguments.length ? (wheelDelta = typeof _2 === "function" ? _2 : constant_default5(+_2), zoom) : wheelDelta;
		  };
		  zoom.filter = function(_2) {
			 return arguments.length ? (filter2 = typeof _2 === "function" ? _2 : constant_default5(!!_2), zoom) : filter2;
		  };
		  zoom.touchable = function(_2) {
			 return arguments.length ? (touchable = typeof _2 === "function" ? _2 : constant_default5(!!_2), zoom) : touchable;
		  };
		  zoom.extent = function(_2) {
			 return arguments.length ? (extent = typeof _2 === "function" ? _2 : constant_default5([[+_2[0][0], +_2[0][1]], [+_2[1][0], +_2[1][1]]]), zoom) : extent;
		  };
		  zoom.scaleExtent = function(_2) {
			 return arguments.length ? (scaleExtent[0] = +_2[0], scaleExtent[1] = +_2[1], zoom) : [scaleExtent[0], scaleExtent[1]];
		  };
		  zoom.translateExtent = function(_2) {
			 return arguments.length ? (translateExtent[0][0] = +_2[0][0], translateExtent[1][0] = +_2[1][0], translateExtent[0][1] = +_2[0][1], translateExtent[1][1] = +_2[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
		  };
		  zoom.constrain = function(_2) {
			 return arguments.length ? (constrain = _2, zoom) : constrain;
		  };
		  zoom.duration = function(_2) {
			 return arguments.length ? (duration = +_2, zoom) : duration;
		  };
		  zoom.interpolate = function(_2) {
			 return arguments.length ? (interpolate = _2, zoom) : interpolate;
		  };
		  zoom.on = function() {
			 var value = listeners.on.apply(listeners, arguments);
			 return value === listeners ? zoom : value;
		  };
		  zoom.clickDistance = function(_2) {
			 return arguments.length ? (clickDistance2 = (_2 = +_2) * _2, zoom) : Math.sqrt(clickDistance2);
		  };
		  zoom.tapDistance = function(_2) {
			 return arguments.length ? (tapDistance = +_2, zoom) : tapDistance;
		  };
		  return zoom;
		}

		// dist/rib-4.0/planning-board/fesm2022/rib-4.0-planning-board.mjs
		var import_lodash = __toESM(require_lodash(), 1);

		// node_modules/date-fns/toDate.mjs
		function toDate2(argument) {
		  const argStr = Object.prototype.toString.call(argument);
		  if (argument instanceof Date || typeof argument === "object" && argStr === "[object Date]") {
			 return new argument.constructor(+argument);
		  } else if (typeof argument === "number" || argStr === "[object Number]" || typeof argument === "string" || argStr === "[object String]") {
			 return new Date(argument);
		  } else {
			 return /* @__PURE__ */ new Date(NaN);
		  }
		}

		// node_modules/date-fns/constructFrom.mjs
		function constructFrom(date2, value) {
		  if (date2 instanceof Date) {
			 return new date2.constructor(value);
		  } else {
			 return new Date(value);
		  }
		}

		// node_modules/date-fns/addDays.mjs
		function addDays(date2, amount) {
		  const _date = toDate2(date2);
		  if (isNaN(amount))
			 return constructFrom(date2, NaN);
		  if (!amount) {
			 return _date;
		  }
		  _date.setDate(_date.getDate() + amount);
		  return _date;
		}

		// node_modules/date-fns/addMonths.mjs
		function addMonths(date2, amount) {
		  const _date = toDate2(date2);
		  if (isNaN(amount))
			 return constructFrom(date2, NaN);
		  if (!amount) {
			 return _date;
		  }
		  const dayOfMonth = _date.getDate();
		  const endOfDesiredMonth = constructFrom(date2, _date.getTime());
		  endOfDesiredMonth.setMonth(_date.getMonth() + amount + 1, 0);
		  const daysInMonth = endOfDesiredMonth.getDate();
		  if (dayOfMonth >= daysInMonth) {
			 return endOfDesiredMonth;
		  } else {
			 _date.setFullYear(
				endOfDesiredMonth.getFullYear(),
				endOfDesiredMonth.getMonth(),
				dayOfMonth
			 );
			 return _date;
		  }
		}

		// node_modules/date-fns/add.mjs
		function add(date2, duration) {
		  const {
			 years = 0,
			 months = 0,
			 weeks = 0,
			 days = 0,
			 hours = 0,
			 minutes = 0,
			 seconds: seconds2 = 0
		  } = duration;
		  const _date = toDate2(date2);
		  const dateWithMonths = months || years ? addMonths(_date, months + years * 12) : _date;
		  const dateWithDays = days || weeks ? addDays(dateWithMonths, days + weeks * 7) : dateWithMonths;
		  const minutesToAdd = minutes + hours * 60;
		  const secondsToAdd = seconds2 + minutesToAdd * 60;
		  const msToAdd = secondsToAdd * 1e3;
		  const finalDate = constructFrom(date2, dateWithDays.getTime() + msToAdd);
		  return finalDate;
		}

		// node_modules/date-fns/constants.mjs
		var daysInYear = 365.2425;
		var maxTime = Math.pow(10, 8) * 24 * 60 * 60 * 1e3;
		var minTime = -maxTime;
		var millisecondsInWeek = 6048e5;
		var millisecondsInDay = 864e5;
		var millisecondsInMinute = 6e4;
		var millisecondsInHour = 36e5;
		var millisecondsInSecond = 1e3;
		var secondsInHour = 3600;
		var secondsInDay = secondsInHour * 24;
		var secondsInWeek = secondsInDay * 7;
		var secondsInYear = secondsInDay * daysInYear;
		var secondsInMonth = secondsInYear / 12;
		var secondsInQuarter = secondsInMonth * 3;

		// node_modules/date-fns/_lib/defaultOptions.mjs
		var defaultOptions = {};
		function getDefaultOptions() {
		  return defaultOptions;
		}
		function setDefaultOptions(newOptions) {
		  defaultOptions = newOptions;
		}

		// node_modules/date-fns/startOfWeek.mjs
		function startOfWeek(date2, options) {
		  const defaultOptions2 = getDefaultOptions();
		  const weekStartsOn = options?.weekStartsOn ?? options?.locale?.options?.weekStartsOn ?? defaultOptions2.weekStartsOn ?? defaultOptions2.locale?.options?.weekStartsOn ?? 0;
		  const _date = toDate2(date2);
		  const day = _date.getDay();
		  const diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
		  _date.setDate(_date.getDate() - diff);
		  _date.setHours(0, 0, 0, 0);
		  return _date;
		}

		// node_modules/date-fns/startOfISOWeek.mjs
		function startOfISOWeek(date2) {
		  return startOfWeek(date2, { weekStartsOn: 1 });
		}

		// node_modules/date-fns/getISOWeekYear.mjs
		function getISOWeekYear(date2) {
		  const _date = toDate2(date2);
		  const year = _date.getFullYear();
		  const fourthOfJanuaryOfNextYear = constructFrom(date2, 0);
		  fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
		  fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
		  const startOfNextYear = startOfISOWeek(fourthOfJanuaryOfNextYear);
		  const fourthOfJanuaryOfThisYear = constructFrom(date2, 0);
		  fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
		  fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
		  const startOfThisYear = startOfISOWeek(fourthOfJanuaryOfThisYear);
		  if (_date.getTime() >= startOfNextYear.getTime()) {
			 return year + 1;
		  } else if (_date.getTime() >= startOfThisYear.getTime()) {
			 return year;
		  } else {
			 return year - 1;
		  }
		}

		// node_modules/date-fns/startOfDay.mjs
		function startOfDay(date2) {
		  const _date = toDate2(date2);
		  _date.setHours(0, 0, 0, 0);
		  return _date;
		}

		// node_modules/date-fns/_lib/getTimezoneOffsetInMilliseconds.mjs
		function getTimezoneOffsetInMilliseconds(date2) {
		  const _date = toDate2(date2);
		  const utcDate2 = new Date(
			 Date.UTC(
				_date.getFullYear(),
				_date.getMonth(),
				_date.getDate(),
				_date.getHours(),
				_date.getMinutes(),
				_date.getSeconds(),
				_date.getMilliseconds()
			 )
		  );
		  utcDate2.setUTCFullYear(_date.getFullYear());
		  return +date2 - +utcDate2;
		}

		// node_modules/date-fns/differenceInCalendarDays.mjs
		function differenceInCalendarDays(dateLeft, dateRight) {
		  const startOfDayLeft = startOfDay(dateLeft);
		  const startOfDayRight = startOfDay(dateRight);
		  const timestampLeft = +startOfDayLeft - getTimezoneOffsetInMilliseconds(startOfDayLeft);
		  const timestampRight = +startOfDayRight - getTimezoneOffsetInMilliseconds(startOfDayRight);
		  return Math.round((timestampLeft - timestampRight) / millisecondsInDay);
		}

		// node_modules/date-fns/startOfISOWeekYear.mjs
		function startOfISOWeekYear(date2) {
		  const year = getISOWeekYear(date2);
		  const fourthOfJanuary = constructFrom(date2, 0);
		  fourthOfJanuary.setFullYear(year, 0, 4);
		  fourthOfJanuary.setHours(0, 0, 0, 0);
		  return startOfISOWeek(fourthOfJanuary);
		}

		// node_modules/date-fns/max.mjs
		function max2(dates) {
		  let result;
		  dates.forEach(function(dirtyDate) {
			 const currentDate = toDate2(dirtyDate);
			 if (result === void 0 || result < currentDate || isNaN(Number(currentDate))) {
				result = currentDate;
			 }
		  });
		  return result || /* @__PURE__ */ new Date(NaN);
		}

		// node_modules/date-fns/min.mjs
		function min2(dates) {
		  let result;
		  dates.forEach((dirtyDate) => {
			 const date2 = toDate2(dirtyDate);
			 if (!result || result > date2 || isNaN(+date2)) {
				result = date2;
			 }
		  });
		  return result || /* @__PURE__ */ new Date(NaN);
		}

		// node_modules/date-fns/closestTo.mjs
		function closestTo(dateToCompare, dates) {
		  const date2 = toDate2(dateToCompare);
		  if (isNaN(Number(date2)))
			 return constructFrom(dateToCompare, NaN);
		  const timeToCompare = date2.getTime();
		  let result;
		  let minDistance;
		  dates.forEach((dirtyDate) => {
			 const currentDate = toDate2(dirtyDate);
			 if (isNaN(Number(currentDate))) {
				result = constructFrom(dateToCompare, NaN);
				minDistance = NaN;
				return;
			 }
			 const distance = Math.abs(timeToCompare - currentDate.getTime());
			 if (result == null || distance < minDistance) {
				result = currentDate;
				minDistance = distance;
			 }
		  });
		  return result;
		}

		// node_modules/date-fns/compareAsc.mjs
		function compareAsc(dateLeft, dateRight) {
		  const _dateLeft = toDate2(dateLeft);
		  const _dateRight = toDate2(dateRight);
		  const diff = _dateLeft.getTime() - _dateRight.getTime();
		  if (diff < 0) {
			 return -1;
		  } else if (diff > 0) {
			 return 1;
		  } else {
			 return diff;
		  }
		}

		// node_modules/date-fns/isDate.mjs
		function isDate2(value) {
		  return value instanceof Date || typeof value === "object" && Object.prototype.toString.call(value) === "[object Date]";
		}

		// node_modules/date-fns/isValid.mjs
		function isValid(date2) {
		  if (!isDate2(date2) && typeof date2 !== "number") {
			 return false;
		  }
		  const _date = toDate2(date2);
		  return !isNaN(Number(_date));
		}

		// node_modules/date-fns/differenceInCalendarMonths.mjs
		function differenceInCalendarMonths(dateLeft, dateRight) {
		  const _dateLeft = toDate2(dateLeft);
		  const _dateRight = toDate2(dateRight);
		  const yearDiff = _dateLeft.getFullYear() - _dateRight.getFullYear();
		  const monthDiff = _dateLeft.getMonth() - _dateRight.getMonth();
		  return yearDiff * 12 + monthDiff;
		}

		// node_modules/date-fns/getQuarter.mjs
		function getQuarter(date2) {
		  const _date = toDate2(date2);
		  const quarter = Math.trunc(_date.getMonth() / 3) + 1;
		  return quarter;
		}

		// node_modules/date-fns/differenceInCalendarYears.mjs
		function differenceInCalendarYears(dateLeft, dateRight) {
		  const _dateLeft = toDate2(dateLeft);
		  const _dateRight = toDate2(dateRight);
		  return _dateLeft.getFullYear() - _dateRight.getFullYear();
		}

		// node_modules/date-fns/differenceInDays.mjs
		function differenceInDays(dateLeft, dateRight) {
		  const _dateLeft = toDate2(dateLeft);
		  const _dateRight = toDate2(dateRight);
		  const sign = compareLocalAsc(_dateLeft, _dateRight);
		  const difference2 = Math.abs(differenceInCalendarDays(_dateLeft, _dateRight));
		  _dateLeft.setDate(_dateLeft.getDate() - sign * difference2);
		  const isLastDayNotFull = Number(
			 compareLocalAsc(_dateLeft, _dateRight) === -sign
		  );
		  const result = sign * (difference2 - isLastDayNotFull);
		  return result === 0 ? 0 : result;
		}
		function compareLocalAsc(dateLeft, dateRight) {
		  const diff = dateLeft.getFullYear() - dateRight.getFullYear() || dateLeft.getMonth() - dateRight.getMonth() || dateLeft.getDate() - dateRight.getDate() || dateLeft.getHours() - dateRight.getHours() || dateLeft.getMinutes() - dateRight.getMinutes() || dateLeft.getSeconds() - dateRight.getSeconds() || dateLeft.getMilliseconds() - dateRight.getMilliseconds();
		  if (diff < 0) {
			 return -1;
		  } else if (diff > 0) {
			 return 1;
		  } else {
			 return diff;
		  }
		}

		// node_modules/date-fns/_lib/getRoundingMethod.mjs
		function getRoundingMethod(method) {
		  return (number5) => {
			 const round2 = method ? Math[method] : Math.trunc;
			 const result = round2(number5);
			 return result === 0 ? 0 : result;
		  };
		}

		// node_modules/date-fns/differenceInMilliseconds.mjs
		function differenceInMilliseconds(dateLeft, dateRight) {
		  return +toDate2(dateLeft) - +toDate2(dateRight);
		}

		// node_modules/date-fns/differenceInHours.mjs
		function differenceInHours(dateLeft, dateRight, options) {
		  const diff = differenceInMilliseconds(dateLeft, dateRight) / millisecondsInHour;
		  return getRoundingMethod(options?.roundingMethod)(diff);
		}

		// node_modules/date-fns/differenceInMinutes.mjs
		function differenceInMinutes(dateLeft, dateRight, options) {
		  const diff = differenceInMilliseconds(dateLeft, dateRight) / millisecondsInMinute;
		  return getRoundingMethod(options?.roundingMethod)(diff);
		}

		// node_modules/date-fns/endOfDay.mjs
		function endOfDay(date2) {
		  const _date = toDate2(date2);
		  _date.setHours(23, 59, 59, 999);
		  return _date;
		}

		// node_modules/date-fns/endOfMonth.mjs
		function endOfMonth(date2) {
		  const _date = toDate2(date2);
		  const month = _date.getMonth();
		  _date.setFullYear(_date.getFullYear(), month + 1, 0);
		  _date.setHours(23, 59, 59, 999);
		  return _date;
		}

		// node_modules/date-fns/isLastDayOfMonth.mjs
		function isLastDayOfMonth(date2) {
		  const _date = toDate2(date2);
		  return +endOfDay(_date) === +endOfMonth(_date);
		}

		// node_modules/date-fns/differenceInMonths.mjs
		function differenceInMonths(dateLeft, dateRight) {
		  const _dateLeft = toDate2(dateLeft);
		  const _dateRight = toDate2(dateRight);
		  const sign = compareAsc(_dateLeft, _dateRight);
		  const difference2 = Math.abs(
			 differenceInCalendarMonths(_dateLeft, _dateRight)
		  );
		  let result;
		  if (difference2 < 1) {
			 result = 0;
		  } else {
			 if (_dateLeft.getMonth() === 1 && _dateLeft.getDate() > 27) {
				_dateLeft.setDate(30);
			 }
			 _dateLeft.setMonth(_dateLeft.getMonth() - sign * difference2);
			 let isLastMonthNotFull = compareAsc(_dateLeft, _dateRight) === -sign;
			 if (isLastDayOfMonth(toDate2(dateLeft)) && difference2 === 1 && compareAsc(dateLeft, _dateRight) === 1) {
				isLastMonthNotFull = false;
			 }
			 result = sign * (difference2 - Number(isLastMonthNotFull));
		  }
		  return result === 0 ? 0 : result;
		}

		// node_modules/date-fns/differenceInSeconds.mjs
		function differenceInSeconds(dateLeft, dateRight, options) {
		  const diff = differenceInMilliseconds(dateLeft, dateRight) / 1e3;
		  return getRoundingMethod(options?.roundingMethod)(diff);
		}

		// node_modules/date-fns/differenceInWeeks.mjs
		function differenceInWeeks(dateLeft, dateRight, options) {
		  const diff = differenceInDays(dateLeft, dateRight) / 7;
		  return getRoundingMethod(options?.roundingMethod)(diff);
		}

		// node_modules/date-fns/differenceInYears.mjs
		function differenceInYears(dateLeft, dateRight) {
		  const _dateLeft = toDate2(dateLeft);
		  const _dateRight = toDate2(dateRight);
		  const sign = compareAsc(_dateLeft, _dateRight);
		  const difference2 = Math.abs(differenceInCalendarYears(_dateLeft, _dateRight));
		  _dateLeft.setFullYear(1584);
		  _dateRight.setFullYear(1584);
		  const isLastYearNotFull = compareAsc(_dateLeft, _dateRight) === -sign;
		  const result = sign * (difference2 - +isLastYearNotFull);
		  return result === 0 ? 0 : result;
		}

		// node_modules/date-fns/startOfMinute.mjs
		function startOfMinute(date2) {
		  const _date = toDate2(date2);
		  _date.setSeconds(0, 0);
		  return _date;
		}

		// node_modules/date-fns/startOfQuarter.mjs
		function startOfQuarter(date2) {
		  const _date = toDate2(date2);
		  const currentMonth = _date.getMonth();
		  const month = currentMonth - currentMonth % 3;
		  _date.setMonth(month, 1);
		  _date.setHours(0, 0, 0, 0);
		  return _date;
		}

		// node_modules/date-fns/startOfMonth.mjs
		function startOfMonth(date2) {
		  const _date = toDate2(date2);
		  _date.setDate(1);
		  _date.setHours(0, 0, 0, 0);
		  return _date;
		}

		// node_modules/date-fns/endOfYear.mjs
		function endOfYear(date2) {
		  const _date = toDate2(date2);
		  const year = _date.getFullYear();
		  _date.setFullYear(year + 1, 0, 0);
		  _date.setHours(23, 59, 59, 999);
		  return _date;
		}

		// node_modules/date-fns/startOfYear.mjs
		function startOfYear(date2) {
		  const cleanDate = toDate2(date2);
		  const _date = constructFrom(date2, 0);
		  _date.setFullYear(cleanDate.getFullYear(), 0, 1);
		  _date.setHours(0, 0, 0, 0);
		  return _date;
		}

		// node_modules/date-fns/endOfHour.mjs
		function endOfHour(date2) {
		  const _date = toDate2(date2);
		  _date.setMinutes(59, 59, 999);
		  return _date;
		}

		// node_modules/date-fns/endOfWeek.mjs
		function endOfWeek(date2, options) {
		  const defaultOptions2 = getDefaultOptions();
		  const weekStartsOn = options?.weekStartsOn ?? options?.locale?.options?.weekStartsOn ?? defaultOptions2.weekStartsOn ?? defaultOptions2.locale?.options?.weekStartsOn ?? 0;
		  const _date = toDate2(date2);
		  const day = _date.getDay();
		  const diff = (day < weekStartsOn ? -7 : 0) + 6 - (day - weekStartsOn);
		  _date.setDate(_date.getDate() + diff);
		  _date.setHours(23, 59, 59, 999);
		  return _date;
		}

		// node_modules/date-fns/endOfISOWeek.mjs
		function endOfISOWeek(date2) {
		  return endOfWeek(date2, { weekStartsOn: 1 });
		}

		// node_modules/date-fns/endOfMinute.mjs
		function endOfMinute(date2) {
		  const _date = toDate2(date2);
		  _date.setSeconds(59, 999);
		  return _date;
		}

		// node_modules/date-fns/endOfQuarter.mjs
		function endOfQuarter(date2) {
		  const _date = toDate2(date2);
		  const currentMonth = _date.getMonth();
		  const month = currentMonth - currentMonth % 3 + 3;
		  _date.setMonth(month, 0);
		  _date.setHours(23, 59, 59, 999);
		  return _date;
		}

		// node_modules/date-fns/endOfSecond.mjs
		function endOfSecond(date2) {
		  const _date = toDate2(date2);
		  _date.setMilliseconds(999);
		  return _date;
		}

		// node_modules/date-fns/locale/en-US/_lib/formatDistance.mjs
		var formatDistanceLocale = {
		  lessThanXSeconds: {
			 one: "less than a second",
			 other: "less than {{count}} seconds"
		  },
		  xSeconds: {
			 one: "1 second",
			 other: "{{count}} seconds"
		  },
		  halfAMinute: "half a minute",
		  lessThanXMinutes: {
			 one: "less than a minute",
			 other: "less than {{count}} minutes"
		  },
		  xMinutes: {
			 one: "1 minute",
			 other: "{{count}} minutes"
		  },
		  aboutXHours: {
			 one: "about 1 hour",
			 other: "about {{count}} hours"
		  },
		  xHours: {
			 one: "1 hour",
			 other: "{{count}} hours"
		  },
		  xDays: {
			 one: "1 day",
			 other: "{{count}} days"
		  },
		  aboutXWeeks: {
			 one: "about 1 week",
			 other: "about {{count}} weeks"
		  },
		  xWeeks: {
			 one: "1 week",
			 other: "{{count}} weeks"
		  },
		  aboutXMonths: {
			 one: "about 1 month",
			 other: "about {{count}} months"
		  },
		  xMonths: {
			 one: "1 month",
			 other: "{{count}} months"
		  },
		  aboutXYears: {
			 one: "about 1 year",
			 other: "about {{count}} years"
		  },
		  xYears: {
			 one: "1 year",
			 other: "{{count}} years"
		  },
		  overXYears: {
			 one: "over 1 year",
			 other: "over {{count}} years"
		  },
		  almostXYears: {
			 one: "almost 1 year",
			 other: "almost {{count}} years"
		  }
		};
		var formatDistance = (token, count, options) => {
		  let result;
		  const tokenValue = formatDistanceLocale[token];
		  if (typeof tokenValue === "string") {
			 result = tokenValue;
		  } else if (count === 1) {
			 result = tokenValue.one;
		  } else {
			 result = tokenValue.other.replace("{{count}}", count.toString());
		  }
		  if (options?.addSuffix) {
			 if (options.comparison && options.comparison > 0) {
				return "in " + result;
			 } else {
				return result + " ago";
			 }
		  }
		  return result;
		};

		// node_modules/date-fns/locale/_lib/buildFormatLongFn.mjs
		function buildFormatLongFn(args) {
		  return (options = {}) => {
			 const width = options.width ? String(options.width) : args.defaultWidth;
			 const format2 = args.formats[width] || args.formats[args.defaultWidth];
			 return format2;
		  };
		}

		// node_modules/date-fns/locale/en-US/_lib/formatLong.mjs
		var dateFormats = {
		  full: "EEEE, MMMM do, y",
		  long: "MMMM do, y",
		  medium: "MMM d, y",
		  short: "MM/dd/yyyy"
		};
		var timeFormats = {
		  full: "h:mm:ss a zzzz",
		  long: "h:mm:ss a z",
		  medium: "h:mm:ss a",
		  short: "h:mm a"
		};
		var dateTimeFormats = {
		  full: "{{date}} 'at' {{time}}",
		  long: "{{date}} 'at' {{time}}",
		  medium: "{{date}}, {{time}}",
		  short: "{{date}}, {{time}}"
		};
		var formatLong = {
		  date: buildFormatLongFn({
			 formats: dateFormats,
			 defaultWidth: "full"
		  }),
		  time: buildFormatLongFn({
			 formats: timeFormats,
			 defaultWidth: "full"
		  }),
		  dateTime: buildFormatLongFn({
			 formats: dateTimeFormats,
			 defaultWidth: "full"
		  })
		};

		// node_modules/date-fns/locale/en-US/_lib/formatRelative.mjs
		var formatRelativeLocale = {
		  lastWeek: "'last' eeee 'at' p",
		  yesterday: "'yesterday at' p",
		  today: "'today at' p",
		  tomorrow: "'tomorrow at' p",
		  nextWeek: "eeee 'at' p",
		  other: "P"
		};
		var formatRelative = (token, _date, _baseDate, _options) => formatRelativeLocale[token];

		// node_modules/date-fns/locale/_lib/buildLocalizeFn.mjs
		function buildLocalizeFn(args) {
		  return (value, options) => {
			 const context2 = options?.context ? String(options.context) : "standalone";
			 let valuesArray;
			 if (context2 === "formatting" && args.formattingValues) {
				const defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
				const width = options?.width ? String(options.width) : defaultWidth;
				valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
			 } else {
				const defaultWidth = args.defaultWidth;
				const width = options?.width ? String(options.width) : args.defaultWidth;
				valuesArray = args.values[width] || args.values[defaultWidth];
			 }
			 const index = args.argumentCallback ? args.argumentCallback(value) : value;
			 return valuesArray[index];
		  };
		}

		// node_modules/date-fns/locale/en-US/_lib/localize.mjs
		var eraValues = {
		  narrow: ["B", "A"],
		  abbreviated: ["BC", "AD"],
		  wide: ["Before Christ", "Anno Domini"]
		};
		var quarterValues = {
		  narrow: ["1", "2", "3", "4"],
		  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
		  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
		};
		var monthValues = {
		  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
		  abbreviated: [
			 "Jan",
			 "Feb",
			 "Mar",
			 "Apr",
			 "May",
			 "Jun",
			 "Jul",
			 "Aug",
			 "Sep",
			 "Oct",
			 "Nov",
			 "Dec"
		  ],
		  wide: [
			 "January",
			 "February",
			 "March",
			 "April",
			 "May",
			 "June",
			 "July",
			 "August",
			 "September",
			 "October",
			 "November",
			 "December"
		  ]
		};
		var dayValues = {
		  narrow: ["S", "M", "T", "W", "T", "F", "S"],
		  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
		  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
		  wide: [
			 "Sunday",
			 "Monday",
			 "Tuesday",
			 "Wednesday",
			 "Thursday",
			 "Friday",
			 "Saturday"
		  ]
		};
		var dayPeriodValues = {
		  narrow: {
			 am: "a",
			 pm: "p",
			 midnight: "mi",
			 noon: "n",
			 morning: "morning",
			 afternoon: "afternoon",
			 evening: "evening",
			 night: "night"
		  },
		  abbreviated: {
			 am: "AM",
			 pm: "PM",
			 midnight: "midnight",
			 noon: "noon",
			 morning: "morning",
			 afternoon: "afternoon",
			 evening: "evening",
			 night: "night"
		  },
		  wide: {
			 am: "a.m.",
			 pm: "p.m.",
			 midnight: "midnight",
			 noon: "noon",
			 morning: "morning",
			 afternoon: "afternoon",
			 evening: "evening",
			 night: "night"
		  }
		};
		var formattingDayPeriodValues = {
		  narrow: {
			 am: "a",
			 pm: "p",
			 midnight: "mi",
			 noon: "n",
			 morning: "in the morning",
			 afternoon: "in the afternoon",
			 evening: "in the evening",
			 night: "at night"
		  },
		  abbreviated: {
			 am: "AM",
			 pm: "PM",
			 midnight: "midnight",
			 noon: "noon",
			 morning: "in the morning",
			 afternoon: "in the afternoon",
			 evening: "in the evening",
			 night: "at night"
		  },
		  wide: {
			 am: "a.m.",
			 pm: "p.m.",
			 midnight: "midnight",
			 noon: "noon",
			 morning: "in the morning",
			 afternoon: "in the afternoon",
			 evening: "in the evening",
			 night: "at night"
		  }
		};
		var ordinalNumber = (dirtyNumber, _options) => {
		  const number5 = Number(dirtyNumber);
		  const rem100 = number5 % 100;
		  if (rem100 > 20 || rem100 < 10) {
			 switch (rem100 % 10) {
				case 1:
				  return number5 + "st";
				case 2:
				  return number5 + "nd";
				case 3:
				  return number5 + "rd";
			 }
		  }
		  return number5 + "th";
		};
		var localize = {
		  ordinalNumber,
		  era: buildLocalizeFn({
			 values: eraValues,
			 defaultWidth: "wide"
		  }),
		  quarter: buildLocalizeFn({
			 values: quarterValues,
			 defaultWidth: "wide",
			 argumentCallback: (quarter) => quarter - 1
		  }),
		  month: buildLocalizeFn({
			 values: monthValues,
			 defaultWidth: "wide"
		  }),
		  day: buildLocalizeFn({
			 values: dayValues,
			 defaultWidth: "wide"
		  }),
		  dayPeriod: buildLocalizeFn({
			 values: dayPeriodValues,
			 defaultWidth: "wide",
			 formattingValues: formattingDayPeriodValues,
			 defaultFormattingWidth: "wide"
		  })
		};

		// node_modules/date-fns/locale/_lib/buildMatchFn.mjs
		function buildMatchFn(args) {
		  return (string, options = {}) => {
			 const width = options.width;
			 const matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
			 const matchResult = string.match(matchPattern);
			 if (!matchResult) {
				return null;
			 }
			 const matchedString = matchResult[0];
			 const parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
			 const key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, (pattern) => pattern.test(matchedString)) : (
				// eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
				findKey(parsePatterns, (pattern) => pattern.test(matchedString))
			 );
			 let value;
			 value = args.valueCallback ? args.valueCallback(key) : key;
			 value = options.valueCallback ? (
				// eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
				options.valueCallback(value)
			 ) : value;
			 const rest = string.slice(matchedString.length);
			 return { value, rest };
		  };
		}
		function findKey(object, predicate) {
		  for (const key in object) {
			 if (Object.prototype.hasOwnProperty.call(object, key) && predicate(object[key])) {
				return key;
			 }
		  }
		  return void 0;
		}
		function findIndex(array2, predicate) {
		  for (let key = 0; key < array2.length; key++) {
			 if (predicate(array2[key])) {
				return key;
			 }
		  }
		  return void 0;
		}

		// node_modules/date-fns/locale/_lib/buildMatchPatternFn.mjs
		function buildMatchPatternFn(args) {
		  return (string, options = {}) => {
			 const matchResult = string.match(args.matchPattern);
			 if (!matchResult)
				return null;
			 const matchedString = matchResult[0];
			 const parseResult = string.match(args.parsePattern);
			 if (!parseResult)
				return null;
			 let value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
			 value = options.valueCallback ? options.valueCallback(value) : value;
			 const rest = string.slice(matchedString.length);
			 return { value, rest };
		  };
		}

		// node_modules/date-fns/locale/en-US/_lib/match.mjs
		var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
		var parseOrdinalNumberPattern = /\d+/i;
		var matchEraPatterns = {
		  narrow: /^(b|a)/i,
		  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
		  wide: /^(before christ|before common era|anno domini|common era)/i
		};
		var parseEraPatterns = {
		  any: [/^b/i, /^(a|c)/i]
		};
		var matchQuarterPatterns = {
		  narrow: /^[1234]/i,
		  abbreviated: /^q[1234]/i,
		  wide: /^[1234](th|st|nd|rd)? quarter/i
		};
		var parseQuarterPatterns = {
		  any: [/1/i, /2/i, /3/i, /4/i]
		};
		var matchMonthPatterns = {
		  narrow: /^[jfmasond]/i,
		  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
		  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
		};
		var parseMonthPatterns = {
		  narrow: [
			 /^j/i,
			 /^f/i,
			 /^m/i,
			 /^a/i,
			 /^m/i,
			 /^j/i,
			 /^j/i,
			 /^a/i,
			 /^s/i,
			 /^o/i,
			 /^n/i,
			 /^d/i
		  ],
		  any: [
			 /^ja/i,
			 /^f/i,
			 /^mar/i,
			 /^ap/i,
			 /^may/i,
			 /^jun/i,
			 /^jul/i,
			 /^au/i,
			 /^s/i,
			 /^o/i,
			 /^n/i,
			 /^d/i
		  ]
		};
		var matchDayPatterns = {
		  narrow: /^[smtwf]/i,
		  short: /^(su|mo|tu|we|th|fr|sa)/i,
		  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
		  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
		};
		var parseDayPatterns = {
		  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
		  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
		};
		var matchDayPeriodPatterns = {
		  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
		  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
		};
		var parseDayPeriodPatterns = {
		  any: {
			 am: /^a/i,
			 pm: /^p/i,
			 midnight: /^mi/i,
			 noon: /^no/i,
			 morning: /morning/i,
			 afternoon: /afternoon/i,
			 evening: /evening/i,
			 night: /night/i
		  }
		};
		var match = {
		  ordinalNumber: buildMatchPatternFn({
			 matchPattern: matchOrdinalNumberPattern,
			 parsePattern: parseOrdinalNumberPattern,
			 valueCallback: (value) => parseInt(value, 10)
		  }),
		  era: buildMatchFn({
			 matchPatterns: matchEraPatterns,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseEraPatterns,
			 defaultParseWidth: "any"
		  }),
		  quarter: buildMatchFn({
			 matchPatterns: matchQuarterPatterns,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseQuarterPatterns,
			 defaultParseWidth: "any",
			 valueCallback: (index) => index + 1
		  }),
		  month: buildMatchFn({
			 matchPatterns: matchMonthPatterns,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseMonthPatterns,
			 defaultParseWidth: "any"
		  }),
		  day: buildMatchFn({
			 matchPatterns: matchDayPatterns,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseDayPatterns,
			 defaultParseWidth: "any"
		  }),
		  dayPeriod: buildMatchFn({
			 matchPatterns: matchDayPeriodPatterns,
			 defaultMatchWidth: "any",
			 parsePatterns: parseDayPeriodPatterns,
			 defaultParseWidth: "any"
		  })
		};

		// node_modules/date-fns/locale/en-US.mjs
		var enUS = {
		  code: "en-US",
		  formatDistance,
		  formatLong,
		  formatRelative,
		  localize,
		  match,
		  options: {
			 weekStartsOn: 0,
			 firstWeekContainsDate: 1
		  }
		};

		// node_modules/date-fns/getDayOfYear.mjs
		function getDayOfYear(date2) {
		  const _date = toDate2(date2);
		  const diff = differenceInCalendarDays(_date, startOfYear(_date));
		  const dayOfYear = diff + 1;
		  return dayOfYear;
		}

		// node_modules/date-fns/getISOWeek.mjs
		function getISOWeek(date2) {
		  const _date = toDate2(date2);
		  const diff = +startOfISOWeek(_date) - +startOfISOWeekYear(_date);
		  return Math.round(diff / millisecondsInWeek) + 1;
		}

		// node_modules/date-fns/getWeekYear.mjs
		function getWeekYear(date2, options) {
		  const _date = toDate2(date2);
		  const year = _date.getFullYear();
		  const defaultOptions2 = getDefaultOptions();
		  const firstWeekContainsDate = options?.firstWeekContainsDate ?? options?.locale?.options?.firstWeekContainsDate ?? defaultOptions2.firstWeekContainsDate ?? defaultOptions2.locale?.options?.firstWeekContainsDate ?? 1;
		  const firstWeekOfNextYear = constructFrom(date2, 0);
		  firstWeekOfNextYear.setFullYear(year + 1, 0, firstWeekContainsDate);
		  firstWeekOfNextYear.setHours(0, 0, 0, 0);
		  const startOfNextYear = startOfWeek(firstWeekOfNextYear, options);
		  const firstWeekOfThisYear = constructFrom(date2, 0);
		  firstWeekOfThisYear.setFullYear(year, 0, firstWeekContainsDate);
		  firstWeekOfThisYear.setHours(0, 0, 0, 0);
		  const startOfThisYear = startOfWeek(firstWeekOfThisYear, options);
		  if (_date.getTime() >= startOfNextYear.getTime()) {
			 return year + 1;
		  } else if (_date.getTime() >= startOfThisYear.getTime()) {
			 return year;
		  } else {
			 return year - 1;
		  }
		}

		// node_modules/date-fns/startOfWeekYear.mjs
		function startOfWeekYear(date2, options) {
		  const defaultOptions2 = getDefaultOptions();
		  const firstWeekContainsDate = options?.firstWeekContainsDate ?? options?.locale?.options?.firstWeekContainsDate ?? defaultOptions2.firstWeekContainsDate ?? defaultOptions2.locale?.options?.firstWeekContainsDate ?? 1;
		  const year = getWeekYear(date2, options);
		  const firstWeek = constructFrom(date2, 0);
		  firstWeek.setFullYear(year, 0, firstWeekContainsDate);
		  firstWeek.setHours(0, 0, 0, 0);
		  const _date = startOfWeek(firstWeek, options);
		  return _date;
		}

		// node_modules/date-fns/getWeek.mjs
		function getWeek(date2, options) {
		  const _date = toDate2(date2);
		  const diff = +startOfWeek(_date, options) - +startOfWeekYear(_date, options);
		  return Math.round(diff / millisecondsInWeek) + 1;
		}

		// node_modules/date-fns/_lib/addLeadingZeros.mjs
		function addLeadingZeros(number5, targetLength) {
		  const sign = number5 < 0 ? "-" : "";
		  const output = Math.abs(number5).toString().padStart(targetLength, "0");
		  return sign + output;
		}

		// node_modules/date-fns/_lib/format/lightFormatters.mjs
		var lightFormatters = {
		  // Year
		  y(date2, token) {
			 const signedYear = date2.getFullYear();
			 const year = signedYear > 0 ? signedYear : 1 - signedYear;
			 return addLeadingZeros(token === "yy" ? year % 100 : year, token.length);
		  },
		  // Month
		  M(date2, token) {
			 const month = date2.getMonth();
			 return token === "M" ? String(month + 1) : addLeadingZeros(month + 1, 2);
		  },
		  // Day of the month
		  d(date2, token) {
			 return addLeadingZeros(date2.getDate(), token.length);
		  },
		  // AM or PM
		  a(date2, token) {
			 const dayPeriodEnumValue = date2.getHours() / 12 >= 1 ? "pm" : "am";
			 switch (token) {
				case "a":
				case "aa":
				  return dayPeriodEnumValue.toUpperCase();
				case "aaa":
				  return dayPeriodEnumValue;
				case "aaaaa":
				  return dayPeriodEnumValue[0];
				case "aaaa":
				default:
				  return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
			 }
		  },
		  // Hour [1-12]
		  h(date2, token) {
			 return addLeadingZeros(date2.getHours() % 12 || 12, token.length);
		  },
		  // Hour [0-23]
		  H(date2, token) {
			 return addLeadingZeros(date2.getHours(), token.length);
		  },
		  // Minute
		  m(date2, token) {
			 return addLeadingZeros(date2.getMinutes(), token.length);
		  },
		  // Second
		  s(date2, token) {
			 return addLeadingZeros(date2.getSeconds(), token.length);
		  },
		  // Fraction of second
		  S(date2, token) {
			 const numberOfDigits = token.length;
			 const milliseconds2 = date2.getMilliseconds();
			 const fractionalSeconds = Math.trunc(
				milliseconds2 * Math.pow(10, numberOfDigits - 3)
			 );
			 return addLeadingZeros(fractionalSeconds, token.length);
		  }
		};

		// node_modules/date-fns/_lib/format/formatters.mjs
		var dayPeriodEnum = {
		  am: "am",
		  pm: "pm",
		  midnight: "midnight",
		  noon: "noon",
		  morning: "morning",
		  afternoon: "afternoon",
		  evening: "evening",
		  night: "night"
		};
		var formatters = {
		  // Era
		  G: function(date2, token, localize23) {
			 const era = date2.getFullYear() > 0 ? 1 : 0;
			 switch (token) {
				case "G":
				case "GG":
				case "GGG":
				  return localize23.era(era, { width: "abbreviated" });
				case "GGGGG":
				  return localize23.era(era, { width: "narrow" });
				case "GGGG":
				default:
				  return localize23.era(era, { width: "wide" });
			 }
		  },
		  // Year
		  y: function(date2, token, localize23) {
			 if (token === "yo") {
				const signedYear = date2.getFullYear();
				const year = signedYear > 0 ? signedYear : 1 - signedYear;
				return localize23.ordinalNumber(year, { unit: "year" });
			 }
			 return lightFormatters.y(date2, token);
		  },
		  // Local week-numbering year
		  Y: function(date2, token, localize23, options) {
			 const signedWeekYear = getWeekYear(date2, options);
			 const weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
			 if (token === "YY") {
				const twoDigitYear = weekYear % 100;
				return addLeadingZeros(twoDigitYear, 2);
			 }
			 if (token === "Yo") {
				return localize23.ordinalNumber(weekYear, { unit: "year" });
			 }
			 return addLeadingZeros(weekYear, token.length);
		  },
		  // ISO week-numbering year
		  R: function(date2, token) {
			 const isoWeekYear = getISOWeekYear(date2);
			 return addLeadingZeros(isoWeekYear, token.length);
		  },
		  // Extended year. This is a single number designating the year of this calendar system.
		  // The main difference between `y` and `u` localizers are B.C. years:
		  // | Year | `y` | `u` |
		  // |------|-----|-----|
		  // | AC 1 |   1 |   1 |
		  // | BC 1 |   1 |   0 |
		  // | BC 2 |   2 |  -1 |
		  // Also `yy` always returns the last two digits of a year,
		  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
		  u: function(date2, token) {
			 const year = date2.getFullYear();
			 return addLeadingZeros(year, token.length);
		  },
		  // Quarter
		  Q: function(date2, token, localize23) {
			 const quarter = Math.ceil((date2.getMonth() + 1) / 3);
			 switch (token) {
				case "Q":
				  return String(quarter);
				case "QQ":
				  return addLeadingZeros(quarter, 2);
				case "Qo":
				  return localize23.ordinalNumber(quarter, { unit: "quarter" });
				case "QQQ":
				  return localize23.quarter(quarter, {
					 width: "abbreviated",
					 context: "formatting"
				  });
				case "QQQQQ":
				  return localize23.quarter(quarter, {
					 width: "narrow",
					 context: "formatting"
				  });
				case "QQQQ":
				default:
				  return localize23.quarter(quarter, {
					 width: "wide",
					 context: "formatting"
				  });
			 }
		  },
		  // Stand-alone quarter
		  q: function(date2, token, localize23) {
			 const quarter = Math.ceil((date2.getMonth() + 1) / 3);
			 switch (token) {
				case "q":
				  return String(quarter);
				case "qq":
				  return addLeadingZeros(quarter, 2);
				case "qo":
				  return localize23.ordinalNumber(quarter, { unit: "quarter" });
				case "qqq":
				  return localize23.quarter(quarter, {
					 width: "abbreviated",
					 context: "standalone"
				  });
				case "qqqqq":
				  return localize23.quarter(quarter, {
					 width: "narrow",
					 context: "standalone"
				  });
				case "qqqq":
				default:
				  return localize23.quarter(quarter, {
					 width: "wide",
					 context: "standalone"
				  });
			 }
		  },
		  // Month
		  M: function(date2, token, localize23) {
			 const month = date2.getMonth();
			 switch (token) {
				case "M":
				case "MM":
				  return lightFormatters.M(date2, token);
				case "Mo":
				  return localize23.ordinalNumber(month + 1, { unit: "month" });
				case "MMM":
				  return localize23.month(month, {
					 width: "abbreviated",
					 context: "formatting"
				  });
				case "MMMMM":
				  return localize23.month(month, {
					 width: "narrow",
					 context: "formatting"
				  });
				case "MMMM":
				default:
				  return localize23.month(month, { width: "wide", context: "formatting" });
			 }
		  },
		  // Stand-alone month
		  L: function(date2, token, localize23) {
			 const month = date2.getMonth();
			 switch (token) {
				case "L":
				  return String(month + 1);
				case "LL":
				  return addLeadingZeros(month + 1, 2);
				case "Lo":
				  return localize23.ordinalNumber(month + 1, { unit: "month" });
				case "LLL":
				  return localize23.month(month, {
					 width: "abbreviated",
					 context: "standalone"
				  });
				case "LLLLL":
				  return localize23.month(month, {
					 width: "narrow",
					 context: "standalone"
				  });
				case "LLLL":
				default:
				  return localize23.month(month, { width: "wide", context: "standalone" });
			 }
		  },
		  // Local week of year
		  w: function(date2, token, localize23, options) {
			 const week = getWeek(date2, options);
			 if (token === "wo") {
				return localize23.ordinalNumber(week, { unit: "week" });
			 }
			 return addLeadingZeros(week, token.length);
		  },
		  // ISO week of year
		  I: function(date2, token, localize23) {
			 const isoWeek = getISOWeek(date2);
			 if (token === "Io") {
				return localize23.ordinalNumber(isoWeek, { unit: "week" });
			 }
			 return addLeadingZeros(isoWeek, token.length);
		  },
		  // Day of the month
		  d: function(date2, token, localize23) {
			 if (token === "do") {
				return localize23.ordinalNumber(date2.getDate(), { unit: "date" });
			 }
			 return lightFormatters.d(date2, token);
		  },
		  // Day of year
		  D: function(date2, token, localize23) {
			 const dayOfYear = getDayOfYear(date2);
			 if (token === "Do") {
				return localize23.ordinalNumber(dayOfYear, { unit: "dayOfYear" });
			 }
			 return addLeadingZeros(dayOfYear, token.length);
		  },
		  // Day of week
		  E: function(date2, token, localize23) {
			 const dayOfWeek = date2.getDay();
			 switch (token) {
				case "E":
				case "EE":
				case "EEE":
				  return localize23.day(dayOfWeek, {
					 width: "abbreviated",
					 context: "formatting"
				  });
				case "EEEEE":
				  return localize23.day(dayOfWeek, {
					 width: "narrow",
					 context: "formatting"
				  });
				case "EEEEEE":
				  return localize23.day(dayOfWeek, {
					 width: "short",
					 context: "formatting"
				  });
				case "EEEE":
				default:
				  return localize23.day(dayOfWeek, {
					 width: "wide",
					 context: "formatting"
				  });
			 }
		  },
		  // Local day of week
		  e: function(date2, token, localize23, options) {
			 const dayOfWeek = date2.getDay();
			 const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
			 switch (token) {
				case "e":
				  return String(localDayOfWeek);
				case "ee":
				  return addLeadingZeros(localDayOfWeek, 2);
				case "eo":
				  return localize23.ordinalNumber(localDayOfWeek, { unit: "day" });
				case "eee":
				  return localize23.day(dayOfWeek, {
					 width: "abbreviated",
					 context: "formatting"
				  });
				case "eeeee":
				  return localize23.day(dayOfWeek, {
					 width: "narrow",
					 context: "formatting"
				  });
				case "eeeeee":
				  return localize23.day(dayOfWeek, {
					 width: "short",
					 context: "formatting"
				  });
				case "eeee":
				default:
				  return localize23.day(dayOfWeek, {
					 width: "wide",
					 context: "formatting"
				  });
			 }
		  },
		  // Stand-alone local day of week
		  c: function(date2, token, localize23, options) {
			 const dayOfWeek = date2.getDay();
			 const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
			 switch (token) {
				case "c":
				  return String(localDayOfWeek);
				case "cc":
				  return addLeadingZeros(localDayOfWeek, token.length);
				case "co":
				  return localize23.ordinalNumber(localDayOfWeek, { unit: "day" });
				case "ccc":
				  return localize23.day(dayOfWeek, {
					 width: "abbreviated",
					 context: "standalone"
				  });
				case "ccccc":
				  return localize23.day(dayOfWeek, {
					 width: "narrow",
					 context: "standalone"
				  });
				case "cccccc":
				  return localize23.day(dayOfWeek, {
					 width: "short",
					 context: "standalone"
				  });
				case "cccc":
				default:
				  return localize23.day(dayOfWeek, {
					 width: "wide",
					 context: "standalone"
				  });
			 }
		  },
		  // ISO day of week
		  i: function(date2, token, localize23) {
			 const dayOfWeek = date2.getDay();
			 const isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
			 switch (token) {
				case "i":
				  return String(isoDayOfWeek);
				case "ii":
				  return addLeadingZeros(isoDayOfWeek, token.length);
				case "io":
				  return localize23.ordinalNumber(isoDayOfWeek, { unit: "day" });
				case "iii":
				  return localize23.day(dayOfWeek, {
					 width: "abbreviated",
					 context: "formatting"
				  });
				case "iiiii":
				  return localize23.day(dayOfWeek, {
					 width: "narrow",
					 context: "formatting"
				  });
				case "iiiiii":
				  return localize23.day(dayOfWeek, {
					 width: "short",
					 context: "formatting"
				  });
				case "iiii":
				default:
				  return localize23.day(dayOfWeek, {
					 width: "wide",
					 context: "formatting"
				  });
			 }
		  },
		  // AM or PM
		  a: function(date2, token, localize23) {
			 const hours = date2.getHours();
			 const dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
			 switch (token) {
				case "a":
				case "aa":
				  return localize23.dayPeriod(dayPeriodEnumValue, {
					 width: "abbreviated",
					 context: "formatting"
				  });
				case "aaa":
				  return localize23.dayPeriod(dayPeriodEnumValue, {
					 width: "abbreviated",
					 context: "formatting"
				  }).toLowerCase();
				case "aaaaa":
				  return localize23.dayPeriod(dayPeriodEnumValue, {
					 width: "narrow",
					 context: "formatting"
				  });
				case "aaaa":
				default:
				  return localize23.dayPeriod(dayPeriodEnumValue, {
					 width: "wide",
					 context: "formatting"
				  });
			 }
		  },
		  // AM, PM, midnight, noon
		  b: function(date2, token, localize23) {
			 const hours = date2.getHours();
			 let dayPeriodEnumValue;
			 if (hours === 12) {
				dayPeriodEnumValue = dayPeriodEnum.noon;
			 } else if (hours === 0) {
				dayPeriodEnumValue = dayPeriodEnum.midnight;
			 } else {
				dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
			 }
			 switch (token) {
				case "b":
				case "bb":
				  return localize23.dayPeriod(dayPeriodEnumValue, {
					 width: "abbreviated",
					 context: "formatting"
				  });
				case "bbb":
				  return localize23.dayPeriod(dayPeriodEnumValue, {
					 width: "abbreviated",
					 context: "formatting"
				  }).toLowerCase();
				case "bbbbb":
				  return localize23.dayPeriod(dayPeriodEnumValue, {
					 width: "narrow",
					 context: "formatting"
				  });
				case "bbbb":
				default:
				  return localize23.dayPeriod(dayPeriodEnumValue, {
					 width: "wide",
					 context: "formatting"
				  });
			 }
		  },
		  // in the morning, in the afternoon, in the evening, at night
		  B: function(date2, token, localize23) {
			 const hours = date2.getHours();
			 let dayPeriodEnumValue;
			 if (hours >= 17) {
				dayPeriodEnumValue = dayPeriodEnum.evening;
			 } else if (hours >= 12) {
				dayPeriodEnumValue = dayPeriodEnum.afternoon;
			 } else if (hours >= 4) {
				dayPeriodEnumValue = dayPeriodEnum.morning;
			 } else {
				dayPeriodEnumValue = dayPeriodEnum.night;
			 }
			 switch (token) {
				case "B":
				case "BB":
				case "BBB":
				  return localize23.dayPeriod(dayPeriodEnumValue, {
					 width: "abbreviated",
					 context: "formatting"
				  });
				case "BBBBB":
				  return localize23.dayPeriod(dayPeriodEnumValue, {
					 width: "narrow",
					 context: "formatting"
				  });
				case "BBBB":
				default:
				  return localize23.dayPeriod(dayPeriodEnumValue, {
					 width: "wide",
					 context: "formatting"
				  });
			 }
		  },
		  // Hour [1-12]
		  h: function(date2, token, localize23) {
			 if (token === "ho") {
				let hours = date2.getHours() % 12;
				if (hours === 0)
				  hours = 12;
				return localize23.ordinalNumber(hours, { unit: "hour" });
			 }
			 return lightFormatters.h(date2, token);
		  },
		  // Hour [0-23]
		  H: function(date2, token, localize23) {
			 if (token === "Ho") {
				return localize23.ordinalNumber(date2.getHours(), { unit: "hour" });
			 }
			 return lightFormatters.H(date2, token);
		  },
		  // Hour [0-11]
		  K: function(date2, token, localize23) {
			 const hours = date2.getHours() % 12;
			 if (token === "Ko") {
				return localize23.ordinalNumber(hours, { unit: "hour" });
			 }
			 return addLeadingZeros(hours, token.length);
		  },
		  // Hour [1-24]
		  k: function(date2, token, localize23) {
			 let hours = date2.getHours();
			 if (hours === 0)
				hours = 24;
			 if (token === "ko") {
				return localize23.ordinalNumber(hours, { unit: "hour" });
			 }
			 return addLeadingZeros(hours, token.length);
		  },
		  // Minute
		  m: function(date2, token, localize23) {
			 if (token === "mo") {
				return localize23.ordinalNumber(date2.getMinutes(), { unit: "minute" });
			 }
			 return lightFormatters.m(date2, token);
		  },
		  // Second
		  s: function(date2, token, localize23) {
			 if (token === "so") {
				return localize23.ordinalNumber(date2.getSeconds(), { unit: "second" });
			 }
			 return lightFormatters.s(date2, token);
		  },
		  // Fraction of second
		  S: function(date2, token) {
			 return lightFormatters.S(date2, token);
		  },
		  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
		  X: function(date2, token, _localize) {
			 const timezoneOffset = date2.getTimezoneOffset();
			 if (timezoneOffset === 0) {
				return "Z";
			 }
			 switch (token) {
				case "X":
				  return formatTimezoneWithOptionalMinutes(timezoneOffset);
				case "XXXX":
				case "XX":
				  return formatTimezone(timezoneOffset);
				case "XXXXX":
				case "XXX":
				default:
				  return formatTimezone(timezoneOffset, ":");
			 }
		  },
		  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
		  x: function(date2, token, _localize) {
			 const timezoneOffset = date2.getTimezoneOffset();
			 switch (token) {
				case "x":
				  return formatTimezoneWithOptionalMinutes(timezoneOffset);
				case "xxxx":
				case "xx":
				  return formatTimezone(timezoneOffset);
				case "xxxxx":
				case "xxx":
				default:
				  return formatTimezone(timezoneOffset, ":");
			 }
		  },
		  // Timezone (GMT)
		  O: function(date2, token, _localize) {
			 const timezoneOffset = date2.getTimezoneOffset();
			 switch (token) {
				case "O":
				case "OO":
				case "OOO":
				  return "GMT" + formatTimezoneShort(timezoneOffset, ":");
				case "OOOO":
				default:
				  return "GMT" + formatTimezone(timezoneOffset, ":");
			 }
		  },
		  // Timezone (specific non-location)
		  z: function(date2, token, _localize) {
			 const timezoneOffset = date2.getTimezoneOffset();
			 switch (token) {
				case "z":
				case "zz":
				case "zzz":
				  return "GMT" + formatTimezoneShort(timezoneOffset, ":");
				case "zzzz":
				default:
				  return "GMT" + formatTimezone(timezoneOffset, ":");
			 }
		  },
		  // Seconds timestamp
		  t: function(date2, token, _localize) {
			 const timestamp = Math.trunc(date2.getTime() / 1e3);
			 return addLeadingZeros(timestamp, token.length);
		  },
		  // Milliseconds timestamp
		  T: function(date2, token, _localize) {
			 const timestamp = date2.getTime();
			 return addLeadingZeros(timestamp, token.length);
		  }
		};
		function formatTimezoneShort(offset, delimiter = "") {
		  const sign = offset > 0 ? "-" : "+";
		  const absOffset = Math.abs(offset);
		  const hours = Math.trunc(absOffset / 60);
		  const minutes = absOffset % 60;
		  if (minutes === 0) {
			 return sign + String(hours);
		  }
		  return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
		}
		function formatTimezoneWithOptionalMinutes(offset, delimiter) {
		  if (offset % 60 === 0) {
			 const sign = offset > 0 ? "-" : "+";
			 return sign + addLeadingZeros(Math.abs(offset) / 60, 2);
		  }
		  return formatTimezone(offset, delimiter);
		}
		function formatTimezone(offset, delimiter = "") {
		  const sign = offset > 0 ? "-" : "+";
		  const absOffset = Math.abs(offset);
		  const hours = addLeadingZeros(Math.trunc(absOffset / 60), 2);
		  const minutes = addLeadingZeros(absOffset % 60, 2);
		  return sign + hours + delimiter + minutes;
		}

		// node_modules/date-fns/_lib/format/longFormatters.mjs
		var dateLongFormatter = (pattern, formatLong26) => {
		  switch (pattern) {
			 case "P":
				return formatLong26.date({ width: "short" });
			 case "PP":
				return formatLong26.date({ width: "medium" });
			 case "PPP":
				return formatLong26.date({ width: "long" });
			 case "PPPP":
			 default:
				return formatLong26.date({ width: "full" });
		  }
		};
		var timeLongFormatter = (pattern, formatLong26) => {
		  switch (pattern) {
			 case "p":
				return formatLong26.time({ width: "short" });
			 case "pp":
				return formatLong26.time({ width: "medium" });
			 case "ppp":
				return formatLong26.time({ width: "long" });
			 case "pppp":
			 default:
				return formatLong26.time({ width: "full" });
		  }
		};
		var dateTimeLongFormatter = (pattern, formatLong26) => {
		  const matchResult = pattern.match(/(P+)(p+)?/) || [];
		  const datePattern = matchResult[1];
		  const timePattern = matchResult[2];
		  if (!timePattern) {
			 return dateLongFormatter(pattern, formatLong26);
		  }
		  let dateTimeFormat;
		  switch (datePattern) {
			 case "P":
				dateTimeFormat = formatLong26.dateTime({ width: "short" });
				break;
			 case "PP":
				dateTimeFormat = formatLong26.dateTime({ width: "medium" });
				break;
			 case "PPP":
				dateTimeFormat = formatLong26.dateTime({ width: "long" });
				break;
			 case "PPPP":
			 default:
				dateTimeFormat = formatLong26.dateTime({ width: "full" });
				break;
		  }
		  return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong26)).replace("{{time}}", timeLongFormatter(timePattern, formatLong26));
		};
		var longFormatters = {
		  p: timeLongFormatter,
		  P: dateTimeLongFormatter
		};

		// node_modules/date-fns/_lib/protectedTokens.mjs
		var dayOfYearTokenRE = /^D+$/;
		var weekYearTokenRE = /^Y+$/;
		var throwTokens = ["D", "DD", "YY", "YYYY"];
		function isProtectedDayOfYearToken(token) {
		  return dayOfYearTokenRE.test(token);
		}
		function isProtectedWeekYearToken(token) {
		  return weekYearTokenRE.test(token);
		}
		function warnOrThrowProtectedError(token, format2, input2) {
		  const _message = message(token, format2, input2);
		  console.warn(_message);
		  if (throwTokens.includes(token))
			 throw new RangeError(_message);
		}
		function message(token, format2, input2) {
		  const subject = token[0] === "Y" ? "years" : "days of the month";
		  return `Use \`${token.toLowerCase()}\` instead of \`${token}\` (in \`${format2}\`) for formatting ${subject} to the input \`${input2}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;
		}

		// node_modules/date-fns/format.mjs
		var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
		var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
		var escapedStringRegExp = /^'([^]*?)'?$/;
		var doubleQuoteRegExp = /''/g;
		var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
		function format(date2, formatStr, options) {
		  const defaultOptions2 = getDefaultOptions();
		  const locale2 = options?.locale ?? defaultOptions2.locale ?? enUS;
		  const firstWeekContainsDate = options?.firstWeekContainsDate ?? options?.locale?.options?.firstWeekContainsDate ?? defaultOptions2.firstWeekContainsDate ?? defaultOptions2.locale?.options?.firstWeekContainsDate ?? 1;
		  const weekStartsOn = options?.weekStartsOn ?? options?.locale?.options?.weekStartsOn ?? defaultOptions2.weekStartsOn ?? defaultOptions2.locale?.options?.weekStartsOn ?? 0;
		  const originalDate = toDate2(date2);
		  if (!isValid(originalDate)) {
			 throw new RangeError("Invalid time value");
		  }
		  let parts = formatStr.match(longFormattingTokensRegExp).map((substring) => {
			 const firstCharacter = substring[0];
			 if (firstCharacter === "p" || firstCharacter === "P") {
				const longFormatter = longFormatters[firstCharacter];
				return longFormatter(substring, locale2.formatLong);
			 }
			 return substring;
		  }).join("").match(formattingTokensRegExp).map((substring) => {
			 if (substring === "''") {
				return { isToken: false, value: "'" };
			 }
			 const firstCharacter = substring[0];
			 if (firstCharacter === "'") {
				return { isToken: false, value: cleanEscapedString(substring) };
			 }
			 if (formatters[firstCharacter]) {
				return { isToken: true, value: substring };
			 }
			 if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
				throw new RangeError(
				  "Format string contains an unescaped latin alphabet character `" + firstCharacter + "`"
				);
			 }
			 return { isToken: false, value: substring };
		  });
		  if (locale2.localize.preprocessor) {
			 parts = locale2.localize.preprocessor(originalDate, parts);
		  }
		  const formatterOptions = {
			 firstWeekContainsDate,
			 weekStartsOn,
			 locale: locale2
		  };
		  return parts.map((part) => {
			 if (!part.isToken)
				return part.value;
			 const token = part.value;
			 if (!options?.useAdditionalWeekYearTokens && isProtectedWeekYearToken(token) || !options?.useAdditionalDayOfYearTokens && isProtectedDayOfYearToken(token)) {
				warnOrThrowProtectedError(token, formatStr, String(date2));
			 }
			 const formatter = formatters[token[0]];
			 return formatter(originalDate, token, locale2.localize, formatterOptions);
		  }).join("");
		}
		function cleanEscapedString(input2) {
		  const matched = input2.match(escapedStringRegExp);
		  if (!matched) {
			 return input2;
		  }
		  return matched[1].replace(doubleQuoteRegExp, "'");
		}

		// node_modules/date-fns/getDay.mjs
		function getDay(date2) {
		  const _date = toDate2(date2);
		  const day = _date.getDay();
		  return day;
		}

		// node_modules/date-fns/getDaysInMonth.mjs
		function getDaysInMonth(date2) {
		  const _date = toDate2(date2);
		  const year = _date.getFullYear();
		  const monthIndex = _date.getMonth();
		  const lastDayOfMonth = constructFrom(date2, 0);
		  lastDayOfMonth.setFullYear(year, monthIndex + 1, 0);
		  lastDayOfMonth.setHours(0, 0, 0, 0);
		  return lastDayOfMonth.getDate();
		}

		// node_modules/date-fns/getDefaultOptions.mjs
		function getDefaultOptions2() {
		  return Object.assign({}, getDefaultOptions());
		}

		// node_modules/date-fns/getHours.mjs
		function getHours(date2) {
		  const _date = toDate2(date2);
		  const hours = _date.getHours();
		  return hours;
		}

		// node_modules/date-fns/getISODay.mjs
		function getISODay(date2) {
		  const _date = toDate2(date2);
		  let day = _date.getDay();
		  if (day === 0) {
			 day = 7;
		  }
		  return day;
		}

		// node_modules/date-fns/getMilliseconds.mjs
		function getMilliseconds(date2) {
		  const _date = toDate2(date2);
		  const milliseconds2 = _date.getMilliseconds();
		  return milliseconds2;
		}

		// node_modules/date-fns/getMinutes.mjs
		function getMinutes(date2) {
		  const _date = toDate2(date2);
		  const minutes = _date.getMinutes();
		  return minutes;
		}

		// node_modules/date-fns/getMonth.mjs
		function getMonth(date2) {
		  const _date = toDate2(date2);
		  const month = _date.getMonth();
		  return month;
		}

		// node_modules/date-fns/getSeconds.mjs
		function getSeconds(date2) {
		  const _date = toDate2(date2);
		  const seconds2 = _date.getSeconds();
		  return seconds2;
		}

		// node_modules/date-fns/getYear.mjs
		function getYear(date2) {
		  return toDate2(date2).getFullYear();
		}

		// node_modules/date-fns/intervalToDuration.mjs
		function intervalToDuration(interval2) {
		  const start2 = toDate2(interval2.start);
		  const end = toDate2(interval2.end);
		  const duration = {};
		  const years = differenceInYears(end, start2);
		  if (years)
			 duration.years = years;
		  const remainingMonths = add(start2, { years: duration.years });
		  const months = differenceInMonths(end, remainingMonths);
		  if (months)
			 duration.months = months;
		  const remainingDays = add(remainingMonths, { months: duration.months });
		  const days = differenceInDays(end, remainingDays);
		  if (days)
			 duration.days = days;
		  const remainingHours = add(remainingDays, { days: duration.days });
		  const hours = differenceInHours(end, remainingHours);
		  if (hours)
			 duration.hours = hours;
		  const remainingMinutes = add(remainingHours, { hours: duration.hours });
		  const minutes = differenceInMinutes(end, remainingMinutes);
		  if (minutes)
			 duration.minutes = minutes;
		  const remainingSeconds = add(remainingMinutes, { minutes: duration.minutes });
		  const seconds2 = differenceInSeconds(end, remainingSeconds);
		  if (seconds2)
			 duration.seconds = seconds2;
		  return duration;
		}

		// node_modules/date-fns/isAfter.mjs
		function isAfter(date2, dateToCompare) {
		  const _date = toDate2(date2);
		  const _dateToCompare = toDate2(dateToCompare);
		  return _date.getTime() > _dateToCompare.getTime();
		}

		// node_modules/date-fns/isBefore.mjs
		function isBefore(date2, dateToCompare) {
		  const _date = toDate2(date2);
		  const _dateToCompare = toDate2(dateToCompare);
		  return +_date < +_dateToCompare;
		}

		// node_modules/date-fns/transpose.mjs
		function transpose(fromDate, constructor) {
		  const date2 = constructor instanceof Date ? constructFrom(constructor, 0) : new constructor(0);
		  date2.setFullYear(
			 fromDate.getFullYear(),
			 fromDate.getMonth(),
			 fromDate.getDate()
		  );
		  date2.setHours(
			 fromDate.getHours(),
			 fromDate.getMinutes(),
			 fromDate.getSeconds(),
			 fromDate.getMilliseconds()
		  );
		  return date2;
		}

		// node_modules/date-fns/parse/_lib/Setter.mjs
		var TIMEZONE_UNIT_PRIORITY = 10;
		var Setter = class {
		  subPriority = 0;
		  validate(_utcDate, _options) {
			 return true;
		  }
		};
		var ValueSetter = class extends Setter {
		  constructor(value, validateValue, setValue, priority, subPriority) {
			 super();
			 this.value = value;
			 this.validateValue = validateValue;
			 this.setValue = setValue;
			 this.priority = priority;
			 if (subPriority) {
				this.subPriority = subPriority;
			 }
		  }
		  validate(date2, options) {
			 return this.validateValue(date2, this.value, options);
		  }
		  set(date2, flags, options) {
			 return this.setValue(date2, flags, this.value, options);
		  }
		};
		var DateToSystemTimezoneSetter = class extends Setter {
		  priority = TIMEZONE_UNIT_PRIORITY;
		  subPriority = -1;
		  set(date2, flags) {
			 if (flags.timestampIsSet)
				return date2;
			 return constructFrom(date2, transpose(date2, Date));
		  }
		};

		// node_modules/date-fns/parse/_lib/Parser.mjs
		var Parser = class {
		  run(dateString, token, match23, options) {
			 const result = this.parse(dateString, token, match23, options);
			 if (!result) {
				return null;
			 }
			 return {
				setter: new ValueSetter(
				  result.value,
				  this.validate,
				  this.set,
				  this.priority,
				  this.subPriority
				),
				rest: result.rest
			 };
		  }
		  validate(_utcDate, _value, _options) {
			 return true;
		  }
		};

		// node_modules/date-fns/parse/_lib/parsers/EraParser.mjs
		var EraParser = class extends Parser {
		  priority = 140;
		  parse(dateString, token, match23) {
			 switch (token) {
				case "G":
				case "GG":
				case "GGG":
				  return match23.era(dateString, { width: "abbreviated" }) || match23.era(dateString, { width: "narrow" });
				case "GGGGG":
				  return match23.era(dateString, { width: "narrow" });
				case "GGGG":
				default:
				  return match23.era(dateString, { width: "wide" }) || match23.era(dateString, { width: "abbreviated" }) || match23.era(dateString, { width: "narrow" });
			 }
		  }
		  set(date2, flags, value) {
			 flags.era = value;
			 date2.setFullYear(value, 0, 1);
			 date2.setHours(0, 0, 0, 0);
			 return date2;
		  }
		  incompatibleTokens = ["R", "u", "t", "T"];
		};

		// node_modules/date-fns/parse/_lib/constants.mjs
		var numericPatterns = {
		  month: /^(1[0-2]|0?\d)/,
		  // 0 to 12
		  date: /^(3[0-1]|[0-2]?\d)/,
		  // 0 to 31
		  dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
		  // 0 to 366
		  week: /^(5[0-3]|[0-4]?\d)/,
		  // 0 to 53
		  hour23h: /^(2[0-3]|[0-1]?\d)/,
		  // 0 to 23
		  hour24h: /^(2[0-4]|[0-1]?\d)/,
		  // 0 to 24
		  hour11h: /^(1[0-1]|0?\d)/,
		  // 0 to 11
		  hour12h: /^(1[0-2]|0?\d)/,
		  // 0 to 12
		  minute: /^[0-5]?\d/,
		  // 0 to 59
		  second: /^[0-5]?\d/,
		  // 0 to 59
		  singleDigit: /^\d/,
		  // 0 to 9
		  twoDigits: /^\d{1,2}/,
		  // 0 to 99
		  threeDigits: /^\d{1,3}/,
		  // 0 to 999
		  fourDigits: /^\d{1,4}/,
		  // 0 to 9999
		  anyDigitsSigned: /^-?\d+/,
		  singleDigitSigned: /^-?\d/,
		  // 0 to 9, -0 to -9
		  twoDigitsSigned: /^-?\d{1,2}/,
		  // 0 to 99, -0 to -99
		  threeDigitsSigned: /^-?\d{1,3}/,
		  // 0 to 999, -0 to -999
		  fourDigitsSigned: /^-?\d{1,4}/
		  // 0 to 9999, -0 to -9999
		};
		var timezonePatterns = {
		  basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
		  basic: /^([+-])(\d{2})(\d{2})|Z/,
		  basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
		  extended: /^([+-])(\d{2}):(\d{2})|Z/,
		  extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
		};

		// node_modules/date-fns/parse/_lib/utils.mjs
		function mapValue(parseFnResult, mapFn) {
		  if (!parseFnResult) {
			 return parseFnResult;
		  }
		  return {
			 value: mapFn(parseFnResult.value),
			 rest: parseFnResult.rest
		  };
		}
		function parseNumericPattern(pattern, dateString) {
		  const matchResult = dateString.match(pattern);
		  if (!matchResult) {
			 return null;
		  }
		  return {
			 value: parseInt(matchResult[0], 10),
			 rest: dateString.slice(matchResult[0].length)
		  };
		}
		function parseTimezonePattern(pattern, dateString) {
		  const matchResult = dateString.match(pattern);
		  if (!matchResult) {
			 return null;
		  }
		  if (matchResult[0] === "Z") {
			 return {
				value: 0,
				rest: dateString.slice(1)
			 };
		  }
		  const sign = matchResult[1] === "+" ? 1 : -1;
		  const hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
		  const minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
		  const seconds2 = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
		  return {
			 value: sign * (hours * millisecondsInHour + minutes * millisecondsInMinute + seconds2 * millisecondsInSecond),
			 rest: dateString.slice(matchResult[0].length)
		  };
		}
		function parseAnyDigitsSigned(dateString) {
		  return parseNumericPattern(numericPatterns.anyDigitsSigned, dateString);
		}
		function parseNDigits(n, dateString) {
		  switch (n) {
			 case 1:
				return parseNumericPattern(numericPatterns.singleDigit, dateString);
			 case 2:
				return parseNumericPattern(numericPatterns.twoDigits, dateString);
			 case 3:
				return parseNumericPattern(numericPatterns.threeDigits, dateString);
			 case 4:
				return parseNumericPattern(numericPatterns.fourDigits, dateString);
			 default:
				return parseNumericPattern(new RegExp("^\\d{1," + n + "}"), dateString);
		  }
		}
		function parseNDigitsSigned(n, dateString) {
		  switch (n) {
			 case 1:
				return parseNumericPattern(numericPatterns.singleDigitSigned, dateString);
			 case 2:
				return parseNumericPattern(numericPatterns.twoDigitsSigned, dateString);
			 case 3:
				return parseNumericPattern(numericPatterns.threeDigitsSigned, dateString);
			 case 4:
				return parseNumericPattern(numericPatterns.fourDigitsSigned, dateString);
			 default:
				return parseNumericPattern(new RegExp("^-?\\d{1," + n + "}"), dateString);
		  }
		}
		function dayPeriodEnumToHours(dayPeriod) {
		  switch (dayPeriod) {
			 case "morning":
				return 4;
			 case "evening":
				return 17;
			 case "pm":
			 case "noon":
			 case "afternoon":
				return 12;
			 case "am":
			 case "midnight":
			 case "night":
			 default:
				return 0;
		  }
		}
		function normalizeTwoDigitYear(twoDigitYear, currentYear) {
		  const isCommonEra = currentYear > 0;
		  const absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
		  let result;
		  if (absCurrentYear <= 50) {
			 result = twoDigitYear || 100;
		  } else {
			 const rangeEnd = absCurrentYear + 50;
			 const rangeEndCentury = Math.trunc(rangeEnd / 100) * 100;
			 const isPreviousCentury = twoDigitYear >= rangeEnd % 100;
			 result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
		  }
		  return isCommonEra ? result : 1 - result;
		}
		function isLeapYearIndex(year) {
		  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
		}

		// node_modules/date-fns/parse/_lib/parsers/YearParser.mjs
		var YearParser = class extends Parser {
		  priority = 130;
		  incompatibleTokens = ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"];
		  parse(dateString, token, match23) {
			 const valueCallback = (year) => ({
				year,
				isTwoDigitYear: token === "yy"
			 });
			 switch (token) {
				case "y":
				  return mapValue(parseNDigits(4, dateString), valueCallback);
				case "yo":
				  return mapValue(
					 match23.ordinalNumber(dateString, {
						unit: "year"
					 }),
					 valueCallback
				  );
				default:
				  return mapValue(parseNDigits(token.length, dateString), valueCallback);
			 }
		  }
		  validate(_date, value) {
			 return value.isTwoDigitYear || value.year > 0;
		  }
		  set(date2, flags, value) {
			 const currentYear = date2.getFullYear();
			 if (value.isTwoDigitYear) {
				const normalizedTwoDigitYear = normalizeTwoDigitYear(
				  value.year,
				  currentYear
				);
				date2.setFullYear(normalizedTwoDigitYear, 0, 1);
				date2.setHours(0, 0, 0, 0);
				return date2;
			 }
			 const year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
			 date2.setFullYear(year, 0, 1);
			 date2.setHours(0, 0, 0, 0);
			 return date2;
		  }
		};

		// node_modules/date-fns/parse/_lib/parsers/LocalWeekYearParser.mjs
		var LocalWeekYearParser = class extends Parser {
		  priority = 130;
		  parse(dateString, token, match23) {
			 const valueCallback = (year) => ({
				year,
				isTwoDigitYear: token === "YY"
			 });
			 switch (token) {
				case "Y":
				  return mapValue(parseNDigits(4, dateString), valueCallback);
				case "Yo":
				  return mapValue(
					 match23.ordinalNumber(dateString, {
						unit: "year"
					 }),
					 valueCallback
				  );
				default:
				  return mapValue(parseNDigits(token.length, dateString), valueCallback);
			 }
		  }
		  validate(_date, value) {
			 return value.isTwoDigitYear || value.year > 0;
		  }
		  set(date2, flags, value, options) {
			 const currentYear = getWeekYear(date2, options);
			 if (value.isTwoDigitYear) {
				const normalizedTwoDigitYear = normalizeTwoDigitYear(
				  value.year,
				  currentYear
				);
				date2.setFullYear(
				  normalizedTwoDigitYear,
				  0,
				  options.firstWeekContainsDate
				);
				date2.setHours(0, 0, 0, 0);
				return startOfWeek(date2, options);
			 }
			 const year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
			 date2.setFullYear(year, 0, options.firstWeekContainsDate);
			 date2.setHours(0, 0, 0, 0);
			 return startOfWeek(date2, options);
		  }
		  incompatibleTokens = [
			 "y",
			 "R",
			 "u",
			 "Q",
			 "q",
			 "M",
			 "L",
			 "I",
			 "d",
			 "D",
			 "i",
			 "t",
			 "T"
		  ];
		};

		// node_modules/date-fns/parse/_lib/parsers/ISOWeekYearParser.mjs
		var ISOWeekYearParser = class extends Parser {
		  priority = 130;
		  parse(dateString, token) {
			 if (token === "R") {
				return parseNDigitsSigned(4, dateString);
			 }
			 return parseNDigitsSigned(token.length, dateString);
		  }
		  set(date2, _flags, value) {
			 const firstWeekOfYear = constructFrom(date2, 0);
			 firstWeekOfYear.setFullYear(value, 0, 4);
			 firstWeekOfYear.setHours(0, 0, 0, 0);
			 return startOfISOWeek(firstWeekOfYear);
		  }
		  incompatibleTokens = [
			 "G",
			 "y",
			 "Y",
			 "u",
			 "Q",
			 "q",
			 "M",
			 "L",
			 "w",
			 "d",
			 "D",
			 "e",
			 "c",
			 "t",
			 "T"
		  ];
		};

		// node_modules/date-fns/parse/_lib/parsers/ExtendedYearParser.mjs
		var ExtendedYearParser = class extends Parser {
		  priority = 130;
		  parse(dateString, token) {
			 if (token === "u") {
				return parseNDigitsSigned(4, dateString);
			 }
			 return parseNDigitsSigned(token.length, dateString);
		  }
		  set(date2, _flags, value) {
			 date2.setFullYear(value, 0, 1);
			 date2.setHours(0, 0, 0, 0);
			 return date2;
		  }
		  incompatibleTokens = ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"];
		};

		// node_modules/date-fns/parse/_lib/parsers/QuarterParser.mjs
		var QuarterParser = class extends Parser {
		  priority = 120;
		  parse(dateString, token, match23) {
			 switch (token) {
				case "Q":
				case "QQ":
				  return parseNDigits(token.length, dateString);
				case "Qo":
				  return match23.ordinalNumber(dateString, { unit: "quarter" });
				case "QQQ":
				  return match23.quarter(dateString, {
					 width: "abbreviated",
					 context: "formatting"
				  }) || match23.quarter(dateString, {
					 width: "narrow",
					 context: "formatting"
				  });
				case "QQQQQ":
				  return match23.quarter(dateString, {
					 width: "narrow",
					 context: "formatting"
				  });
				case "QQQQ":
				default:
				  return match23.quarter(dateString, {
					 width: "wide",
					 context: "formatting"
				  }) || match23.quarter(dateString, {
					 width: "abbreviated",
					 context: "formatting"
				  }) || match23.quarter(dateString, {
					 width: "narrow",
					 context: "formatting"
				  });
			 }
		  }
		  validate(_date, value) {
			 return value >= 1 && value <= 4;
		  }
		  set(date2, _flags, value) {
			 date2.setMonth((value - 1) * 3, 1);
			 date2.setHours(0, 0, 0, 0);
			 return date2;
		  }
		  incompatibleTokens = [
			 "Y",
			 "R",
			 "q",
			 "M",
			 "L",
			 "w",
			 "I",
			 "d",
			 "D",
			 "i",
			 "e",
			 "c",
			 "t",
			 "T"
		  ];
		};

		// node_modules/date-fns/parse/_lib/parsers/StandAloneQuarterParser.mjs
		var StandAloneQuarterParser = class extends Parser {
		  priority = 120;
		  parse(dateString, token, match23) {
			 switch (token) {
				case "q":
				case "qq":
				  return parseNDigits(token.length, dateString);
				case "qo":
				  return match23.ordinalNumber(dateString, { unit: "quarter" });
				case "qqq":
				  return match23.quarter(dateString, {
					 width: "abbreviated",
					 context: "standalone"
				  }) || match23.quarter(dateString, {
					 width: "narrow",
					 context: "standalone"
				  });
				case "qqqqq":
				  return match23.quarter(dateString, {
					 width: "narrow",
					 context: "standalone"
				  });
				case "qqqq":
				default:
				  return match23.quarter(dateString, {
					 width: "wide",
					 context: "standalone"
				  }) || match23.quarter(dateString, {
					 width: "abbreviated",
					 context: "standalone"
				  }) || match23.quarter(dateString, {
					 width: "narrow",
					 context: "standalone"
				  });
			 }
		  }
		  validate(_date, value) {
			 return value >= 1 && value <= 4;
		  }
		  set(date2, _flags, value) {
			 date2.setMonth((value - 1) * 3, 1);
			 date2.setHours(0, 0, 0, 0);
			 return date2;
		  }
		  incompatibleTokens = [
			 "Y",
			 "R",
			 "Q",
			 "M",
			 "L",
			 "w",
			 "I",
			 "d",
			 "D",
			 "i",
			 "e",
			 "c",
			 "t",
			 "T"
		  ];
		};

		// node_modules/date-fns/parse/_lib/parsers/MonthParser.mjs
		var MonthParser = class extends Parser {
		  incompatibleTokens = [
			 "Y",
			 "R",
			 "q",
			 "Q",
			 "L",
			 "w",
			 "I",
			 "D",
			 "i",
			 "e",
			 "c",
			 "t",
			 "T"
		  ];
		  priority = 110;
		  parse(dateString, token, match23) {
			 const valueCallback = (value) => value - 1;
			 switch (token) {
				case "M":
				  return mapValue(
					 parseNumericPattern(numericPatterns.month, dateString),
					 valueCallback
				  );
				case "MM":
				  return mapValue(parseNDigits(2, dateString), valueCallback);
				case "Mo":
				  return mapValue(
					 match23.ordinalNumber(dateString, {
						unit: "month"
					 }),
					 valueCallback
				  );
				case "MMM":
				  return match23.month(dateString, {
					 width: "abbreviated",
					 context: "formatting"
				  }) || match23.month(dateString, { width: "narrow", context: "formatting" });
				case "MMMMM":
				  return match23.month(dateString, {
					 width: "narrow",
					 context: "formatting"
				  });
				case "MMMM":
				default:
				  return match23.month(dateString, { width: "wide", context: "formatting" }) || match23.month(dateString, {
					 width: "abbreviated",
					 context: "formatting"
				  }) || match23.month(dateString, { width: "narrow", context: "formatting" });
			 }
		  }
		  validate(_date, value) {
			 return value >= 0 && value <= 11;
		  }
		  set(date2, _flags, value) {
			 date2.setMonth(value, 1);
			 date2.setHours(0, 0, 0, 0);
			 return date2;
		  }
		};

		// node_modules/date-fns/parse/_lib/parsers/StandAloneMonthParser.mjs
		var StandAloneMonthParser = class extends Parser {
		  priority = 110;
		  parse(dateString, token, match23) {
			 const valueCallback = (value) => value - 1;
			 switch (token) {
				case "L":
				  return mapValue(
					 parseNumericPattern(numericPatterns.month, dateString),
					 valueCallback
				  );
				case "LL":
				  return mapValue(parseNDigits(2, dateString), valueCallback);
				case "Lo":
				  return mapValue(
					 match23.ordinalNumber(dateString, {
						unit: "month"
					 }),
					 valueCallback
				  );
				case "LLL":
				  return match23.month(dateString, {
					 width: "abbreviated",
					 context: "standalone"
				  }) || match23.month(dateString, { width: "narrow", context: "standalone" });
				case "LLLLL":
				  return match23.month(dateString, {
					 width: "narrow",
					 context: "standalone"
				  });
				case "LLLL":
				default:
				  return match23.month(dateString, { width: "wide", context: "standalone" }) || match23.month(dateString, {
					 width: "abbreviated",
					 context: "standalone"
				  }) || match23.month(dateString, { width: "narrow", context: "standalone" });
			 }
		  }
		  validate(_date, value) {
			 return value >= 0 && value <= 11;
		  }
		  set(date2, _flags, value) {
			 date2.setMonth(value, 1);
			 date2.setHours(0, 0, 0, 0);
			 return date2;
		  }
		  incompatibleTokens = [
			 "Y",
			 "R",
			 "q",
			 "Q",
			 "M",
			 "w",
			 "I",
			 "D",
			 "i",
			 "e",
			 "c",
			 "t",
			 "T"
		  ];
		};

		// node_modules/date-fns/setWeek.mjs
		function setWeek(date2, week, options) {
		  const _date = toDate2(date2);
		  const diff = getWeek(_date, options) - week;
		  _date.setDate(_date.getDate() - diff * 7);
		  return _date;
		}

		// node_modules/date-fns/parse/_lib/parsers/LocalWeekParser.mjs
		var LocalWeekParser = class extends Parser {
		  priority = 100;
		  parse(dateString, token, match23) {
			 switch (token) {
				case "w":
				  return parseNumericPattern(numericPatterns.week, dateString);
				case "wo":
				  return match23.ordinalNumber(dateString, { unit: "week" });
				default:
				  return parseNDigits(token.length, dateString);
			 }
		  }
		  validate(_date, value) {
			 return value >= 1 && value <= 53;
		  }
		  set(date2, _flags, value, options) {
			 return startOfWeek(setWeek(date2, value, options), options);
		  }
		  incompatibleTokens = [
			 "y",
			 "R",
			 "u",
			 "q",
			 "Q",
			 "M",
			 "L",
			 "I",
			 "d",
			 "D",
			 "i",
			 "t",
			 "T"
		  ];
		};

		// node_modules/date-fns/setISOWeek.mjs
		function setISOWeek(date2, week) {
		  const _date = toDate2(date2);
		  const diff = getISOWeek(_date) - week;
		  _date.setDate(_date.getDate() - diff * 7);
		  return _date;
		}

		// node_modules/date-fns/parse/_lib/parsers/ISOWeekParser.mjs
		var ISOWeekParser = class extends Parser {
		  priority = 100;
		  parse(dateString, token, match23) {
			 switch (token) {
				case "I":
				  return parseNumericPattern(numericPatterns.week, dateString);
				case "Io":
				  return match23.ordinalNumber(dateString, { unit: "week" });
				default:
				  return parseNDigits(token.length, dateString);
			 }
		  }
		  validate(_date, value) {
			 return value >= 1 && value <= 53;
		  }
		  set(date2, _flags, value) {
			 return startOfISOWeek(setISOWeek(date2, value));
		  }
		  incompatibleTokens = [
			 "y",
			 "Y",
			 "u",
			 "q",
			 "Q",
			 "M",
			 "L",
			 "w",
			 "d",
			 "D",
			 "e",
			 "c",
			 "t",
			 "T"
		  ];
		};

		// node_modules/date-fns/parse/_lib/parsers/DateParser.mjs
		var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
		var DAYS_IN_MONTH_LEAP_YEAR = [
		  31,
		  29,
		  31,
		  30,
		  31,
		  30,
		  31,
		  31,
		  30,
		  31,
		  30,
		  31
		];
		var DateParser = class extends Parser {
		  priority = 90;
		  subPriority = 1;
		  parse(dateString, token, match23) {
			 switch (token) {
				case "d":
				  return parseNumericPattern(numericPatterns.date, dateString);
				case "do":
				  return match23.ordinalNumber(dateString, { unit: "date" });
				default:
				  return parseNDigits(token.length, dateString);
			 }
		  }
		  validate(date2, value) {
			 const year = date2.getFullYear();
			 const isLeapYear = isLeapYearIndex(year);
			 const month = date2.getMonth();
			 if (isLeapYear) {
				return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
			 } else {
				return value >= 1 && value <= DAYS_IN_MONTH[month];
			 }
		  }
		  set(date2, _flags, value) {
			 date2.setDate(value);
			 date2.setHours(0, 0, 0, 0);
			 return date2;
		  }
		  incompatibleTokens = [
			 "Y",
			 "R",
			 "q",
			 "Q",
			 "w",
			 "I",
			 "D",
			 "i",
			 "e",
			 "c",
			 "t",
			 "T"
		  ];
		};

		// node_modules/date-fns/parse/_lib/parsers/DayOfYearParser.mjs
		var DayOfYearParser = class extends Parser {
		  priority = 90;
		  subpriority = 1;
		  parse(dateString, token, match23) {
			 switch (token) {
				case "D":
				case "DD":
				  return parseNumericPattern(numericPatterns.dayOfYear, dateString);
				case "Do":
				  return match23.ordinalNumber(dateString, { unit: "date" });
				default:
				  return parseNDigits(token.length, dateString);
			 }
		  }
		  validate(date2, value) {
			 const year = date2.getFullYear();
			 const isLeapYear = isLeapYearIndex(year);
			 if (isLeapYear) {
				return value >= 1 && value <= 366;
			 } else {
				return value >= 1 && value <= 365;
			 }
		  }
		  set(date2, _flags, value) {
			 date2.setMonth(0, value);
			 date2.setHours(0, 0, 0, 0);
			 return date2;
		  }
		  incompatibleTokens = [
			 "Y",
			 "R",
			 "q",
			 "Q",
			 "M",
			 "L",
			 "w",
			 "I",
			 "d",
			 "E",
			 "i",
			 "e",
			 "c",
			 "t",
			 "T"
		  ];
		};

		// node_modules/date-fns/setDay.mjs
		function setDay(date2, day, options) {
		  const defaultOptions2 = getDefaultOptions();
		  const weekStartsOn = options?.weekStartsOn ?? options?.locale?.options?.weekStartsOn ?? defaultOptions2.weekStartsOn ?? defaultOptions2.locale?.options?.weekStartsOn ?? 0;
		  const _date = toDate2(date2);
		  const currentDay = _date.getDay();
		  const remainder = day % 7;
		  const dayIndex = (remainder + 7) % 7;
		  const delta = 7 - weekStartsOn;
		  const diff = day < 0 || day > 6 ? day - (currentDay + delta) % 7 : (dayIndex + delta) % 7 - (currentDay + delta) % 7;
		  return addDays(_date, diff);
		}

		// node_modules/date-fns/parse/_lib/parsers/DayParser.mjs
		var DayParser = class extends Parser {
		  priority = 90;
		  parse(dateString, token, match23) {
			 switch (token) {
				case "E":
				case "EE":
				case "EEE":
				  return match23.day(dateString, {
					 width: "abbreviated",
					 context: "formatting"
				  }) || match23.day(dateString, { width: "short", context: "formatting" }) || match23.day(dateString, { width: "narrow", context: "formatting" });
				case "EEEEE":
				  return match23.day(dateString, {
					 width: "narrow",
					 context: "formatting"
				  });
				case "EEEEEE":
				  return match23.day(dateString, { width: "short", context: "formatting" }) || match23.day(dateString, { width: "narrow", context: "formatting" });
				case "EEEE":
				default:
				  return match23.day(dateString, { width: "wide", context: "formatting" }) || match23.day(dateString, {
					 width: "abbreviated",
					 context: "formatting"
				  }) || match23.day(dateString, { width: "short", context: "formatting" }) || match23.day(dateString, { width: "narrow", context: "formatting" });
			 }
		  }
		  validate(_date, value) {
			 return value >= 0 && value <= 6;
		  }
		  set(date2, _flags, value, options) {
			 date2 = setDay(date2, value, options);
			 date2.setHours(0, 0, 0, 0);
			 return date2;
		  }
		  incompatibleTokens = ["D", "i", "e", "c", "t", "T"];
		};

		// node_modules/date-fns/parse/_lib/parsers/LocalDayParser.mjs
		var LocalDayParser = class extends Parser {
		  priority = 90;
		  parse(dateString, token, match23, options) {
			 const valueCallback = (value) => {
				const wholeWeekDays = Math.floor((value - 1) / 7) * 7;
				return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
			 };
			 switch (token) {
				case "e":
				case "ee":
				  return mapValue(parseNDigits(token.length, dateString), valueCallback);
				case "eo":
				  return mapValue(
					 match23.ordinalNumber(dateString, {
						unit: "day"
					 }),
					 valueCallback
				  );
				case "eee":
				  return match23.day(dateString, {
					 width: "abbreviated",
					 context: "formatting"
				  }) || match23.day(dateString, { width: "short", context: "formatting" }) || match23.day(dateString, { width: "narrow", context: "formatting" });
				case "eeeee":
				  return match23.day(dateString, {
					 width: "narrow",
					 context: "formatting"
				  });
				case "eeeeee":
				  return match23.day(dateString, { width: "short", context: "formatting" }) || match23.day(dateString, { width: "narrow", context: "formatting" });
				case "eeee":
				default:
				  return match23.day(dateString, { width: "wide", context: "formatting" }) || match23.day(dateString, {
					 width: "abbreviated",
					 context: "formatting"
				  }) || match23.day(dateString, { width: "short", context: "formatting" }) || match23.day(dateString, { width: "narrow", context: "formatting" });
			 }
		  }
		  validate(_date, value) {
			 return value >= 0 && value <= 6;
		  }
		  set(date2, _flags, value, options) {
			 date2 = setDay(date2, value, options);
			 date2.setHours(0, 0, 0, 0);
			 return date2;
		  }
		  incompatibleTokens = [
			 "y",
			 "R",
			 "u",
			 "q",
			 "Q",
			 "M",
			 "L",
			 "I",
			 "d",
			 "D",
			 "E",
			 "i",
			 "c",
			 "t",
			 "T"
		  ];
		};

		// node_modules/date-fns/parse/_lib/parsers/StandAloneLocalDayParser.mjs
		var StandAloneLocalDayParser = class extends Parser {
		  priority = 90;
		  parse(dateString, token, match23, options) {
			 const valueCallback = (value) => {
				const wholeWeekDays = Math.floor((value - 1) / 7) * 7;
				return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
			 };
			 switch (token) {
				case "c":
				case "cc":
				  return mapValue(parseNDigits(token.length, dateString), valueCallback);
				case "co":
				  return mapValue(
					 match23.ordinalNumber(dateString, {
						unit: "day"
					 }),
					 valueCallback
				  );
				case "ccc":
				  return match23.day(dateString, {
					 width: "abbreviated",
					 context: "standalone"
				  }) || match23.day(dateString, { width: "short", context: "standalone" }) || match23.day(dateString, { width: "narrow", context: "standalone" });
				case "ccccc":
				  return match23.day(dateString, {
					 width: "narrow",
					 context: "standalone"
				  });
				case "cccccc":
				  return match23.day(dateString, { width: "short", context: "standalone" }) || match23.day(dateString, { width: "narrow", context: "standalone" });
				case "cccc":
				default:
				  return match23.day(dateString, { width: "wide", context: "standalone" }) || match23.day(dateString, {
					 width: "abbreviated",
					 context: "standalone"
				  }) || match23.day(dateString, { width: "short", context: "standalone" }) || match23.day(dateString, { width: "narrow", context: "standalone" });
			 }
		  }
		  validate(_date, value) {
			 return value >= 0 && value <= 6;
		  }
		  set(date2, _flags, value, options) {
			 date2 = setDay(date2, value, options);
			 date2.setHours(0, 0, 0, 0);
			 return date2;
		  }
		  incompatibleTokens = [
			 "y",
			 "R",
			 "u",
			 "q",
			 "Q",
			 "M",
			 "L",
			 "I",
			 "d",
			 "D",
			 "E",
			 "i",
			 "e",
			 "t",
			 "T"
		  ];
		};

		// node_modules/date-fns/setISODay.mjs
		function setISODay(date2, day) {
		  const _date = toDate2(date2);
		  const currentDay = getISODay(_date);
		  const diff = day - currentDay;
		  return addDays(_date, diff);
		}

		// node_modules/date-fns/parse/_lib/parsers/ISODayParser.mjs
		var ISODayParser = class extends Parser {
		  priority = 90;
		  parse(dateString, token, match23) {
			 const valueCallback = (value) => {
				if (value === 0) {
				  return 7;
				}
				return value;
			 };
			 switch (token) {
				case "i":
				case "ii":
				  return parseNDigits(token.length, dateString);
				case "io":
				  return match23.ordinalNumber(dateString, { unit: "day" });
				case "iii":
				  return mapValue(
					 match23.day(dateString, {
						width: "abbreviated",
						context: "formatting"
					 }) || match23.day(dateString, {
						width: "short",
						context: "formatting"
					 }) || match23.day(dateString, {
						width: "narrow",
						context: "formatting"
					 }),
					 valueCallback
				  );
				case "iiiii":
				  return mapValue(
					 match23.day(dateString, {
						width: "narrow",
						context: "formatting"
					 }),
					 valueCallback
				  );
				case "iiiiii":
				  return mapValue(
					 match23.day(dateString, {
						width: "short",
						context: "formatting"
					 }) || match23.day(dateString, {
						width: "narrow",
						context: "formatting"
					 }),
					 valueCallback
				  );
				case "iiii":
				default:
				  return mapValue(
					 match23.day(dateString, {
						width: "wide",
						context: "formatting"
					 }) || match23.day(dateString, {
						width: "abbreviated",
						context: "formatting"
					 }) || match23.day(dateString, {
						width: "short",
						context: "formatting"
					 }) || match23.day(dateString, {
						width: "narrow",
						context: "formatting"
					 }),
					 valueCallback
				  );
			 }
		  }
		  validate(_date, value) {
			 return value >= 1 && value <= 7;
		  }
		  set(date2, _flags, value) {
			 date2 = setISODay(date2, value);
			 date2.setHours(0, 0, 0, 0);
			 return date2;
		  }
		  incompatibleTokens = [
			 "y",
			 "Y",
			 "u",
			 "q",
			 "Q",
			 "M",
			 "L",
			 "w",
			 "d",
			 "D",
			 "E",
			 "e",
			 "c",
			 "t",
			 "T"
		  ];
		};

		// node_modules/date-fns/parse/_lib/parsers/AMPMParser.mjs
		var AMPMParser = class extends Parser {
		  priority = 80;
		  parse(dateString, token, match23) {
			 switch (token) {
				case "a":
				case "aa":
				case "aaa":
				  return match23.dayPeriod(dateString, {
					 width: "abbreviated",
					 context: "formatting"
				  }) || match23.dayPeriod(dateString, {
					 width: "narrow",
					 context: "formatting"
				  });
				case "aaaaa":
				  return match23.dayPeriod(dateString, {
					 width: "narrow",
					 context: "formatting"
				  });
				case "aaaa":
				default:
				  return match23.dayPeriod(dateString, {
					 width: "wide",
					 context: "formatting"
				  }) || match23.dayPeriod(dateString, {
					 width: "abbreviated",
					 context: "formatting"
				  }) || match23.dayPeriod(dateString, {
					 width: "narrow",
					 context: "formatting"
				  });
			 }
		  }
		  set(date2, _flags, value) {
			 date2.setHours(dayPeriodEnumToHours(value), 0, 0, 0);
			 return date2;
		  }
		  incompatibleTokens = ["b", "B", "H", "k", "t", "T"];
		};

		// node_modules/date-fns/parse/_lib/parsers/AMPMMidnightParser.mjs
		var AMPMMidnightParser = class extends Parser {
		  priority = 80;
		  parse(dateString, token, match23) {
			 switch (token) {
				case "b":
				case "bb":
				case "bbb":
				  return match23.dayPeriod(dateString, {
					 width: "abbreviated",
					 context: "formatting"
				  }) || match23.dayPeriod(dateString, {
					 width: "narrow",
					 context: "formatting"
				  });
				case "bbbbb":
				  return match23.dayPeriod(dateString, {
					 width: "narrow",
					 context: "formatting"
				  });
				case "bbbb":
				default:
				  return match23.dayPeriod(dateString, {
					 width: "wide",
					 context: "formatting"
				  }) || match23.dayPeriod(dateString, {
					 width: "abbreviated",
					 context: "formatting"
				  }) || match23.dayPeriod(dateString, {
					 width: "narrow",
					 context: "formatting"
				  });
			 }
		  }
		  set(date2, _flags, value) {
			 date2.setHours(dayPeriodEnumToHours(value), 0, 0, 0);
			 return date2;
		  }
		  incompatibleTokens = ["a", "B", "H", "k", "t", "T"];
		};

		// node_modules/date-fns/parse/_lib/parsers/DayPeriodParser.mjs
		var DayPeriodParser = class extends Parser {
		  priority = 80;
		  parse(dateString, token, match23) {
			 switch (token) {
				case "B":
				case "BB":
				case "BBB":
				  return match23.dayPeriod(dateString, {
					 width: "abbreviated",
					 context: "formatting"
				  }) || match23.dayPeriod(dateString, {
					 width: "narrow",
					 context: "formatting"
				  });
				case "BBBBB":
				  return match23.dayPeriod(dateString, {
					 width: "narrow",
					 context: "formatting"
				  });
				case "BBBB":
				default:
				  return match23.dayPeriod(dateString, {
					 width: "wide",
					 context: "formatting"
				  }) || match23.dayPeriod(dateString, {
					 width: "abbreviated",
					 context: "formatting"
				  }) || match23.dayPeriod(dateString, {
					 width: "narrow",
					 context: "formatting"
				  });
			 }
		  }
		  set(date2, _flags, value) {
			 date2.setHours(dayPeriodEnumToHours(value), 0, 0, 0);
			 return date2;
		  }
		  incompatibleTokens = ["a", "b", "t", "T"];
		};

		// node_modules/date-fns/parse/_lib/parsers/Hour1to12Parser.mjs
		var Hour1to12Parser = class extends Parser {
		  priority = 70;
		  parse(dateString, token, match23) {
			 switch (token) {
				case "h":
				  return parseNumericPattern(numericPatterns.hour12h, dateString);
				case "ho":
				  return match23.ordinalNumber(dateString, { unit: "hour" });
				default:
				  return parseNDigits(token.length, dateString);
			 }
		  }
		  validate(_date, value) {
			 return value >= 1 && value <= 12;
		  }
		  set(date2, _flags, value) {
			 const isPM = date2.getHours() >= 12;
			 if (isPM && value < 12) {
				date2.setHours(value + 12, 0, 0, 0);
			 } else if (!isPM && value === 12) {
				date2.setHours(0, 0, 0, 0);
			 } else {
				date2.setHours(value, 0, 0, 0);
			 }
			 return date2;
		  }
		  incompatibleTokens = ["H", "K", "k", "t", "T"];
		};

		// node_modules/date-fns/parse/_lib/parsers/Hour0to23Parser.mjs
		var Hour0to23Parser = class extends Parser {
		  priority = 70;
		  parse(dateString, token, match23) {
			 switch (token) {
				case "H":
				  return parseNumericPattern(numericPatterns.hour23h, dateString);
				case "Ho":
				  return match23.ordinalNumber(dateString, { unit: "hour" });
				default:
				  return parseNDigits(token.length, dateString);
			 }
		  }
		  validate(_date, value) {
			 return value >= 0 && value <= 23;
		  }
		  set(date2, _flags, value) {
			 date2.setHours(value, 0, 0, 0);
			 return date2;
		  }
		  incompatibleTokens = ["a", "b", "h", "K", "k", "t", "T"];
		};

		// node_modules/date-fns/parse/_lib/parsers/Hour0To11Parser.mjs
		var Hour0To11Parser = class extends Parser {
		  priority = 70;
		  parse(dateString, token, match23) {
			 switch (token) {
				case "K":
				  return parseNumericPattern(numericPatterns.hour11h, dateString);
				case "Ko":
				  return match23.ordinalNumber(dateString, { unit: "hour" });
				default:
				  return parseNDigits(token.length, dateString);
			 }
		  }
		  validate(_date, value) {
			 return value >= 0 && value <= 11;
		  }
		  set(date2, _flags, value) {
			 const isPM = date2.getHours() >= 12;
			 if (isPM && value < 12) {
				date2.setHours(value + 12, 0, 0, 0);
			 } else {
				date2.setHours(value, 0, 0, 0);
			 }
			 return date2;
		  }
		  incompatibleTokens = ["h", "H", "k", "t", "T"];
		};

		// node_modules/date-fns/parse/_lib/parsers/Hour1To24Parser.mjs
		var Hour1To24Parser = class extends Parser {
		  priority = 70;
		  parse(dateString, token, match23) {
			 switch (token) {
				case "k":
				  return parseNumericPattern(numericPatterns.hour24h, dateString);
				case "ko":
				  return match23.ordinalNumber(dateString, { unit: "hour" });
				default:
				  return parseNDigits(token.length, dateString);
			 }
		  }
		  validate(_date, value) {
			 return value >= 1 && value <= 24;
		  }
		  set(date2, _flags, value) {
			 const hours = value <= 24 ? value % 24 : value;
			 date2.setHours(hours, 0, 0, 0);
			 return date2;
		  }
		  incompatibleTokens = ["a", "b", "h", "H", "K", "t", "T"];
		};

		// node_modules/date-fns/parse/_lib/parsers/MinuteParser.mjs
		var MinuteParser = class extends Parser {
		  priority = 60;
		  parse(dateString, token, match23) {
			 switch (token) {
				case "m":
				  return parseNumericPattern(numericPatterns.minute, dateString);
				case "mo":
				  return match23.ordinalNumber(dateString, { unit: "minute" });
				default:
				  return parseNDigits(token.length, dateString);
			 }
		  }
		  validate(_date, value) {
			 return value >= 0 && value <= 59;
		  }
		  set(date2, _flags, value) {
			 date2.setMinutes(value, 0, 0);
			 return date2;
		  }
		  incompatibleTokens = ["t", "T"];
		};

		// node_modules/date-fns/parse/_lib/parsers/SecondParser.mjs
		var SecondParser = class extends Parser {
		  priority = 50;
		  parse(dateString, token, match23) {
			 switch (token) {
				case "s":
				  return parseNumericPattern(numericPatterns.second, dateString);
				case "so":
				  return match23.ordinalNumber(dateString, { unit: "second" });
				default:
				  return parseNDigits(token.length, dateString);
			 }
		  }
		  validate(_date, value) {
			 return value >= 0 && value <= 59;
		  }
		  set(date2, _flags, value) {
			 date2.setSeconds(value, 0);
			 return date2;
		  }
		  incompatibleTokens = ["t", "T"];
		};

		// node_modules/date-fns/parse/_lib/parsers/FractionOfSecondParser.mjs
		var FractionOfSecondParser = class extends Parser {
		  priority = 30;
		  parse(dateString, token) {
			 const valueCallback = (value) => Math.trunc(value * Math.pow(10, -token.length + 3));
			 return mapValue(parseNDigits(token.length, dateString), valueCallback);
		  }
		  set(date2, _flags, value) {
			 date2.setMilliseconds(value);
			 return date2;
		  }
		  incompatibleTokens = ["t", "T"];
		};

		// node_modules/date-fns/parse/_lib/parsers/ISOTimezoneWithZParser.mjs
		var ISOTimezoneWithZParser = class extends Parser {
		  priority = 10;
		  parse(dateString, token) {
			 switch (token) {
				case "X":
				  return parseTimezonePattern(
					 timezonePatterns.basicOptionalMinutes,
					 dateString
				  );
				case "XX":
				  return parseTimezonePattern(timezonePatterns.basic, dateString);
				case "XXXX":
				  return parseTimezonePattern(
					 timezonePatterns.basicOptionalSeconds,
					 dateString
				  );
				case "XXXXX":
				  return parseTimezonePattern(
					 timezonePatterns.extendedOptionalSeconds,
					 dateString
				  );
				case "XXX":
				default:
				  return parseTimezonePattern(timezonePatterns.extended, dateString);
			 }
		  }
		  set(date2, flags, value) {
			 if (flags.timestampIsSet)
				return date2;
			 return constructFrom(
				date2,
				date2.getTime() - getTimezoneOffsetInMilliseconds(date2) - value
			 );
		  }
		  incompatibleTokens = ["t", "T", "x"];
		};

		// node_modules/date-fns/parse/_lib/parsers/ISOTimezoneParser.mjs
		var ISOTimezoneParser = class extends Parser {
		  priority = 10;
		  parse(dateString, token) {
			 switch (token) {
				case "x":
				  return parseTimezonePattern(
					 timezonePatterns.basicOptionalMinutes,
					 dateString
				  );
				case "xx":
				  return parseTimezonePattern(timezonePatterns.basic, dateString);
				case "xxxx":
				  return parseTimezonePattern(
					 timezonePatterns.basicOptionalSeconds,
					 dateString
				  );
				case "xxxxx":
				  return parseTimezonePattern(
					 timezonePatterns.extendedOptionalSeconds,
					 dateString
				  );
				case "xxx":
				default:
				  return parseTimezonePattern(timezonePatterns.extended, dateString);
			 }
		  }
		  set(date2, flags, value) {
			 if (flags.timestampIsSet)
				return date2;
			 return constructFrom(
				date2,
				date2.getTime() - getTimezoneOffsetInMilliseconds(date2) - value
			 );
		  }
		  incompatibleTokens = ["t", "T", "X"];
		};

		// node_modules/date-fns/parse/_lib/parsers/TimestampSecondsParser.mjs
		var TimestampSecondsParser = class extends Parser {
		  priority = 40;
		  parse(dateString) {
			 return parseAnyDigitsSigned(dateString);
		  }
		  set(date2, _flags, value) {
			 return [constructFrom(date2, value * 1e3), { timestampIsSet: true }];
		  }
		  incompatibleTokens = "*";
		};

		// node_modules/date-fns/parse/_lib/parsers/TimestampMillisecondsParser.mjs
		var TimestampMillisecondsParser = class extends Parser {
		  priority = 20;
		  parse(dateString) {
			 return parseAnyDigitsSigned(dateString);
		  }
		  set(date2, _flags, value) {
			 return [constructFrom(date2, value), { timestampIsSet: true }];
		  }
		  incompatibleTokens = "*";
		};

		// node_modules/date-fns/parse/_lib/parsers.mjs
		var parsers = {
		  G: new EraParser(),
		  y: new YearParser(),
		  Y: new LocalWeekYearParser(),
		  R: new ISOWeekYearParser(),
		  u: new ExtendedYearParser(),
		  Q: new QuarterParser(),
		  q: new StandAloneQuarterParser(),
		  M: new MonthParser(),
		  L: new StandAloneMonthParser(),
		  w: new LocalWeekParser(),
		  I: new ISOWeekParser(),
		  d: new DateParser(),
		  D: new DayOfYearParser(),
		  E: new DayParser(),
		  e: new LocalDayParser(),
		  c: new StandAloneLocalDayParser(),
		  i: new ISODayParser(),
		  a: new AMPMParser(),
		  b: new AMPMMidnightParser(),
		  B: new DayPeriodParser(),
		  h: new Hour1to12Parser(),
		  H: new Hour0to23Parser(),
		  K: new Hour0To11Parser(),
		  k: new Hour1To24Parser(),
		  m: new MinuteParser(),
		  s: new SecondParser(),
		  S: new FractionOfSecondParser(),
		  X: new ISOTimezoneWithZParser(),
		  x: new ISOTimezoneParser(),
		  t: new TimestampSecondsParser(),
		  T: new TimestampMillisecondsParser()
		};

		// node_modules/date-fns/parse.mjs
		var formattingTokensRegExp2 = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
		var longFormattingTokensRegExp2 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
		var escapedStringRegExp2 = /^'([^]*?)'?$/;
		var doubleQuoteRegExp2 = /''/g;
		var notWhitespaceRegExp = /\S/;
		var unescapedLatinCharacterRegExp2 = /[a-zA-Z]/;
		function parse(dateStr, formatStr, referenceDate, options) {
		  const defaultOptions2 = getDefaultOptions2();
		  const locale2 = options?.locale ?? defaultOptions2.locale ?? enUS;
		  const firstWeekContainsDate = options?.firstWeekContainsDate ?? options?.locale?.options?.firstWeekContainsDate ?? defaultOptions2.firstWeekContainsDate ?? defaultOptions2.locale?.options?.firstWeekContainsDate ?? 1;
		  const weekStartsOn = options?.weekStartsOn ?? options?.locale?.options?.weekStartsOn ?? defaultOptions2.weekStartsOn ?? defaultOptions2.locale?.options?.weekStartsOn ?? 0;
		  if (formatStr === "") {
			 if (dateStr === "") {
				return toDate2(referenceDate);
			 } else {
				return constructFrom(referenceDate, NaN);
			 }
		  }
		  const subFnOptions = {
			 firstWeekContainsDate,
			 weekStartsOn,
			 locale: locale2
		  };
		  const setters = [new DateToSystemTimezoneSetter()];
		  const tokens = formatStr.match(longFormattingTokensRegExp2).map((substring) => {
			 const firstCharacter = substring[0];
			 if (firstCharacter in longFormatters) {
				const longFormatter = longFormatters[firstCharacter];
				return longFormatter(substring, locale2.formatLong);
			 }
			 return substring;
		  }).join("").match(formattingTokensRegExp2);
		  const usedTokens = [];
		  for (let token of tokens) {
			 if (!options?.useAdditionalWeekYearTokens && isProtectedWeekYearToken(token)) {
				warnOrThrowProtectedError(token, formatStr, dateStr);
			 }
			 if (!options?.useAdditionalDayOfYearTokens && isProtectedDayOfYearToken(token)) {
				warnOrThrowProtectedError(token, formatStr, dateStr);
			 }
			 const firstCharacter = token[0];
			 const parser = parsers[firstCharacter];
			 if (parser) {
				const { incompatibleTokens } = parser;
				if (Array.isArray(incompatibleTokens)) {
				  const incompatibleToken = usedTokens.find(
					 (usedToken) => incompatibleTokens.includes(usedToken.token) || usedToken.token === firstCharacter
				  );
				  if (incompatibleToken) {
					 throw new RangeError(
						`The format string mustn't contain \`${incompatibleToken.fullToken}\` and \`${token}\` at the same time`
					 );
				  }
				} else if (parser.incompatibleTokens === "*" && usedTokens.length > 0) {
				  throw new RangeError(
					 `The format string mustn't contain \`${token}\` and any other token at the same time`
				  );
				}
				usedTokens.push({ token: firstCharacter, fullToken: token });
				const parseResult = parser.run(
				  dateStr,
				  token,
				  locale2.match,
				  subFnOptions
				);
				if (!parseResult) {
				  return constructFrom(referenceDate, NaN);
				}
				setters.push(parseResult.setter);
				dateStr = parseResult.rest;
			 } else {
				if (firstCharacter.match(unescapedLatinCharacterRegExp2)) {
				  throw new RangeError(
					 "Format string contains an unescaped latin alphabet character `" + firstCharacter + "`"
				  );
				}
				if (token === "''") {
				  token = "'";
				} else if (firstCharacter === "'") {
				  token = cleanEscapedString2(token);
				}
				if (dateStr.indexOf(token) === 0) {
				  dateStr = dateStr.slice(token.length);
				} else {
				  return constructFrom(referenceDate, NaN);
				}
			 }
		  }
		  if (dateStr.length > 0 && notWhitespaceRegExp.test(dateStr)) {
			 return constructFrom(referenceDate, NaN);
		  }
		  const uniquePrioritySetters = setters.map((setter) => setter.priority).sort((a, b) => b - a).filter((priority, index, array2) => array2.indexOf(priority) === index).map(
			 (priority) => setters.filter((setter) => setter.priority === priority).sort((a, b) => b.subPriority - a.subPriority)
		  ).map((setterArray) => setterArray[0]);
		  let date2 = toDate2(referenceDate);
		  if (isNaN(date2.getTime())) {
			 return constructFrom(referenceDate, NaN);
		  }
		  const flags = {};
		  for (const setter of uniquePrioritySetters) {
			 if (!setter.validate(date2, subFnOptions)) {
				return constructFrom(referenceDate, NaN);
			 }
			 const result = setter.set(date2, flags, subFnOptions);
			 if (Array.isArray(result)) {
				date2 = result[0];
				Object.assign(flags, result[1]);
			 } else {
				date2 = result;
			 }
		  }
		  return constructFrom(referenceDate, date2);
		}
		function cleanEscapedString2(input2) {
		  return input2.match(escapedStringRegExp2)[1].replace(doubleQuoteRegExp2, "'");
		}

		// node_modules/date-fns/startOfHour.mjs
		function startOfHour(date2) {
		  const _date = toDate2(date2);
		  _date.setMinutes(0, 0, 0);
		  return _date;
		}

		// node_modules/date-fns/isSameWeek.mjs
		function isSameWeek(dateLeft, dateRight, options) {
		  const dateLeftStartOfWeek = startOfWeek(dateLeft, options);
		  const dateRightStartOfWeek = startOfWeek(dateRight, options);
		  return +dateLeftStartOfWeek === +dateRightStartOfWeek;
		}

		// node_modules/date-fns/startOfSecond.mjs
		function startOfSecond(date2) {
		  const _date = toDate2(date2);
		  _date.setMilliseconds(0);
		  return _date;
		}

		// node_modules/date-fns/setMonth.mjs
		function setMonth(date2, month) {
		  const _date = toDate2(date2);
		  const year = _date.getFullYear();
		  const day = _date.getDate();
		  const dateWithDesiredMonth = constructFrom(date2, 0);
		  dateWithDesiredMonth.setFullYear(year, month, 15);
		  dateWithDesiredMonth.setHours(0, 0, 0, 0);
		  const daysInMonth = getDaysInMonth(dateWithDesiredMonth);
		  _date.setMonth(month, Math.min(day, daysInMonth));
		  return _date;
		}

		// node_modules/date-fns/setDefaultOptions.mjs
		function setDefaultOptions2(options) {
		  const result = {};
		  const defaultOptions2 = getDefaultOptions();
		  for (const property in defaultOptions2) {
			 if (Object.prototype.hasOwnProperty.call(defaultOptions2, property)) {
				result[property] = defaultOptions2[property];
			 }
		  }
		  for (const property in options) {
			 if (Object.prototype.hasOwnProperty.call(options, property)) {
				if (options[property] === void 0) {
				  delete result[property];
				} else {
				  result[property] = options[property];
				}
			 }
		  }
		  setDefaultOptions(result);
		}

		// node_modules/date-fns/setHours.mjs
		function setHours(date2, hours) {
		  const _date = toDate2(date2);
		  _date.setHours(hours);
		  return _date;
		}

		// node_modules/date-fns/setMilliseconds.mjs
		function setMilliseconds(date2, milliseconds2) {
		  const _date = toDate2(date2);
		  _date.setMilliseconds(milliseconds2);
		  return _date;
		}

		// node_modules/date-fns/setMinutes.mjs
		function setMinutes(date2, minutes) {
		  const _date = toDate2(date2);
		  _date.setMinutes(minutes);
		  return _date;
		}

		// node_modules/date-fns/setSeconds.mjs
		function setSeconds(date2, seconds2) {
		  const _date = toDate2(date2);
		  _date.setSeconds(seconds2);
		  return _date;
		}

		// node_modules/date-fns/setYear.mjs
		function setYear(date2, year) {
		  const _date = toDate2(date2);
		  if (isNaN(+_date)) {
			 return constructFrom(date2, NaN);
		  }
		  _date.setFullYear(year);
		  return _date;
		}

		// node_modules/date-fns/locale/cs/_lib/formatDistance.mjs
		var formatDistanceLocale2 = {
		  lessThanXSeconds: {
			 one: {
				regular: "m\xE9n\u011B ne\u017E 1 sekunda",
				past: "p\u0159ed m\xE9n\u011B ne\u017E 1 sekundou",
				future: "za m\xE9n\u011B ne\u017E 1 sekundu"
			 },
			 few: {
				regular: "m\xE9n\u011B ne\u017E {{count}} sekundy",
				past: "p\u0159ed m\xE9n\u011B ne\u017E {{count}} sekundami",
				future: "za m\xE9n\u011B ne\u017E {{count}} sekundy"
			 },
			 many: {
				regular: "m\xE9n\u011B ne\u017E {{count}} sekund",
				past: "p\u0159ed m\xE9n\u011B ne\u017E {{count}} sekundami",
				future: "za m\xE9n\u011B ne\u017E {{count}} sekund"
			 }
		  },
		  xSeconds: {
			 one: {
				regular: "1 sekunda",
				past: "p\u0159ed 1 sekundou",
				future: "za 1 sekundu"
			 },
			 few: {
				regular: "{{count}} sekundy",
				past: "p\u0159ed {{count}} sekundami",
				future: "za {{count}} sekundy"
			 },
			 many: {
				regular: "{{count}} sekund",
				past: "p\u0159ed {{count}} sekundami",
				future: "za {{count}} sekund"
			 }
		  },
		  halfAMinute: {
			 type: "other",
			 other: {
				regular: "p\u016Fl minuty",
				past: "p\u0159ed p\u016Fl minutou",
				future: "za p\u016Fl minuty"
			 }
		  },
		  lessThanXMinutes: {
			 one: {
				regular: "m\xE9n\u011B ne\u017E 1 minuta",
				past: "p\u0159ed m\xE9n\u011B ne\u017E 1 minutou",
				future: "za m\xE9n\u011B ne\u017E 1 minutu"
			 },
			 few: {
				regular: "m\xE9n\u011B ne\u017E {{count}} minuty",
				past: "p\u0159ed m\xE9n\u011B ne\u017E {{count}} minutami",
				future: "za m\xE9n\u011B ne\u017E {{count}} minuty"
			 },
			 many: {
				regular: "m\xE9n\u011B ne\u017E {{count}} minut",
				past: "p\u0159ed m\xE9n\u011B ne\u017E {{count}} minutami",
				future: "za m\xE9n\u011B ne\u017E {{count}} minut"
			 }
		  },
		  xMinutes: {
			 one: {
				regular: "1 minuta",
				past: "p\u0159ed 1 minutou",
				future: "za 1 minutu"
			 },
			 few: {
				regular: "{{count}} minuty",
				past: "p\u0159ed {{count}} minutami",
				future: "za {{count}} minuty"
			 },
			 many: {
				regular: "{{count}} minut",
				past: "p\u0159ed {{count}} minutami",
				future: "za {{count}} minut"
			 }
		  },
		  aboutXHours: {
			 one: {
				regular: "p\u0159ibli\u017En\u011B 1 hodina",
				past: "p\u0159ibli\u017En\u011B p\u0159ed 1 hodinou",
				future: "p\u0159ibli\u017En\u011B za 1 hodinu"
			 },
			 few: {
				regular: "p\u0159ibli\u017En\u011B {{count}} hodiny",
				past: "p\u0159ibli\u017En\u011B p\u0159ed {{count}} hodinami",
				future: "p\u0159ibli\u017En\u011B za {{count}} hodiny"
			 },
			 many: {
				regular: "p\u0159ibli\u017En\u011B {{count}} hodin",
				past: "p\u0159ibli\u017En\u011B p\u0159ed {{count}} hodinami",
				future: "p\u0159ibli\u017En\u011B za {{count}} hodin"
			 }
		  },
		  xHours: {
			 one: {
				regular: "1 hodina",
				past: "p\u0159ed 1 hodinou",
				future: "za 1 hodinu"
			 },
			 few: {
				regular: "{{count}} hodiny",
				past: "p\u0159ed {{count}} hodinami",
				future: "za {{count}} hodiny"
			 },
			 many: {
				regular: "{{count}} hodin",
				past: "p\u0159ed {{count}} hodinami",
				future: "za {{count}} hodin"
			 }
		  },
		  xDays: {
			 one: {
				regular: "1 den",
				past: "p\u0159ed 1 dnem",
				future: "za 1 den"
			 },
			 few: {
				regular: "{{count}} dny",
				past: "p\u0159ed {{count}} dny",
				future: "za {{count}} dny"
			 },
			 many: {
				regular: "{{count}} dn\xED",
				past: "p\u0159ed {{count}} dny",
				future: "za {{count}} dn\xED"
			 }
		  },
		  aboutXWeeks: {
			 one: {
				regular: "p\u0159ibli\u017En\u011B 1 t\xFDden",
				past: "p\u0159ibli\u017En\u011B p\u0159ed 1 t\xFDdnem",
				future: "p\u0159ibli\u017En\u011B za 1 t\xFDden"
			 },
			 few: {
				regular: "p\u0159ibli\u017En\u011B {{count}} t\xFDdny",
				past: "p\u0159ibli\u017En\u011B p\u0159ed {{count}} t\xFDdny",
				future: "p\u0159ibli\u017En\u011B za {{count}} t\xFDdny"
			 },
			 many: {
				regular: "p\u0159ibli\u017En\u011B {{count}} t\xFDdn\u016F",
				past: "p\u0159ibli\u017En\u011B p\u0159ed {{count}} t\xFDdny",
				future: "p\u0159ibli\u017En\u011B za {{count}} t\xFDdn\u016F"
			 }
		  },
		  xWeeks: {
			 one: {
				regular: "1 t\xFDden",
				past: "p\u0159ed 1 t\xFDdnem",
				future: "za 1 t\xFDden"
			 },
			 few: {
				regular: "{{count}} t\xFDdny",
				past: "p\u0159ed {{count}} t\xFDdny",
				future: "za {{count}} t\xFDdny"
			 },
			 many: {
				regular: "{{count}} t\xFDdn\u016F",
				past: "p\u0159ed {{count}} t\xFDdny",
				future: "za {{count}} t\xFDdn\u016F"
			 }
		  },
		  aboutXMonths: {
			 one: {
				regular: "p\u0159ibli\u017En\u011B 1 m\u011Bs\xEDc",
				past: "p\u0159ibli\u017En\u011B p\u0159ed 1 m\u011Bs\xEDcem",
				future: "p\u0159ibli\u017En\u011B za 1 m\u011Bs\xEDc"
			 },
			 few: {
				regular: "p\u0159ibli\u017En\u011B {{count}} m\u011Bs\xEDce",
				past: "p\u0159ibli\u017En\u011B p\u0159ed {{count}} m\u011Bs\xEDci",
				future: "p\u0159ibli\u017En\u011B za {{count}} m\u011Bs\xEDce"
			 },
			 many: {
				regular: "p\u0159ibli\u017En\u011B {{count}} m\u011Bs\xEDc\u016F",
				past: "p\u0159ibli\u017En\u011B p\u0159ed {{count}} m\u011Bs\xEDci",
				future: "p\u0159ibli\u017En\u011B za {{count}} m\u011Bs\xEDc\u016F"
			 }
		  },
		  xMonths: {
			 one: {
				regular: "1 m\u011Bs\xEDc",
				past: "p\u0159ed 1 m\u011Bs\xEDcem",
				future: "za 1 m\u011Bs\xEDc"
			 },
			 few: {
				regular: "{{count}} m\u011Bs\xEDce",
				past: "p\u0159ed {{count}} m\u011Bs\xEDci",
				future: "za {{count}} m\u011Bs\xEDce"
			 },
			 many: {
				regular: "{{count}} m\u011Bs\xEDc\u016F",
				past: "p\u0159ed {{count}} m\u011Bs\xEDci",
				future: "za {{count}} m\u011Bs\xEDc\u016F"
			 }
		  },
		  aboutXYears: {
			 one: {
				regular: "p\u0159ibli\u017En\u011B 1 rok",
				past: "p\u0159ibli\u017En\u011B p\u0159ed 1 rokem",
				future: "p\u0159ibli\u017En\u011B za 1 rok"
			 },
			 few: {
				regular: "p\u0159ibli\u017En\u011B {{count}} roky",
				past: "p\u0159ibli\u017En\u011B p\u0159ed {{count}} roky",
				future: "p\u0159ibli\u017En\u011B za {{count}} roky"
			 },
			 many: {
				regular: "p\u0159ibli\u017En\u011B {{count}} rok\u016F",
				past: "p\u0159ibli\u017En\u011B p\u0159ed {{count}} roky",
				future: "p\u0159ibli\u017En\u011B za {{count}} rok\u016F"
			 }
		  },
		  xYears: {
			 one: {
				regular: "1 rok",
				past: "p\u0159ed 1 rokem",
				future: "za 1 rok"
			 },
			 few: {
				regular: "{{count}} roky",
				past: "p\u0159ed {{count}} roky",
				future: "za {{count}} roky"
			 },
			 many: {
				regular: "{{count}} rok\u016F",
				past: "p\u0159ed {{count}} roky",
				future: "za {{count}} rok\u016F"
			 }
		  },
		  overXYears: {
			 one: {
				regular: "v\xEDce ne\u017E 1 rok",
				past: "p\u0159ed v\xEDce ne\u017E 1 rokem",
				future: "za v\xEDce ne\u017E 1 rok"
			 },
			 few: {
				regular: "v\xEDce ne\u017E {{count}} roky",
				past: "p\u0159ed v\xEDce ne\u017E {{count}} roky",
				future: "za v\xEDce ne\u017E {{count}} roky"
			 },
			 many: {
				regular: "v\xEDce ne\u017E {{count}} rok\u016F",
				past: "p\u0159ed v\xEDce ne\u017E {{count}} roky",
				future: "za v\xEDce ne\u017E {{count}} rok\u016F"
			 }
		  },
		  almostXYears: {
			 one: {
				regular: "skoro 1 rok",
				past: "skoro p\u0159ed 1 rokem",
				future: "skoro za 1 rok"
			 },
			 few: {
				regular: "skoro {{count}} roky",
				past: "skoro p\u0159ed {{count}} roky",
				future: "skoro za {{count}} roky"
			 },
			 many: {
				regular: "skoro {{count}} rok\u016F",
				past: "skoro p\u0159ed {{count}} roky",
				future: "skoro za {{count}} rok\u016F"
			 }
		  }
		};
		var formatDistance2 = (token, count, options) => {
		  let pluralResult;
		  const tokenValue = formatDistanceLocale2[token];
		  if (tokenValue.type === "other") {
			 pluralResult = tokenValue.other;
		  } else if (count === 1) {
			 pluralResult = tokenValue.one;
		  } else if (count > 1 && count < 5) {
			 pluralResult = tokenValue.few;
		  } else {
			 pluralResult = tokenValue.many;
		  }
		  const suffixExist = options?.addSuffix === true;
		  const comparison = options?.comparison;
		  let timeResult;
		  if (suffixExist && comparison === -1) {
			 timeResult = pluralResult.past;
		  } else if (suffixExist && comparison === 1) {
			 timeResult = pluralResult.future;
		  } else {
			 timeResult = pluralResult.regular;
		  }
		  return timeResult.replace("{{count}}", String(count));
		};

		// node_modules/date-fns/locale/cs/_lib/formatLong.mjs
		var dateFormats2 = {
		  full: "EEEE, d. MMMM yyyy",
		  long: "d. MMMM yyyy",
		  medium: "d. M. yyyy",
		  short: "dd.MM.yyyy"
		};
		var timeFormats2 = {
		  full: "H:mm:ss zzzz",
		  long: "H:mm:ss z",
		  medium: "H:mm:ss",
		  short: "H:mm"
		};
		var dateTimeFormats2 = {
		  full: "{{date}} 'v' {{time}}",
		  long: "{{date}} 'v' {{time}}",
		  medium: "{{date}}, {{time}}",
		  short: "{{date}}, {{time}}"
		};
		var formatLong2 = {
		  date: buildFormatLongFn({
			 formats: dateFormats2,
			 defaultWidth: "full"
		  }),
		  time: buildFormatLongFn({
			 formats: timeFormats2,
			 defaultWidth: "full"
		  }),
		  dateTime: buildFormatLongFn({
			 formats: dateTimeFormats2,
			 defaultWidth: "full"
		  })
		};

		// node_modules/date-fns/locale/cs/_lib/formatRelative.mjs
		var accusativeWeekdays = [
		  "ned\u011Bli",
		  "pond\u011Bl\xED",
		  "\xFAter\xFD",
		  "st\u0159edu",
		  "\u010Dtvrtek",
		  "p\xE1tek",
		  "sobotu"
		];
		var formatRelativeLocale2 = {
		  lastWeek: "'posledn\xED' eeee 've' p",
		  yesterday: "'v\u010Dera v' p",
		  today: "'dnes v' p",
		  tomorrow: "'z\xEDtra v' p",
		  nextWeek: (date2) => {
			 const day = date2.getDay();
			 return "'v " + accusativeWeekdays[day] + " o' p";
		  },
		  other: "P"
		};
		var formatRelative2 = (token, date2) => {
		  const format2 = formatRelativeLocale2[token];
		  if (typeof format2 === "function") {
			 return format2(date2);
		  }
		  return format2;
		};

		// node_modules/date-fns/locale/cs/_lib/localize.mjs
		var eraValues2 = {
		  narrow: ["p\u0159. n. l.", "n. l."],
		  abbreviated: ["p\u0159. n. l.", "n. l."],
		  wide: ["p\u0159ed na\u0161\xEDm letopo\u010Dtem", "na\u0161eho letopo\u010Dtu"]
		};
		var quarterValues2 = {
		  narrow: ["1", "2", "3", "4"],
		  abbreviated: ["1. \u010Dtvrtlet\xED", "2. \u010Dtvrtlet\xED", "3. \u010Dtvrtlet\xED", "4. \u010Dtvrtlet\xED"],
		  wide: ["1. \u010Dtvrtlet\xED", "2. \u010Dtvrtlet\xED", "3. \u010Dtvrtlet\xED", "4. \u010Dtvrtlet\xED"]
		};
		var monthValues2 = {
		  narrow: ["L", "\xDA", "B", "D", "K", "\u010C", "\u010C", "S", "Z", "\u0158", "L", "P"],
		  abbreviated: [
			 "led",
			 "\xFAno",
			 "b\u0159e",
			 "dub",
			 "kv\u011B",
			 "\u010Dvn",
			 "\u010Dvc",
			 "srp",
			 "z\xE1\u0159",
			 "\u0159\xEDj",
			 "lis",
			 "pro"
		  ],
		  wide: [
			 "leden",
			 "\xFAnor",
			 "b\u0159ezen",
			 "duben",
			 "kv\u011Bten",
			 "\u010Derven",
			 "\u010Dervenec",
			 "srpen",
			 "z\xE1\u0159\xED",
			 "\u0159\xEDjen",
			 "listopad",
			 "prosinec"
		  ]
		};
		var formattingMonthValues = {
		  narrow: ["L", "\xDA", "B", "D", "K", "\u010C", "\u010C", "S", "Z", "\u0158", "L", "P"],
		  abbreviated: [
			 "led",
			 "\xFAno",
			 "b\u0159e",
			 "dub",
			 "kv\u011B",
			 "\u010Dvn",
			 "\u010Dvc",
			 "srp",
			 "z\xE1\u0159",
			 "\u0159\xEDj",
			 "lis",
			 "pro"
		  ],
		  wide: [
			 "ledna",
			 "\xFAnora",
			 "b\u0159ezna",
			 "dubna",
			 "kv\u011Btna",
			 "\u010Dervna",
			 "\u010Dervence",
			 "srpna",
			 "z\xE1\u0159\xED",
			 "\u0159\xEDjna",
			 "listopadu",
			 "prosince"
		  ]
		};
		var dayValues2 = {
		  narrow: ["ne", "po", "\xFAt", "st", "\u010Dt", "p\xE1", "so"],
		  short: ["ne", "po", "\xFAt", "st", "\u010Dt", "p\xE1", "so"],
		  abbreviated: ["ned", "pon", "\xFAte", "st\u0159", "\u010Dtv", "p\xE1t", "sob"],
		  wide: ["ned\u011Ble", "pond\u011Bl\xED", "\xFAter\xFD", "st\u0159eda", "\u010Dtvrtek", "p\xE1tek", "sobota"]
		};
		var dayPeriodValues2 = {
		  narrow: {
			 am: "dop.",
			 pm: "odp.",
			 midnight: "p\u016Flnoc",
			 noon: "poledne",
			 morning: "r\xE1no",
			 afternoon: "odpoledne",
			 evening: "ve\u010Der",
			 night: "noc"
		  },
		  abbreviated: {
			 am: "dop.",
			 pm: "odp.",
			 midnight: "p\u016Flnoc",
			 noon: "poledne",
			 morning: "r\xE1no",
			 afternoon: "odpoledne",
			 evening: "ve\u010Der",
			 night: "noc"
		  },
		  wide: {
			 am: "dopoledne",
			 pm: "odpoledne",
			 midnight: "p\u016Flnoc",
			 noon: "poledne",
			 morning: "r\xE1no",
			 afternoon: "odpoledne",
			 evening: "ve\u010Der",
			 night: "noc"
		  }
		};
		var formattingDayPeriodValues2 = {
		  narrow: {
			 am: "dop.",
			 pm: "odp.",
			 midnight: "p\u016Flnoc",
			 noon: "poledne",
			 morning: "r\xE1no",
			 afternoon: "odpoledne",
			 evening: "ve\u010Der",
			 night: "noc"
		  },
		  abbreviated: {
			 am: "dop.",
			 pm: "odp.",
			 midnight: "p\u016Flnoc",
			 noon: "poledne",
			 morning: "r\xE1no",
			 afternoon: "odpoledne",
			 evening: "ve\u010Der",
			 night: "noc"
		  },
		  wide: {
			 am: "dopoledne",
			 pm: "odpoledne",
			 midnight: "p\u016Flnoc",
			 noon: "poledne",
			 morning: "r\xE1no",
			 afternoon: "odpoledne",
			 evening: "ve\u010Der",
			 night: "noc"
		  }
		};
		var ordinalNumber2 = (dirtyNumber, _options) => {
		  const number5 = Number(dirtyNumber);
		  return number5 + ".";
		};
		var localize2 = {
		  ordinalNumber: ordinalNumber2,
		  era: buildLocalizeFn({
			 values: eraValues2,
			 defaultWidth: "wide"
		  }),
		  quarter: buildLocalizeFn({
			 values: quarterValues2,
			 defaultWidth: "wide",
			 argumentCallback: (quarter) => quarter - 1
		  }),
		  month: buildLocalizeFn({
			 values: monthValues2,
			 defaultWidth: "wide",
			 formattingValues: formattingMonthValues,
			 defaultFormattingWidth: "wide"
		  }),
		  day: buildLocalizeFn({
			 values: dayValues2,
			 defaultWidth: "wide"
		  }),
		  dayPeriod: buildLocalizeFn({
			 values: dayPeriodValues2,
			 defaultWidth: "wide",
			 formattingValues: formattingDayPeriodValues2,
			 defaultFormattingWidth: "wide"
		  })
		};

		// node_modules/date-fns/locale/cs/_lib/match.mjs
		var matchOrdinalNumberPattern2 = /^(\d+)\.?/i;
		var parseOrdinalNumberPattern2 = /\d+/i;
		var matchEraPatterns2 = {
		  narrow: /^(p[r](\.|ed) Kr\.|p[r](\.|ed) n\. l\.|po Kr\.|n\. l\.)/i,
		  abbreviated: /^(p[r](\.|ed) Kr\.|p[r](\.|ed) n\. l\.|po Kr\.|n\. l\.)/i,
		  wide: /^(p[r](\.|ed) Kristem|p[r](\.|ed) na[s][i]m letopo[c]tem|po Kristu|na[s]eho letopo[c]tu)/i
		};
		var parseEraPatterns2 = {
		  any: [/^p[r]/i, /^(po|n)/i]
		};
		var matchQuarterPatterns2 = {
		  narrow: /^[1234]/i,
		  abbreviated: /^[1234]\. [c]tvrtlet[i]/i,
		  wide: /^[1234]\. [c]tvrtlet[i]/i
		};
		var parseQuarterPatterns2 = {
		  any: [/1/i, /2/i, /3/i, /4/i]
		};
		var matchMonthPatterns2 = {
		  narrow: /^[lubdkcszrlp]/i,
		  abbreviated: /^(led|[u]no|b[r]e|dub|kv[e]|[c]vn|[c]vc|srp|z[a][r]|[r][i]j|lis|pro)/i,
		  wide: /^(leden|ledna|[u]nora?|b[r]ezen|b[r]ezna|duben|dubna|kv[e]ten|kv[e]tna|[c]erven(ec|ce)?|[c]ervna|srpen|srpna|z[a][r][i]|[r][i]jen|[r][i]jna|listopad(a|u)?|prosinec|prosince)/i
		};
		var parseMonthPatterns2 = {
		  narrow: [
			 /^l/i,
			 /^[u]/i,
			 /^b/i,
			 /^d/i,
			 /^k/i,
			 /^[c]/i,
			 /^[c]/i,
			 /^s/i,
			 /^z/i,
			 /^[r]/i,
			 /^l/i,
			 /^p/i
		  ],
		  any: [
			 /^led/i,
			 /^[u]n/i,
			 /^b[r]e/i,
			 /^dub/i,
			 /^kv[e]/i,
			 /^[c]vn|[c]erven(?!\w)|[c]ervna/i,
			 /^[c]vc|[c]erven(ec|ce)/i,
			 /^srp/i,
			 /^z[a][r]/i,
			 /^[r][i]j/i,
			 /^lis/i,
			 /^pro/i
		  ]
		};
		var matchDayPatterns2 = {
		  narrow: /^[npusps]/i,
		  short: /^(ne|po|[u]t|st|[c]t|p[a]|so)/i,
		  abbreviated: /^(ned|pon|[u]te|st[r]|[c]tv|p[a]t|sob)/i,
		  wide: /^(ned[e]le|pond[e]l[i]|[u]ter[y]|st[r]eda|[c]tvrtek|p[a]tek|sobota)/i
		};
		var parseDayPatterns2 = {
		  narrow: [/^n/i, /^p/i, /^[u]/i, /^s/i, /^[c]/i, /^p/i, /^s/i],
		  any: [/^ne/i, /^po/i, /^[u]t/i, /^st/i, /^[c]t/i, /^p[a]/i, /^so/i]
		};
		var matchDayPeriodPatterns2 = {
		  any: /^dopoledne|dop\.?|odpoledne|odp\.?|p[u]lnoc|poledne|r[a]no|odpoledne|ve[c]er|(v )?noci?/i
		};
		var parseDayPeriodPatterns2 = {
		  any: {
			 am: /^dop/i,
			 pm: /^odp/i,
			 midnight: /^p[u]lnoc/i,
			 noon: /^poledne/i,
			 morning: /r[a]no/i,
			 afternoon: /odpoledne/i,
			 evening: /ve[c]er/i,
			 night: /noc/i
		  }
		};
		var match2 = {
		  ordinalNumber: buildMatchPatternFn({
			 matchPattern: matchOrdinalNumberPattern2,
			 parsePattern: parseOrdinalNumberPattern2,
			 valueCallback: (value) => parseInt(value, 10)
		  }),
		  era: buildMatchFn({
			 matchPatterns: matchEraPatterns2,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseEraPatterns2,
			 defaultParseWidth: "any"
		  }),
		  quarter: buildMatchFn({
			 matchPatterns: matchQuarterPatterns2,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseQuarterPatterns2,
			 defaultParseWidth: "any",
			 valueCallback: (index) => index + 1
		  }),
		  month: buildMatchFn({
			 matchPatterns: matchMonthPatterns2,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseMonthPatterns2,
			 defaultParseWidth: "any"
		  }),
		  day: buildMatchFn({
			 matchPatterns: matchDayPatterns2,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseDayPatterns2,
			 defaultParseWidth: "any"
		  }),
		  dayPeriod: buildMatchFn({
			 matchPatterns: matchDayPeriodPatterns2,
			 defaultMatchWidth: "any",
			 parsePatterns: parseDayPeriodPatterns2,
			 defaultParseWidth: "any"
		  })
		};

		// node_modules/date-fns/locale/cs.mjs
		var cs = {
		  code: "cs",
		  formatDistance: formatDistance2,
		  formatLong: formatLong2,
		  formatRelative: formatRelative2,
		  localize: localize2,
		  match: match2,
		  options: {
			 weekStartsOn: 1,
			 firstWeekContainsDate: 4
		  }
		};

		// node_modules/date-fns/locale/da/_lib/formatDistance.mjs
		var formatDistanceLocale3 = {
		  lessThanXSeconds: {
			 one: "mindre end \xE9t sekund",
			 other: "mindre end {{count}} sekunder"
		  },
		  xSeconds: {
			 one: "1 sekund",
			 other: "{{count}} sekunder"
		  },
		  halfAMinute: "\xE9t halvt minut",
		  lessThanXMinutes: {
			 one: "mindre end \xE9t minut",
			 other: "mindre end {{count}} minutter"
		  },
		  xMinutes: {
			 one: "1 minut",
			 other: "{{count}} minutter"
		  },
		  aboutXHours: {
			 one: "cirka 1 time",
			 other: "cirka {{count}} timer"
		  },
		  xHours: {
			 one: "1 time",
			 other: "{{count}} timer"
		  },
		  xDays: {
			 one: "1 dag",
			 other: "{{count}} dage"
		  },
		  aboutXWeeks: {
			 one: "cirka 1 uge",
			 other: "cirka {{count}} uger"
		  },
		  xWeeks: {
			 one: "1 uge",
			 other: "{{count}} uger"
		  },
		  aboutXMonths: {
			 one: "cirka 1 m\xE5ned",
			 other: "cirka {{count}} m\xE5neder"
		  },
		  xMonths: {
			 one: "1 m\xE5ned",
			 other: "{{count}} m\xE5neder"
		  },
		  aboutXYears: {
			 one: "cirka 1 \xE5r",
			 other: "cirka {{count}} \xE5r"
		  },
		  xYears: {
			 one: "1 \xE5r",
			 other: "{{count}} \xE5r"
		  },
		  overXYears: {
			 one: "over 1 \xE5r",
			 other: "over {{count}} \xE5r"
		  },
		  almostXYears: {
			 one: "n\xE6sten 1 \xE5r",
			 other: "n\xE6sten {{count}} \xE5r"
		  }
		};
		var formatDistance3 = (token, count, options) => {
		  let result;
		  const tokenValue = formatDistanceLocale3[token];
		  if (typeof tokenValue === "string") {
			 result = tokenValue;
		  } else if (count === 1) {
			 result = tokenValue.one;
		  } else {
			 result = tokenValue.other.replace("{{count}}", String(count));
		  }
		  if (options?.addSuffix) {
			 if (options.comparison && options.comparison > 0) {
				return "om " + result;
			 } else {
				return result + " siden";
			 }
		  }
		  return result;
		};

		// node_modules/date-fns/locale/da/_lib/formatLong.mjs
		var dateFormats3 = {
		  full: "EEEE 'den' d. MMMM y",
		  long: "d. MMMM y",
		  medium: "d. MMM y",
		  short: "dd/MM/y"
		};
		var timeFormats3 = {
		  full: "HH:mm:ss zzzz",
		  long: "HH:mm:ss z",
		  medium: "HH:mm:ss",
		  short: "HH:mm"
		};
		var dateTimeFormats3 = {
		  full: "{{date}} 'kl'. {{time}}",
		  long: "{{date}} 'kl'. {{time}}",
		  medium: "{{date}} {{time}}",
		  short: "{{date}} {{time}}"
		};
		var formatLong3 = {
		  date: buildFormatLongFn({
			 formats: dateFormats3,
			 defaultWidth: "full"
		  }),
		  time: buildFormatLongFn({
			 formats: timeFormats3,
			 defaultWidth: "full"
		  }),
		  dateTime: buildFormatLongFn({
			 formats: dateTimeFormats3,
			 defaultWidth: "full"
		  })
		};

		// node_modules/date-fns/locale/da/_lib/formatRelative.mjs
		var formatRelativeLocale3 = {
		  lastWeek: "'sidste' eeee 'kl.' p",
		  yesterday: "'i g\xE5r kl.' p",
		  today: "'i dag kl.' p",
		  tomorrow: "'i morgen kl.' p",
		  nextWeek: "'p\xE5' eeee 'kl.' p",
		  other: "P"
		};
		var formatRelative3 = (token, _date, _baseDate, _options) => formatRelativeLocale3[token];

		// node_modules/date-fns/locale/da/_lib/localize.mjs
		var eraValues3 = {
		  narrow: ["fvt", "vt"],
		  abbreviated: ["f.v.t.", "v.t."],
		  wide: ["f\xF8r vesterlandsk tidsregning", "vesterlandsk tidsregning"]
		};
		var quarterValues3 = {
		  narrow: ["1", "2", "3", "4"],
		  abbreviated: ["1. kvt.", "2. kvt.", "3. kvt.", "4. kvt."],
		  wide: ["1. kvartal", "2. kvartal", "3. kvartal", "4. kvartal"]
		};
		var monthValues3 = {
		  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
		  abbreviated: [
			 "jan.",
			 "feb.",
			 "mar.",
			 "apr.",
			 "maj",
			 "jun.",
			 "jul.",
			 "aug.",
			 "sep.",
			 "okt.",
			 "nov.",
			 "dec."
		  ],
		  wide: [
			 "januar",
			 "februar",
			 "marts",
			 "april",
			 "maj",
			 "juni",
			 "juli",
			 "august",
			 "september",
			 "oktober",
			 "november",
			 "december"
		  ]
		};
		var dayValues3 = {
		  narrow: ["S", "M", "T", "O", "T", "F", "L"],
		  short: ["s\xF8", "ma", "ti", "on", "to", "fr", "l\xF8"],
		  abbreviated: ["s\xF8n.", "man.", "tir.", "ons.", "tor.", "fre.", "l\xF8r."],
		  wide: [
			 "s\xF8ndag",
			 "mandag",
			 "tirsdag",
			 "onsdag",
			 "torsdag",
			 "fredag",
			 "l\xF8rdag"
		  ]
		};
		var dayPeriodValues3 = {
		  narrow: {
			 am: "a",
			 pm: "p",
			 midnight: "midnat",
			 noon: "middag",
			 morning: "morgen",
			 afternoon: "eftermiddag",
			 evening: "aften",
			 night: "nat"
		  },
		  abbreviated: {
			 am: "AM",
			 pm: "PM",
			 midnight: "midnat",
			 noon: "middag",
			 morning: "morgen",
			 afternoon: "eftermiddag",
			 evening: "aften",
			 night: "nat"
		  },
		  wide: {
			 am: "a.m.",
			 pm: "p.m.",
			 midnight: "midnat",
			 noon: "middag",
			 morning: "morgen",
			 afternoon: "eftermiddag",
			 evening: "aften",
			 night: "nat"
		  }
		};
		var formattingDayPeriodValues3 = {
		  narrow: {
			 am: "a",
			 pm: "p",
			 midnight: "midnat",
			 noon: "middag",
			 morning: "om morgenen",
			 afternoon: "om eftermiddagen",
			 evening: "om aftenen",
			 night: "om natten"
		  },
		  abbreviated: {
			 am: "AM",
			 pm: "PM",
			 midnight: "midnat",
			 noon: "middag",
			 morning: "om morgenen",
			 afternoon: "om eftermiddagen",
			 evening: "om aftenen",
			 night: "om natten"
		  },
		  wide: {
			 am: "a.m.",
			 pm: "p.m.",
			 midnight: "midnat",
			 noon: "middag",
			 morning: "om morgenen",
			 afternoon: "om eftermiddagen",
			 evening: "om aftenen",
			 night: "om natten"
		  }
		};
		var ordinalNumber3 = (dirtyNumber, _options) => {
		  const number5 = Number(dirtyNumber);
		  return number5 + ".";
		};
		var localize3 = {
		  ordinalNumber: ordinalNumber3,
		  era: buildLocalizeFn({
			 values: eraValues3,
			 defaultWidth: "wide"
		  }),
		  quarter: buildLocalizeFn({
			 values: quarterValues3,
			 defaultWidth: "wide",
			 argumentCallback: (quarter) => quarter - 1
		  }),
		  month: buildLocalizeFn({
			 values: monthValues3,
			 defaultWidth: "wide"
		  }),
		  day: buildLocalizeFn({
			 values: dayValues3,
			 defaultWidth: "wide"
		  }),
		  dayPeriod: buildLocalizeFn({
			 values: dayPeriodValues3,
			 defaultWidth: "wide",
			 formattingValues: formattingDayPeriodValues3,
			 defaultFormattingWidth: "wide"
		  })
		};

		// node_modules/date-fns/locale/da/_lib/match.mjs
		var matchOrdinalNumberPattern3 = /^(\d+)(\.)?/i;
		var parseOrdinalNumberPattern3 = /\d+/i;
		var matchEraPatterns3 = {
		  narrow: /^(fKr|fvt|eKr|vt)/i,
		  abbreviated: /^(f\.Kr\.?|f\.v\.t\.?|e\.Kr\.?|v\.t\.)/i,
		  wide: /^(f.Kr.|fr vesterlandsk tidsregning|e.Kr.|vesterlandsk tidsregning)/i
		};
		var parseEraPatterns3 = {
		  any: [/^f/i, /^(v|e)/i]
		};
		var matchQuarterPatterns3 = {
		  narrow: /^[1234]/i,
		  abbreviated: /^[1234]. kvt\./i,
		  wide: /^[1234]\.? kvartal/i
		};
		var parseQuarterPatterns3 = {
		  any: [/1/i, /2/i, /3/i, /4/i]
		};
		var matchMonthPatterns3 = {
		  narrow: /^[jfmasond]/i,
		  abbreviated: /^(jan.|feb.|mar.|apr.|maj|jun.|jul.|aug.|sep.|okt.|nov.|dec.)/i,
		  wide: /^(januar|februar|marts|april|maj|juni|juli|august|september|oktober|november|december)/i
		};
		var parseMonthPatterns3 = {
		  narrow: [
			 /^j/i,
			 /^f/i,
			 /^m/i,
			 /^a/i,
			 /^m/i,
			 /^j/i,
			 /^j/i,
			 /^a/i,
			 /^s/i,
			 /^o/i,
			 /^n/i,
			 /^d/i
		  ],
		  any: [
			 /^ja/i,
			 /^f/i,
			 /^mar/i,
			 /^ap/i,
			 /^maj/i,
			 /^jun/i,
			 /^jul/i,
			 /^au/i,
			 /^s/i,
			 /^o/i,
			 /^n/i,
			 /^d/i
		  ]
		};
		var matchDayPatterns3 = {
		  narrow: /^[smtofl]/i,
		  short: /^(sn.|man.|tir.|ons.|tor.|fre.|lr.)/i,
		  abbreviated: /^(sn|man|tir|ons|tor|fre|lr)/i,
		  wide: /^(sndag|mandag|tirsdag|onsdag|torsdag|fredag|lrdag)/i
		};
		var parseDayPatterns3 = {
		  narrow: [/^s/i, /^m/i, /^t/i, /^o/i, /^t/i, /^f/i, /^l/i],
		  any: [/^s/i, /^m/i, /^ti/i, /^o/i, /^to/i, /^f/i, /^l/i]
		};
		var matchDayPeriodPatterns3 = {
		  narrow: /^(a|p|midnat|middag|(om) (morgenen|eftermiddagen|aftenen|natten))/i,
		  any: /^([ap]\.?\s?m\.?|midnat|middag|(om) (morgenen|eftermiddagen|aftenen|natten))/i
		};
		var parseDayPeriodPatterns3 = {
		  any: {
			 am: /^a/i,
			 pm: /^p/i,
			 midnight: /midnat/i,
			 noon: /middag/i,
			 morning: /morgen/i,
			 afternoon: /eftermiddag/i,
			 evening: /aften/i,
			 night: /nat/i
		  }
		};
		var match3 = {
		  ordinalNumber: buildMatchPatternFn({
			 matchPattern: matchOrdinalNumberPattern3,
			 parsePattern: parseOrdinalNumberPattern3,
			 valueCallback: (value) => parseInt(value, 10)
		  }),
		  era: buildMatchFn({
			 matchPatterns: matchEraPatterns3,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseEraPatterns3,
			 defaultParseWidth: "any"
		  }),
		  quarter: buildMatchFn({
			 matchPatterns: matchQuarterPatterns3,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseQuarterPatterns3,
			 defaultParseWidth: "any",
			 valueCallback: (index) => index + 1
		  }),
		  month: buildMatchFn({
			 matchPatterns: matchMonthPatterns3,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseMonthPatterns3,
			 defaultParseWidth: "any"
		  }),
		  day: buildMatchFn({
			 matchPatterns: matchDayPatterns3,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseDayPatterns3,
			 defaultParseWidth: "any"
		  }),
		  dayPeriod: buildMatchFn({
			 matchPatterns: matchDayPeriodPatterns3,
			 defaultMatchWidth: "any",
			 parsePatterns: parseDayPeriodPatterns3,
			 defaultParseWidth: "any"
		  })
		};

		// node_modules/date-fns/locale/da.mjs
		var da = {
		  code: "da",
		  formatDistance: formatDistance3,
		  formatLong: formatLong3,
		  formatRelative: formatRelative3,
		  localize: localize3,
		  match: match3,
		  options: {
			 weekStartsOn: 1,
			 firstWeekContainsDate: 4
		  }
		};

		// node_modules/date-fns/locale/de/_lib/formatDistance.mjs
		var formatDistanceLocale4 = {
		  lessThanXSeconds: {
			 standalone: {
				one: "weniger als 1 Sekunde",
				other: "weniger als {{count}} Sekunden"
			 },
			 withPreposition: {
				one: "weniger als 1 Sekunde",
				other: "weniger als {{count}} Sekunden"
			 }
		  },
		  xSeconds: {
			 standalone: {
				one: "1 Sekunde",
				other: "{{count}} Sekunden"
			 },
			 withPreposition: {
				one: "1 Sekunde",
				other: "{{count}} Sekunden"
			 }
		  },
		  halfAMinute: {
			 standalone: "eine halbe Minute",
			 withPreposition: "einer halben Minute"
		  },
		  lessThanXMinutes: {
			 standalone: {
				one: "weniger als 1 Minute",
				other: "weniger als {{count}} Minuten"
			 },
			 withPreposition: {
				one: "weniger als 1 Minute",
				other: "weniger als {{count}} Minuten"
			 }
		  },
		  xMinutes: {
			 standalone: {
				one: "1 Minute",
				other: "{{count}} Minuten"
			 },
			 withPreposition: {
				one: "1 Minute",
				other: "{{count}} Minuten"
			 }
		  },
		  aboutXHours: {
			 standalone: {
				one: "etwa 1 Stunde",
				other: "etwa {{count}} Stunden"
			 },
			 withPreposition: {
				one: "etwa 1 Stunde",
				other: "etwa {{count}} Stunden"
			 }
		  },
		  xHours: {
			 standalone: {
				one: "1 Stunde",
				other: "{{count}} Stunden"
			 },
			 withPreposition: {
				one: "1 Stunde",
				other: "{{count}} Stunden"
			 }
		  },
		  xDays: {
			 standalone: {
				one: "1 Tag",
				other: "{{count}} Tage"
			 },
			 withPreposition: {
				one: "1 Tag",
				other: "{{count}} Tagen"
			 }
		  },
		  aboutXWeeks: {
			 standalone: {
				one: "etwa 1 Woche",
				other: "etwa {{count}} Wochen"
			 },
			 withPreposition: {
				one: "etwa 1 Woche",
				other: "etwa {{count}} Wochen"
			 }
		  },
		  xWeeks: {
			 standalone: {
				one: "1 Woche",
				other: "{{count}} Wochen"
			 },
			 withPreposition: {
				one: "1 Woche",
				other: "{{count}} Wochen"
			 }
		  },
		  aboutXMonths: {
			 standalone: {
				one: "etwa 1 Monat",
				other: "etwa {{count}} Monate"
			 },
			 withPreposition: {
				one: "etwa 1 Monat",
				other: "etwa {{count}} Monaten"
			 }
		  },
		  xMonths: {
			 standalone: {
				one: "1 Monat",
				other: "{{count}} Monate"
			 },
			 withPreposition: {
				one: "1 Monat",
				other: "{{count}} Monaten"
			 }
		  },
		  aboutXYears: {
			 standalone: {
				one: "etwa 1 Jahr",
				other: "etwa {{count}} Jahre"
			 },
			 withPreposition: {
				one: "etwa 1 Jahr",
				other: "etwa {{count}} Jahren"
			 }
		  },
		  xYears: {
			 standalone: {
				one: "1 Jahr",
				other: "{{count}} Jahre"
			 },
			 withPreposition: {
				one: "1 Jahr",
				other: "{{count}} Jahren"
			 }
		  },
		  overXYears: {
			 standalone: {
				one: "mehr als 1 Jahr",
				other: "mehr als {{count}} Jahre"
			 },
			 withPreposition: {
				one: "mehr als 1 Jahr",
				other: "mehr als {{count}} Jahren"
			 }
		  },
		  almostXYears: {
			 standalone: {
				one: "fast 1 Jahr",
				other: "fast {{count}} Jahre"
			 },
			 withPreposition: {
				one: "fast 1 Jahr",
				other: "fast {{count}} Jahren"
			 }
		  }
		};
		var formatDistance4 = (token, count, options) => {
		  let result;
		  const tokenValue = options?.addSuffix ? formatDistanceLocale4[token].withPreposition : formatDistanceLocale4[token].standalone;
		  if (typeof tokenValue === "string") {
			 result = tokenValue;
		  } else if (count === 1) {
			 result = tokenValue.one;
		  } else {
			 result = tokenValue.other.replace("{{count}}", String(count));
		  }
		  if (options?.addSuffix) {
			 if (options.comparison && options.comparison > 0) {
				return "in " + result;
			 } else {
				return "vor " + result;
			 }
		  }
		  return result;
		};

		// node_modules/date-fns/locale/de/_lib/formatLong.mjs
		var dateFormats4 = {
		  full: "EEEE, do MMMM y",
		  // Montag, 7. Januar 2018
		  long: "do MMMM y",
		  // 7. Januar 2018
		  medium: "do MMM y",
		  // 7. Jan. 2018
		  short: "dd.MM.y"
		  // 07.01.2018
		};
		var timeFormats4 = {
		  full: "HH:mm:ss zzzz",
		  long: "HH:mm:ss z",
		  medium: "HH:mm:ss",
		  short: "HH:mm"
		};
		var dateTimeFormats4 = {
		  full: "{{date}} 'um' {{time}}",
		  long: "{{date}} 'um' {{time}}",
		  medium: "{{date}} {{time}}",
		  short: "{{date}} {{time}}"
		};
		var formatLong4 = {
		  date: buildFormatLongFn({
			 formats: dateFormats4,
			 defaultWidth: "full"
		  }),
		  time: buildFormatLongFn({
			 formats: timeFormats4,
			 defaultWidth: "full"
		  }),
		  dateTime: buildFormatLongFn({
			 formats: dateTimeFormats4,
			 defaultWidth: "full"
		  })
		};

		// node_modules/date-fns/locale/de/_lib/formatRelative.mjs
		var formatRelativeLocale4 = {
		  lastWeek: "'letzten' eeee 'um' p",
		  yesterday: "'gestern um' p",
		  today: "'heute um' p",
		  tomorrow: "'morgen um' p",
		  nextWeek: "eeee 'um' p",
		  other: "P"
		};
		var formatRelative4 = (token, _date, _baseDate, _options) => formatRelativeLocale4[token];

		// node_modules/date-fns/locale/de/_lib/localize.mjs
		var eraValues4 = {
		  narrow: ["v.Chr.", "n.Chr."],
		  abbreviated: ["v.Chr.", "n.Chr."],
		  wide: ["vor Christus", "nach Christus"]
		};
		var quarterValues4 = {
		  narrow: ["1", "2", "3", "4"],
		  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
		  wide: ["1. Quartal", "2. Quartal", "3. Quartal", "4. Quartal"]
		};
		var monthValues4 = {
		  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
		  abbreviated: [
			 "Jan",
			 "Feb",
			 "M\xE4r",
			 "Apr",
			 "Mai",
			 "Jun",
			 "Jul",
			 "Aug",
			 "Sep",
			 "Okt",
			 "Nov",
			 "Dez"
		  ],
		  wide: [
			 "Januar",
			 "Februar",
			 "M\xE4rz",
			 "April",
			 "Mai",
			 "Juni",
			 "Juli",
			 "August",
			 "September",
			 "Oktober",
			 "November",
			 "Dezember"
		  ]
		};
		var formattingMonthValues2 = {
		  narrow: monthValues4.narrow,
		  abbreviated: [
			 "Jan.",
			 "Feb.",
			 "M\xE4rz",
			 "Apr.",
			 "Mai",
			 "Juni",
			 "Juli",
			 "Aug.",
			 "Sep.",
			 "Okt.",
			 "Nov.",
			 "Dez."
		  ],
		  wide: monthValues4.wide
		};
		var dayValues4 = {
		  narrow: ["S", "M", "D", "M", "D", "F", "S"],
		  short: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"],
		  abbreviated: ["So.", "Mo.", "Di.", "Mi.", "Do.", "Fr.", "Sa."],
		  wide: [
			 "Sonntag",
			 "Montag",
			 "Dienstag",
			 "Mittwoch",
			 "Donnerstag",
			 "Freitag",
			 "Samstag"
		  ]
		};
		var dayPeriodValues4 = {
		  narrow: {
			 am: "vm.",
			 pm: "nm.",
			 midnight: "Mitternacht",
			 noon: "Mittag",
			 morning: "Morgen",
			 afternoon: "Nachm.",
			 evening: "Abend",
			 night: "Nacht"
		  },
		  abbreviated: {
			 am: "vorm.",
			 pm: "nachm.",
			 midnight: "Mitternacht",
			 noon: "Mittag",
			 morning: "Morgen",
			 afternoon: "Nachmittag",
			 evening: "Abend",
			 night: "Nacht"
		  },
		  wide: {
			 am: "vormittags",
			 pm: "nachmittags",
			 midnight: "Mitternacht",
			 noon: "Mittag",
			 morning: "Morgen",
			 afternoon: "Nachmittag",
			 evening: "Abend",
			 night: "Nacht"
		  }
		};
		var formattingDayPeriodValues4 = {
		  narrow: {
			 am: "vm.",
			 pm: "nm.",
			 midnight: "Mitternacht",
			 noon: "Mittag",
			 morning: "morgens",
			 afternoon: "nachm.",
			 evening: "abends",
			 night: "nachts"
		  },
		  abbreviated: {
			 am: "vorm.",
			 pm: "nachm.",
			 midnight: "Mitternacht",
			 noon: "Mittag",
			 morning: "morgens",
			 afternoon: "nachmittags",
			 evening: "abends",
			 night: "nachts"
		  },
		  wide: {
			 am: "vormittags",
			 pm: "nachmittags",
			 midnight: "Mitternacht",
			 noon: "Mittag",
			 morning: "morgens",
			 afternoon: "nachmittags",
			 evening: "abends",
			 night: "nachts"
		  }
		};
		var ordinalNumber4 = (dirtyNumber) => {
		  const number5 = Number(dirtyNumber);
		  return number5 + ".";
		};
		var localize4 = {
		  ordinalNumber: ordinalNumber4,
		  era: buildLocalizeFn({
			 values: eraValues4,
			 defaultWidth: "wide"
		  }),
		  quarter: buildLocalizeFn({
			 values: quarterValues4,
			 defaultWidth: "wide",
			 argumentCallback: (quarter) => quarter - 1
		  }),
		  month: buildLocalizeFn({
			 values: monthValues4,
			 formattingValues: formattingMonthValues2,
			 defaultWidth: "wide"
		  }),
		  day: buildLocalizeFn({
			 values: dayValues4,
			 defaultWidth: "wide"
		  }),
		  dayPeriod: buildLocalizeFn({
			 values: dayPeriodValues4,
			 defaultWidth: "wide",
			 formattingValues: formattingDayPeriodValues4,
			 defaultFormattingWidth: "wide"
		  })
		};

		// node_modules/date-fns/locale/de/_lib/match.mjs
		var matchOrdinalNumberPattern4 = /^(\d+)(\.)?/i;
		var parseOrdinalNumberPattern4 = /\d+/i;
		var matchEraPatterns4 = {
		  narrow: /^(v\.? ?Chr\.?|n\.? ?Chr\.?)/i,
		  abbreviated: /^(v\.? ?Chr\.?|n\.? ?Chr\.?)/i,
		  wide: /^(vor Christus|vor unserer Zeitrechnung|nach Christus|unserer Zeitrechnung)/i
		};
		var parseEraPatterns4 = {
		  any: [/^v/i, /^n/i]
		};
		var matchQuarterPatterns4 = {
		  narrow: /^[1234]/i,
		  abbreviated: /^q[1234]/i,
		  wide: /^[1234](\.)? Quartal/i
		};
		var parseQuarterPatterns4 = {
		  any: [/1/i, /2/i, /3/i, /4/i]
		};
		var matchMonthPatterns4 = {
		  narrow: /^[jfmasond]/i,
		  abbreviated: /^(j[a]n|feb|mr[z]?|apr|mai|jun[i]?|jul[i]?|aug|sep|okt|nov|dez)\.?/i,
		  wide: /^(januar|februar|mrz|april|mai|juni|juli|august|september|oktober|november|dezember)/i
		};
		var parseMonthPatterns4 = {
		  narrow: [
			 /^j/i,
			 /^f/i,
			 /^m/i,
			 /^a/i,
			 /^m/i,
			 /^j/i,
			 /^j/i,
			 /^a/i,
			 /^s/i,
			 /^o/i,
			 /^n/i,
			 /^d/i
		  ],
		  any: [
			 /^j[a]/i,
			 /^f/i,
			 /^mr/i,
			 /^ap/i,
			 /^mai/i,
			 /^jun/i,
			 /^jul/i,
			 /^au/i,
			 /^s/i,
			 /^o/i,
			 /^n/i,
			 /^d/i
		  ]
		};
		var matchDayPatterns4 = {
		  narrow: /^[smdmf]/i,
		  short: /^(so|mo|di|mi|do|fr|sa)/i,
		  abbreviated: /^(son?|mon?|die?|mit?|don?|fre?|sam?)\.?/i,
		  wide: /^(sonntag|montag|dienstag|mittwoch|donnerstag|freitag|samstag)/i
		};
		var parseDayPatterns4 = {
		  any: [/^so/i, /^mo/i, /^di/i, /^mi/i, /^do/i, /^f/i, /^sa/i]
		};
		var matchDayPeriodPatterns4 = {
		  narrow: /^(vm\.?|nm\.?|Mitternacht|Mittag|morgens|nachm\.?|abends|nachts)/i,
		  abbreviated: /^(vorm\.?|nachm\.?|Mitternacht|Mittag|morgens|nachm\.?|abends|nachts)/i,
		  wide: /^(vormittags|nachmittags|Mitternacht|Mittag|morgens|nachmittags|abends|nachts)/i
		};
		var parseDayPeriodPatterns4 = {
		  any: {
			 am: /^v/i,
			 pm: /^n/i,
			 midnight: /^Mitte/i,
			 noon: /^Mitta/i,
			 morning: /morgens/i,
			 afternoon: /nachmittags/i,
			 // will never be matched. Afternoon is matched by `pm`
			 evening: /abends/i,
			 night: /nachts/i
			 // will never be matched. Night is matched by `pm`
		  }
		};
		var match4 = {
		  ordinalNumber: buildMatchPatternFn({
			 matchPattern: matchOrdinalNumberPattern4,
			 parsePattern: parseOrdinalNumberPattern4,
			 valueCallback: (value) => parseInt(value)
		  }),
		  era: buildMatchFn({
			 matchPatterns: matchEraPatterns4,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseEraPatterns4,
			 defaultParseWidth: "any"
		  }),
		  quarter: buildMatchFn({
			 matchPatterns: matchQuarterPatterns4,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseQuarterPatterns4,
			 defaultParseWidth: "any",
			 valueCallback: (index) => index + 1
		  }),
		  month: buildMatchFn({
			 matchPatterns: matchMonthPatterns4,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseMonthPatterns4,
			 defaultParseWidth: "any"
		  }),
		  day: buildMatchFn({
			 matchPatterns: matchDayPatterns4,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseDayPatterns4,
			 defaultParseWidth: "any"
		  }),
		  dayPeriod: buildMatchFn({
			 matchPatterns: matchDayPeriodPatterns4,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseDayPeriodPatterns4,
			 defaultParseWidth: "any"
		  })
		};

		// node_modules/date-fns/locale/de.mjs
		var de = {
		  code: "de",
		  formatDistance: formatDistance4,
		  formatLong: formatLong4,
		  formatRelative: formatRelative4,
		  localize: localize4,
		  match: match4,
		  options: {
			 weekStartsOn: 1,
			 firstWeekContainsDate: 4
		  }
		};

		// node_modules/date-fns/locale/en-GB/_lib/formatLong.mjs
		var dateFormats5 = {
		  full: "EEEE, d MMMM yyyy",
		  long: "d MMMM yyyy",
		  medium: "d MMM yyyy",
		  short: "dd/MM/yyyy"
		};
		var timeFormats5 = {
		  full: "HH:mm:ss zzzz",
		  long: "HH:mm:ss z",
		  medium: "HH:mm:ss",
		  short: "HH:mm"
		};
		var dateTimeFormats5 = {
		  full: "{{date}} 'at' {{time}}",
		  long: "{{date}} 'at' {{time}}",
		  medium: "{{date}}, {{time}}",
		  short: "{{date}}, {{time}}"
		};
		var formatLong5 = {
		  date: buildFormatLongFn({
			 formats: dateFormats5,
			 defaultWidth: "full"
		  }),
		  time: buildFormatLongFn({
			 formats: timeFormats5,
			 defaultWidth: "full"
		  }),
		  dateTime: buildFormatLongFn({
			 formats: dateTimeFormats5,
			 defaultWidth: "full"
		  })
		};

		// node_modules/date-fns/locale/en-GB.mjs
		var enGB = {
		  code: "en-GB",
		  formatDistance,
		  formatLong: formatLong5,
		  formatRelative,
		  localize,
		  match,
		  options: {
			 weekStartsOn: 1,
			 firstWeekContainsDate: 4
		  }
		};

		// node_modules/date-fns/locale/es/_lib/formatDistance.mjs
		var formatDistanceLocale5 = {
		  lessThanXSeconds: {
			 one: "menos de un segundo",
			 other: "menos de {{count}} segundos"
		  },
		  xSeconds: {
			 one: "1 segundo",
			 other: "{{count}} segundos"
		  },
		  halfAMinute: "medio minuto",
		  lessThanXMinutes: {
			 one: "menos de un minuto",
			 other: "menos de {{count}} minutos"
		  },
		  xMinutes: {
			 one: "1 minuto",
			 other: "{{count}} minutos"
		  },
		  aboutXHours: {
			 one: "alrededor de 1 hora",
			 other: "alrededor de {{count}} horas"
		  },
		  xHours: {
			 one: "1 hora",
			 other: "{{count}} horas"
		  },
		  xDays: {
			 one: "1 d\xEDa",
			 other: "{{count}} d\xEDas"
		  },
		  aboutXWeeks: {
			 one: "alrededor de 1 semana",
			 other: "alrededor de {{count}} semanas"
		  },
		  xWeeks: {
			 one: "1 semana",
			 other: "{{count}} semanas"
		  },
		  aboutXMonths: {
			 one: "alrededor de 1 mes",
			 other: "alrededor de {{count}} meses"
		  },
		  xMonths: {
			 one: "1 mes",
			 other: "{{count}} meses"
		  },
		  aboutXYears: {
			 one: "alrededor de 1 a\xF1o",
			 other: "alrededor de {{count}} a\xF1os"
		  },
		  xYears: {
			 one: "1 a\xF1o",
			 other: "{{count}} a\xF1os"
		  },
		  overXYears: {
			 one: "m\xE1s de 1 a\xF1o",
			 other: "m\xE1s de {{count}} a\xF1os"
		  },
		  almostXYears: {
			 one: "casi 1 a\xF1o",
			 other: "casi {{count}} a\xF1os"
		  }
		};
		var formatDistance5 = (token, count, options) => {
		  let result;
		  const tokenValue = formatDistanceLocale5[token];
		  if (typeof tokenValue === "string") {
			 result = tokenValue;
		  } else if (count === 1) {
			 result = tokenValue.one;
		  } else {
			 result = tokenValue.other.replace("{{count}}", count.toString());
		  }
		  if (options?.addSuffix) {
			 if (options.comparison && options.comparison > 0) {
				return "en " + result;
			 } else {
				return "hace " + result;
			 }
		  }
		  return result;
		};

		// node_modules/date-fns/locale/es/_lib/formatLong.mjs
		var dateFormats6 = {
		  full: "EEEE, d 'de' MMMM 'de' y",
		  long: "d 'de' MMMM 'de' y",
		  medium: "d MMM y",
		  short: "dd/MM/y"
		};
		var timeFormats6 = {
		  full: "HH:mm:ss zzzz",
		  long: "HH:mm:ss z",
		  medium: "HH:mm:ss",
		  short: "HH:mm"
		};
		var dateTimeFormats6 = {
		  full: "{{date}} 'a las' {{time}}",
		  long: "{{date}} 'a las' {{time}}",
		  medium: "{{date}}, {{time}}",
		  short: "{{date}}, {{time}}"
		};
		var formatLong6 = {
		  date: buildFormatLongFn({
			 formats: dateFormats6,
			 defaultWidth: "full"
		  }),
		  time: buildFormatLongFn({
			 formats: timeFormats6,
			 defaultWidth: "full"
		  }),
		  dateTime: buildFormatLongFn({
			 formats: dateTimeFormats6,
			 defaultWidth: "full"
		  })
		};

		// node_modules/date-fns/locale/es/_lib/formatRelative.mjs
		var formatRelativeLocale5 = {
		  lastWeek: "'el' eeee 'pasado a la' p",
		  yesterday: "'ayer a la' p",
		  today: "'hoy a la' p",
		  tomorrow: "'ma\xF1ana a la' p",
		  nextWeek: "eeee 'a la' p",
		  other: "P"
		};
		var formatRelativeLocalePlural = {
		  lastWeek: "'el' eeee 'pasado a las' p",
		  yesterday: "'ayer a las' p",
		  today: "'hoy a las' p",
		  tomorrow: "'ma\xF1ana a las' p",
		  nextWeek: "eeee 'a las' p",
		  other: "P"
		};
		var formatRelative5 = (token, date2, _baseDate, _options) => {
		  if (date2.getHours() !== 1) {
			 return formatRelativeLocalePlural[token];
		  } else {
			 return formatRelativeLocale5[token];
		  }
		};

		// node_modules/date-fns/locale/es/_lib/localize.mjs
		var eraValues5 = {
		  narrow: ["AC", "DC"],
		  abbreviated: ["AC", "DC"],
		  wide: ["antes de cristo", "despu\xE9s de cristo"]
		};
		var quarterValues5 = {
		  narrow: ["1", "2", "3", "4"],
		  abbreviated: ["T1", "T2", "T3", "T4"],
		  wide: ["1\xBA trimestre", "2\xBA trimestre", "3\xBA trimestre", "4\xBA trimestre"]
		};
		var monthValues5 = {
		  narrow: ["e", "f", "m", "a", "m", "j", "j", "a", "s", "o", "n", "d"],
		  abbreviated: [
			 "ene",
			 "feb",
			 "mar",
			 "abr",
			 "may",
			 "jun",
			 "jul",
			 "ago",
			 "sep",
			 "oct",
			 "nov",
			 "dic"
		  ],
		  wide: [
			 "enero",
			 "febrero",
			 "marzo",
			 "abril",
			 "mayo",
			 "junio",
			 "julio",
			 "agosto",
			 "septiembre",
			 "octubre",
			 "noviembre",
			 "diciembre"
		  ]
		};
		var dayValues5 = {
		  narrow: ["d", "l", "m", "m", "j", "v", "s"],
		  short: ["do", "lu", "ma", "mi", "ju", "vi", "s\xE1"],
		  abbreviated: ["dom", "lun", "mar", "mi\xE9", "jue", "vie", "s\xE1b"],
		  wide: [
			 "domingo",
			 "lunes",
			 "martes",
			 "mi\xE9rcoles",
			 "jueves",
			 "viernes",
			 "s\xE1bado"
		  ]
		};
		var dayPeriodValues5 = {
		  narrow: {
			 am: "a",
			 pm: "p",
			 midnight: "mn",
			 noon: "md",
			 morning: "ma\xF1ana",
			 afternoon: "tarde",
			 evening: "tarde",
			 night: "noche"
		  },
		  abbreviated: {
			 am: "AM",
			 pm: "PM",
			 midnight: "medianoche",
			 noon: "mediodia",
			 morning: "ma\xF1ana",
			 afternoon: "tarde",
			 evening: "tarde",
			 night: "noche"
		  },
		  wide: {
			 am: "a.m.",
			 pm: "p.m.",
			 midnight: "medianoche",
			 noon: "mediodia",
			 morning: "ma\xF1ana",
			 afternoon: "tarde",
			 evening: "tarde",
			 night: "noche"
		  }
		};
		var formattingDayPeriodValues5 = {
		  narrow: {
			 am: "a",
			 pm: "p",
			 midnight: "mn",
			 noon: "md",
			 morning: "de la ma\xF1ana",
			 afternoon: "de la tarde",
			 evening: "de la tarde",
			 night: "de la noche"
		  },
		  abbreviated: {
			 am: "AM",
			 pm: "PM",
			 midnight: "medianoche",
			 noon: "mediodia",
			 morning: "de la ma\xF1ana",
			 afternoon: "de la tarde",
			 evening: "de la tarde",
			 night: "de la noche"
		  },
		  wide: {
			 am: "a.m.",
			 pm: "p.m.",
			 midnight: "medianoche",
			 noon: "mediodia",
			 morning: "de la ma\xF1ana",
			 afternoon: "de la tarde",
			 evening: "de la tarde",
			 night: "de la noche"
		  }
		};
		var ordinalNumber5 = (dirtyNumber, _options) => {
		  const number5 = Number(dirtyNumber);
		  return number5 + "\xBA";
		};
		var localize5 = {
		  ordinalNumber: ordinalNumber5,
		  era: buildLocalizeFn({
			 values: eraValues5,
			 defaultWidth: "wide"
		  }),
		  quarter: buildLocalizeFn({
			 values: quarterValues5,
			 defaultWidth: "wide",
			 argumentCallback: (quarter) => Number(quarter) - 1
		  }),
		  month: buildLocalizeFn({
			 values: monthValues5,
			 defaultWidth: "wide"
		  }),
		  day: buildLocalizeFn({
			 values: dayValues5,
			 defaultWidth: "wide"
		  }),
		  dayPeriod: buildLocalizeFn({
			 values: dayPeriodValues5,
			 defaultWidth: "wide",
			 formattingValues: formattingDayPeriodValues5,
			 defaultFormattingWidth: "wide"
		  })
		};

		// node_modules/date-fns/locale/es/_lib/match.mjs
		var matchOrdinalNumberPattern5 = /^(\d+)()?/i;
		var parseOrdinalNumberPattern5 = /\d+/i;
		var matchEraPatterns5 = {
		  narrow: /^(ac|dc|a|d)/i,
		  abbreviated: /^(a\.?\s?c\.?|a\.?\s?e\.?\s?c\.?|d\.?\s?c\.?|e\.?\s?c\.?)/i,
		  wide: /^(antes de cristo|antes de la era com[u]n|despu[e]s de cristo|era com[u]n)/i
		};
		var parseEraPatterns5 = {
		  any: [/^ac/i, /^dc/i],
		  wide: [
			 /^(antes de cristo|antes de la era com[u]n)/i,
			 /^(despu[e]s de cristo|era com[u]n)/i
		  ]
		};
		var matchQuarterPatterns5 = {
		  narrow: /^[1234]/i,
		  abbreviated: /^T[1234]/i,
		  wide: /^[1234]()? trimestre/i
		};
		var parseQuarterPatterns5 = {
		  any: [/1/i, /2/i, /3/i, /4/i]
		};
		var matchMonthPatterns5 = {
		  narrow: /^[efmajsond]/i,
		  abbreviated: /^(ene|feb|mar|abr|may|jun|jul|ago|sep|oct|nov|dic)/i,
		  wide: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i
		};
		var parseMonthPatterns5 = {
		  narrow: [
			 /^e/i,
			 /^f/i,
			 /^m/i,
			 /^a/i,
			 /^m/i,
			 /^j/i,
			 /^j/i,
			 /^a/i,
			 /^s/i,
			 /^o/i,
			 /^n/i,
			 /^d/i
		  ],
		  any: [
			 /^en/i,
			 /^feb/i,
			 /^mar/i,
			 /^abr/i,
			 /^may/i,
			 /^jun/i,
			 /^jul/i,
			 /^ago/i,
			 /^sep/i,
			 /^oct/i,
			 /^nov/i,
			 /^dic/i
		  ]
		};
		var matchDayPatterns5 = {
		  narrow: /^[dlmjvs]/i,
		  short: /^(do|lu|ma|mi|ju|vi|s[a])/i,
		  abbreviated: /^(dom|lun|mar|mi[e]|jue|vie|s[a]b)/i,
		  wide: /^(domingo|lunes|martes|mi[e]rcoles|jueves|viernes|s[a]bado)/i
		};
		var parseDayPatterns5 = {
		  narrow: [/^d/i, /^l/i, /^m/i, /^m/i, /^j/i, /^v/i, /^s/i],
		  any: [/^do/i, /^lu/i, /^ma/i, /^mi/i, /^ju/i, /^vi/i, /^sa/i]
		};
		var matchDayPeriodPatterns5 = {
		  narrow: /^(a|p|mn|md|(de la|a las) (maana|tarde|noche))/i,
		  any: /^([ap]\.?\s?m\.?|medianoche|mediodia|(de la|a las) (maana|tarde|noche))/i
		};
		var parseDayPeriodPatterns5 = {
		  any: {
			 am: /^a/i,
			 pm: /^p/i,
			 midnight: /^mn/i,
			 noon: /^md/i,
			 morning: /maana/i,
			 afternoon: /tarde/i,
			 evening: /tarde/i,
			 night: /noche/i
		  }
		};
		var match5 = {
		  ordinalNumber: buildMatchPatternFn({
			 matchPattern: matchOrdinalNumberPattern5,
			 parsePattern: parseOrdinalNumberPattern5,
			 valueCallback: function(value) {
				return parseInt(value, 10);
			 }
		  }),
		  era: buildMatchFn({
			 matchPatterns: matchEraPatterns5,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseEraPatterns5,
			 defaultParseWidth: "any"
		  }),
		  quarter: buildMatchFn({
			 matchPatterns: matchQuarterPatterns5,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseQuarterPatterns5,
			 defaultParseWidth: "any",
			 valueCallback: (index) => index + 1
		  }),
		  month: buildMatchFn({
			 matchPatterns: matchMonthPatterns5,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseMonthPatterns5,
			 defaultParseWidth: "any"
		  }),
		  day: buildMatchFn({
			 matchPatterns: matchDayPatterns5,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseDayPatterns5,
			 defaultParseWidth: "any"
		  }),
		  dayPeriod: buildMatchFn({
			 matchPatterns: matchDayPeriodPatterns5,
			 defaultMatchWidth: "any",
			 parsePatterns: parseDayPeriodPatterns5,
			 defaultParseWidth: "any"
		  })
		};

		// node_modules/date-fns/locale/es.mjs
		var es = {
		  code: "es",
		  formatDistance: formatDistance5,
		  formatLong: formatLong6,
		  formatRelative: formatRelative5,
		  localize: localize5,
		  match: match5,
		  options: {
			 weekStartsOn: 1,
			 firstWeekContainsDate: 1
		  }
		};

		// node_modules/date-fns/locale/fi/_lib/formatDistance.mjs
		function futureSeconds(text) {
		  return text.replace(/sekuntia?/, "sekunnin");
		}
		function futureMinutes(text) {
		  return text.replace(/minuuttia?/, "minuutin");
		}
		function futureHours(text) {
		  return text.replace(/tuntia?/, "tunnin");
		}
		function futureDays(text) {
		  return text.replace(/piv?/, "p\xE4iv\xE4n");
		}
		function futureWeeks(text) {
		  return text.replace(/(viikko|viikkoa)/, "viikon");
		}
		function futureMonths(text) {
		  return text.replace(/(kuukausi|kuukautta)/, "kuukauden");
		}
		function futureYears(text) {
		  return text.replace(/(vuosi|vuotta)/, "vuoden");
		}
		var formatDistanceLocale6 = {
		  lessThanXSeconds: {
			 one: "alle sekunti",
			 other: "alle {{count}} sekuntia",
			 futureTense: futureSeconds
		  },
		  xSeconds: {
			 one: "sekunti",
			 other: "{{count}} sekuntia",
			 futureTense: futureSeconds
		  },
		  halfAMinute: {
			 one: "puoli minuuttia",
			 other: "puoli minuuttia",
			 futureTense: (_text) => "puolen minuutin"
		  },
		  lessThanXMinutes: {
			 one: "alle minuutti",
			 other: "alle {{count}} minuuttia",
			 futureTense: futureMinutes
		  },
		  xMinutes: {
			 one: "minuutti",
			 other: "{{count}} minuuttia",
			 futureTense: futureMinutes
		  },
		  aboutXHours: {
			 one: "noin tunti",
			 other: "noin {{count}} tuntia",
			 futureTense: futureHours
		  },
		  xHours: {
			 one: "tunti",
			 other: "{{count}} tuntia",
			 futureTense: futureHours
		  },
		  xDays: {
			 one: "p\xE4iv\xE4",
			 other: "{{count}} p\xE4iv\xE4\xE4",
			 futureTense: futureDays
		  },
		  aboutXWeeks: {
			 one: "noin viikko",
			 other: "noin {{count}} viikkoa",
			 futureTense: futureWeeks
		  },
		  xWeeks: {
			 one: "viikko",
			 other: "{{count}} viikkoa",
			 futureTense: futureWeeks
		  },
		  aboutXMonths: {
			 one: "noin kuukausi",
			 other: "noin {{count}} kuukautta",
			 futureTense: futureMonths
		  },
		  xMonths: {
			 one: "kuukausi",
			 other: "{{count}} kuukautta",
			 futureTense: futureMonths
		  },
		  aboutXYears: {
			 one: "noin vuosi",
			 other: "noin {{count}} vuotta",
			 futureTense: futureYears
		  },
		  xYears: {
			 one: "vuosi",
			 other: "{{count}} vuotta",
			 futureTense: futureYears
		  },
		  overXYears: {
			 one: "yli vuosi",
			 other: "yli {{count}} vuotta",
			 futureTense: futureYears
		  },
		  almostXYears: {
			 one: "l\xE4hes vuosi",
			 other: "l\xE4hes {{count}} vuotta",
			 futureTense: futureYears
		  }
		};
		var formatDistance6 = (token, count, options) => {
		  const tokenValue = formatDistanceLocale6[token];
		  const result = count === 1 ? tokenValue.one : tokenValue.other.replace("{{count}}", String(count));
		  if (options?.addSuffix) {
			 if (options.comparison && options.comparison > 0) {
				return tokenValue.futureTense(result) + " kuluttua";
			 } else {
				return result + " sitten";
			 }
		  }
		  return result;
		};

		// node_modules/date-fns/locale/fi/_lib/formatLong.mjs
		var dateFormats7 = {
		  full: "eeee d. MMMM y",
		  long: "d. MMMM y",
		  medium: "d. MMM y",
		  short: "d.M.y"
		};
		var timeFormats7 = {
		  full: "HH.mm.ss zzzz",
		  long: "HH.mm.ss z",
		  medium: "HH.mm.ss",
		  short: "HH.mm"
		};
		var dateTimeFormats7 = {
		  full: "{{date}} 'klo' {{time}}",
		  long: "{{date}} 'klo' {{time}}",
		  medium: "{{date}} {{time}}",
		  short: "{{date}} {{time}}"
		};
		var formatLong7 = {
		  date: buildFormatLongFn({
			 formats: dateFormats7,
			 defaultWidth: "full"
		  }),
		  time: buildFormatLongFn({
			 formats: timeFormats7,
			 defaultWidth: "full"
		  }),
		  dateTime: buildFormatLongFn({
			 formats: dateTimeFormats7,
			 defaultWidth: "full"
		  })
		};

		// node_modules/date-fns/locale/fi/_lib/formatRelative.mjs
		var formatRelativeLocale6 = {
		  lastWeek: "'viime' eeee 'klo' p",
		  yesterday: "'eilen klo' p",
		  today: "'t\xE4n\xE4\xE4n klo' p",
		  tomorrow: "'huomenna klo' p",
		  nextWeek: "'ensi' eeee 'klo' p",
		  other: "P"
		};
		var formatRelative6 = (token, _date, _baseDate, _options) => formatRelativeLocale6[token];

		// node_modules/date-fns/locale/fi/_lib/localize.mjs
		var eraValues6 = {
		  narrow: ["eaa.", "jaa."],
		  abbreviated: ["eaa.", "jaa."],
		  wide: ["ennen ajanlaskun alkua", "j\xE4lkeen ajanlaskun alun"]
		};
		var quarterValues6 = {
		  narrow: ["1", "2", "3", "4"],
		  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
		  wide: ["1. kvartaali", "2. kvartaali", "3. kvartaali", "4. kvartaali"]
		};
		var monthValues6 = {
		  narrow: ["T", "H", "M", "H", "T", "K", "H", "E", "S", "L", "M", "J"],
		  abbreviated: [
			 "tammi",
			 "helmi",
			 "maalis",
			 "huhti",
			 "touko",
			 "kes\xE4",
			 "hein\xE4",
			 "elo",
			 "syys",
			 "loka",
			 "marras",
			 "joulu"
		  ],
		  wide: [
			 "tammikuu",
			 "helmikuu",
			 "maaliskuu",
			 "huhtikuu",
			 "toukokuu",
			 "kes\xE4kuu",
			 "hein\xE4kuu",
			 "elokuu",
			 "syyskuu",
			 "lokakuu",
			 "marraskuu",
			 "joulukuu"
		  ]
		};
		var formattingMonthValues3 = {
		  narrow: monthValues6.narrow,
		  abbreviated: monthValues6.abbreviated,
		  wide: [
			 "tammikuuta",
			 "helmikuuta",
			 "maaliskuuta",
			 "huhtikuuta",
			 "toukokuuta",
			 "kes\xE4kuuta",
			 "hein\xE4kuuta",
			 "elokuuta",
			 "syyskuuta",
			 "lokakuuta",
			 "marraskuuta",
			 "joulukuuta"
		  ]
		};
		var dayValues6 = {
		  narrow: ["S", "M", "T", "K", "T", "P", "L"],
		  short: ["su", "ma", "ti", "ke", "to", "pe", "la"],
		  abbreviated: ["sunn.", "maan.", "tiis.", "kesk.", "torst.", "perj.", "la"],
		  wide: [
			 "sunnuntai",
			 "maanantai",
			 "tiistai",
			 "keskiviikko",
			 "torstai",
			 "perjantai",
			 "lauantai"
		  ]
		};
		var formattingDayValues = {
		  narrow: dayValues6.narrow,
		  short: dayValues6.short,
		  abbreviated: dayValues6.abbreviated,
		  wide: [
			 "sunnuntaina",
			 "maanantaina",
			 "tiistaina",
			 "keskiviikkona",
			 "torstaina",
			 "perjantaina",
			 "lauantaina"
		  ]
		};
		var dayPeriodValues6 = {
		  narrow: {
			 am: "ap",
			 pm: "ip",
			 midnight: "keskiy\xF6",
			 noon: "keskip\xE4iv\xE4",
			 morning: "ap",
			 afternoon: "ip",
			 evening: "illalla",
			 night: "y\xF6ll\xE4"
		  },
		  abbreviated: {
			 am: "ap",
			 pm: "ip",
			 midnight: "keskiy\xF6",
			 noon: "keskip\xE4iv\xE4",
			 morning: "ap",
			 afternoon: "ip",
			 evening: "illalla",
			 night: "y\xF6ll\xE4"
		  },
		  wide: {
			 am: "ap",
			 pm: "ip",
			 midnight: "keskiy\xF6ll\xE4",
			 noon: "keskip\xE4iv\xE4ll\xE4",
			 morning: "aamup\xE4iv\xE4ll\xE4",
			 afternoon: "iltap\xE4iv\xE4ll\xE4",
			 evening: "illalla",
			 night: "y\xF6ll\xE4"
		  }
		};
		var ordinalNumber6 = (dirtyNumber, _options) => {
		  const number5 = Number(dirtyNumber);
		  return number5 + ".";
		};
		var localize6 = {
		  ordinalNumber: ordinalNumber6,
		  era: buildLocalizeFn({
			 values: eraValues6,
			 defaultWidth: "wide"
		  }),
		  quarter: buildLocalizeFn({
			 values: quarterValues6,
			 defaultWidth: "wide",
			 argumentCallback: (quarter) => quarter - 1
		  }),
		  month: buildLocalizeFn({
			 values: monthValues6,
			 defaultWidth: "wide",
			 formattingValues: formattingMonthValues3,
			 defaultFormattingWidth: "wide"
		  }),
		  day: buildLocalizeFn({
			 values: dayValues6,
			 defaultWidth: "wide",
			 formattingValues: formattingDayValues,
			 defaultFormattingWidth: "wide"
		  }),
		  dayPeriod: buildLocalizeFn({
			 values: dayPeriodValues6,
			 defaultWidth: "wide"
		  })
		};

		// node_modules/date-fns/locale/fi/_lib/match.mjs
		var matchOrdinalNumberPattern6 = /^(\d+)(\.)/i;
		var parseOrdinalNumberPattern6 = /\d+/i;
		var matchEraPatterns6 = {
		  narrow: /^(e|j)/i,
		  abbreviated: /^(eaa.|jaa.)/i,
		  wide: /^(ennen ajanlaskun alkua|jlkeen ajanlaskun alun)/i
		};
		var parseEraPatterns6 = {
		  any: [/^e/i, /^j/i]
		};
		var matchQuarterPatterns6 = {
		  narrow: /^[1234]/i,
		  abbreviated: /^q[1234]/i,
		  wide: /^[1234]\.? kvartaali/i
		};
		var parseQuarterPatterns6 = {
		  any: [/1/i, /2/i, /3/i, /4/i]
		};
		var matchMonthPatterns6 = {
		  narrow: /^[thmkeslj]/i,
		  abbreviated: /^(tammi|helmi|maalis|huhti|touko|kes|hein|elo|syys|loka|marras|joulu)/i,
		  wide: /^(tammikuu|helmikuu|maaliskuu|huhtikuu|toukokuu|keskuu|heinkuu|elokuu|syyskuu|lokakuu|marraskuu|joulukuu)(ta)?/i
		};
		var parseMonthPatterns6 = {
		  narrow: [
			 /^t/i,
			 /^h/i,
			 /^m/i,
			 /^h/i,
			 /^t/i,
			 /^k/i,
			 /^h/i,
			 /^e/i,
			 /^s/i,
			 /^l/i,
			 /^m/i,
			 /^j/i
		  ],
		  any: [
			 /^ta/i,
			 /^hel/i,
			 /^maa/i,
			 /^hu/i,
			 /^to/i,
			 /^k/i,
			 /^hei/i,
			 /^e/i,
			 /^s/i,
			 /^l/i,
			 /^mar/i,
			 /^j/i
		  ]
		};
		var matchDayPatterns6 = {
		  narrow: /^[smtkpl]/i,
		  short: /^(su|ma|ti|ke|to|pe|la)/i,
		  abbreviated: /^(sunn.|maan.|tiis.|kesk.|torst.|perj.|la)/i,
		  wide: /^(sunnuntai|maanantai|tiistai|keskiviikko|torstai|perjantai|lauantai)(na)?/i
		};
		var parseDayPatterns6 = {
		  narrow: [/^s/i, /^m/i, /^t/i, /^k/i, /^t/i, /^p/i, /^l/i],
		  any: [/^s/i, /^m/i, /^ti/i, /^k/i, /^to/i, /^p/i, /^l/i]
		};
		var matchDayPeriodPatterns6 = {
		  narrow: /^(ap|ip|keskiy|keskipiv|aamupivll|iltapivll|illalla|yll)/i,
		  any: /^(ap|ip|keskiyll|keskipivll|aamupivll|iltapivll|illalla|yll)/i
		};
		var parseDayPeriodPatterns6 = {
		  any: {
			 am: /^ap/i,
			 pm: /^ip/i,
			 midnight: /^keskiy/i,
			 noon: /^keskipiv/i,
			 morning: /aamupivll/i,
			 afternoon: /iltapivll/i,
			 evening: /illalla/i,
			 night: /yll/i
		  }
		};
		var match6 = {
		  ordinalNumber: buildMatchPatternFn({
			 matchPattern: matchOrdinalNumberPattern6,
			 parsePattern: parseOrdinalNumberPattern6,
			 valueCallback: (value) => parseInt(value, 10)
		  }),
		  era: buildMatchFn({
			 matchPatterns: matchEraPatterns6,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseEraPatterns6,
			 defaultParseWidth: "any"
		  }),
		  quarter: buildMatchFn({
			 matchPatterns: matchQuarterPatterns6,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseQuarterPatterns6,
			 defaultParseWidth: "any",
			 valueCallback: (index) => index + 1
		  }),
		  month: buildMatchFn({
			 matchPatterns: matchMonthPatterns6,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseMonthPatterns6,
			 defaultParseWidth: "any"
		  }),
		  day: buildMatchFn({
			 matchPatterns: matchDayPatterns6,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseDayPatterns6,
			 defaultParseWidth: "any"
		  }),
		  dayPeriod: buildMatchFn({
			 matchPatterns: matchDayPeriodPatterns6,
			 defaultMatchWidth: "any",
			 parsePatterns: parseDayPeriodPatterns6,
			 defaultParseWidth: "any"
		  })
		};

		// node_modules/date-fns/locale/fi.mjs
		var fi = {
		  code: "fi",
		  formatDistance: formatDistance6,
		  formatLong: formatLong7,
		  formatRelative: formatRelative6,
		  localize: localize6,
		  match: match6,
		  options: {
			 weekStartsOn: 1,
			 firstWeekContainsDate: 4
		  }
		};

		// node_modules/date-fns/locale/fr/_lib/formatDistance.mjs
		var formatDistanceLocale7 = {
		  lessThanXSeconds: {
			 one: "moins d\u2019une seconde",
			 other: "moins de {{count}} secondes"
		  },
		  xSeconds: {
			 one: "1 seconde",
			 other: "{{count}} secondes"
		  },
		  halfAMinute: "30 secondes",
		  lessThanXMinutes: {
			 one: "moins d\u2019une minute",
			 other: "moins de {{count}} minutes"
		  },
		  xMinutes: {
			 one: "1 minute",
			 other: "{{count}} minutes"
		  },
		  aboutXHours: {
			 one: "environ 1 heure",
			 other: "environ {{count}} heures"
		  },
		  xHours: {
			 one: "1 heure",
			 other: "{{count}} heures"
		  },
		  xDays: {
			 one: "1 jour",
			 other: "{{count}} jours"
		  },
		  aboutXWeeks: {
			 one: "environ 1 semaine",
			 other: "environ {{count}} semaines"
		  },
		  xWeeks: {
			 one: "1 semaine",
			 other: "{{count}} semaines"
		  },
		  aboutXMonths: {
			 one: "environ 1 mois",
			 other: "environ {{count}} mois"
		  },
		  xMonths: {
			 one: "1 mois",
			 other: "{{count}} mois"
		  },
		  aboutXYears: {
			 one: "environ 1 an",
			 other: "environ {{count}} ans"
		  },
		  xYears: {
			 one: "1 an",
			 other: "{{count}} ans"
		  },
		  overXYears: {
			 one: "plus d\u2019un an",
			 other: "plus de {{count}} ans"
		  },
		  almostXYears: {
			 one: "presqu\u2019un an",
			 other: "presque {{count}} ans"
		  }
		};
		var formatDistance7 = (token, count, options) => {
		  let result;
		  const form = formatDistanceLocale7[token];
		  if (typeof form === "string") {
			 result = form;
		  } else if (count === 1) {
			 result = form.one;
		  } else {
			 result = form.other.replace("{{count}}", String(count));
		  }
		  if (options?.addSuffix) {
			 if (options.comparison && options.comparison > 0) {
				return "dans " + result;
			 } else {
				return "il y a " + result;
			 }
		  }
		  return result;
		};

		// node_modules/date-fns/locale/fr/_lib/formatLong.mjs
		var dateFormats8 = {
		  full: "EEEE d MMMM y",
		  long: "d MMMM y",
		  medium: "d MMM y",
		  short: "dd/MM/y"
		};
		var timeFormats8 = {
		  full: "HH:mm:ss zzzz",
		  long: "HH:mm:ss z",
		  medium: "HH:mm:ss",
		  short: "HH:mm"
		};
		var dateTimeFormats8 = {
		  full: "{{date}} '\xE0' {{time}}",
		  long: "{{date}} '\xE0' {{time}}",
		  medium: "{{date}}, {{time}}",
		  short: "{{date}}, {{time}}"
		};
		var formatLong8 = {
		  date: buildFormatLongFn({
			 formats: dateFormats8,
			 defaultWidth: "full"
		  }),
		  time: buildFormatLongFn({
			 formats: timeFormats8,
			 defaultWidth: "full"
		  }),
		  dateTime: buildFormatLongFn({
			 formats: dateTimeFormats8,
			 defaultWidth: "full"
		  })
		};

		// node_modules/date-fns/locale/fr/_lib/formatRelative.mjs
		var formatRelativeLocale7 = {
		  lastWeek: "eeee 'dernier \xE0' p",
		  yesterday: "'hier \xE0' p",
		  today: "'aujourd\u2019hui \xE0' p",
		  tomorrow: "'demain \xE0' p'",
		  nextWeek: "eeee 'prochain \xE0' p",
		  other: "P"
		};
		var formatRelative7 = (token, _date, _baseDate, _options) => formatRelativeLocale7[token];

		// node_modules/date-fns/locale/fr/_lib/localize.mjs
		var eraValues7 = {
		  narrow: ["av. J.-C", "ap. J.-C"],
		  abbreviated: ["av. J.-C", "ap. J.-C"],
		  wide: ["avant J\xE9sus-Christ", "apr\xE8s J\xE9sus-Christ"]
		};
		var quarterValues7 = {
		  narrow: ["T1", "T2", "T3", "T4"],
		  abbreviated: ["1er trim.", "2\xE8me trim.", "3\xE8me trim.", "4\xE8me trim."],
		  wide: ["1er trimestre", "2\xE8me trimestre", "3\xE8me trimestre", "4\xE8me trimestre"]
		};
		var monthValues7 = {
		  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
		  abbreviated: [
			 "janv.",
			 "f\xE9vr.",
			 "mars",
			 "avr.",
			 "mai",
			 "juin",
			 "juil.",
			 "ao\xFBt",
			 "sept.",
			 "oct.",
			 "nov.",
			 "d\xE9c."
		  ],
		  wide: [
			 "janvier",
			 "f\xE9vrier",
			 "mars",
			 "avril",
			 "mai",
			 "juin",
			 "juillet",
			 "ao\xFBt",
			 "septembre",
			 "octobre",
			 "novembre",
			 "d\xE9cembre"
		  ]
		};
		var dayValues7 = {
		  narrow: ["D", "L", "M", "M", "J", "V", "S"],
		  short: ["di", "lu", "ma", "me", "je", "ve", "sa"],
		  abbreviated: ["dim.", "lun.", "mar.", "mer.", "jeu.", "ven.", "sam."],
		  wide: [
			 "dimanche",
			 "lundi",
			 "mardi",
			 "mercredi",
			 "jeudi",
			 "vendredi",
			 "samedi"
		  ]
		};
		var dayPeriodValues7 = {
		  narrow: {
			 am: "AM",
			 pm: "PM",
			 midnight: "minuit",
			 noon: "midi",
			 morning: "mat.",
			 afternoon: "ap.m.",
			 evening: "soir",
			 night: "mat."
		  },
		  abbreviated: {
			 am: "AM",
			 pm: "PM",
			 midnight: "minuit",
			 noon: "midi",
			 morning: "matin",
			 afternoon: "apr\xE8s-midi",
			 evening: "soir",
			 night: "matin"
		  },
		  wide: {
			 am: "AM",
			 pm: "PM",
			 midnight: "minuit",
			 noon: "midi",
			 morning: "du matin",
			 afternoon: "de l\u2019apr\xE8s-midi",
			 evening: "du soir",
			 night: "du matin"
		  }
		};
		var ordinalNumber7 = (dirtyNumber, options) => {
		  const number5 = Number(dirtyNumber);
		  const unit2 = options?.unit;
		  if (number5 === 0)
			 return "0";
		  const feminineUnits = ["year", "week", "hour", "minute", "second"];
		  let suffix;
		  if (number5 === 1) {
			 suffix = unit2 && feminineUnits.includes(unit2) ? "\xE8re" : "er";
		  } else {
			 suffix = "\xE8me";
		  }
		  return number5 + suffix;
		};
		var LONG_MONTHS_TOKENS = ["MMM", "MMMM"];
		var localize7 = {
		  preprocessor: (date2, parts) => {
			 if (date2.getDate() === 1)
				return parts;
			 const hasLongMonthToken = parts.some(
				(part) => part.isToken && LONG_MONTHS_TOKENS.includes(part.value)
			 );
			 if (!hasLongMonthToken)
				return parts;
			 return parts.map(
				(part) => part.isToken && part.value === "do" ? { isToken: true, value: "d" } : part
			 );
		  },
		  ordinalNumber: ordinalNumber7,
		  era: buildLocalizeFn({
			 values: eraValues7,
			 defaultWidth: "wide"
		  }),
		  quarter: buildLocalizeFn({
			 values: quarterValues7,
			 defaultWidth: "wide",
			 argumentCallback: (quarter) => quarter - 1
		  }),
		  month: buildLocalizeFn({
			 values: monthValues7,
			 defaultWidth: "wide"
		  }),
		  day: buildLocalizeFn({
			 values: dayValues7,
			 defaultWidth: "wide"
		  }),
		  dayPeriod: buildLocalizeFn({
			 values: dayPeriodValues7,
			 defaultWidth: "wide"
		  })
		};

		// node_modules/date-fns/locale/fr/_lib/match.mjs
		var matchOrdinalNumberPattern7 = /^(\d+)(ime|re|me|er|e)?/i;
		var parseOrdinalNumberPattern7 = /\d+/i;
		var matchEraPatterns7 = {
		  narrow: /^(av\.J\.C|ap\.J\.C|ap\.J\.-C)/i,
		  abbreviated: /^(av\.J\.-C|av\.J-C|apr\.J\.-C|apr\.J-C|ap\.J-C)/i,
		  wide: /^(avant Jsus-Christ|aprs Jsus-Christ)/i
		};
		var parseEraPatterns7 = {
		  any: [/^av/i, /^ap/i]
		};
		var matchQuarterPatterns7 = {
		  narrow: /^T?[1234]/i,
		  abbreviated: /^[1234](er|me|e)? trim\.?/i,
		  wide: /^[1234](er|me|e)? trimestre/i
		};
		var parseQuarterPatterns7 = {
		  any: [/1/i, /2/i, /3/i, /4/i]
		};
		var matchMonthPatterns7 = {
		  narrow: /^[jfmasond]/i,
		  abbreviated: /^(janv|fvr|mars|avr|mai|juin|juill|juil|aot|sept|oct|nov|dc)\.?/i,
		  wide: /^(janvier|fvrier|mars|avril|mai|juin|juillet|aot|septembre|octobre|novembre|dcembre)/i
		};
		var parseMonthPatterns7 = {
		  narrow: [
			 /^j/i,
			 /^f/i,
			 /^m/i,
			 /^a/i,
			 /^m/i,
			 /^j/i,
			 /^j/i,
			 /^a/i,
			 /^s/i,
			 /^o/i,
			 /^n/i,
			 /^d/i
		  ],
		  any: [
			 /^ja/i,
			 /^f/i,
			 /^mar/i,
			 /^av/i,
			 /^ma/i,
			 /^juin/i,
			 /^juil/i,
			 /^ao/i,
			 /^s/i,
			 /^o/i,
			 /^n/i,
			 /^d/i
		  ]
		};
		var matchDayPatterns7 = {
		  narrow: /^[lmjvsd]/i,
		  short: /^(di|lu|ma|me|je|ve|sa)/i,
		  abbreviated: /^(dim|lun|mar|mer|jeu|ven|sam)\.?/i,
		  wide: /^(dimanche|lundi|mardi|mercredi|jeudi|vendredi|samedi)/i
		};
		var parseDayPatterns7 = {
		  narrow: [/^d/i, /^l/i, /^m/i, /^m/i, /^j/i, /^v/i, /^s/i],
		  any: [/^di/i, /^lu/i, /^ma/i, /^me/i, /^je/i, /^ve/i, /^sa/i]
		};
		var matchDayPeriodPatterns7 = {
		  narrow: /^(a|p|minuit|midi|mat\.?|ap\.?m\.?|soir|nuit)/i,
		  any: /^([ap]\.?\s?m\.?|du matin|de l'aprs[-\s]midi|du soir|de la nuit)/i
		};
		var parseDayPeriodPatterns7 = {
		  any: {
			 am: /^a/i,
			 pm: /^p/i,
			 midnight: /^min/i,
			 noon: /^mid/i,
			 morning: /mat/i,
			 afternoon: /ap/i,
			 evening: /soir/i,
			 night: /nuit/i
		  }
		};
		var match7 = {
		  ordinalNumber: buildMatchPatternFn({
			 matchPattern: matchOrdinalNumberPattern7,
			 parsePattern: parseOrdinalNumberPattern7,
			 valueCallback: (value) => parseInt(value)
		  }),
		  era: buildMatchFn({
			 matchPatterns: matchEraPatterns7,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseEraPatterns7,
			 defaultParseWidth: "any"
		  }),
		  quarter: buildMatchFn({
			 matchPatterns: matchQuarterPatterns7,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseQuarterPatterns7,
			 defaultParseWidth: "any",
			 valueCallback: (index) => index + 1
		  }),
		  month: buildMatchFn({
			 matchPatterns: matchMonthPatterns7,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseMonthPatterns7,
			 defaultParseWidth: "any"
		  }),
		  day: buildMatchFn({
			 matchPatterns: matchDayPatterns7,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseDayPatterns7,
			 defaultParseWidth: "any"
		  }),
		  dayPeriod: buildMatchFn({
			 matchPatterns: matchDayPeriodPatterns7,
			 defaultMatchWidth: "any",
			 parsePatterns: parseDayPeriodPatterns7,
			 defaultParseWidth: "any"
		  })
		};

		// node_modules/date-fns/locale/fr.mjs
		var fr = {
		  code: "fr",
		  formatDistance: formatDistance7,
		  formatLong: formatLong8,
		  formatRelative: formatRelative7,
		  localize: localize7,
		  match: match7,
		  options: {
			 weekStartsOn: 1,
			 firstWeekContainsDate: 4
		  }
		};

		// node_modules/date-fns/locale/fr-CH/_lib/formatLong.mjs
		var dateFormats9 = {
		  full: "EEEE d MMMM y",
		  long: "d MMMM y",
		  medium: "d MMM y",
		  short: "dd.MM.y"
		};
		var timeFormats9 = {
		  full: "HH:mm:ss zzzz",
		  long: "HH:mm:ss z",
		  medium: "HH:mm:ss",
		  short: "HH:mm"
		};
		var dateTimeFormats9 = {
		  full: "{{date}} '\xE0' {{time}}",
		  long: "{{date}} '\xE0' {{time}}",
		  medium: "{{date}}, {{time}}",
		  short: "{{date}}, {{time}}"
		};
		var formatLong9 = {
		  date: buildFormatLongFn({
			 formats: dateFormats9,
			 defaultWidth: "full"
		  }),
		  time: buildFormatLongFn({
			 formats: timeFormats9,
			 defaultWidth: "full"
		  }),
		  dateTime: buildFormatLongFn({
			 formats: dateTimeFormats9,
			 defaultWidth: "full"
		  })
		};

		// node_modules/date-fns/locale/fr-CH/_lib/formatRelative.mjs
		var formatRelativeLocale8 = {
		  lastWeek: "eeee 'la semaine derni\xE8re \xE0' p",
		  yesterday: "'hier \xE0' p",
		  today: "'aujourd\u2019hui \xE0' p",
		  tomorrow: "'demain \xE0' p'",
		  nextWeek: "eeee 'la semaine prochaine \xE0' p",
		  other: "P"
		};
		var formatRelative8 = (token, _date, _baseDate, _options) => formatRelativeLocale8[token];

		// node_modules/date-fns/locale/fr-CH.mjs
		var frCH = {
		  code: "fr-CH",
		  formatDistance: formatDistance7,
		  formatLong: formatLong9,
		  formatRelative: formatRelative8,
		  localize: localize7,
		  match: match7,
		  options: {
			 weekStartsOn: 1,
			 firstWeekContainsDate: 4
		  }
		};

		// node_modules/date-fns/locale/id/_lib/formatDistance.mjs
		var formatDistanceLocale8 = {
		  lessThanXSeconds: {
			 one: "kurang dari 1 detik",
			 other: "kurang dari {{count}} detik"
		  },
		  xSeconds: {
			 one: "1 detik",
			 other: "{{count}} detik"
		  },
		  halfAMinute: "setengah menit",
		  lessThanXMinutes: {
			 one: "kurang dari 1 menit",
			 other: "kurang dari {{count}} menit"
		  },
		  xMinutes: {
			 one: "1 menit",
			 other: "{{count}} menit"
		  },
		  aboutXHours: {
			 one: "sekitar 1 jam",
			 other: "sekitar {{count}} jam"
		  },
		  xHours: {
			 one: "1 jam",
			 other: "{{count}} jam"
		  },
		  xDays: {
			 one: "1 hari",
			 other: "{{count}} hari"
		  },
		  aboutXWeeks: {
			 one: "sekitar 1 minggu",
			 other: "sekitar {{count}} minggu"
		  },
		  xWeeks: {
			 one: "1 minggu",
			 other: "{{count}} minggu"
		  },
		  aboutXMonths: {
			 one: "sekitar 1 bulan",
			 other: "sekitar {{count}} bulan"
		  },
		  xMonths: {
			 one: "1 bulan",
			 other: "{{count}} bulan"
		  },
		  aboutXYears: {
			 one: "sekitar 1 tahun",
			 other: "sekitar {{count}} tahun"
		  },
		  xYears: {
			 one: "1 tahun",
			 other: "{{count}} tahun"
		  },
		  overXYears: {
			 one: "lebih dari 1 tahun",
			 other: "lebih dari {{count}} tahun"
		  },
		  almostXYears: {
			 one: "hampir 1 tahun",
			 other: "hampir {{count}} tahun"
		  }
		};
		var formatDistance8 = (token, count, options) => {
		  let result;
		  const tokenValue = formatDistanceLocale8[token];
		  if (typeof tokenValue === "string") {
			 result = tokenValue;
		  } else if (count === 1) {
			 result = tokenValue.one;
		  } else {
			 result = tokenValue.other.replace("{{count}}", count.toString());
		  }
		  if (options?.addSuffix) {
			 if (options.comparison && options.comparison > 0) {
				return "dalam waktu " + result;
			 } else {
				return result + " yang lalu";
			 }
		  }
		  return result;
		};

		// node_modules/date-fns/locale/id/_lib/formatLong.mjs
		var dateFormats10 = {
		  full: "EEEE, d MMMM yyyy",
		  long: "d MMMM yyyy",
		  medium: "d MMM yyyy",
		  short: "d/M/yyyy"
		};
		var timeFormats10 = {
		  full: "HH.mm.ss",
		  long: "HH.mm.ss",
		  medium: "HH.mm",
		  short: "HH.mm"
		};
		var dateTimeFormats10 = {
		  full: "{{date}} 'pukul' {{time}}",
		  long: "{{date}} 'pukul' {{time}}",
		  medium: "{{date}}, {{time}}",
		  short: "{{date}}, {{time}}"
		};
		var formatLong10 = {
		  date: buildFormatLongFn({
			 formats: dateFormats10,
			 defaultWidth: "full"
		  }),
		  time: buildFormatLongFn({
			 formats: timeFormats10,
			 defaultWidth: "full"
		  }),
		  dateTime: buildFormatLongFn({
			 formats: dateTimeFormats10,
			 defaultWidth: "full"
		  })
		};

		// node_modules/date-fns/locale/id/_lib/formatRelative.mjs
		var formatRelativeLocale9 = {
		  lastWeek: "eeee 'lalu pukul' p",
		  yesterday: "'Kemarin pukul' p",
		  today: "'Hari ini pukul' p",
		  tomorrow: "'Besok pukul' p",
		  nextWeek: "eeee 'pukul' p",
		  other: "P"
		};
		var formatRelative9 = (token, _date, _baseDate, _options) => formatRelativeLocale9[token];

		// node_modules/date-fns/locale/id/_lib/localize.mjs
		var eraValues8 = {
		  narrow: ["SM", "M"],
		  abbreviated: ["SM", "M"],
		  wide: ["Sebelum Masehi", "Masehi"]
		};
		var quarterValues8 = {
		  narrow: ["1", "2", "3", "4"],
		  abbreviated: ["K1", "K2", "K3", "K4"],
		  wide: ["Kuartal ke-1", "Kuartal ke-2", "Kuartal ke-3", "Kuartal ke-4"]
		};
		var monthValues8 = {
		  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
		  abbreviated: [
			 "Jan",
			 "Feb",
			 "Mar",
			 "Apr",
			 "Mei",
			 "Jun",
			 "Jul",
			 "Agt",
			 "Sep",
			 "Okt",
			 "Nov",
			 "Des"
		  ],
		  wide: [
			 "Januari",
			 "Februari",
			 "Maret",
			 "April",
			 "Mei",
			 "Juni",
			 "Juli",
			 "Agustus",
			 "September",
			 "Oktober",
			 "November",
			 "Desember"
		  ]
		};
		var dayValues8 = {
		  narrow: ["M", "S", "S", "R", "K", "J", "S"],
		  short: ["Min", "Sen", "Sel", "Rab", "Kam", "Jum", "Sab"],
		  abbreviated: ["Min", "Sen", "Sel", "Rab", "Kam", "Jum", "Sab"],
		  wide: ["Minggu", "Senin", "Selasa", "Rabu", "Kamis", "Jumat", "Sabtu"]
		};
		var dayPeriodValues8 = {
		  narrow: {
			 am: "AM",
			 pm: "PM",
			 midnight: "tengah malam",
			 noon: "tengah hari",
			 morning: "pagi",
			 afternoon: "siang",
			 evening: "sore",
			 night: "malam"
		  },
		  abbreviated: {
			 am: "AM",
			 pm: "PM",
			 midnight: "tengah malam",
			 noon: "tengah hari",
			 morning: "pagi",
			 afternoon: "siang",
			 evening: "sore",
			 night: "malam"
		  },
		  wide: {
			 am: "AM",
			 pm: "PM",
			 midnight: "tengah malam",
			 noon: "tengah hari",
			 morning: "pagi",
			 afternoon: "siang",
			 evening: "sore",
			 night: "malam"
		  }
		};
		var formattingDayPeriodValues6 = {
		  narrow: {
			 am: "AM",
			 pm: "PM",
			 midnight: "tengah malam",
			 noon: "tengah hari",
			 morning: "pagi",
			 afternoon: "siang",
			 evening: "sore",
			 night: "malam"
		  },
		  abbreviated: {
			 am: "AM",
			 pm: "PM",
			 midnight: "tengah malam",
			 noon: "tengah hari",
			 morning: "pagi",
			 afternoon: "siang",
			 evening: "sore",
			 night: "malam"
		  },
		  wide: {
			 am: "AM",
			 pm: "PM",
			 midnight: "tengah malam",
			 noon: "tengah hari",
			 morning: "pagi",
			 afternoon: "siang",
			 evening: "sore",
			 night: "malam"
		  }
		};
		var ordinalNumber8 = (dirtyNumber, _options) => {
		  const number5 = Number(dirtyNumber);
		  return "ke-" + number5;
		};
		var localize8 = {
		  ordinalNumber: ordinalNumber8,
		  era: buildLocalizeFn({
			 values: eraValues8,
			 defaultWidth: "wide"
		  }),
		  quarter: buildLocalizeFn({
			 values: quarterValues8,
			 defaultWidth: "wide",
			 argumentCallback: (quarter) => quarter - 1
		  }),
		  month: buildLocalizeFn({
			 values: monthValues8,
			 defaultWidth: "wide"
		  }),
		  day: buildLocalizeFn({
			 values: dayValues8,
			 defaultWidth: "wide"
		  }),
		  dayPeriod: buildLocalizeFn({
			 values: dayPeriodValues8,
			 defaultWidth: "wide",
			 formattingValues: formattingDayPeriodValues6,
			 defaultFormattingWidth: "wide"
		  })
		};

		// node_modules/date-fns/locale/id/_lib/match.mjs
		var matchOrdinalNumberPattern8 = /^ke-(\d+)?/i;
		var parseOrdinalNumberPattern8 = /\d+/i;
		var matchEraPatterns8 = {
		  narrow: /^(sm|m)/i,
		  abbreviated: /^(s\.?\s?m\.?|s\.?\s?e\.?\s?u\.?|m\.?|e\.?\s?u\.?)/i,
		  wide: /^(sebelum masehi|sebelum era umum|masehi|era umum)/i
		};
		var parseEraPatterns8 = {
		  any: [/^s/i, /^(m|e)/i]
		};
		var matchQuarterPatterns8 = {
		  narrow: /^[1234]/i,
		  abbreviated: /^K-?\s[1234]/i,
		  wide: /^Kuartal ke-?\s?[1234]/i
		};
		var parseQuarterPatterns8 = {
		  any: [/1/i, /2/i, /3/i, /4/i]
		};
		var matchMonthPatterns8 = {
		  narrow: /^[jfmasond]/i,
		  abbreviated: /^(jan|feb|mar|apr|mei|jun|jul|agt|sep|okt|nov|des)/i,
		  wide: /^(januari|februari|maret|april|mei|juni|juli|agustus|september|oktober|november|desember)/i
		};
		var parseMonthPatterns8 = {
		  narrow: [
			 /^j/i,
			 /^f/i,
			 /^m/i,
			 /^a/i,
			 /^m/i,
			 /^j/i,
			 /^j/i,
			 /^a/i,
			 /^s/i,
			 /^o/i,
			 /^n/i,
			 /^d/i
		  ],
		  any: [
			 /^ja/i,
			 /^f/i,
			 /^ma/i,
			 /^ap/i,
			 /^me/i,
			 /^jun/i,
			 /^jul/i,
			 /^ag/i,
			 /^s/i,
			 /^o/i,
			 /^n/i,
			 /^d/i
		  ]
		};
		var matchDayPatterns8 = {
		  narrow: /^[srkjm]/i,
		  short: /^(min|sen|sel|rab|kam|jum|sab)/i,
		  abbreviated: /^(min|sen|sel|rab|kam|jum|sab)/i,
		  wide: /^(minggu|senin|selasa|rabu|kamis|jumat|sabtu)/i
		};
		var parseDayPatterns8 = {
		  narrow: [/^m/i, /^s/i, /^s/i, /^r/i, /^k/i, /^j/i, /^s/i],
		  any: [/^m/i, /^sen/i, /^sel/i, /^r/i, /^k/i, /^j/i, /^sa/i]
		};
		var matchDayPeriodPatterns8 = {
		  narrow: /^(a|p|tengah m|tengah h|(di(\swaktu)?) (pagi|siang|sore|malam))/i,
		  any: /^([ap]\.?\s?m\.?|tengah malam|tengah hari|(di(\swaktu)?) (pagi|siang|sore|malam))/i
		};
		var parseDayPeriodPatterns8 = {
		  any: {
			 am: /^a/i,
			 pm: /^pm/i,
			 midnight: /^tengah m/i,
			 noon: /^tengah h/i,
			 morning: /pagi/i,
			 afternoon: /siang/i,
			 evening: /sore/i,
			 night: /malam/i
		  }
		};
		var match8 = {
		  ordinalNumber: buildMatchPatternFn({
			 matchPattern: matchOrdinalNumberPattern8,
			 parsePattern: parseOrdinalNumberPattern8,
			 valueCallback: (value) => parseInt(value, 10)
		  }),
		  era: buildMatchFn({
			 matchPatterns: matchEraPatterns8,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseEraPatterns8,
			 defaultParseWidth: "any"
		  }),
		  quarter: buildMatchFn({
			 matchPatterns: matchQuarterPatterns8,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseQuarterPatterns8,
			 defaultParseWidth: "any",
			 valueCallback: (index) => index + 1
		  }),
		  month: buildMatchFn({
			 matchPatterns: matchMonthPatterns8,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseMonthPatterns8,
			 defaultParseWidth: "any"
		  }),
		  day: buildMatchFn({
			 matchPatterns: matchDayPatterns8,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseDayPatterns8,
			 defaultParseWidth: "any"
		  }),
		  dayPeriod: buildMatchFn({
			 matchPatterns: matchDayPeriodPatterns8,
			 defaultMatchWidth: "any",
			 parsePatterns: parseDayPeriodPatterns8,
			 defaultParseWidth: "any"
		  })
		};

		// node_modules/date-fns/locale/id.mjs
		var id2 = {
		  code: "id",
		  formatDistance: formatDistance8,
		  formatLong: formatLong10,
		  formatRelative: formatRelative9,
		  localize: localize8,
		  match: match8,
		  options: {
			 weekStartsOn: 1,
			 firstWeekContainsDate: 1
		  }
		};

		// node_modules/date-fns/locale/it/_lib/formatDistance.mjs
		var formatDistanceLocale9 = {
		  lessThanXSeconds: {
			 one: "meno di un secondo",
			 other: "meno di {{count}} secondi"
		  },
		  xSeconds: {
			 one: "un secondo",
			 other: "{{count}} secondi"
		  },
		  halfAMinute: "alcuni secondi",
		  lessThanXMinutes: {
			 one: "meno di un minuto",
			 other: "meno di {{count}} minuti"
		  },
		  xMinutes: {
			 one: "un minuto",
			 other: "{{count}} minuti"
		  },
		  aboutXHours: {
			 one: "circa un'ora",
			 other: "circa {{count}} ore"
		  },
		  xHours: {
			 one: "un'ora",
			 other: "{{count}} ore"
		  },
		  xDays: {
			 one: "un giorno",
			 other: "{{count}} giorni"
		  },
		  aboutXWeeks: {
			 one: "circa una settimana",
			 other: "circa {{count}} settimane"
		  },
		  xWeeks: {
			 one: "una settimana",
			 other: "{{count}} settimane"
		  },
		  aboutXMonths: {
			 one: "circa un mese",
			 other: "circa {{count}} mesi"
		  },
		  xMonths: {
			 one: "un mese",
			 other: "{{count}} mesi"
		  },
		  aboutXYears: {
			 one: "circa un anno",
			 other: "circa {{count}} anni"
		  },
		  xYears: {
			 one: "un anno",
			 other: "{{count}} anni"
		  },
		  overXYears: {
			 one: "pi\xF9 di un anno",
			 other: "pi\xF9 di {{count}} anni"
		  },
		  almostXYears: {
			 one: "quasi un anno",
			 other: "quasi {{count}} anni"
		  }
		};
		var formatDistance9 = (token, count, options) => {
		  let result;
		  const tokenValue = formatDistanceLocale9[token];
		  if (typeof tokenValue === "string") {
			 result = tokenValue;
		  } else if (count === 1) {
			 result = tokenValue.one;
		  } else {
			 result = tokenValue.other.replace("{{count}}", count.toString());
		  }
		  if (options?.addSuffix) {
			 if (options.comparison && options.comparison > 0) {
				return "tra " + result;
			 } else {
				return result + " fa";
			 }
		  }
		  return result;
		};

		// node_modules/date-fns/locale/it/_lib/formatLong.mjs
		var dateFormats11 = {
		  full: "EEEE d MMMM y",
		  long: "d MMMM y",
		  medium: "d MMM y",
		  short: "dd/MM/y"
		};
		var timeFormats11 = {
		  full: "HH:mm:ss zzzz",
		  long: "HH:mm:ss z",
		  medium: "HH:mm:ss",
		  short: "HH:mm"
		};
		var dateTimeFormats11 = {
		  full: "{{date}} {{time}}",
		  long: "{{date}} {{time}}",
		  medium: "{{date}} {{time}}",
		  short: "{{date}} {{time}}"
		};
		var formatLong11 = {
		  date: buildFormatLongFn({
			 formats: dateFormats11,
			 defaultWidth: "full"
		  }),
		  time: buildFormatLongFn({
			 formats: timeFormats11,
			 defaultWidth: "full"
		  }),
		  dateTime: buildFormatLongFn({
			 formats: dateTimeFormats11,
			 defaultWidth: "full"
		  })
		};

		// node_modules/date-fns/locale/it/_lib/formatRelative.mjs
		var weekdays = [
		  "domenica",
		  "luned\xEC",
		  "marted\xEC",
		  "mercoled\xEC",
		  "gioved\xEC",
		  "venerd\xEC",
		  "sabato"
		];
		function lastWeek(day) {
		  switch (day) {
			 case 0:
				return "'domenica scorsa alle' p";
			 default:
				return "'" + weekdays[day] + " scorso alle' p";
		  }
		}
		function thisWeek(day) {
		  return "'" + weekdays[day] + " alle' p";
		}
		function nextWeek(day) {
		  switch (day) {
			 case 0:
				return "'domenica prossima alle' p";
			 default:
				return "'" + weekdays[day] + " prossimo alle' p";
		  }
		}
		var formatRelativeLocale10 = {
		  lastWeek: (date2, baseDate, options) => {
			 const day = date2.getDay();
			 if (isSameWeek(date2, baseDate, options)) {
				return thisWeek(day);
			 } else {
				return lastWeek(day);
			 }
		  },
		  yesterday: "'ieri alle' p",
		  today: "'oggi alle' p",
		  tomorrow: "'domani alle' p",
		  nextWeek: (date2, baseDate, options) => {
			 const day = date2.getDay();
			 if (isSameWeek(date2, baseDate, options)) {
				return thisWeek(day);
			 } else {
				return nextWeek(day);
			 }
		  },
		  other: "P"
		};
		var formatRelative10 = (token, date2, baseDate, options) => {
		  const format2 = formatRelativeLocale10[token];
		  if (typeof format2 === "function") {
			 return format2(date2, baseDate, options);
		  }
		  return format2;
		};

		// node_modules/date-fns/locale/it/_lib/localize.mjs
		var eraValues9 = {
		  narrow: ["aC", "dC"],
		  abbreviated: ["a.C.", "d.C."],
		  wide: ["avanti Cristo", "dopo Cristo"]
		};
		var quarterValues9 = {
		  narrow: ["1", "2", "3", "4"],
		  abbreviated: ["T1", "T2", "T3", "T4"],
		  wide: ["1\xBA trimestre", "2\xBA trimestre", "3\xBA trimestre", "4\xBA trimestre"]
		};
		var monthValues9 = {
		  narrow: ["G", "F", "M", "A", "M", "G", "L", "A", "S", "O", "N", "D"],
		  abbreviated: [
			 "gen",
			 "feb",
			 "mar",
			 "apr",
			 "mag",
			 "giu",
			 "lug",
			 "ago",
			 "set",
			 "ott",
			 "nov",
			 "dic"
		  ],
		  wide: [
			 "gennaio",
			 "febbraio",
			 "marzo",
			 "aprile",
			 "maggio",
			 "giugno",
			 "luglio",
			 "agosto",
			 "settembre",
			 "ottobre",
			 "novembre",
			 "dicembre"
		  ]
		};
		var dayValues9 = {
		  narrow: ["D", "L", "M", "M", "G", "V", "S"],
		  short: ["dom", "lun", "mar", "mer", "gio", "ven", "sab"],
		  abbreviated: ["dom", "lun", "mar", "mer", "gio", "ven", "sab"],
		  wide: [
			 "domenica",
			 "luned\xEC",
			 "marted\xEC",
			 "mercoled\xEC",
			 "gioved\xEC",
			 "venerd\xEC",
			 "sabato"
		  ]
		};
		var dayPeriodValues9 = {
		  narrow: {
			 am: "m.",
			 pm: "p.",
			 midnight: "mezzanotte",
			 noon: "mezzogiorno",
			 morning: "mattina",
			 afternoon: "pomeriggio",
			 evening: "sera",
			 night: "notte"
		  },
		  abbreviated: {
			 am: "AM",
			 pm: "PM",
			 midnight: "mezzanotte",
			 noon: "mezzogiorno",
			 morning: "mattina",
			 afternoon: "pomeriggio",
			 evening: "sera",
			 night: "notte"
		  },
		  wide: {
			 am: "AM",
			 pm: "PM",
			 midnight: "mezzanotte",
			 noon: "mezzogiorno",
			 morning: "mattina",
			 afternoon: "pomeriggio",
			 evening: "sera",
			 night: "notte"
		  }
		};
		var formattingDayPeriodValues7 = {
		  narrow: {
			 am: "m.",
			 pm: "p.",
			 midnight: "mezzanotte",
			 noon: "mezzogiorno",
			 morning: "di mattina",
			 afternoon: "del pomeriggio",
			 evening: "di sera",
			 night: "di notte"
		  },
		  abbreviated: {
			 am: "AM",
			 pm: "PM",
			 midnight: "mezzanotte",
			 noon: "mezzogiorno",
			 morning: "di mattina",
			 afternoon: "del pomeriggio",
			 evening: "di sera",
			 night: "di notte"
		  },
		  wide: {
			 am: "AM",
			 pm: "PM",
			 midnight: "mezzanotte",
			 noon: "mezzogiorno",
			 morning: "di mattina",
			 afternoon: "del pomeriggio",
			 evening: "di sera",
			 night: "di notte"
		  }
		};
		var ordinalNumber9 = (dirtyNumber, _options) => {
		  const number5 = Number(dirtyNumber);
		  return String(number5);
		};
		var localize9 = {
		  ordinalNumber: ordinalNumber9,
		  era: buildLocalizeFn({
			 values: eraValues9,
			 defaultWidth: "wide"
		  }),
		  quarter: buildLocalizeFn({
			 values: quarterValues9,
			 defaultWidth: "wide",
			 argumentCallback: (quarter) => quarter - 1
		  }),
		  month: buildLocalizeFn({
			 values: monthValues9,
			 defaultWidth: "wide"
		  }),
		  day: buildLocalizeFn({
			 values: dayValues9,
			 defaultWidth: "wide"
		  }),
		  dayPeriod: buildLocalizeFn({
			 values: dayPeriodValues9,
			 defaultWidth: "wide",
			 formattingValues: formattingDayPeriodValues7,
			 defaultFormattingWidth: "wide"
		  })
		};

		// node_modules/date-fns/locale/it/_lib/match.mjs
		var matchOrdinalNumberPattern9 = /^(\d+)()?/i;
		var parseOrdinalNumberPattern9 = /\d+/i;
		var matchEraPatterns9 = {
		  narrow: /^(aC|dC)/i,
		  abbreviated: /^(a\.?\s?C\.?|a\.?\s?e\.?\s?v\.?|d\.?\s?C\.?|e\.?\s?v\.?)/i,
		  wide: /^(avanti Cristo|avanti Era Volgare|dopo Cristo|Era Volgare)/i
		};
		var parseEraPatterns9 = {
		  any: [/^a/i, /^(d|e)/i]
		};
		var matchQuarterPatterns9 = {
		  narrow: /^[1234]/i,
		  abbreviated: /^t[1234]/i,
		  wide: /^[1234]()? trimestre/i
		};
		var parseQuarterPatterns9 = {
		  any: [/1/i, /2/i, /3/i, /4/i]
		};
		var matchMonthPatterns9 = {
		  narrow: /^[gfmalsond]/i,
		  abbreviated: /^(gen|feb|mar|apr|mag|giu|lug|ago|set|ott|nov|dic)/i,
		  wide: /^(gennaio|febbraio|marzo|aprile|maggio|giugno|luglio|agosto|settembre|ottobre|novembre|dicembre)/i
		};
		var parseMonthPatterns9 = {
		  narrow: [
			 /^g/i,
			 /^f/i,
			 /^m/i,
			 /^a/i,
			 /^m/i,
			 /^g/i,
			 /^l/i,
			 /^a/i,
			 /^s/i,
			 /^o/i,
			 /^n/i,
			 /^d/i
		  ],
		  any: [
			 /^ge/i,
			 /^f/i,
			 /^mar/i,
			 /^ap/i,
			 /^mag/i,
			 /^gi/i,
			 /^l/i,
			 /^ag/i,
			 /^s/i,
			 /^o/i,
			 /^n/i,
			 /^d/i
		  ]
		};
		var matchDayPatterns9 = {
		  narrow: /^[dlmgvs]/i,
		  short: /^(do|lu|ma|me|gi|ve|sa)/i,
		  abbreviated: /^(dom|lun|mar|mer|gio|ven|sab)/i,
		  wide: /^(domenica|luned[i|]|marted[i|]|mercoled[i|]|gioved[i|]|venerd[i|]|sabato)/i
		};
		var parseDayPatterns9 = {
		  narrow: [/^d/i, /^l/i, /^m/i, /^m/i, /^g/i, /^v/i, /^s/i],
		  any: [/^d/i, /^l/i, /^ma/i, /^me/i, /^g/i, /^v/i, /^s/i]
		};
		var matchDayPeriodPatterns9 = {
		  narrow: /^(a|m\.|p|mezzanotte|mezzogiorno|(di|del) (mattina|pomeriggio|sera|notte))/i,
		  any: /^([ap]\.?\s?m\.?|mezzanotte|mezzogiorno|(di|del) (mattina|pomeriggio|sera|notte))/i
		};
		var parseDayPeriodPatterns9 = {
		  any: {
			 am: /^a/i,
			 pm: /^p/i,
			 midnight: /^mezza/i,
			 noon: /^mezzo/i,
			 morning: /mattina/i,
			 afternoon: /pomeriggio/i,
			 evening: /sera/i,
			 night: /notte/i
		  }
		};
		var match9 = {
		  ordinalNumber: buildMatchPatternFn({
			 matchPattern: matchOrdinalNumberPattern9,
			 parsePattern: parseOrdinalNumberPattern9,
			 valueCallback: (value) => parseInt(value, 10)
		  }),
		  era: buildMatchFn({
			 matchPatterns: matchEraPatterns9,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseEraPatterns9,
			 defaultParseWidth: "any"
		  }),
		  quarter: buildMatchFn({
			 matchPatterns: matchQuarterPatterns9,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseQuarterPatterns9,
			 defaultParseWidth: "any",
			 valueCallback: (index) => index + 1
		  }),
		  month: buildMatchFn({
			 matchPatterns: matchMonthPatterns9,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseMonthPatterns9,
			 defaultParseWidth: "any"
		  }),
		  day: buildMatchFn({
			 matchPatterns: matchDayPatterns9,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseDayPatterns9,
			 defaultParseWidth: "any"
		  }),
		  dayPeriod: buildMatchFn({
			 matchPatterns: matchDayPeriodPatterns9,
			 defaultMatchWidth: "any",
			 parsePatterns: parseDayPeriodPatterns9,
			 defaultParseWidth: "any"
		  })
		};

		// node_modules/date-fns/locale/it.mjs
		var it = {
		  code: "it",
		  formatDistance: formatDistance9,
		  formatLong: formatLong11,
		  formatRelative: formatRelative10,
		  localize: localize9,
		  match: match9,
		  options: {
			 weekStartsOn: 1,
			 firstWeekContainsDate: 4
		  }
		};

		// node_modules/date-fns/locale/it-CH/_lib/formatLong.mjs
		var dateFormats12 = {
		  full: "EEEE d MMMM y",
		  long: "d MMMM y",
		  medium: "d MMM y",
		  short: "dd.MM.y"
		};
		var timeFormats12 = {
		  full: "HH:mm:ss zzzz",
		  long: "HH:mm:ss z",
		  medium: "HH:mm:ss",
		  short: "HH:mm"
		};
		var dateTimeFormats12 = {
		  full: "{{date}} {{time}}",
		  long: "{{date}} {{time}}",
		  medium: "{{date}} {{time}}",
		  short: "{{date}} {{time}}"
		};
		var formatLong12 = {
		  date: buildFormatLongFn({
			 formats: dateFormats12,
			 defaultWidth: "full"
		  }),
		  time: buildFormatLongFn({
			 formats: timeFormats12,
			 defaultWidth: "full"
		  }),
		  dateTime: buildFormatLongFn({
			 formats: dateTimeFormats12,
			 defaultWidth: "full"
		  })
		};

		// node_modules/date-fns/locale/it-CH.mjs
		var itCH = {
		  code: "it-CH",
		  formatDistance: formatDistance9,
		  formatLong: formatLong12,
		  formatRelative: formatRelative10,
		  localize: localize9,
		  match: match9,
		  options: {
			 weekStartsOn: 1,
			 firstWeekContainsDate: 4
		  }
		};

		// node_modules/date-fns/locale/ja/_lib/formatDistance.mjs
		var formatDistanceLocale10 = {
		  lessThanXSeconds: {
			 one: "1\u79D2\u672A\u6E80",
			 other: "{{count}}\u79D2\u672A\u6E80",
			 oneWithSuffix: "\u7D041\u79D2",
			 otherWithSuffix: "\u7D04{{count}}\u79D2"
		  },
		  xSeconds: {
			 one: "1\u79D2",
			 other: "{{count}}\u79D2"
		  },
		  halfAMinute: "30\u79D2",
		  lessThanXMinutes: {
			 one: "1\u5206\u672A\u6E80",
			 other: "{{count}}\u5206\u672A\u6E80",
			 oneWithSuffix: "\u7D041\u5206",
			 otherWithSuffix: "\u7D04{{count}}\u5206"
		  },
		  xMinutes: {
			 one: "1\u5206",
			 other: "{{count}}\u5206"
		  },
		  aboutXHours: {
			 one: "\u7D041\u6642\u9593",
			 other: "\u7D04{{count}}\u6642\u9593"
		  },
		  xHours: {
			 one: "1\u6642\u9593",
			 other: "{{count}}\u6642\u9593"
		  },
		  xDays: {
			 one: "1\u65E5",
			 other: "{{count}}\u65E5"
		  },
		  aboutXWeeks: {
			 one: "\u7D041\u9031\u9593",
			 other: "\u7D04{{count}}\u9031\u9593"
		  },
		  xWeeks: {
			 one: "1\u9031\u9593",
			 other: "{{count}}\u9031\u9593"
		  },
		  aboutXMonths: {
			 one: "\u7D041\u304B\u6708",
			 other: "\u7D04{{count}}\u304B\u6708"
		  },
		  xMonths: {
			 one: "1\u304B\u6708",
			 other: "{{count}}\u304B\u6708"
		  },
		  aboutXYears: {
			 one: "\u7D041\u5E74",
			 other: "\u7D04{{count}}\u5E74"
		  },
		  xYears: {
			 one: "1\u5E74",
			 other: "{{count}}\u5E74"
		  },
		  overXYears: {
			 one: "1\u5E74\u4EE5\u4E0A",
			 other: "{{count}}\u5E74\u4EE5\u4E0A"
		  },
		  almostXYears: {
			 one: "1\u5E74\u8FD1\u304F",
			 other: "{{count}}\u5E74\u8FD1\u304F"
		  }
		};
		var formatDistance10 = (token, count, options) => {
		  options = options || {};
		  let result;
		  const tokenValue = formatDistanceLocale10[token];
		  if (typeof tokenValue === "string") {
			 result = tokenValue;
		  } else if (count === 1) {
			 if (options.addSuffix && tokenValue.oneWithSuffix) {
				result = tokenValue.oneWithSuffix;
			 } else {
				result = tokenValue.one;
			 }
		  } else {
			 if (options.addSuffix && tokenValue.otherWithSuffix) {
				result = tokenValue.otherWithSuffix.replace("{{count}}", String(count));
			 } else {
				result = tokenValue.other.replace("{{count}}", String(count));
			 }
		  }
		  if (options.addSuffix) {
			 if (options.comparison && options.comparison > 0) {
				return result + "\u5F8C";
			 } else {
				return result + "\u524D";
			 }
		  }
		  return result;
		};

		// node_modules/date-fns/locale/ja/_lib/formatLong.mjs
		var dateFormats13 = {
		  full: "y\u5E74M\u6708d\u65E5EEEE",
		  long: "y\u5E74M\u6708d\u65E5",
		  medium: "y/MM/dd",
		  short: "y/MM/dd"
		};
		var timeFormats13 = {
		  full: "H\u6642mm\u5206ss\u79D2 zzzz",
		  long: "H:mm:ss z",
		  medium: "H:mm:ss",
		  short: "H:mm"
		};
		var dateTimeFormats13 = {
		  full: "{{date}} {{time}}",
		  long: "{{date}} {{time}}",
		  medium: "{{date}} {{time}}",
		  short: "{{date}} {{time}}"
		};
		var formatLong13 = {
		  date: buildFormatLongFn({
			 formats: dateFormats13,
			 defaultWidth: "full"
		  }),
		  time: buildFormatLongFn({
			 formats: timeFormats13,
			 defaultWidth: "full"
		  }),
		  dateTime: buildFormatLongFn({
			 formats: dateTimeFormats13,
			 defaultWidth: "full"
		  })
		};

		// node_modules/date-fns/locale/ja/_lib/formatRelative.mjs
		var formatRelativeLocale11 = {
		  lastWeek: "\u5148\u9031\u306Eeeee\u306Ep",
		  yesterday: "\u6628\u65E5\u306Ep",
		  today: "\u4ECA\u65E5\u306Ep",
		  tomorrow: "\u660E\u65E5\u306Ep",
		  nextWeek: "\u7FCC\u9031\u306Eeeee\u306Ep",
		  other: "P"
		};
		var formatRelative11 = (token, _date, _baseDate, _options) => {
		  return formatRelativeLocale11[token];
		};

		// node_modules/date-fns/locale/ja/_lib/localize.mjs
		var eraValues10 = {
		  narrow: ["BC", "AC"],
		  abbreviated: ["\u7D00\u5143\u524D", "\u897F\u66A6"],
		  wide: ["\u7D00\u5143\u524D", "\u897F\u66A6"]
		};
		var quarterValues10 = {
		  narrow: ["1", "2", "3", "4"],
		  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
		  wide: ["\u7B2C1\u56DB\u534A\u671F", "\u7B2C2\u56DB\u534A\u671F", "\u7B2C3\u56DB\u534A\u671F", "\u7B2C4\u56DB\u534A\u671F"]
		};
		var monthValues10 = {
		  narrow: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
		  abbreviated: [
			 "1\u6708",
			 "2\u6708",
			 "3\u6708",
			 "4\u6708",
			 "5\u6708",
			 "6\u6708",
			 "7\u6708",
			 "8\u6708",
			 "9\u6708",
			 "10\u6708",
			 "11\u6708",
			 "12\u6708"
		  ],
		  wide: [
			 "1\u6708",
			 "2\u6708",
			 "3\u6708",
			 "4\u6708",
			 "5\u6708",
			 "6\u6708",
			 "7\u6708",
			 "8\u6708",
			 "9\u6708",
			 "10\u6708",
			 "11\u6708",
			 "12\u6708"
		  ]
		};
		var dayValues10 = {
		  narrow: ["\u65E5", "\u6708", "\u706B", "\u6C34", "\u6728", "\u91D1", "\u571F"],
		  short: ["\u65E5", "\u6708", "\u706B", "\u6C34", "\u6728", "\u91D1", "\u571F"],
		  abbreviated: ["\u65E5", "\u6708", "\u706B", "\u6C34", "\u6728", "\u91D1", "\u571F"],
		  wide: ["\u65E5\u66DC\u65E5", "\u6708\u66DC\u65E5", "\u706B\u66DC\u65E5", "\u6C34\u66DC\u65E5", "\u6728\u66DC\u65E5", "\u91D1\u66DC\u65E5", "\u571F\u66DC\u65E5"]
		};
		var dayPeriodValues10 = {
		  narrow: {
			 am: "\u5348\u524D",
			 pm: "\u5348\u5F8C",
			 midnight: "\u6DF1\u591C",
			 noon: "\u6B63\u5348",
			 morning: "\u671D",
			 afternoon: "\u5348\u5F8C",
			 evening: "\u591C",
			 night: "\u6DF1\u591C"
		  },
		  abbreviated: {
			 am: "\u5348\u524D",
			 pm: "\u5348\u5F8C",
			 midnight: "\u6DF1\u591C",
			 noon: "\u6B63\u5348",
			 morning: "\u671D",
			 afternoon: "\u5348\u5F8C",
			 evening: "\u591C",
			 night: "\u6DF1\u591C"
		  },
		  wide: {
			 am: "\u5348\u524D",
			 pm: "\u5348\u5F8C",
			 midnight: "\u6DF1\u591C",
			 noon: "\u6B63\u5348",
			 morning: "\u671D",
			 afternoon: "\u5348\u5F8C",
			 evening: "\u591C",
			 night: "\u6DF1\u591C"
		  }
		};
		var formattingDayPeriodValues8 = {
		  narrow: {
			 am: "\u5348\u524D",
			 pm: "\u5348\u5F8C",
			 midnight: "\u6DF1\u591C",
			 noon: "\u6B63\u5348",
			 morning: "\u671D",
			 afternoon: "\u5348\u5F8C",
			 evening: "\u591C",
			 night: "\u6DF1\u591C"
		  },
		  abbreviated: {
			 am: "\u5348\u524D",
			 pm: "\u5348\u5F8C",
			 midnight: "\u6DF1\u591C",
			 noon: "\u6B63\u5348",
			 morning: "\u671D",
			 afternoon: "\u5348\u5F8C",
			 evening: "\u591C",
			 night: "\u6DF1\u591C"
		  },
		  wide: {
			 am: "\u5348\u524D",
			 pm: "\u5348\u5F8C",
			 midnight: "\u6DF1\u591C",
			 noon: "\u6B63\u5348",
			 morning: "\u671D",
			 afternoon: "\u5348\u5F8C",
			 evening: "\u591C",
			 night: "\u6DF1\u591C"
		  }
		};
		var ordinalNumber10 = (dirtyNumber, options) => {
		  const number5 = Number(dirtyNumber);
		  const unit2 = String(options?.unit);
		  switch (unit2) {
			 case "year":
				return `${number5}\u5E74`;
			 case "quarter":
				return `\u7B2C${number5}\u56DB\u534A\u671F`;
			 case "month":
				return `${number5}\u6708`;
			 case "week":
				return `\u7B2C${number5}\u9031`;
			 case "date":
				return `${number5}\u65E5`;
			 case "hour":
				return `${number5}\u6642`;
			 case "minute":
				return `${number5}\u5206`;
			 case "second":
				return `${number5}\u79D2`;
			 default:
				return `${number5}`;
		  }
		};
		var localize10 = {
		  ordinalNumber: ordinalNumber10,
		  era: buildLocalizeFn({
			 values: eraValues10,
			 defaultWidth: "wide"
		  }),
		  quarter: buildLocalizeFn({
			 values: quarterValues10,
			 defaultWidth: "wide",
			 argumentCallback: (quarter) => Number(quarter) - 1
		  }),
		  month: buildLocalizeFn({
			 values: monthValues10,
			 defaultWidth: "wide"
		  }),
		  day: buildLocalizeFn({
			 values: dayValues10,
			 defaultWidth: "wide"
		  }),
		  dayPeriod: buildLocalizeFn({
			 values: dayPeriodValues10,
			 defaultWidth: "wide",
			 formattingValues: formattingDayPeriodValues8,
			 defaultFormattingWidth: "wide"
		  })
		};

		// node_modules/date-fns/locale/ja/_lib/match.mjs
		var matchOrdinalNumberPattern10 = /^?\d+(|||||||)?/i;
		var parseOrdinalNumberPattern10 = /\d+/i;
		var matchEraPatterns10 = {
		  narrow: /^(B\.?C\.?|A\.?D\.?)/i,
		  abbreviated: /^([]|)/i,
		  wide: /^([]|)/i
		};
		var parseEraPatterns10 = {
		  narrow: [/^B/i, /^A/i],
		  any: [/^()/i, /^(|)/i]
		};
		var matchQuarterPatterns10 = {
		  narrow: /^[1234]/i,
		  abbreviated: /^Q[1234]/i,
		  wide: /^[1234]/i
		};
		var parseQuarterPatterns10 = {
		  any: [/(1||)/i, /(2||)/i, /(3||)/i, /(4||)/i]
		};
		var matchMonthPatterns10 = {
		  narrow: /^([123456789]|1[012])/,
		  abbreviated: /^([123456789]|1[012])/i,
		  wide: /^([123456789]|1[012])/i
		};
		var parseMonthPatterns10 = {
		  any: [
			 /^1\D/,
			 /^2/,
			 /^3/,
			 /^4/,
			 /^5/,
			 /^6/,
			 /^7/,
			 /^8/,
			 /^9/,
			 /^10/,
			 /^11/,
			 /^12/
		  ]
		};
		var matchDayPatterns10 = {
		  narrow: /^[]/,
		  short: /^[]/,
		  abbreviated: /^[]/,
		  wide: /^[]/
		};
		var parseDayPatterns10 = {
		  any: [/^/, /^/, /^/, /^/, /^/, /^/, /^/]
		};
		var matchDayPeriodPatterns10 = {
		  any: /^(AM|PM|||||||)/i
		};
		var parseDayPeriodPatterns10 = {
		  any: {
			 am: /^(A|)/i,
			 pm: /^(P|)/i,
			 midnight: /^|/i,
			 noon: /^/i,
			 morning: /^/i,
			 afternoon: /^/i,
			 evening: /^/i,
			 night: /^/i
		  }
		};
		var match10 = {
		  ordinalNumber: buildMatchPatternFn({
			 matchPattern: matchOrdinalNumberPattern10,
			 parsePattern: parseOrdinalNumberPattern10,
			 valueCallback: function(value) {
				return parseInt(value, 10);
			 }
		  }),
		  era: buildMatchFn({
			 matchPatterns: matchEraPatterns10,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseEraPatterns10,
			 defaultParseWidth: "any"
		  }),
		  quarter: buildMatchFn({
			 matchPatterns: matchQuarterPatterns10,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseQuarterPatterns10,
			 defaultParseWidth: "any",
			 valueCallback: (index) => index + 1
		  }),
		  month: buildMatchFn({
			 matchPatterns: matchMonthPatterns10,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseMonthPatterns10,
			 defaultParseWidth: "any"
		  }),
		  day: buildMatchFn({
			 matchPatterns: matchDayPatterns10,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseDayPatterns10,
			 defaultParseWidth: "any"
		  }),
		  dayPeriod: buildMatchFn({
			 matchPatterns: matchDayPeriodPatterns10,
			 defaultMatchWidth: "any",
			 parsePatterns: parseDayPeriodPatterns10,
			 defaultParseWidth: "any"
		  })
		};

		// node_modules/date-fns/locale/ja.mjs
		var ja = {
		  code: "ja",
		  formatDistance: formatDistance10,
		  formatLong: formatLong13,
		  formatRelative: formatRelative11,
		  localize: localize10,
		  match: match10,
		  options: {
			 weekStartsOn: 0,
			 firstWeekContainsDate: 1
		  }
		};

		// node_modules/date-fns/locale/ko/_lib/formatDistance.mjs
		var formatDistanceLocale11 = {
		  lessThanXSeconds: {
			 one: "1\uCD08 \uBBF8\uB9CC",
			 other: "{{count}}\uCD08 \uBBF8\uB9CC"
		  },
		  xSeconds: {
			 one: "1\uCD08",
			 other: "{{count}}\uCD08"
		  },
		  halfAMinute: "30\uCD08",
		  lessThanXMinutes: {
			 one: "1\uBD84 \uBBF8\uB9CC",
			 other: "{{count}}\uBD84 \uBBF8\uB9CC"
		  },
		  xMinutes: {
			 one: "1\uBD84",
			 other: "{{count}}\uBD84"
		  },
		  aboutXHours: {
			 one: "\uC57D 1\uC2DC\uAC04",
			 other: "\uC57D {{count}}\uC2DC\uAC04"
		  },
		  xHours: {
			 one: "1\uC2DC\uAC04",
			 other: "{{count}}\uC2DC\uAC04"
		  },
		  xDays: {
			 one: "1\uC77C",
			 other: "{{count}}\uC77C"
		  },
		  aboutXWeeks: {
			 one: "\uC57D 1\uC8FC",
			 other: "\uC57D {{count}}\uC8FC"
		  },
		  xWeeks: {
			 one: "1\uC8FC",
			 other: "{{count}}\uC8FC"
		  },
		  aboutXMonths: {
			 one: "\uC57D 1\uAC1C\uC6D4",
			 other: "\uC57D {{count}}\uAC1C\uC6D4"
		  },
		  xMonths: {
			 one: "1\uAC1C\uC6D4",
			 other: "{{count}}\uAC1C\uC6D4"
		  },
		  aboutXYears: {
			 one: "\uC57D 1\uB144",
			 other: "\uC57D {{count}}\uB144"
		  },
		  xYears: {
			 one: "1\uB144",
			 other: "{{count}}\uB144"
		  },
		  overXYears: {
			 one: "1\uB144 \uC774\uC0C1",
			 other: "{{count}}\uB144 \uC774\uC0C1"
		  },
		  almostXYears: {
			 one: "\uAC70\uC758 1\uB144",
			 other: "\uAC70\uC758 {{count}}\uB144"
		  }
		};
		var formatDistance11 = (token, count, options) => {
		  let result;
		  const tokenValue = formatDistanceLocale11[token];
		  if (typeof tokenValue === "string") {
			 result = tokenValue;
		  } else if (count === 1) {
			 result = tokenValue.one;
		  } else {
			 result = tokenValue.other.replace("{{count}}", count.toString());
		  }
		  if (options?.addSuffix) {
			 if (options.comparison && options.comparison > 0) {
				return result + " \uD6C4";
			 } else {
				return result + " \uC804";
			 }
		  }
		  return result;
		};

		// node_modules/date-fns/locale/ko/_lib/formatLong.mjs
		var dateFormats14 = {
		  full: "y\uB144 M\uC6D4 d\uC77C EEEE",
		  long: "y\uB144 M\uC6D4 d\uC77C",
		  medium: "y.MM.dd",
		  short: "y.MM.dd"
		};
		var timeFormats14 = {
		  full: "a H\uC2DC mm\uBD84 ss\uCD08 zzzz",
		  long: "a H:mm:ss z",
		  medium: "HH:mm:ss",
		  short: "HH:mm"
		};
		var dateTimeFormats14 = {
		  full: "{{date}} {{time}}",
		  long: "{{date}} {{time}}",
		  medium: "{{date}} {{time}}",
		  short: "{{date}} {{time}}"
		};
		var formatLong14 = {
		  date: buildFormatLongFn({
			 formats: dateFormats14,
			 defaultWidth: "full"
		  }),
		  time: buildFormatLongFn({
			 formats: timeFormats14,
			 defaultWidth: "full"
		  }),
		  dateTime: buildFormatLongFn({
			 formats: dateTimeFormats14,
			 defaultWidth: "full"
		  })
		};

		// node_modules/date-fns/locale/ko/_lib/formatRelative.mjs
		var formatRelativeLocale12 = {
		  lastWeek: "'\uC9C0\uB09C' eeee p",
		  yesterday: "'\uC5B4\uC81C' p",
		  today: "'\uC624\uB298' p",
		  tomorrow: "'\uB0B4\uC77C' p",
		  nextWeek: "'\uB2E4\uC74C' eeee p",
		  other: "P"
		};
		var formatRelative12 = (token, _date, _baseDate, _options) => formatRelativeLocale12[token];

		// node_modules/date-fns/locale/ko/_lib/localize.mjs
		var eraValues11 = {
		  narrow: ["BC", "AD"],
		  abbreviated: ["BC", "AD"],
		  wide: ["\uAE30\uC6D0\uC804", "\uC11C\uAE30"]
		};
		var quarterValues11 = {
		  narrow: ["1", "2", "3", "4"],
		  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
		  wide: ["1\uBD84\uAE30", "2\uBD84\uAE30", "3\uBD84\uAE30", "4\uBD84\uAE30"]
		};
		var monthValues11 = {
		  narrow: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
		  abbreviated: [
			 "1\uC6D4",
			 "2\uC6D4",
			 "3\uC6D4",
			 "4\uC6D4",
			 "5\uC6D4",
			 "6\uC6D4",
			 "7\uC6D4",
			 "8\uC6D4",
			 "9\uC6D4",
			 "10\uC6D4",
			 "11\uC6D4",
			 "12\uC6D4"
		  ],
		  wide: [
			 "1\uC6D4",
			 "2\uC6D4",
			 "3\uC6D4",
			 "4\uC6D4",
			 "5\uC6D4",
			 "6\uC6D4",
			 "7\uC6D4",
			 "8\uC6D4",
			 "9\uC6D4",
			 "10\uC6D4",
			 "11\uC6D4",
			 "12\uC6D4"
		  ]
		};
		var dayValues11 = {
		  narrow: ["\uC77C", "\uC6D4", "\uD654", "\uC218", "\uBAA9", "\uAE08", "\uD1A0"],
		  short: ["\uC77C", "\uC6D4", "\uD654", "\uC218", "\uBAA9", "\uAE08", "\uD1A0"],
		  abbreviated: ["\uC77C", "\uC6D4", "\uD654", "\uC218", "\uBAA9", "\uAE08", "\uD1A0"],
		  wide: ["\uC77C\uC694\uC77C", "\uC6D4\uC694\uC77C", "\uD654\uC694\uC77C", "\uC218\uC694\uC77C", "\uBAA9\uC694\uC77C", "\uAE08\uC694\uC77C", "\uD1A0\uC694\uC77C"]
		};
		var dayPeriodValues11 = {
		  narrow: {
			 am: "\uC624\uC804",
			 pm: "\uC624\uD6C4",
			 midnight: "\uC790\uC815",
			 noon: "\uC815\uC624",
			 morning: "\uC544\uCE68",
			 afternoon: "\uC624\uD6C4",
			 evening: "\uC800\uB141",
			 night: "\uBC24"
		  },
		  abbreviated: {
			 am: "\uC624\uC804",
			 pm: "\uC624\uD6C4",
			 midnight: "\uC790\uC815",
			 noon: "\uC815\uC624",
			 morning: "\uC544\uCE68",
			 afternoon: "\uC624\uD6C4",
			 evening: "\uC800\uB141",
			 night: "\uBC24"
		  },
		  wide: {
			 am: "\uC624\uC804",
			 pm: "\uC624\uD6C4",
			 midnight: "\uC790\uC815",
			 noon: "\uC815\uC624",
			 morning: "\uC544\uCE68",
			 afternoon: "\uC624\uD6C4",
			 evening: "\uC800\uB141",
			 night: "\uBC24"
		  }
		};
		var formattingDayPeriodValues9 = {
		  narrow: {
			 am: "\uC624\uC804",
			 pm: "\uC624\uD6C4",
			 midnight: "\uC790\uC815",
			 noon: "\uC815\uC624",
			 morning: "\uC544\uCE68",
			 afternoon: "\uC624\uD6C4",
			 evening: "\uC800\uB141",
			 night: "\uBC24"
		  },
		  abbreviated: {
			 am: "\uC624\uC804",
			 pm: "\uC624\uD6C4",
			 midnight: "\uC790\uC815",
			 noon: "\uC815\uC624",
			 morning: "\uC544\uCE68",
			 afternoon: "\uC624\uD6C4",
			 evening: "\uC800\uB141",
			 night: "\uBC24"
		  },
		  wide: {
			 am: "\uC624\uC804",
			 pm: "\uC624\uD6C4",
			 midnight: "\uC790\uC815",
			 noon: "\uC815\uC624",
			 morning: "\uC544\uCE68",
			 afternoon: "\uC624\uD6C4",
			 evening: "\uC800\uB141",
			 night: "\uBC24"
		  }
		};
		var ordinalNumber11 = (dirtyNumber, options) => {
		  const number5 = Number(dirtyNumber);
		  const unit2 = String(options?.unit);
		  switch (unit2) {
			 case "minute":
			 case "second":
				return String(number5);
			 case "date":
				return number5 + "\uC77C";
			 default:
				return number5 + "\uBC88\uC9F8";
		  }
		};
		var localize11 = {
		  ordinalNumber: ordinalNumber11,
		  era: buildLocalizeFn({
			 values: eraValues11,
			 defaultWidth: "wide"
		  }),
		  quarter: buildLocalizeFn({
			 values: quarterValues11,
			 defaultWidth: "wide",
			 argumentCallback: (quarter) => quarter - 1
		  }),
		  month: buildLocalizeFn({
			 values: monthValues11,
			 defaultWidth: "wide"
		  }),
		  day: buildLocalizeFn({
			 values: dayValues11,
			 defaultWidth: "wide"
		  }),
		  dayPeriod: buildLocalizeFn({
			 values: dayPeriodValues11,
			 defaultWidth: "wide",
			 formattingValues: formattingDayPeriodValues9,
			 defaultFormattingWidth: "wide"
		  })
		};

		// node_modules/date-fns/locale/ko/_lib/match.mjs
		var matchOrdinalNumberPattern11 = /^(\d+)(|)?/i;
		var parseOrdinalNumberPattern11 = /\d+/i;
		var matchEraPatterns11 = {
		  narrow: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
		  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
		  wide: /^(|)/i
		};
		var parseEraPatterns11 = {
		  any: [/^(bc|)/i, /^(ad|)/i]
		};
		var matchQuarterPatterns11 = {
		  narrow: /^[1234]/i,
		  abbreviated: /^q[1234]/i,
		  wide: /^[1234]?/i
		};
		var parseQuarterPatterns11 = {
		  any: [/1/i, /2/i, /3/i, /4/i]
		};
		var matchMonthPatterns11 = {
		  narrow: /^(1[012]|[123456789])/,
		  abbreviated: /^(1[012]|[123456789])/i,
		  wide: /^(1[012]|[123456789])/i
		};
		var parseMonthPatterns11 = {
		  any: [
			 /^1?$/,
			 /^2/,
			 /^3/,
			 /^4/,
			 /^5/,
			 /^6/,
			 /^7/,
			 /^8/,
			 /^9/,
			 /^10/,
			 /^11/,
			 /^12/
		  ]
		};
		var matchDayPatterns11 = {
		  narrow: /^[]/,
		  short: /^[]/,
		  abbreviated: /^[]/,
		  wide: /^[]/
		};
		var parseDayPatterns11 = {
		  any: [/^/, /^/, /^/, /^/, /^/, /^/, /^/]
		};
		var matchDayPeriodPatterns11 = {
		  any: /^(am|pm|||||||)/i
		};
		var parseDayPeriodPatterns11 = {
		  any: {
			 am: /^(am|)/i,
			 pm: /^(pm|)/i,
			 midnight: /^/i,
			 noon: /^/i,
			 morning: /^/i,
			 afternoon: /^/i,
			 evening: /^/i,
			 night: /^/i
		  }
		};
		var match11 = {
		  ordinalNumber: buildMatchPatternFn({
			 matchPattern: matchOrdinalNumberPattern11,
			 parsePattern: parseOrdinalNumberPattern11,
			 valueCallback: (value) => parseInt(value, 10)
		  }),
		  era: buildMatchFn({
			 matchPatterns: matchEraPatterns11,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseEraPatterns11,
			 defaultParseWidth: "any"
		  }),
		  quarter: buildMatchFn({
			 matchPatterns: matchQuarterPatterns11,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseQuarterPatterns11,
			 defaultParseWidth: "any",
			 valueCallback: (index) => index + 1
		  }),
		  month: buildMatchFn({
			 matchPatterns: matchMonthPatterns11,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseMonthPatterns11,
			 defaultParseWidth: "any"
		  }),
		  day: buildMatchFn({
			 matchPatterns: matchDayPatterns11,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseDayPatterns11,
			 defaultParseWidth: "any"
		  }),
		  dayPeriod: buildMatchFn({
			 matchPatterns: matchDayPeriodPatterns11,
			 defaultMatchWidth: "any",
			 parsePatterns: parseDayPeriodPatterns11,
			 defaultParseWidth: "any"
		  })
		};

		// node_modules/date-fns/locale/ko.mjs
		var ko = {
		  code: "ko",
		  formatDistance: formatDistance11,
		  formatLong: formatLong14,
		  formatRelative: formatRelative12,
		  localize: localize11,
		  match: match11,
		  options: {
			 weekStartsOn: 0,
			 firstWeekContainsDate: 1
		  }
		};

		// node_modules/date-fns/locale/lt/_lib/formatDistance.mjs
		var translations = {
		  xseconds_other: "sekund\u0117_sekund\u017Ei\u0173_sekundes",
		  xminutes_one: "minut\u0117_minut\u0117s_minut\u0119",
		  xminutes_other: "minut\u0117s_minu\u010Di\u0173_minutes",
		  xhours_one: "valanda_valandos_valand\u0105",
		  xhours_other: "valandos_valand\u0173_valandas",
		  xdays_one: "diena_dienos_dien\u0105",
		  xdays_other: "dienos_dien\u0173_dienas",
		  xweeks_one: "savait\u0117_savait\u0117s_savait\u0119",
		  xweeks_other: "savait\u0117s_savai\u010Di\u0173_savaites",
		  xmonths_one: "m\u0117nuo_m\u0117nesio_m\u0117nes\u012F",
		  xmonths_other: "m\u0117nesiai_m\u0117nesi\u0173_m\u0117nesius",
		  xyears_one: "metai_met\u0173_metus",
		  xyears_other: "metai_met\u0173_metus",
		  about: "apie",
		  over: "daugiau nei",
		  almost: "beveik",
		  lessthan: "ma\u017Eiau nei"
		};
		var translateSeconds = (_number, addSuffix, _key, isFuture) => {
		  if (!addSuffix) {
			 return "kelios sekund\u0117s";
		  } else {
			 return isFuture ? "keli\u0173 sekund\u017Ei\u0173" : "kelias sekundes";
		  }
		};
		var translateSingular = (_number, addSuffix, key, isFuture) => {
		  return !addSuffix ? forms(key)[0] : isFuture ? forms(key)[1] : forms(key)[2];
		};
		var translate = (number5, addSuffix, key, isFuture) => {
		  const result = number5 + " ";
		  if (number5 === 1) {
			 return result + translateSingular(number5, addSuffix, key, isFuture);
		  } else if (!addSuffix) {
			 return result + (special(number5) ? forms(key)[1] : forms(key)[0]);
		  } else {
			 if (isFuture) {
				return result + forms(key)[1];
			 } else {
				return result + (special(number5) ? forms(key)[1] : forms(key)[2]);
			 }
		  }
		};
		function special(number5) {
		  return number5 % 10 === 0 || number5 > 10 && number5 < 20;
		}
		function forms(key) {
		  return translations[key].split("_");
		}
		var formatDistanceLocale12 = {
		  lessThanXSeconds: {
			 one: translateSeconds,
			 other: translate
		  },
		  xSeconds: {
			 one: translateSeconds,
			 other: translate
		  },
		  halfAMinute: "pus\u0117 minut\u0117s",
		  lessThanXMinutes: {
			 one: translateSingular,
			 other: translate
		  },
		  xMinutes: {
			 one: translateSingular,
			 other: translate
		  },
		  aboutXHours: {
			 one: translateSingular,
			 other: translate
		  },
		  xHours: {
			 one: translateSingular,
			 other: translate
		  },
		  xDays: {
			 one: translateSingular,
			 other: translate
		  },
		  aboutXWeeks: {
			 one: translateSingular,
			 other: translate
		  },
		  xWeeks: {
			 one: translateSingular,
			 other: translate
		  },
		  aboutXMonths: {
			 one: translateSingular,
			 other: translate
		  },
		  xMonths: {
			 one: translateSingular,
			 other: translate
		  },
		  aboutXYears: {
			 one: translateSingular,
			 other: translate
		  },
		  xYears: {
			 one: translateSingular,
			 other: translate
		  },
		  overXYears: {
			 one: translateSingular,
			 other: translate
		  },
		  almostXYears: {
			 one: translateSingular,
			 other: translate
		  }
		};
		var formatDistance12 = (token, count, options) => {
		  const adverb = token.match(/about|over|almost|lessthan/i);
		  const unit2 = adverb ? token.replace(adverb[0], "") : token;
		  const isFuture = options?.comparison !== void 0 && options.comparison > 0;
		  let result;
		  const tokenValue = formatDistanceLocale12[token];
		  if (typeof tokenValue === "string") {
			 result = tokenValue;
		  } else if (count === 1) {
			 result = tokenValue.one(
				count,
				options?.addSuffix === true,
				unit2.toLowerCase() + "_one",
				isFuture
			 );
		  } else {
			 result = tokenValue.other(
				count,
				options?.addSuffix === true,
				unit2.toLowerCase() + "_other",
				isFuture
			 );
		  }
		  if (adverb) {
			 const key = adverb[0].toLowerCase();
			 result = translations[key] + " " + result;
		  }
		  if (options?.addSuffix) {
			 if (options.comparison && options.comparison > 0) {
				return "po " + result;
			 } else {
				return "prie\u0161 " + result;
			 }
		  }
		  return result;
		};

		// node_modules/date-fns/locale/lt/_lib/formatLong.mjs
		var dateFormats15 = {
		  full: "y 'm'. MMMM d 'd'., EEEE",
		  long: "y 'm'. MMMM d 'd'.",
		  medium: "y-MM-dd",
		  short: "y-MM-dd"
		};
		var timeFormats15 = {
		  full: "HH:mm:ss zzzz",
		  long: "HH:mm:ss z",
		  medium: "HH:mm:ss",
		  short: "HH:mm"
		};
		var dateTimeFormats15 = {
		  full: "{{date}} {{time}}",
		  long: "{{date}} {{time}}",
		  medium: "{{date}} {{time}}",
		  short: "{{date}} {{time}}"
		};
		var formatLong15 = {
		  date: buildFormatLongFn({
			 formats: dateFormats15,
			 defaultWidth: "full"
		  }),
		  time: buildFormatLongFn({
			 formats: timeFormats15,
			 defaultWidth: "full"
		  }),
		  dateTime: buildFormatLongFn({
			 formats: dateTimeFormats15,
			 defaultWidth: "full"
		  })
		};

		// node_modules/date-fns/locale/lt/_lib/formatRelative.mjs
		var formatRelativeLocale13 = {
		  lastWeek: "'Pra\u0117jus\u012F' eeee p",
		  yesterday: "'Vakar' p",
		  today: "'\u0160iandien' p",
		  tomorrow: "'Rytoj' p",
		  nextWeek: "eeee p",
		  other: "P"
		};
		var formatRelative13 = (token, _date, _baseDate, _options) => formatRelativeLocale13[token];

		// node_modules/date-fns/locale/lt/_lib/localize.mjs
		var eraValues12 = {
		  narrow: ["pr. Kr.", "po Kr."],
		  abbreviated: ["pr. Kr.", "po Kr."],
		  wide: ["prie\u0161 Krist\u0173", "po Kristaus"]
		};
		var quarterValues12 = {
		  narrow: ["1", "2", "3", "4"],
		  abbreviated: ["I ketv.", "II ketv.", "III ketv.", "IV ketv."],
		  wide: ["I ketvirtis", "II ketvirtis", "III ketvirtis", "IV ketvirtis"]
		};
		var formattingQuarterValues = {
		  narrow: ["1", "2", "3", "4"],
		  abbreviated: ["I k.", "II k.", "III k.", "IV k."],
		  wide: ["I ketvirtis", "II ketvirtis", "III ketvirtis", "IV ketvirtis"]
		};
		var monthValues12 = {
		  narrow: ["S", "V", "K", "B", "G", "B", "L", "R", "R", "S", "L", "G"],
		  abbreviated: [
			 "saus.",
			 "vas.",
			 "kov.",
			 "bal.",
			 "geg.",
			 "bir\u017E.",
			 "liep.",
			 "rugp.",
			 "rugs.",
			 "spal.",
			 "lapkr.",
			 "gruod."
		  ],
		  wide: [
			 "sausis",
			 "vasaris",
			 "kovas",
			 "balandis",
			 "gegu\u017E\u0117",
			 "bir\u017Eelis",
			 "liepa",
			 "rugpj\u016Btis",
			 "rugs\u0117jis",
			 "spalis",
			 "lapkritis",
			 "gruodis"
		  ]
		};
		var formattingMonthValues4 = {
		  narrow: ["S", "V", "K", "B", "G", "B", "L", "R", "R", "S", "L", "G"],
		  abbreviated: [
			 "saus.",
			 "vas.",
			 "kov.",
			 "bal.",
			 "geg.",
			 "bir\u017E.",
			 "liep.",
			 "rugp.",
			 "rugs.",
			 "spal.",
			 "lapkr.",
			 "gruod."
		  ],
		  wide: [
			 "sausio",
			 "vasario",
			 "kovo",
			 "baland\u017Eio",
			 "gegu\u017E\u0117s",
			 "bir\u017Eelio",
			 "liepos",
			 "rugpj\u016B\u010Dio",
			 "rugs\u0117jo",
			 "spalio",
			 "lapkri\u010Dio",
			 "gruod\u017Eio"
		  ]
		};
		var dayValues12 = {
		  narrow: ["S", "P", "A", "T", "K", "P", "\u0160"],
		  short: ["Sk", "Pr", "An", "Tr", "Kt", "Pn", "\u0160t"],
		  abbreviated: ["sk", "pr", "an", "tr", "kt", "pn", "\u0161t"],
		  wide: [
			 "sekmadienis",
			 "pirmadienis",
			 "antradienis",
			 "tre\u010Diadienis",
			 "ketvirtadienis",
			 "penktadienis",
			 "\u0161e\u0161tadienis"
		  ]
		};
		var formattingDayValues2 = {
		  narrow: ["S", "P", "A", "T", "K", "P", "\u0160"],
		  short: ["Sk", "Pr", "An", "Tr", "Kt", "Pn", "\u0160t"],
		  abbreviated: ["sk", "pr", "an", "tr", "kt", "pn", "\u0161t"],
		  wide: [
			 "sekmadien\u012F",
			 "pirmadien\u012F",
			 "antradien\u012F",
			 "tre\u010Diadien\u012F",
			 "ketvirtadien\u012F",
			 "penktadien\u012F",
			 "\u0161e\u0161tadien\u012F"
		  ]
		};
		var dayPeriodValues12 = {
		  narrow: {
			 am: "pr. p.",
			 pm: "pop.",
			 midnight: "vidurnaktis",
			 noon: "vidurdienis",
			 morning: "rytas",
			 afternoon: "diena",
			 evening: "vakaras",
			 night: "naktis"
		  },
		  abbreviated: {
			 am: "prie\u0161piet",
			 pm: "popiet",
			 midnight: "vidurnaktis",
			 noon: "vidurdienis",
			 morning: "rytas",
			 afternoon: "diena",
			 evening: "vakaras",
			 night: "naktis"
		  },
		  wide: {
			 am: "prie\u0161piet",
			 pm: "popiet",
			 midnight: "vidurnaktis",
			 noon: "vidurdienis",
			 morning: "rytas",
			 afternoon: "diena",
			 evening: "vakaras",
			 night: "naktis"
		  }
		};
		var formattingDayPeriodValues10 = {
		  narrow: {
			 am: "pr. p.",
			 pm: "pop.",
			 midnight: "vidurnaktis",
			 noon: "perpiet",
			 morning: "rytas",
			 afternoon: "popiet\u0117",
			 evening: "vakaras",
			 night: "naktis"
		  },
		  abbreviated: {
			 am: "prie\u0161piet",
			 pm: "popiet",
			 midnight: "vidurnaktis",
			 noon: "perpiet",
			 morning: "rytas",
			 afternoon: "popiet\u0117",
			 evening: "vakaras",
			 night: "naktis"
		  },
		  wide: {
			 am: "prie\u0161piet",
			 pm: "popiet",
			 midnight: "vidurnaktis",
			 noon: "perpiet",
			 morning: "rytas",
			 afternoon: "popiet\u0117",
			 evening: "vakaras",
			 night: "naktis"
		  }
		};
		var ordinalNumber12 = (dirtyNumber, _options) => {
		  const number5 = Number(dirtyNumber);
		  return number5 + "-oji";
		};
		var localize12 = {
		  ordinalNumber: ordinalNumber12,
		  era: buildLocalizeFn({
			 values: eraValues12,
			 defaultWidth: "wide"
		  }),
		  quarter: buildLocalizeFn({
			 values: quarterValues12,
			 defaultWidth: "wide",
			 formattingValues: formattingQuarterValues,
			 defaultFormattingWidth: "wide",
			 argumentCallback: (quarter) => quarter - 1
		  }),
		  month: buildLocalizeFn({
			 values: monthValues12,
			 defaultWidth: "wide",
			 formattingValues: formattingMonthValues4,
			 defaultFormattingWidth: "wide"
		  }),
		  day: buildLocalizeFn({
			 values: dayValues12,
			 defaultWidth: "wide",
			 formattingValues: formattingDayValues2,
			 defaultFormattingWidth: "wide"
		  }),
		  dayPeriod: buildLocalizeFn({
			 values: dayPeriodValues12,
			 defaultWidth: "wide",
			 formattingValues: formattingDayPeriodValues10,
			 defaultFormattingWidth: "wide"
		  })
		};

		// node_modules/date-fns/locale/lt/_lib/match.mjs
		var matchOrdinalNumberPattern12 = /^(\d+)(-oji)?/i;
		var parseOrdinalNumberPattern12 = /\d+/i;
		var matchEraPatterns12 = {
		  narrow: /^p(r|o)\.?\s?(kr\.?|me)/i,
		  abbreviated: /^(pr\.\s?(kr\.|m\.\s?e\.)|po\s?kr\.|ms eroje)/i,
		  wide: /^(prie Krist|prie ms er|po Kristaus|ms eroje)/i
		};
		var parseEraPatterns12 = {
		  wide: [/prie/i, /(po|ms)/i],
		  any: [/^pr/i, /^(po|m)/i]
		};
		var matchQuarterPatterns12 = {
		  narrow: /^([1234])/i,
		  abbreviated: /^(I|II|III|IV)\s?ketv?\.?/i,
		  wide: /^(I|II|III|IV)\s?ketvirtis/i
		};
		var parseQuarterPatterns12 = {
		  narrow: [/1/i, /2/i, /3/i, /4/i],
		  any: [/I$/i, /II$/i, /III/i, /IV/i]
		};
		var matchMonthPatterns12 = {
		  narrow: /^[svkbglr]/i,
		  abbreviated: /^(saus\.|vas\.|kov\.|bal\.|geg\.|bir\.|liep\.|rugp\.|rugs\.|spal\.|lapkr\.|gruod\.)/i,
		  wide: /^(sausi(s|o)|vasari(s|o)|kov(a|o)s|baland?i(s|o)|gegus?|bireli(s|o)|liep(a|os)|rugpj(t|)i(s|o)|rugsj(is|o)|spali(s|o)|lapkri(t|)i(s|o)|gruod?i(s|o))/i
		};
		var parseMonthPatterns12 = {
		  narrow: [
			 /^s/i,
			 /^v/i,
			 /^k/i,
			 /^b/i,
			 /^g/i,
			 /^b/i,
			 /^l/i,
			 /^r/i,
			 /^r/i,
			 /^s/i,
			 /^l/i,
			 /^g/i
		  ],
		  any: [
			 /^saus/i,
			 /^vas/i,
			 /^kov/i,
			 /^bal/i,
			 /^geg/i,
			 /^bir/i,
			 /^liep/i,
			 /^rugp/i,
			 /^rugs/i,
			 /^spal/i,
			 /^lapkr/i,
			 /^gruod/i
		  ]
		};
		var matchDayPatterns12 = {
		  narrow: /^[spatk]/i,
		  short: /^(sk|pr|an|tr|kt|pn|t)/i,
		  abbreviated: /^(sk|pr|an|tr|kt|pn|t)/i,
		  wide: /^(sekmadien(is|)|pirmadien(is|)|antradien(is|)|treiadien(is|)|ketvirtadien(is|)|penktadien(is|)|etadien(is|))/i
		};
		var parseDayPatterns12 = {
		  narrow: [/^s/i, /^p/i, /^a/i, /^t/i, /^k/i, /^p/i, /^/i],
		  wide: [/^se/i, /^pi/i, /^an/i, /^tr/i, /^ke/i, /^pe/i, /^e/i],
		  any: [/^sk/i, /^pr/i, /^an/i, /^tr/i, /^kt/i, /^pn/i, /^t/i]
		};
		var matchDayPeriodPatterns12 = {
		  narrow: /^(pr.\s?p.|pop.|vidurnaktis|(vidurdienis|perpiet)|rytas|(diena|popiet)|vakaras|naktis)/i,
		  any: /^(priepiet|popiet$|vidurnaktis|(vidurdienis|perpiet)|rytas|(diena|popiet)|vakaras|naktis)/i
		};
		var parseDayPeriodPatterns12 = {
		  narrow: {
			 am: /^pr/i,
			 pm: /^pop./i,
			 midnight: /^vidurnaktis/i,
			 noon: /^(vidurdienis|perp)/i,
			 morning: /rytas/i,
			 afternoon: /(die|popiet)/i,
			 evening: /vakaras/i,
			 night: /naktis/i
		  },
		  any: {
			 am: /^pr/i,
			 pm: /^popiet$/i,
			 midnight: /^vidurnaktis/i,
			 noon: /^(vidurdienis|perp)/i,
			 morning: /rytas/i,
			 afternoon: /(die|popiet)/i,
			 evening: /vakaras/i,
			 night: /naktis/i
		  }
		};
		var match12 = {
		  ordinalNumber: buildMatchPatternFn({
			 matchPattern: matchOrdinalNumberPattern12,
			 parsePattern: parseOrdinalNumberPattern12,
			 valueCallback: (value) => parseInt(value, 10)
		  }),
		  era: buildMatchFn({
			 matchPatterns: matchEraPatterns12,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseEraPatterns12,
			 defaultParseWidth: "any"
		  }),
		  quarter: buildMatchFn({
			 matchPatterns: matchQuarterPatterns12,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseQuarterPatterns12,
			 defaultParseWidth: "any",
			 valueCallback: (index) => index + 1
		  }),
		  month: buildMatchFn({
			 matchPatterns: matchMonthPatterns12,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseMonthPatterns12,
			 defaultParseWidth: "any"
		  }),
		  day: buildMatchFn({
			 matchPatterns: matchDayPatterns12,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseDayPatterns12,
			 defaultParseWidth: "any"
		  }),
		  dayPeriod: buildMatchFn({
			 matchPatterns: matchDayPeriodPatterns12,
			 defaultMatchWidth: "any",
			 parsePatterns: parseDayPeriodPatterns12,
			 defaultParseWidth: "any"
		  })
		};

		// node_modules/date-fns/locale/lt.mjs
		var lt = {
		  code: "lt",
		  formatDistance: formatDistance12,
		  formatLong: formatLong15,
		  formatRelative: formatRelative13,
		  localize: localize12,
		  match: match12,
		  options: {
			 weekStartsOn: 1,
			 firstWeekContainsDate: 4
		  }
		};

		// node_modules/date-fns/locale/nb/_lib/formatDistance.mjs
		var formatDistanceLocale13 = {
		  lessThanXSeconds: {
			 one: "mindre enn ett sekund",
			 other: "mindre enn {{count}} sekunder"
		  },
		  xSeconds: {
			 one: "ett sekund",
			 other: "{{count}} sekunder"
		  },
		  halfAMinute: "et halvt minutt",
		  lessThanXMinutes: {
			 one: "mindre enn ett minutt",
			 other: "mindre enn {{count}} minutter"
		  },
		  xMinutes: {
			 one: "ett minutt",
			 other: "{{count}} minutter"
		  },
		  aboutXHours: {
			 one: "omtrent en time",
			 other: "omtrent {{count}} timer"
		  },
		  xHours: {
			 one: "en time",
			 other: "{{count}} timer"
		  },
		  xDays: {
			 one: "en dag",
			 other: "{{count}} dager"
		  },
		  aboutXWeeks: {
			 one: "omtrent en uke",
			 other: "omtrent {{count}} uker"
		  },
		  xWeeks: {
			 one: "en uke",
			 other: "{{count}} uker"
		  },
		  aboutXMonths: {
			 one: "omtrent en m\xE5ned",
			 other: "omtrent {{count}} m\xE5neder"
		  },
		  xMonths: {
			 one: "en m\xE5ned",
			 other: "{{count}} m\xE5neder"
		  },
		  aboutXYears: {
			 one: "omtrent ett \xE5r",
			 other: "omtrent {{count}} \xE5r"
		  },
		  xYears: {
			 one: "ett \xE5r",
			 other: "{{count}} \xE5r"
		  },
		  overXYears: {
			 one: "over ett \xE5r",
			 other: "over {{count}} \xE5r"
		  },
		  almostXYears: {
			 one: "nesten ett \xE5r",
			 other: "nesten {{count}} \xE5r"
		  }
		};
		var formatDistance13 = (token, count, options) => {
		  let result;
		  const tokenValue = formatDistanceLocale13[token];
		  if (typeof tokenValue === "string") {
			 result = tokenValue;
		  } else if (count === 1) {
			 result = tokenValue.one;
		  } else {
			 result = tokenValue.other.replace("{{count}}", String(count));
		  }
		  if (options?.addSuffix) {
			 if (options.comparison && options.comparison > 0) {
				return "om " + result;
			 } else {
				return result + " siden";
			 }
		  }
		  return result;
		};

		// node_modules/date-fns/locale/nb/_lib/formatLong.mjs
		var dateFormats16 = {
		  full: "EEEE d. MMMM y",
		  long: "d. MMMM y",
		  medium: "d. MMM y",
		  short: "dd.MM.y"
		};
		var timeFormats16 = {
		  full: "'kl'. HH:mm:ss zzzz",
		  long: "HH:mm:ss z",
		  medium: "HH:mm:ss",
		  short: "HH:mm"
		};
		var dateTimeFormats16 = {
		  full: "{{date}} 'kl.' {{time}}",
		  long: "{{date}} 'kl.' {{time}}",
		  medium: "{{date}} {{time}}",
		  short: "{{date}} {{time}}"
		};
		var formatLong16 = {
		  date: buildFormatLongFn({
			 formats: dateFormats16,
			 defaultWidth: "full"
		  }),
		  time: buildFormatLongFn({
			 formats: timeFormats16,
			 defaultWidth: "full"
		  }),
		  dateTime: buildFormatLongFn({
			 formats: dateTimeFormats16,
			 defaultWidth: "full"
		  })
		};

		// node_modules/date-fns/locale/nb/_lib/formatRelative.mjs
		var formatRelativeLocale14 = {
		  lastWeek: "'forrige' eeee 'kl.' p",
		  yesterday: "'i g\xE5r kl.' p",
		  today: "'i dag kl.' p",
		  tomorrow: "'i morgen kl.' p",
		  nextWeek: "EEEE 'kl.' p",
		  other: "P"
		};
		var formatRelative14 = (token, _date, _baseDate, _options) => formatRelativeLocale14[token];

		// node_modules/date-fns/locale/nb/_lib/localize.mjs
		var eraValues13 = {
		  narrow: ["f.Kr.", "e.Kr."],
		  abbreviated: ["f.Kr.", "e.Kr."],
		  wide: ["f\xF8r Kristus", "etter Kristus"]
		};
		var quarterValues13 = {
		  narrow: ["1", "2", "3", "4"],
		  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
		  wide: ["1. kvartal", "2. kvartal", "3. kvartal", "4. kvartal"]
		};
		var monthValues13 = {
		  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
		  abbreviated: [
			 "jan.",
			 "feb.",
			 "mars",
			 "apr.",
			 "mai",
			 "juni",
			 "juli",
			 "aug.",
			 "sep.",
			 "okt.",
			 "nov.",
			 "des."
		  ],
		  wide: [
			 "januar",
			 "februar",
			 "mars",
			 "april",
			 "mai",
			 "juni",
			 "juli",
			 "august",
			 "september",
			 "oktober",
			 "november",
			 "desember"
		  ]
		};
		var dayValues13 = {
		  narrow: ["S", "M", "T", "O", "T", "F", "L"],
		  short: ["s\xF8", "ma", "ti", "on", "to", "fr", "l\xF8"],
		  abbreviated: ["s\xF8n", "man", "tir", "ons", "tor", "fre", "l\xF8r"],
		  wide: [
			 "s\xF8ndag",
			 "mandag",
			 "tirsdag",
			 "onsdag",
			 "torsdag",
			 "fredag",
			 "l\xF8rdag"
		  ]
		};
		var dayPeriodValues13 = {
		  narrow: {
			 am: "a",
			 pm: "p",
			 midnight: "midnatt",
			 noon: "middag",
			 morning: "p\xE5 morg.",
			 afternoon: "p\xE5 etterm.",
			 evening: "p\xE5 kvelden",
			 night: "p\xE5 natten"
		  },
		  abbreviated: {
			 am: "a.m.",
			 pm: "p.m.",
			 midnight: "midnatt",
			 noon: "middag",
			 morning: "p\xE5 morg.",
			 afternoon: "p\xE5 etterm.",
			 evening: "p\xE5 kvelden",
			 night: "p\xE5 natten"
		  },
		  wide: {
			 am: "a.m.",
			 pm: "p.m.",
			 midnight: "midnatt",
			 noon: "middag",
			 morning: "p\xE5 morgenen",
			 afternoon: "p\xE5 ettermiddagen",
			 evening: "p\xE5 kvelden",
			 night: "p\xE5 natten"
		  }
		};
		var ordinalNumber13 = (dirtyNumber, _options) => {
		  const number5 = Number(dirtyNumber);
		  return number5 + ".";
		};
		var localize13 = {
		  ordinalNumber: ordinalNumber13,
		  era: buildLocalizeFn({
			 values: eraValues13,
			 defaultWidth: "wide"
		  }),
		  quarter: buildLocalizeFn({
			 values: quarterValues13,
			 defaultWidth: "wide",
			 argumentCallback: (quarter) => quarter - 1
		  }),
		  month: buildLocalizeFn({
			 values: monthValues13,
			 defaultWidth: "wide"
		  }),
		  day: buildLocalizeFn({
			 values: dayValues13,
			 defaultWidth: "wide"
		  }),
		  dayPeriod: buildLocalizeFn({
			 values: dayPeriodValues13,
			 defaultWidth: "wide"
		  })
		};

		// node_modules/date-fns/locale/nb/_lib/match.mjs
		var matchOrdinalNumberPattern13 = /^(\d+)\.?/i;
		var parseOrdinalNumberPattern13 = /\d+/i;
		var matchEraPatterns13 = {
		  narrow: /^(f\.? ?Kr\.?|fvt\.?|e\.? ?Kr\.?|evt\.?)/i,
		  abbreviated: /^(f\.? ?Kr\.?|fvt\.?|e\.? ?Kr\.?|evt\.?)/i,
		  wide: /^(fr Kristus|fr vr tid|etter Kristus|vr tid)/i
		};
		var parseEraPatterns13 = {
		  any: [/^f/i, /^e/i]
		};
		var matchQuarterPatterns13 = {
		  narrow: /^[1234]/i,
		  abbreviated: /^q[1234]/i,
		  wide: /^[1234](\.)? kvartal/i
		};
		var parseQuarterPatterns13 = {
		  any: [/1/i, /2/i, /3/i, /4/i]
		};
		var matchMonthPatterns13 = {
		  narrow: /^[jfmasond]/i,
		  abbreviated: /^(jan|feb|mars?|apr|mai|juni?|juli?|aug|sep|okt|nov|des)\.?/i,
		  wide: /^(januar|februar|mars|april|mai|juni|juli|august|september|oktober|november|desember)/i
		};
		var parseMonthPatterns13 = {
		  narrow: [
			 /^j/i,
			 /^f/i,
			 /^m/i,
			 /^a/i,
			 /^m/i,
			 /^j/i,
			 /^j/i,
			 /^a/i,
			 /^s/i,
			 /^o/i,
			 /^n/i,
			 /^d/i
		  ],
		  any: [
			 /^ja/i,
			 /^f/i,
			 /^mar/i,
			 /^ap/i,
			 /^mai/i,
			 /^jun/i,
			 /^jul/i,
			 /^aug/i,
			 /^s/i,
			 /^o/i,
			 /^n/i,
			 /^d/i
		  ]
		};
		var matchDayPatterns13 = {
		  narrow: /^[smtofl]/i,
		  short: /^(s|ma|ti|on|to|fr|l)/i,
		  abbreviated: /^(sn|man|tir|ons|tor|fre|lr)/i,
		  wide: /^(sndag|mandag|tirsdag|onsdag|torsdag|fredag|lrdag)/i
		};
		var parseDayPatterns13 = {
		  any: [/^s/i, /^m/i, /^ti/i, /^o/i, /^to/i, /^f/i, /^l/i]
		};
		var matchDayPeriodPatterns13 = {
		  narrow: /^(midnatt|middag|(p) (morgenen|ettermiddagen|kvelden|natten)|[ap])/i,
		  any: /^([ap]\.?\s?m\.?|midnatt|middag|(p) (morgenen|ettermiddagen|kvelden|natten))/i
		};
		var parseDayPeriodPatterns13 = {
		  any: {
			 am: /^a(\.?\s?m\.?)?$/i,
			 pm: /^p(\.?\s?m\.?)?$/i,
			 midnight: /^midn/i,
			 noon: /^midd/i,
			 morning: /morgen/i,
			 afternoon: /ettermiddag/i,
			 evening: /kveld/i,
			 night: /natt/i
		  }
		};
		var match13 = {
		  ordinalNumber: buildMatchPatternFn({
			 matchPattern: matchOrdinalNumberPattern13,
			 parsePattern: parseOrdinalNumberPattern13,
			 valueCallback: (value) => parseInt(value, 10)
		  }),
		  era: buildMatchFn({
			 matchPatterns: matchEraPatterns13,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseEraPatterns13,
			 defaultParseWidth: "any"
		  }),
		  quarter: buildMatchFn({
			 matchPatterns: matchQuarterPatterns13,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseQuarterPatterns13,
			 defaultParseWidth: "any",
			 valueCallback: (index) => index + 1
		  }),
		  month: buildMatchFn({
			 matchPatterns: matchMonthPatterns13,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseMonthPatterns13,
			 defaultParseWidth: "any"
		  }),
		  day: buildMatchFn({
			 matchPatterns: matchDayPatterns13,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseDayPatterns13,
			 defaultParseWidth: "any"
		  }),
		  dayPeriod: buildMatchFn({
			 matchPatterns: matchDayPeriodPatterns13,
			 defaultMatchWidth: "any",
			 parsePatterns: parseDayPeriodPatterns13,
			 defaultParseWidth: "any"
		  })
		};

		// node_modules/date-fns/locale/nb.mjs
		var nb = {
		  code: "nb",
		  formatDistance: formatDistance13,
		  formatLong: formatLong16,
		  formatRelative: formatRelative14,
		  localize: localize13,
		  match: match13,
		  options: {
			 weekStartsOn: 1,
			 firstWeekContainsDate: 4
		  }
		};

		// node_modules/date-fns/locale/nl/_lib/formatDistance.mjs
		var formatDistanceLocale14 = {
		  lessThanXSeconds: {
			 one: "minder dan een seconde",
			 other: "minder dan {{count}} seconden"
		  },
		  xSeconds: {
			 one: "1 seconde",
			 other: "{{count}} seconden"
		  },
		  halfAMinute: "een halve minuut",
		  lessThanXMinutes: {
			 one: "minder dan een minuut",
			 other: "minder dan {{count}} minuten"
		  },
		  xMinutes: {
			 one: "een minuut",
			 other: "{{count}} minuten"
		  },
		  aboutXHours: {
			 one: "ongeveer 1 uur",
			 other: "ongeveer {{count}} uur"
		  },
		  xHours: {
			 one: "1 uur",
			 other: "{{count}} uur"
		  },
		  xDays: {
			 one: "1 dag",
			 other: "{{count}} dagen"
		  },
		  aboutXWeeks: {
			 one: "ongeveer 1 week",
			 other: "ongeveer {{count}} weken"
		  },
		  xWeeks: {
			 one: "1 week",
			 other: "{{count}} weken"
		  },
		  aboutXMonths: {
			 one: "ongeveer 1 maand",
			 other: "ongeveer {{count}} maanden"
		  },
		  xMonths: {
			 one: "1 maand",
			 other: "{{count}} maanden"
		  },
		  aboutXYears: {
			 one: "ongeveer 1 jaar",
			 other: "ongeveer {{count}} jaar"
		  },
		  xYears: {
			 one: "1 jaar",
			 other: "{{count}} jaar"
		  },
		  overXYears: {
			 one: "meer dan 1 jaar",
			 other: "meer dan {{count}} jaar"
		  },
		  almostXYears: {
			 one: "bijna 1 jaar",
			 other: "bijna {{count}} jaar"
		  }
		};
		var formatDistance14 = (token, count, options) => {
		  let result;
		  const tokenValue = formatDistanceLocale14[token];
		  if (typeof tokenValue === "string") {
			 result = tokenValue;
		  } else if (count === 1) {
			 result = tokenValue.one;
		  } else {
			 result = tokenValue.other.replace("{{count}}", String(count));
		  }
		  if (options?.addSuffix) {
			 if (options.comparison && options.comparison > 0) {
				return "over " + result;
			 } else {
				return result + " geleden";
			 }
		  }
		  return result;
		};

		// node_modules/date-fns/locale/nl/_lib/formatLong.mjs
		var dateFormats17 = {
		  full: "EEEE d MMMM y",
		  long: "d MMMM y",
		  medium: "d MMM y",
		  short: "dd-MM-y"
		};
		var timeFormats17 = {
		  full: "HH:mm:ss zzzz",
		  long: "HH:mm:ss z",
		  medium: "HH:mm:ss",
		  short: "HH:mm"
		};
		var dateTimeFormats17 = {
		  full: "{{date}} 'om' {{time}}",
		  long: "{{date}} 'om' {{time}}",
		  medium: "{{date}}, {{time}}",
		  short: "{{date}}, {{time}}"
		};
		var formatLong17 = {
		  date: buildFormatLongFn({
			 formats: dateFormats17,
			 defaultWidth: "full"
		  }),
		  time: buildFormatLongFn({
			 formats: timeFormats17,
			 defaultWidth: "full"
		  }),
		  dateTime: buildFormatLongFn({
			 formats: dateTimeFormats17,
			 defaultWidth: "full"
		  })
		};

		// node_modules/date-fns/locale/nl/_lib/formatRelative.mjs
		var formatRelativeLocale15 = {
		  lastWeek: "'afgelopen' eeee 'om' p",
		  yesterday: "'gisteren om' p",
		  today: "'vandaag om' p",
		  tomorrow: "'morgen om' p",
		  nextWeek: "eeee 'om' p",
		  other: "P"
		};
		var formatRelative15 = (token, _date, _baseDate, _options) => formatRelativeLocale15[token];

		// node_modules/date-fns/locale/nl/_lib/localize.mjs
		var eraValues14 = {
		  narrow: ["v.C.", "n.C."],
		  abbreviated: ["v.Chr.", "n.Chr."],
		  wide: ["voor Christus", "na Christus"]
		};
		var quarterValues14 = {
		  narrow: ["1", "2", "3", "4"],
		  abbreviated: ["K1", "K2", "K3", "K4"],
		  wide: ["1e kwartaal", "2e kwartaal", "3e kwartaal", "4e kwartaal"]
		};
		var monthValues14 = {
		  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
		  abbreviated: [
			 "jan.",
			 "feb.",
			 "mrt.",
			 "apr.",
			 "mei",
			 "jun.",
			 "jul.",
			 "aug.",
			 "sep.",
			 "okt.",
			 "nov.",
			 "dec."
		  ],
		  wide: [
			 "januari",
			 "februari",
			 "maart",
			 "april",
			 "mei",
			 "juni",
			 "juli",
			 "augustus",
			 "september",
			 "oktober",
			 "november",
			 "december"
		  ]
		};
		var dayValues14 = {
		  narrow: ["Z", "M", "D", "W", "D", "V", "Z"],
		  short: ["zo", "ma", "di", "wo", "do", "vr", "za"],
		  abbreviated: ["zon", "maa", "din", "woe", "don", "vri", "zat"],
		  wide: [
			 "zondag",
			 "maandag",
			 "dinsdag",
			 "woensdag",
			 "donderdag",
			 "vrijdag",
			 "zaterdag"
		  ]
		};
		var dayPeriodValues14 = {
		  narrow: {
			 am: "AM",
			 pm: "PM",
			 midnight: "middernacht",
			 noon: "het middaguur",
			 morning: "'s ochtends",
			 afternoon: "'s middags",
			 evening: "'s avonds",
			 night: "'s nachts"
		  },
		  abbreviated: {
			 am: "AM",
			 pm: "PM",
			 midnight: "middernacht",
			 noon: "het middaguur",
			 morning: "'s ochtends",
			 afternoon: "'s middags",
			 evening: "'s avonds",
			 night: "'s nachts"
		  },
		  wide: {
			 am: "AM",
			 pm: "PM",
			 midnight: "middernacht",
			 noon: "het middaguur",
			 morning: "'s ochtends",
			 afternoon: "'s middags",
			 evening: "'s avonds",
			 night: "'s nachts"
		  }
		};
		var ordinalNumber14 = (dirtyNumber, _options) => {
		  const number5 = Number(dirtyNumber);
		  return number5 + "e";
		};
		var localize14 = {
		  ordinalNumber: ordinalNumber14,
		  era: buildLocalizeFn({
			 values: eraValues14,
			 defaultWidth: "wide"
		  }),
		  quarter: buildLocalizeFn({
			 values: quarterValues14,
			 defaultWidth: "wide",
			 argumentCallback: (quarter) => quarter - 1
		  }),
		  month: buildLocalizeFn({
			 values: monthValues14,
			 defaultWidth: "wide"
		  }),
		  day: buildLocalizeFn({
			 values: dayValues14,
			 defaultWidth: "wide"
		  }),
		  dayPeriod: buildLocalizeFn({
			 values: dayPeriodValues14,
			 defaultWidth: "wide"
		  })
		};

		// node_modules/date-fns/locale/nl/_lib/match.mjs
		var matchOrdinalNumberPattern14 = /^(\d+)e?/i;
		var parseOrdinalNumberPattern14 = /\d+/i;
		var matchEraPatterns14 = {
		  narrow: /^([vn]\.? ?C\.?)/,
		  abbreviated: /^([vn]\. ?Chr\.?)/,
		  wide: /^((voor|na) Christus)/
		};
		var parseEraPatterns14 = {
		  any: [/^v/, /^n/]
		};
		var matchQuarterPatterns14 = {
		  narrow: /^[1234]/i,
		  abbreviated: /^K[1234]/i,
		  wide: /^[1234]e kwartaal/i
		};
		var parseQuarterPatterns14 = {
		  any: [/1/i, /2/i, /3/i, /4/i]
		};
		var matchMonthPatterns14 = {
		  narrow: /^[jfmasond]/i,
		  abbreviated: /^(jan.|feb.|mrt.|apr.|mei|jun.|jul.|aug.|sep.|okt.|nov.|dec.)/i,
		  wide: /^(januari|februari|maart|april|mei|juni|juli|augustus|september|oktober|november|december)/i
		};
		var parseMonthPatterns14 = {
		  narrow: [
			 /^j/i,
			 /^f/i,
			 /^m/i,
			 /^a/i,
			 /^m/i,
			 /^j/i,
			 /^j/i,
			 /^a/i,
			 /^s/i,
			 /^o/i,
			 /^n/i,
			 /^d/i
		  ],
		  any: [
			 /^jan/i,
			 /^feb/i,
			 /^m(r|a)/i,
			 /^apr/i,
			 /^mei/i,
			 /^jun/i,
			 /^jul/i,
			 /^aug/i,
			 /^sep/i,
			 /^okt/i,
			 /^nov/i,
			 /^dec/i
		  ]
		};
		var matchDayPatterns14 = {
		  narrow: /^[zmdwv]/i,
		  short: /^(zo|ma|di|wo|do|vr|za)/i,
		  abbreviated: /^(zon|maa|din|woe|don|vri|zat)/i,
		  wide: /^(zondag|maandag|dinsdag|woensdag|donderdag|vrijdag|zaterdag)/i
		};
		var parseDayPatterns14 = {
		  narrow: [/^z/i, /^m/i, /^d/i, /^w/i, /^d/i, /^v/i, /^z/i],
		  any: [/^zo/i, /^ma/i, /^di/i, /^wo/i, /^do/i, /^vr/i, /^za/i]
		};
		var matchDayPeriodPatterns14 = {
		  any: /^(am|pm|middernacht|het middaguur|'s (ochtends|middags|avonds|nachts))/i
		};
		var parseDayPeriodPatterns14 = {
		  any: {
			 am: /^am/i,
			 pm: /^pm/i,
			 midnight: /^middernacht/i,
			 noon: /^het middaguur/i,
			 morning: /ochtend/i,
			 afternoon: /middag/i,
			 evening: /avond/i,
			 night: /nacht/i
		  }
		};
		var match14 = {
		  ordinalNumber: buildMatchPatternFn({
			 matchPattern: matchOrdinalNumberPattern14,
			 parsePattern: parseOrdinalNumberPattern14,
			 valueCallback: (value) => parseInt(value, 10)
		  }),
		  era: buildMatchFn({
			 matchPatterns: matchEraPatterns14,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseEraPatterns14,
			 defaultParseWidth: "any"
		  }),
		  quarter: buildMatchFn({
			 matchPatterns: matchQuarterPatterns14,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseQuarterPatterns14,
			 defaultParseWidth: "any",
			 valueCallback: (index) => index + 1
		  }),
		  month: buildMatchFn({
			 matchPatterns: matchMonthPatterns14,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseMonthPatterns14,
			 defaultParseWidth: "any"
		  }),
		  day: buildMatchFn({
			 matchPatterns: matchDayPatterns14,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseDayPatterns14,
			 defaultParseWidth: "any"
		  }),
		  dayPeriod: buildMatchFn({
			 matchPatterns: matchDayPeriodPatterns14,
			 defaultMatchWidth: "any",
			 parsePatterns: parseDayPeriodPatterns14,
			 defaultParseWidth: "any"
		  })
		};

		// node_modules/date-fns/locale/nl.mjs
		var nl = {
		  code: "nl",
		  formatDistance: formatDistance14,
		  formatLong: formatLong17,
		  formatRelative: formatRelative15,
		  localize: localize14,
		  match: match14,
		  options: {
			 weekStartsOn: 1,
			 firstWeekContainsDate: 4
		  }
		};

		// node_modules/date-fns/locale/pl/_lib/formatDistance.mjs
		var formatDistanceLocale15 = {
		  lessThanXSeconds: {
			 one: {
				regular: "mniej ni\u017C sekunda",
				past: "mniej ni\u017C sekund\u0119",
				future: "mniej ni\u017C sekund\u0119"
			 },
			 twoFour: "mniej ni\u017C {{count}} sekundy",
			 other: "mniej ni\u017C {{count}} sekund"
		  },
		  xSeconds: {
			 one: {
				regular: "sekunda",
				past: "sekund\u0119",
				future: "sekund\u0119"
			 },
			 twoFour: "{{count}} sekundy",
			 other: "{{count}} sekund"
		  },
		  halfAMinute: {
			 one: "p\xF3\u0142 minuty",
			 twoFour: "p\xF3\u0142 minuty",
			 other: "p\xF3\u0142 minuty"
		  },
		  lessThanXMinutes: {
			 one: {
				regular: "mniej ni\u017C minuta",
				past: "mniej ni\u017C minut\u0119",
				future: "mniej ni\u017C minut\u0119"
			 },
			 twoFour: "mniej ni\u017C {{count}} minuty",
			 other: "mniej ni\u017C {{count}} minut"
		  },
		  xMinutes: {
			 one: {
				regular: "minuta",
				past: "minut\u0119",
				future: "minut\u0119"
			 },
			 twoFour: "{{count}} minuty",
			 other: "{{count}} minut"
		  },
		  aboutXHours: {
			 one: {
				regular: "oko\u0142o godziny",
				past: "oko\u0142o godziny",
				future: "oko\u0142o godzin\u0119"
			 },
			 twoFour: "oko\u0142o {{count}} godziny",
			 other: "oko\u0142o {{count}} godzin"
		  },
		  xHours: {
			 one: {
				regular: "godzina",
				past: "godzin\u0119",
				future: "godzin\u0119"
			 },
			 twoFour: "{{count}} godziny",
			 other: "{{count}} godzin"
		  },
		  xDays: {
			 one: {
				regular: "dzie\u0144",
				past: "dzie\u0144",
				future: "1 dzie\u0144"
			 },
			 twoFour: "{{count}} dni",
			 other: "{{count}} dni"
		  },
		  aboutXWeeks: {
			 one: "oko\u0142o tygodnia",
			 twoFour: "oko\u0142o {{count}} tygodni",
			 other: "oko\u0142o {{count}} tygodni"
		  },
		  xWeeks: {
			 one: "tydzie\u0144",
			 twoFour: "{{count}} tygodnie",
			 other: "{{count}} tygodni"
		  },
		  aboutXMonths: {
			 one: "oko\u0142o miesi\u0105c",
			 twoFour: "oko\u0142o {{count}} miesi\u0105ce",
			 other: "oko\u0142o {{count}} miesi\u0119cy"
		  },
		  xMonths: {
			 one: "miesi\u0105c",
			 twoFour: "{{count}} miesi\u0105ce",
			 other: "{{count}} miesi\u0119cy"
		  },
		  aboutXYears: {
			 one: "oko\u0142o rok",
			 twoFour: "oko\u0142o {{count}} lata",
			 other: "oko\u0142o {{count}} lat"
		  },
		  xYears: {
			 one: "rok",
			 twoFour: "{{count}} lata",
			 other: "{{count}} lat"
		  },
		  overXYears: {
			 one: "ponad rok",
			 twoFour: "ponad {{count}} lata",
			 other: "ponad {{count}} lat"
		  },
		  almostXYears: {
			 one: "prawie rok",
			 twoFour: "prawie {{count}} lata",
			 other: "prawie {{count}} lat"
		  }
		};
		function declensionGroup(scheme, count) {
		  if (count === 1) {
			 return scheme.one;
		  }
		  const rem100 = count % 100;
		  if (rem100 <= 20 && rem100 > 10) {
			 return scheme.other;
		  }
		  const rem10 = rem100 % 10;
		  if (rem10 >= 2 && rem10 <= 4) {
			 return scheme.twoFour;
		  }
		  return scheme.other;
		}
		function declension(scheme, count, time) {
		  const group = declensionGroup(scheme, count);
		  const finalText = typeof group === "string" ? group : group[time];
		  return finalText.replace("{{count}}", String(count));
		}
		var formatDistance15 = (token, count, options) => {
		  const scheme = formatDistanceLocale15[token];
		  if (!options?.addSuffix) {
			 return declension(scheme, count, "regular");
		  }
		  if (options.comparison && options.comparison > 0) {
			 return "za " + declension(scheme, count, "future");
		  } else {
			 return declension(scheme, count, "past") + " temu";
		  }
		};

		// node_modules/date-fns/locale/pl/_lib/formatLong.mjs
		var dateFormats18 = {
		  full: "EEEE, do MMMM y",
		  long: "do MMMM y",
		  medium: "do MMM y",
		  short: "dd.MM.y"
		};
		var timeFormats18 = {
		  full: "HH:mm:ss zzzz",
		  long: "HH:mm:ss z",
		  medium: "HH:mm:ss",
		  short: "HH:mm"
		};
		var dateTimeFormats18 = {
		  full: "{{date}} {{time}}",
		  long: "{{date}} {{time}}",
		  medium: "{{date}}, {{time}}",
		  short: "{{date}}, {{time}}"
		};
		var formatLong18 = {
		  date: buildFormatLongFn({
			 formats: dateFormats18,
			 defaultWidth: "full"
		  }),
		  time: buildFormatLongFn({
			 formats: timeFormats18,
			 defaultWidth: "full"
		  }),
		  dateTime: buildFormatLongFn({
			 formats: dateTimeFormats18,
			 defaultWidth: "full"
		  })
		};

		// node_modules/date-fns/locale/pl/_lib/formatRelative.mjs
		var adjectivesLastWeek = {
		  masculine: "ostatni",
		  feminine: "ostatnia"
		};
		var adjectivesThisWeek = {
		  masculine: "ten",
		  feminine: "ta"
		};
		var adjectivesNextWeek = {
		  masculine: "nast\u0119pny",
		  feminine: "nast\u0119pna"
		};
		var dayGrammaticalGender = {
		  0: "feminine",
		  1: "masculine",
		  2: "masculine",
		  3: "feminine",
		  4: "masculine",
		  5: "masculine",
		  6: "feminine"
		};
		function dayAndTimeWithAdjective(token, date2, baseDate, options) {
		  let adjectives;
		  if (isSameWeek(date2, baseDate, options)) {
			 adjectives = adjectivesThisWeek;
		  } else if (token === "lastWeek") {
			 adjectives = adjectivesLastWeek;
		  } else if (token === "nextWeek") {
			 adjectives = adjectivesNextWeek;
		  } else {
			 throw new Error(`Cannot determine adjectives for token ${token}`);
		  }
		  const day = date2.getDay();
		  const grammaticalGender = dayGrammaticalGender[day];
		  const adjective = adjectives[grammaticalGender];
		  return `'${adjective}' eeee 'o' p`;
		}
		var formatRelativeLocale16 = {
		  lastWeek: dayAndTimeWithAdjective,
		  yesterday: "'wczoraj o' p",
		  today: "'dzisiaj o' p",
		  tomorrow: "'jutro o' p",
		  nextWeek: dayAndTimeWithAdjective,
		  other: "P"
		};
		var formatRelative16 = (token, date2, baseDate, options) => {
		  const format2 = formatRelativeLocale16[token];
		  if (typeof format2 === "function") {
			 return format2(token, date2, baseDate, options);
		  }
		  return format2;
		};

		// node_modules/date-fns/locale/pl/_lib/localize.mjs
		var eraValues15 = {
		  narrow: ["p.n.e.", "n.e."],
		  abbreviated: ["p.n.e.", "n.e."],
		  wide: ["przed nasz\u0105 er\u0105", "naszej ery"]
		};
		var quarterValues15 = {
		  narrow: ["1", "2", "3", "4"],
		  abbreviated: ["I kw.", "II kw.", "III kw.", "IV kw."],
		  wide: ["I kwarta\u0142", "II kwarta\u0142", "III kwarta\u0142", "IV kwarta\u0142"]
		};
		var monthValues15 = {
		  narrow: ["S", "L", "M", "K", "M", "C", "L", "S", "W", "P", "L", "G"],
		  abbreviated: [
			 "sty",
			 "lut",
			 "mar",
			 "kwi",
			 "maj",
			 "cze",
			 "lip",
			 "sie",
			 "wrz",
			 "pa\u017A",
			 "lis",
			 "gru"
		  ],
		  wide: [
			 "stycze\u0144",
			 "luty",
			 "marzec",
			 "kwiecie\u0144",
			 "maj",
			 "czerwiec",
			 "lipiec",
			 "sierpie\u0144",
			 "wrzesie\u0144",
			 "pa\u017Adziernik",
			 "listopad",
			 "grudzie\u0144"
		  ]
		};
		var monthFormattingValues = {
		  narrow: ["s", "l", "m", "k", "m", "c", "l", "s", "w", "p", "l", "g"],
		  abbreviated: [
			 "sty",
			 "lut",
			 "mar",
			 "kwi",
			 "maj",
			 "cze",
			 "lip",
			 "sie",
			 "wrz",
			 "pa\u017A",
			 "lis",
			 "gru"
		  ],
		  wide: [
			 "stycznia",
			 "lutego",
			 "marca",
			 "kwietnia",
			 "maja",
			 "czerwca",
			 "lipca",
			 "sierpnia",
			 "wrze\u015Bnia",
			 "pa\u017Adziernika",
			 "listopada",
			 "grudnia"
		  ]
		};
		var dayValues15 = {
		  narrow: ["N", "P", "W", "\u015A", "C", "P", "S"],
		  short: ["nie", "pon", "wto", "\u015Bro", "czw", "pi\u0105", "sob"],
		  abbreviated: ["niedz.", "pon.", "wt.", "\u015Br.", "czw.", "pt.", "sob."],
		  wide: [
			 "niedziela",
			 "poniedzia\u0142ek",
			 "wtorek",
			 "\u015Broda",
			 "czwartek",
			 "pi\u0105tek",
			 "sobota"
		  ]
		};
		var dayFormattingValues = {
		  narrow: ["n", "p", "w", "\u015B", "c", "p", "s"],
		  short: ["nie", "pon", "wto", "\u015Bro", "czw", "pi\u0105", "sob"],
		  abbreviated: ["niedz.", "pon.", "wt.", "\u015Br.", "czw.", "pt.", "sob."],
		  wide: [
			 "niedziela",
			 "poniedzia\u0142ek",
			 "wtorek",
			 "\u015Broda",
			 "czwartek",
			 "pi\u0105tek",
			 "sobota"
		  ]
		};
		var dayPeriodValues15 = {
		  narrow: {
			 am: "a",
			 pm: "p",
			 midnight: "p\xF3\u0142n.",
			 noon: "po\u0142",
			 morning: "rano",
			 afternoon: "popo\u0142.",
			 evening: "wiecz.",
			 night: "noc"
		  },
		  abbreviated: {
			 am: "AM",
			 pm: "PM",
			 midnight: "p\xF3\u0142noc",
			 noon: "po\u0142udnie",
			 morning: "rano",
			 afternoon: "popo\u0142udnie",
			 evening: "wiecz\xF3r",
			 night: "noc"
		  },
		  wide: {
			 am: "AM",
			 pm: "PM",
			 midnight: "p\xF3\u0142noc",
			 noon: "po\u0142udnie",
			 morning: "rano",
			 afternoon: "popo\u0142udnie",
			 evening: "wiecz\xF3r",
			 night: "noc"
		  }
		};
		var dayPeriodFormattingValues = {
		  narrow: {
			 am: "a",
			 pm: "p",
			 midnight: "o p\xF3\u0142n.",
			 noon: "w po\u0142.",
			 morning: "rano",
			 afternoon: "po po\u0142.",
			 evening: "wiecz.",
			 night: "w nocy"
		  },
		  abbreviated: {
			 am: "AM",
			 pm: "PM",
			 midnight: "o p\xF3\u0142nocy",
			 noon: "w po\u0142udnie",
			 morning: "rano",
			 afternoon: "po po\u0142udniu",
			 evening: "wieczorem",
			 night: "w nocy"
		  },
		  wide: {
			 am: "AM",
			 pm: "PM",
			 midnight: "o p\xF3\u0142nocy",
			 noon: "w po\u0142udnie",
			 morning: "rano",
			 afternoon: "po po\u0142udniu",
			 evening: "wieczorem",
			 night: "w nocy"
		  }
		};
		var ordinalNumber15 = (dirtyNumber, _options) => {
		  return String(dirtyNumber);
		};
		var localize15 = {
		  ordinalNumber: ordinalNumber15,
		  era: buildLocalizeFn({
			 values: eraValues15,
			 defaultWidth: "wide"
		  }),
		  quarter: buildLocalizeFn({
			 values: quarterValues15,
			 defaultWidth: "wide",
			 argumentCallback: (quarter) => quarter - 1
		  }),
		  month: buildLocalizeFn({
			 values: monthValues15,
			 defaultWidth: "wide",
			 formattingValues: monthFormattingValues,
			 defaultFormattingWidth: "wide"
		  }),
		  day: buildLocalizeFn({
			 values: dayValues15,
			 defaultWidth: "wide",
			 formattingValues: dayFormattingValues,
			 defaultFormattingWidth: "wide"
		  }),
		  dayPeriod: buildLocalizeFn({
			 values: dayPeriodValues15,
			 defaultWidth: "wide",
			 formattingValues: dayPeriodFormattingValues,
			 defaultFormattingWidth: "wide"
		  })
		};

		// node_modules/date-fns/locale/pl/_lib/match.mjs
		var matchOrdinalNumberPattern15 = /^(\d+)?/i;
		var parseOrdinalNumberPattern15 = /\d+/i;
		var matchEraPatterns15 = {
		  narrow: /^(p\.?\s*n\.?\s*e\.?\s*|n\.?\s*e\.?\s*)/i,
		  abbreviated: /^(p\.?\s*n\.?\s*e\.?\s*|n\.?\s*e\.?\s*)/i,
		  wide: /^(przed\s*nasz(|a)\s*er(|a)|naszej\s*ery)/i
		};
		var parseEraPatterns15 = {
		  any: [/^p/i, /^n/i]
		};
		var matchQuarterPatterns15 = {
		  narrow: /^[1234]/i,
		  abbreviated: /^(I|II|III|IV)\s*kw\.?/i,
		  wide: /^(I|II|III|IV)\s*kwarta(|l)/i
		};
		var parseQuarterPatterns15 = {
		  narrow: [/1/i, /2/i, /3/i, /4/i],
		  any: [/^I kw/i, /^II kw/i, /^III kw/i, /^IV kw/i]
		};
		var matchMonthPatterns15 = {
		  narrow: /^[slmkcwpg]/i,
		  abbreviated: /^(sty|lut|mar|kwi|maj|cze|lip|sie|wrz|pa(|z)|lis|gru)/i,
		  wide: /^(stycznia|stycze(|n)|lutego|luty|marca|marzec|kwietnia|kwiecie(|n)|maja|maj|czerwca|czerwiec|lipca|lipiec|sierpnia|sierpie(|n)|wrze(|s)nia|wrzesie(|n)|pa(|z)dziernika|pa(|z)dziernik|listopada|listopad|grudnia|grudzie(|n))/i
		};
		var parseMonthPatterns15 = {
		  narrow: [
			 /^s/i,
			 /^l/i,
			 /^m/i,
			 /^k/i,
			 /^m/i,
			 /^c/i,
			 /^l/i,
			 /^s/i,
			 /^w/i,
			 /^p/i,
			 /^l/i,
			 /^g/i
		  ],
		  any: [
			 /^st/i,
			 /^lu/i,
			 /^mar/i,
			 /^k/i,
			 /^maj/i,
			 /^c/i,
			 /^lip/i,
			 /^si/i,
			 /^w/i,
			 /^p/i,
			 /^lis/i,
			 /^g/i
		  ]
		};
		var matchDayPatterns15 = {
		  narrow: /^[npwcs]/i,
		  short: /^(nie|pon|wto|(|s)ro|czw|pi(|a)|sob)/i,
		  abbreviated: /^(niedz|pon|wt|(|s)r|czw|pt|sob)\.?/i,
		  wide: /^(niedziela|poniedzia(|l)ek|wtorek|(|s)roda|czwartek|pi(|a)tek|sobota)/i
		};
		var parseDayPatterns15 = {
		  narrow: [/^n/i, /^p/i, /^w/i, /^/i, /^c/i, /^p/i, /^s/i],
		  abbreviated: [/^n/i, /^po/i, /^w/i, /^(|s)r/i, /^c/i, /^pt/i, /^so/i],
		  any: [/^n/i, /^po/i, /^w/i, /^(|s)r/i, /^c/i, /^pi/i, /^so/i]
		};
		var matchDayPeriodPatterns15 = {
		  narrow: /^(^a$|^p$|p(|l)n\.?|o\s*p(|l)n\.?|po(|l)\.?|w\s*po(|l)\.?|po\s*po(|l)\.?|rano|wiecz\.?|noc|w\s*nocy)/i,
		  any: /^(am|pm|p(|l)noc|o\s*p(|l)nocy|po(|l)udnie|w\s*po(|l)udnie|popo(|l)udnie|po\s*po(|l)udniu|rano|wieczr|wieczorem|noc|w\s*nocy)/i
		};
		var parseDayPeriodPatterns15 = {
		  narrow: {
			 am: /^a$/i,
			 pm: /^p$/i,
			 midnight: /p(|l)n/i,
			 noon: /po(|l)/i,
			 morning: /rano/i,
			 afternoon: /po\s*po(|l)/i,
			 evening: /wiecz/i,
			 night: /noc/i
		  },
		  any: {
			 am: /^am/i,
			 pm: /^pm/i,
			 midnight: /p(|l)n/i,
			 noon: /po(|l)/i,
			 morning: /rano/i,
			 afternoon: /po\s*po(|l)/i,
			 evening: /wiecz/i,
			 night: /noc/i
		  }
		};
		var match15 = {
		  ordinalNumber: buildMatchPatternFn({
			 matchPattern: matchOrdinalNumberPattern15,
			 parsePattern: parseOrdinalNumberPattern15,
			 valueCallback: (value) => parseInt(value, 10)
		  }),
		  era: buildMatchFn({
			 matchPatterns: matchEraPatterns15,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseEraPatterns15,
			 defaultParseWidth: "any"
		  }),
		  quarter: buildMatchFn({
			 matchPatterns: matchQuarterPatterns15,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseQuarterPatterns15,
			 defaultParseWidth: "any",
			 valueCallback: (index) => index + 1
		  }),
		  month: buildMatchFn({
			 matchPatterns: matchMonthPatterns15,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseMonthPatterns15,
			 defaultParseWidth: "any"
		  }),
		  day: buildMatchFn({
			 matchPatterns: matchDayPatterns15,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseDayPatterns15,
			 defaultParseWidth: "any"
		  }),
		  dayPeriod: buildMatchFn({
			 matchPatterns: matchDayPeriodPatterns15,
			 defaultMatchWidth: "any",
			 parsePatterns: parseDayPeriodPatterns15,
			 defaultParseWidth: "any"
		  })
		};

		// node_modules/date-fns/locale/pl.mjs
		var pl = {
		  code: "pl",
		  formatDistance: formatDistance15,
		  formatLong: formatLong18,
		  formatRelative: formatRelative16,
		  localize: localize15,
		  match: match15,
		  options: {
			 weekStartsOn: 1,
			 firstWeekContainsDate: 4
		  }
		};

		// node_modules/date-fns/locale/pt/_lib/formatDistance.mjs
		var formatDistanceLocale16 = {
		  lessThanXSeconds: {
			 one: "menos de um segundo",
			 other: "menos de {{count}} segundos"
		  },
		  xSeconds: {
			 one: "1 segundo",
			 other: "{{count}} segundos"
		  },
		  halfAMinute: "meio minuto",
		  lessThanXMinutes: {
			 one: "menos de um minuto",
			 other: "menos de {{count}} minutos"
		  },
		  xMinutes: {
			 one: "1 minuto",
			 other: "{{count}} minutos"
		  },
		  aboutXHours: {
			 one: "aproximadamente 1 hora",
			 other: "aproximadamente {{count}} horas"
		  },
		  xHours: {
			 one: "1 hora",
			 other: "{{count}} horas"
		  },
		  xDays: {
			 one: "1 dia",
			 other: "{{count}} dias"
		  },
		  aboutXWeeks: {
			 one: "aproximadamente 1 semana",
			 other: "aproximadamente {{count}} semanas"
		  },
		  xWeeks: {
			 one: "1 semana",
			 other: "{{count}} semanas"
		  },
		  aboutXMonths: {
			 one: "aproximadamente 1 m\xEAs",
			 other: "aproximadamente {{count}} meses"
		  },
		  xMonths: {
			 one: "1 m\xEAs",
			 other: "{{count}} meses"
		  },
		  aboutXYears: {
			 one: "aproximadamente 1 ano",
			 other: "aproximadamente {{count}} anos"
		  },
		  xYears: {
			 one: "1 ano",
			 other: "{{count}} anos"
		  },
		  overXYears: {
			 one: "mais de 1 ano",
			 other: "mais de {{count}} anos"
		  },
		  almostXYears: {
			 one: "quase 1 ano",
			 other: "quase {{count}} anos"
		  }
		};
		var formatDistance16 = (token, count, options) => {
		  let result;
		  const tokenValue = formatDistanceLocale16[token];
		  if (typeof tokenValue === "string") {
			 result = tokenValue;
		  } else if (count === 1) {
			 result = tokenValue.one;
		  } else {
			 result = tokenValue.other.replace("{{count}}", String(count));
		  }
		  if (options?.addSuffix) {
			 if (options.comparison && options.comparison > 0) {
				return "daqui a " + result;
			 } else {
				return "h\xE1 " + result;
			 }
		  }
		  return result;
		};

		// node_modules/date-fns/locale/pt/_lib/formatLong.mjs
		var dateFormats19 = {
		  full: "EEEE, d 'de' MMMM 'de' y",
		  long: "d 'de' MMMM 'de' y",
		  medium: "d 'de' MMM 'de' y",
		  short: "dd/MM/y"
		};
		var timeFormats19 = {
		  full: "HH:mm:ss zzzz",
		  long: "HH:mm:ss z",
		  medium: "HH:mm:ss",
		  short: "HH:mm"
		};
		var dateTimeFormats19 = {
		  full: "{{date}} '\xE0s' {{time}}",
		  long: "{{date}} '\xE0s' {{time}}",
		  medium: "{{date}}, {{time}}",
		  short: "{{date}}, {{time}}"
		};
		var formatLong19 = {
		  date: buildFormatLongFn({
			 formats: dateFormats19,
			 defaultWidth: "full"
		  }),
		  time: buildFormatLongFn({
			 formats: timeFormats19,
			 defaultWidth: "full"
		  }),
		  dateTime: buildFormatLongFn({
			 formats: dateTimeFormats19,
			 defaultWidth: "full"
		  })
		};

		// node_modules/date-fns/locale/pt/_lib/formatRelative.mjs
		var formatRelativeLocale17 = {
		  lastWeek: (date2) => {
			 const weekday = date2.getDay();
			 const last2 = weekday === 0 || weekday === 6 ? "\xFAltimo" : "\xFAltima";
			 return "'" + last2 + "' eeee '\xE0s' p";
		  },
		  yesterday: "'ontem \xE0s' p",
		  today: "'hoje \xE0s' p",
		  tomorrow: "'amanh\xE3 \xE0s' p",
		  nextWeek: "eeee '\xE0s' p",
		  other: "P"
		};
		var formatRelative17 = (token, date2, _baseDate, _options) => {
		  const format2 = formatRelativeLocale17[token];
		  if (typeof format2 === "function") {
			 return format2(date2);
		  }
		  return format2;
		};

		// node_modules/date-fns/locale/pt/_lib/localize.mjs
		var eraValues16 = {
		  narrow: ["aC", "dC"],
		  abbreviated: ["a.C.", "d.C."],
		  wide: ["antes de Cristo", "depois de Cristo"]
		};
		var quarterValues16 = {
		  narrow: ["1", "2", "3", "4"],
		  abbreviated: ["T1", "T2", "T3", "T4"],
		  wide: ["1\xBA trimestre", "2\xBA trimestre", "3\xBA trimestre", "4\xBA trimestre"]
		};
		var monthValues16 = {
		  narrow: ["j", "f", "m", "a", "m", "j", "j", "a", "s", "o", "n", "d"],
		  abbreviated: [
			 "jan",
			 "fev",
			 "mar",
			 "abr",
			 "mai",
			 "jun",
			 "jul",
			 "ago",
			 "set",
			 "out",
			 "nov",
			 "dez"
		  ],
		  wide: [
			 "janeiro",
			 "fevereiro",
			 "mar\xE7o",
			 "abril",
			 "maio",
			 "junho",
			 "julho",
			 "agosto",
			 "setembro",
			 "outubro",
			 "novembro",
			 "dezembro"
		  ]
		};
		var dayValues16 = {
		  narrow: ["d", "s", "t", "q", "q", "s", "s"],
		  short: ["dom", "seg", "ter", "qua", "qui", "sex", "s\xE1b"],
		  abbreviated: ["dom", "seg", "ter", "qua", "qui", "sex", "s\xE1b"],
		  wide: [
			 "domingo",
			 "segunda-feira",
			 "ter\xE7a-feira",
			 "quarta-feira",
			 "quinta-feira",
			 "sexta-feira",
			 "s\xE1bado"
		  ]
		};
		var dayPeriodValues16 = {
		  narrow: {
			 am: "AM",
			 pm: "PM",
			 midnight: "meia-noite",
			 noon: "meio-dia",
			 morning: "manh\xE3",
			 afternoon: "tarde",
			 evening: "noite",
			 night: "madrugada"
		  },
		  abbreviated: {
			 am: "AM",
			 pm: "PM",
			 midnight: "meia-noite",
			 noon: "meio-dia",
			 morning: "manh\xE3",
			 afternoon: "tarde",
			 evening: "noite",
			 night: "madrugada"
		  },
		  wide: {
			 am: "AM",
			 pm: "PM",
			 midnight: "meia-noite",
			 noon: "meio-dia",
			 morning: "manh\xE3",
			 afternoon: "tarde",
			 evening: "noite",
			 night: "madrugada"
		  }
		};
		var formattingDayPeriodValues11 = {
		  narrow: {
			 am: "AM",
			 pm: "PM",
			 midnight: "meia-noite",
			 noon: "meio-dia",
			 morning: "da manh\xE3",
			 afternoon: "da tarde",
			 evening: "da noite",
			 night: "da madrugada"
		  },
		  abbreviated: {
			 am: "AM",
			 pm: "PM",
			 midnight: "meia-noite",
			 noon: "meio-dia",
			 morning: "da manh\xE3",
			 afternoon: "da tarde",
			 evening: "da noite",
			 night: "da madrugada"
		  },
		  wide: {
			 am: "AM",
			 pm: "PM",
			 midnight: "meia-noite",
			 noon: "meio-dia",
			 morning: "da manh\xE3",
			 afternoon: "da tarde",
			 evening: "da noite",
			 night: "da madrugada"
		  }
		};
		var ordinalNumber16 = (dirtyNumber, _options) => {
		  const number5 = Number(dirtyNumber);
		  return number5 + "\xBA";
		};
		var localize16 = {
		  ordinalNumber: ordinalNumber16,
		  era: buildLocalizeFn({
			 values: eraValues16,
			 defaultWidth: "wide"
		  }),
		  quarter: buildLocalizeFn({
			 values: quarterValues16,
			 defaultWidth: "wide",
			 argumentCallback: (quarter) => quarter - 1
		  }),
		  month: buildLocalizeFn({
			 values: monthValues16,
			 defaultWidth: "wide"
		  }),
		  day: buildLocalizeFn({
			 values: dayValues16,
			 defaultWidth: "wide"
		  }),
		  dayPeriod: buildLocalizeFn({
			 values: dayPeriodValues16,
			 defaultWidth: "wide",
			 formattingValues: formattingDayPeriodValues11,
			 defaultFormattingWidth: "wide"
		  })
		};

		// node_modules/date-fns/locale/pt/_lib/match.mjs
		var matchOrdinalNumberPattern16 = /^(\d+)(|)?/i;
		var parseOrdinalNumberPattern16 = /\d+/i;
		var matchEraPatterns16 = {
		  narrow: /^(ac|dc|a|d)/i,
		  abbreviated: /^(a\.?\s?c\.?|a\.?\s?e\.?\s?c\.?|d\.?\s?c\.?|e\.?\s?c\.?)/i,
		  wide: /^(antes de cristo|antes da era comum|depois de cristo|era comum)/i
		};
		var parseEraPatterns16 = {
		  any: [/^ac/i, /^dc/i],
		  wide: [
			 /^(antes de cristo|antes da era comum)/i,
			 /^(depois de cristo|era comum)/i
		  ]
		};
		var matchQuarterPatterns16 = {
		  narrow: /^[1234]/i,
		  abbreviated: /^T[1234]/i,
		  wide: /^[1234](|)? trimestre/i
		};
		var parseQuarterPatterns16 = {
		  any: [/1/i, /2/i, /3/i, /4/i]
		};
		var matchMonthPatterns16 = {
		  narrow: /^[jfmasond]/i,
		  abbreviated: /^(jan|fev|mar|abr|mai|jun|jul|ago|set|out|nov|dez)/i,
		  wide: /^(janeiro|fevereiro|maro|abril|maio|junho|julho|agosto|setembro|outubro|novembro|dezembro)/i
		};
		var parseMonthPatterns16 = {
		  narrow: [
			 /^j/i,
			 /^f/i,
			 /^m/i,
			 /^a/i,
			 /^m/i,
			 /^j/i,
			 /^j/i,
			 /^a/i,
			 /^s/i,
			 /^o/i,
			 /^n/i,
			 /^d/i
		  ],
		  any: [
			 /^ja/i,
			 /^f/i,
			 /^mar/i,
			 /^ab/i,
			 /^mai/i,
			 /^jun/i,
			 /^jul/i,
			 /^ag/i,
			 /^s/i,
			 /^o/i,
			 /^n/i,
			 /^d/i
		  ]
		};
		var matchDayPatterns16 = {
		  narrow: /^[dstq]/i,
		  short: /^(dom|seg|ter|qua|qui|sex|s[a]b)/i,
		  abbreviated: /^(dom|seg|ter|qua|qui|sex|s[a]b)/i,
		  wide: /^(domingo|segunda-?\s?feira|tera-?\s?feira|quarta-?\s?feira|quinta-?\s?feira|sexta-?\s?feira|s[a]bado)/i
		};
		var parseDayPatterns16 = {
		  narrow: [/^d/i, /^s/i, /^t/i, /^q/i, /^q/i, /^s/i, /^s/i],
		  any: [/^d/i, /^seg/i, /^t/i, /^qua/i, /^qui/i, /^sex/i, /^s[a]/i]
		};
		var matchDayPeriodPatterns16 = {
		  narrow: /^(a|p|meia-?\s?noite|meio-?\s?dia|(da) (manh[a]|tarde|noite|madrugada))/i,
		  any: /^([ap]\.?\s?m\.?|meia-?\s?noite|meio-?\s?dia|(da) (manh[a]|tarde|noite|madrugada))/i
		};
		var parseDayPeriodPatterns16 = {
		  any: {
			 am: /^a/i,
			 pm: /^p/i,
			 midnight: /^meia/i,
			 noon: /^meio/i,
			 morning: /manh[a]/i,
			 afternoon: /tarde/i,
			 evening: /noite/i,
			 night: /madrugada/i
		  }
		};
		var match16 = {
		  ordinalNumber: buildMatchPatternFn({
			 matchPattern: matchOrdinalNumberPattern16,
			 parsePattern: parseOrdinalNumberPattern16,
			 valueCallback: (value) => parseInt(value, 10)
		  }),
		  era: buildMatchFn({
			 matchPatterns: matchEraPatterns16,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseEraPatterns16,
			 defaultParseWidth: "any"
		  }),
		  quarter: buildMatchFn({
			 matchPatterns: matchQuarterPatterns16,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseQuarterPatterns16,
			 defaultParseWidth: "any",
			 valueCallback: (index) => index + 1
		  }),
		  month: buildMatchFn({
			 matchPatterns: matchMonthPatterns16,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseMonthPatterns16,
			 defaultParseWidth: "any"
		  }),
		  day: buildMatchFn({
			 matchPatterns: matchDayPatterns16,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseDayPatterns16,
			 defaultParseWidth: "any"
		  }),
		  dayPeriod: buildMatchFn({
			 matchPatterns: matchDayPeriodPatterns16,
			 defaultMatchWidth: "any",
			 parsePatterns: parseDayPeriodPatterns16,
			 defaultParseWidth: "any"
		  })
		};

		// node_modules/date-fns/locale/pt.mjs
		var pt = {
		  code: "pt",
		  formatDistance: formatDistance16,
		  formatLong: formatLong19,
		  formatRelative: formatRelative17,
		  localize: localize16,
		  match: match16,
		  options: {
			 weekStartsOn: 1,
			 firstWeekContainsDate: 4
		  }
		};

		// node_modules/date-fns/locale/ru/_lib/formatDistance.mjs
		function declension2(scheme, count) {
		  if (scheme.one !== void 0 && count === 1) {
			 return scheme.one;
		  }
		  const rem10 = count % 10;
		  const rem100 = count % 100;
		  if (rem10 === 1 && rem100 !== 11) {
			 return scheme.singularNominative.replace("{{count}}", String(count));
		  } else if (rem10 >= 2 && rem10 <= 4 && (rem100 < 10 || rem100 > 20)) {
			 return scheme.singularGenitive.replace("{{count}}", String(count));
		  } else {
			 return scheme.pluralGenitive.replace("{{count}}", String(count));
		  }
		}
		function buildLocalizeTokenFn(scheme) {
		  return (count, options) => {
			 if (options?.addSuffix) {
				if (options.comparison && options.comparison > 0) {
				  if (scheme.future) {
					 return declension2(scheme.future, count);
				  } else {
					 return "\u0447\u0435\u0440\u0435\u0437 " + declension2(scheme.regular, count);
				  }
				} else {
				  if (scheme.past) {
					 return declension2(scheme.past, count);
				  } else {
					 return declension2(scheme.regular, count) + " \u043D\u0430\u0437\u0430\u0434";
				  }
				}
			 } else {
				return declension2(scheme.regular, count);
			 }
		  };
		}
		var formatDistanceLocale17 = {
		  lessThanXSeconds: buildLocalizeTokenFn({
			 regular: {
				one: "\u043C\u0435\u043D\u044C\u0448\u0435 \u0441\u0435\u043A\u0443\u043D\u0434\u044B",
				singularNominative: "\u043C\u0435\u043D\u044C\u0448\u0435 {{count}} \u0441\u0435\u043A\u0443\u043D\u0434\u044B",
				singularGenitive: "\u043C\u0435\u043D\u044C\u0448\u0435 {{count}} \u0441\u0435\u043A\u0443\u043D\u0434",
				pluralGenitive: "\u043C\u0435\u043D\u044C\u0448\u0435 {{count}} \u0441\u0435\u043A\u0443\u043D\u0434"
			 },
			 future: {
				one: "\u043C\u0435\u043D\u044C\u0448\u0435, \u0447\u0435\u043C \u0447\u0435\u0440\u0435\u0437 \u0441\u0435\u043A\u0443\u043D\u0434\u0443",
				singularNominative: "\u043C\u0435\u043D\u044C\u0448\u0435, \u0447\u0435\u043C \u0447\u0435\u0440\u0435\u0437 {{count}} \u0441\u0435\u043A\u0443\u043D\u0434\u0443",
				singularGenitive: "\u043C\u0435\u043D\u044C\u0448\u0435, \u0447\u0435\u043C \u0447\u0435\u0440\u0435\u0437 {{count}} \u0441\u0435\u043A\u0443\u043D\u0434\u044B",
				pluralGenitive: "\u043C\u0435\u043D\u044C\u0448\u0435, \u0447\u0435\u043C \u0447\u0435\u0440\u0435\u0437 {{count}} \u0441\u0435\u043A\u0443\u043D\u0434"
			 }
		  }),
		  xSeconds: buildLocalizeTokenFn({
			 regular: {
				singularNominative: "{{count}} \u0441\u0435\u043A\u0443\u043D\u0434\u0430",
				singularGenitive: "{{count}} \u0441\u0435\u043A\u0443\u043D\u0434\u044B",
				pluralGenitive: "{{count}} \u0441\u0435\u043A\u0443\u043D\u0434"
			 },
			 past: {
				singularNominative: "{{count}} \u0441\u0435\u043A\u0443\u043D\u0434\u0443 \u043D\u0430\u0437\u0430\u0434",
				singularGenitive: "{{count}} \u0441\u0435\u043A\u0443\u043D\u0434\u044B \u043D\u0430\u0437\u0430\u0434",
				pluralGenitive: "{{count}} \u0441\u0435\u043A\u0443\u043D\u0434 \u043D\u0430\u0437\u0430\u0434"
			 },
			 future: {
				singularNominative: "\u0447\u0435\u0440\u0435\u0437 {{count}} \u0441\u0435\u043A\u0443\u043D\u0434\u0443",
				singularGenitive: "\u0447\u0435\u0440\u0435\u0437 {{count}} \u0441\u0435\u043A\u0443\u043D\u0434\u044B",
				pluralGenitive: "\u0447\u0435\u0440\u0435\u0437 {{count}} \u0441\u0435\u043A\u0443\u043D\u0434"
			 }
		  }),
		  halfAMinute: (_count, options) => {
			 if (options?.addSuffix) {
				if (options.comparison && options.comparison > 0) {
				  return "\u0447\u0435\u0440\u0435\u0437 \u043F\u043E\u043B\u043C\u0438\u043D\u0443\u0442\u044B";
				} else {
				  return "\u043F\u043E\u043B\u043C\u0438\u043D\u0443\u0442\u044B \u043D\u0430\u0437\u0430\u0434";
				}
			 }
			 return "\u043F\u043E\u043B\u043C\u0438\u043D\u0443\u0442\u044B";
		  },
		  lessThanXMinutes: buildLocalizeTokenFn({
			 regular: {
				one: "\u043C\u0435\u043D\u044C\u0448\u0435 \u043C\u0438\u043D\u0443\u0442\u044B",
				singularNominative: "\u043C\u0435\u043D\u044C\u0448\u0435 {{count}} \u043C\u0438\u043D\u0443\u0442\u044B",
				singularGenitive: "\u043C\u0435\u043D\u044C\u0448\u0435 {{count}} \u043C\u0438\u043D\u0443\u0442",
				pluralGenitive: "\u043C\u0435\u043D\u044C\u0448\u0435 {{count}} \u043C\u0438\u043D\u0443\u0442"
			 },
			 future: {
				one: "\u043C\u0435\u043D\u044C\u0448\u0435, \u0447\u0435\u043C \u0447\u0435\u0440\u0435\u0437 \u043C\u0438\u043D\u0443\u0442\u0443",
				singularNominative: "\u043C\u0435\u043D\u044C\u0448\u0435, \u0447\u0435\u043C \u0447\u0435\u0440\u0435\u0437 {{count}} \u043C\u0438\u043D\u0443\u0442\u0443",
				singularGenitive: "\u043C\u0435\u043D\u044C\u0448\u0435, \u0447\u0435\u043C \u0447\u0435\u0440\u0435\u0437 {{count}} \u043C\u0438\u043D\u0443\u0442\u044B",
				pluralGenitive: "\u043C\u0435\u043D\u044C\u0448\u0435, \u0447\u0435\u043C \u0447\u0435\u0440\u0435\u0437 {{count}} \u043C\u0438\u043D\u0443\u0442"
			 }
		  }),
		  xMinutes: buildLocalizeTokenFn({
			 regular: {
				singularNominative: "{{count}} \u043C\u0438\u043D\u0443\u0442\u0430",
				singularGenitive: "{{count}} \u043C\u0438\u043D\u0443\u0442\u044B",
				pluralGenitive: "{{count}} \u043C\u0438\u043D\u0443\u0442"
			 },
			 past: {
				singularNominative: "{{count}} \u043C\u0438\u043D\u0443\u0442\u0443 \u043D\u0430\u0437\u0430\u0434",
				singularGenitive: "{{count}} \u043C\u0438\u043D\u0443\u0442\u044B \u043D\u0430\u0437\u0430\u0434",
				pluralGenitive: "{{count}} \u043C\u0438\u043D\u0443\u0442 \u043D\u0430\u0437\u0430\u0434"
			 },
			 future: {
				singularNominative: "\u0447\u0435\u0440\u0435\u0437 {{count}} \u043C\u0438\u043D\u0443\u0442\u0443",
				singularGenitive: "\u0447\u0435\u0440\u0435\u0437 {{count}} \u043C\u0438\u043D\u0443\u0442\u044B",
				pluralGenitive: "\u0447\u0435\u0440\u0435\u0437 {{count}} \u043C\u0438\u043D\u0443\u0442"
			 }
		  }),
		  aboutXHours: buildLocalizeTokenFn({
			 regular: {
				singularNominative: "\u043E\u043A\u043E\u043B\u043E {{count}} \u0447\u0430\u0441\u0430",
				singularGenitive: "\u043E\u043A\u043E\u043B\u043E {{count}} \u0447\u0430\u0441\u043E\u0432",
				pluralGenitive: "\u043E\u043A\u043E\u043B\u043E {{count}} \u0447\u0430\u0441\u043E\u0432"
			 },
			 future: {
				singularNominative: "\u043F\u0440\u0438\u0431\u043B\u0438\u0437\u0438\u0442\u0435\u043B\u044C\u043D\u043E \u0447\u0435\u0440\u0435\u0437 {{count}} \u0447\u0430\u0441",
				singularGenitive: "\u043F\u0440\u0438\u0431\u043B\u0438\u0437\u0438\u0442\u0435\u043B\u044C\u043D\u043E \u0447\u0435\u0440\u0435\u0437 {{count}} \u0447\u0430\u0441\u0430",
				pluralGenitive: "\u043F\u0440\u0438\u0431\u043B\u0438\u0437\u0438\u0442\u0435\u043B\u044C\u043D\u043E \u0447\u0435\u0440\u0435\u0437 {{count}} \u0447\u0430\u0441\u043E\u0432"
			 }
		  }),
		  xHours: buildLocalizeTokenFn({
			 regular: {
				singularNominative: "{{count}} \u0447\u0430\u0441",
				singularGenitive: "{{count}} \u0447\u0430\u0441\u0430",
				pluralGenitive: "{{count}} \u0447\u0430\u0441\u043E\u0432"
			 }
		  }),
		  xDays: buildLocalizeTokenFn({
			 regular: {
				singularNominative: "{{count}} \u0434\u0435\u043D\u044C",
				singularGenitive: "{{count}} \u0434\u043D\u044F",
				pluralGenitive: "{{count}} \u0434\u043D\u0435\u0439"
			 }
		  }),
		  aboutXWeeks: buildLocalizeTokenFn({
			 regular: {
				singularNominative: "\u043E\u043A\u043E\u043B\u043E {{count}} \u043D\u0435\u0434\u0435\u043B\u0438",
				singularGenitive: "\u043E\u043A\u043E\u043B\u043E {{count}} \u043D\u0435\u0434\u0435\u043B\u044C",
				pluralGenitive: "\u043E\u043A\u043E\u043B\u043E {{count}} \u043D\u0435\u0434\u0435\u043B\u044C"
			 },
			 future: {
				singularNominative: "\u043F\u0440\u0438\u0431\u043B\u0438\u0437\u0438\u0442\u0435\u043B\u044C\u043D\u043E \u0447\u0435\u0440\u0435\u0437 {{count}} \u043D\u0435\u0434\u0435\u043B\u044E",
				singularGenitive: "\u043F\u0440\u0438\u0431\u043B\u0438\u0437\u0438\u0442\u0435\u043B\u044C\u043D\u043E \u0447\u0435\u0440\u0435\u0437 {{count}} \u043D\u0435\u0434\u0435\u043B\u0438",
				pluralGenitive: "\u043F\u0440\u0438\u0431\u043B\u0438\u0437\u0438\u0442\u0435\u043B\u044C\u043D\u043E \u0447\u0435\u0440\u0435\u0437 {{count}} \u043D\u0435\u0434\u0435\u043B\u044C"
			 }
		  }),
		  xWeeks: buildLocalizeTokenFn({
			 regular: {
				singularNominative: "{{count}} \u043D\u0435\u0434\u0435\u043B\u044F",
				singularGenitive: "{{count}} \u043D\u0435\u0434\u0435\u043B\u0438",
				pluralGenitive: "{{count}} \u043D\u0435\u0434\u0435\u043B\u044C"
			 }
		  }),
		  aboutXMonths: buildLocalizeTokenFn({
			 regular: {
				singularNominative: "\u043E\u043A\u043E\u043B\u043E {{count}} \u043C\u0435\u0441\u044F\u0446\u0430",
				singularGenitive: "\u043E\u043A\u043E\u043B\u043E {{count}} \u043C\u0435\u0441\u044F\u0446\u0435\u0432",
				pluralGenitive: "\u043E\u043A\u043E\u043B\u043E {{count}} \u043C\u0435\u0441\u044F\u0446\u0435\u0432"
			 },
			 future: {
				singularNominative: "\u043F\u0440\u0438\u0431\u043B\u0438\u0437\u0438\u0442\u0435\u043B\u044C\u043D\u043E \u0447\u0435\u0440\u0435\u0437 {{count}} \u043C\u0435\u0441\u044F\u0446",
				singularGenitive: "\u043F\u0440\u0438\u0431\u043B\u0438\u0437\u0438\u0442\u0435\u043B\u044C\u043D\u043E \u0447\u0435\u0440\u0435\u0437 {{count}} \u043C\u0435\u0441\u044F\u0446\u0430",
				pluralGenitive: "\u043F\u0440\u0438\u0431\u043B\u0438\u0437\u0438\u0442\u0435\u043B\u044C\u043D\u043E \u0447\u0435\u0440\u0435\u0437 {{count}} \u043C\u0435\u0441\u044F\u0446\u0435\u0432"
			 }
		  }),
		  xMonths: buildLocalizeTokenFn({
			 regular: {
				singularNominative: "{{count}} \u043C\u0435\u0441\u044F\u0446",
				singularGenitive: "{{count}} \u043C\u0435\u0441\u044F\u0446\u0430",
				pluralGenitive: "{{count}} \u043C\u0435\u0441\u044F\u0446\u0435\u0432"
			 }
		  }),
		  aboutXYears: buildLocalizeTokenFn({
			 regular: {
				singularNominative: "\u043E\u043A\u043E\u043B\u043E {{count}} \u0433\u043E\u0434\u0430",
				singularGenitive: "\u043E\u043A\u043E\u043B\u043E {{count}} \u043B\u0435\u0442",
				pluralGenitive: "\u043E\u043A\u043E\u043B\u043E {{count}} \u043B\u0435\u0442"
			 },
			 future: {
				singularNominative: "\u043F\u0440\u0438\u0431\u043B\u0438\u0437\u0438\u0442\u0435\u043B\u044C\u043D\u043E \u0447\u0435\u0440\u0435\u0437 {{count}} \u0433\u043E\u0434",
				singularGenitive: "\u043F\u0440\u0438\u0431\u043B\u0438\u0437\u0438\u0442\u0435\u043B\u044C\u043D\u043E \u0447\u0435\u0440\u0435\u0437 {{count}} \u0433\u043E\u0434\u0430",
				pluralGenitive: "\u043F\u0440\u0438\u0431\u043B\u0438\u0437\u0438\u0442\u0435\u043B\u044C\u043D\u043E \u0447\u0435\u0440\u0435\u0437 {{count}} \u043B\u0435\u0442"
			 }
		  }),
		  xYears: buildLocalizeTokenFn({
			 regular: {
				singularNominative: "{{count}} \u0433\u043E\u0434",
				singularGenitive: "{{count}} \u0433\u043E\u0434\u0430",
				pluralGenitive: "{{count}} \u043B\u0435\u0442"
			 }
		  }),
		  overXYears: buildLocalizeTokenFn({
			 regular: {
				singularNominative: "\u0431\u043E\u043B\u044C\u0448\u0435 {{count}} \u0433\u043E\u0434\u0430",
				singularGenitive: "\u0431\u043E\u043B\u044C\u0448\u0435 {{count}} \u043B\u0435\u0442",
				pluralGenitive: "\u0431\u043E\u043B\u044C\u0448\u0435 {{count}} \u043B\u0435\u0442"
			 },
			 future: {
				singularNominative: "\u0431\u043E\u043B\u044C\u0448\u0435, \u0447\u0435\u043C \u0447\u0435\u0440\u0435\u0437 {{count}} \u0433\u043E\u0434",
				singularGenitive: "\u0431\u043E\u043B\u044C\u0448\u0435, \u0447\u0435\u043C \u0447\u0435\u0440\u0435\u0437 {{count}} \u0433\u043E\u0434\u0430",
				pluralGenitive: "\u0431\u043E\u043B\u044C\u0448\u0435, \u0447\u0435\u043C \u0447\u0435\u0440\u0435\u0437 {{count}} \u043B\u0435\u0442"
			 }
		  }),
		  almostXYears: buildLocalizeTokenFn({
			 regular: {
				singularNominative: "\u043F\u043E\u0447\u0442\u0438 {{count}} \u0433\u043E\u0434",
				singularGenitive: "\u043F\u043E\u0447\u0442\u0438 {{count}} \u0433\u043E\u0434\u0430",
				pluralGenitive: "\u043F\u043E\u0447\u0442\u0438 {{count}} \u043B\u0435\u0442"
			 },
			 future: {
				singularNominative: "\u043F\u043E\u0447\u0442\u0438 \u0447\u0435\u0440\u0435\u0437 {{count}} \u0433\u043E\u0434",
				singularGenitive: "\u043F\u043E\u0447\u0442\u0438 \u0447\u0435\u0440\u0435\u0437 {{count}} \u0433\u043E\u0434\u0430",
				pluralGenitive: "\u043F\u043E\u0447\u0442\u0438 \u0447\u0435\u0440\u0435\u0437 {{count}} \u043B\u0435\u0442"
			 }
		  })
		};
		var formatDistance17 = (token, count, options) => {
		  return formatDistanceLocale17[token](count, options);
		};

		// node_modules/date-fns/locale/ru/_lib/formatLong.mjs
		var dateFormats20 = {
		  full: "EEEE, d MMMM y '\u0433.'",
		  long: "d MMMM y '\u0433.'",
		  medium: "d MMM y '\u0433.'",
		  short: "dd.MM.y"
		};
		var timeFormats20 = {
		  full: "H:mm:ss zzzz",
		  long: "H:mm:ss z",
		  medium: "H:mm:ss",
		  short: "H:mm"
		};
		var dateTimeFormats20 = {
		  any: "{{date}}, {{time}}"
		};
		var formatLong20 = {
		  date: buildFormatLongFn({
			 formats: dateFormats20,
			 defaultWidth: "full"
		  }),
		  time: buildFormatLongFn({
			 formats: timeFormats20,
			 defaultWidth: "full"
		  }),
		  dateTime: buildFormatLongFn({
			 formats: dateTimeFormats20,
			 defaultWidth: "any"
		  })
		};

		// node_modules/date-fns/locale/ru/_lib/formatRelative.mjs
		var accusativeWeekdays2 = [
		  "\u0432\u043E\u0441\u043A\u0440\u0435\u0441\u0435\u043D\u044C\u0435",
		  "\u043F\u043E\u043D\u0435\u0434\u0435\u043B\u044C\u043D\u0438\u043A",
		  "\u0432\u0442\u043E\u0440\u043D\u0438\u043A",
		  "\u0441\u0440\u0435\u0434\u0443",
		  "\u0447\u0435\u0442\u0432\u0435\u0440\u0433",
		  "\u043F\u044F\u0442\u043D\u0438\u0446\u0443",
		  "\u0441\u0443\u0431\u0431\u043E\u0442\u0443"
		];
		function lastWeek2(day) {
		  const weekday = accusativeWeekdays2[day];
		  switch (day) {
			 case 0:
				return "'\u0432 \u043F\u0440\u043E\u0448\u043B\u043E\u0435 " + weekday + " \u0432' p";
			 case 1:
			 case 2:
			 case 4:
				return "'\u0432 \u043F\u0440\u043E\u0448\u043B\u044B\u0439 " + weekday + " \u0432' p";
			 case 3:
			 case 5:
			 case 6:
				return "'\u0432 \u043F\u0440\u043E\u0448\u043B\u0443\u044E " + weekday + " \u0432' p";
		  }
		}
		function thisWeek2(day) {
		  const weekday = accusativeWeekdays2[day];
		  if (day === 2) {
			 return "'\u0432\u043E " + weekday + " \u0432' p";
		  } else {
			 return "'\u0432 " + weekday + " \u0432' p";
		  }
		}
		function nextWeek2(day) {
		  const weekday = accusativeWeekdays2[day];
		  switch (day) {
			 case 0:
				return "'\u0432 \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0435 " + weekday + " \u0432' p";
			 case 1:
			 case 2:
			 case 4:
				return "'\u0432 \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0438\u0439 " + weekday + " \u0432' p";
			 case 3:
			 case 5:
			 case 6:
				return "'\u0432 \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0443\u044E " + weekday + " \u0432' p";
		  }
		}
		var formatRelativeLocale18 = {
		  lastWeek: (date2, baseDate, options) => {
			 const day = date2.getDay();
			 if (isSameWeek(date2, baseDate, options)) {
				return thisWeek2(day);
			 } else {
				return lastWeek2(day);
			 }
		  },
		  yesterday: "'\u0432\u0447\u0435\u0440\u0430 \u0432' p",
		  today: "'\u0441\u0435\u0433\u043E\u0434\u043D\u044F \u0432' p",
		  tomorrow: "'\u0437\u0430\u0432\u0442\u0440\u0430 \u0432' p",
		  nextWeek: (date2, baseDate, options) => {
			 const day = date2.getDay();
			 if (isSameWeek(date2, baseDate, options)) {
				return thisWeek2(day);
			 } else {
				return nextWeek2(day);
			 }
		  },
		  other: "P"
		};
		var formatRelative18 = (token, date2, baseDate, options) => {
		  const format2 = formatRelativeLocale18[token];
		  if (typeof format2 === "function") {
			 return format2(date2, baseDate, options);
		  }
		  return format2;
		};

		// node_modules/date-fns/locale/ru/_lib/localize.mjs
		var eraValues17 = {
		  narrow: ["\u0434\u043E \u043D.\u044D.", "\u043D.\u044D."],
		  abbreviated: ["\u0434\u043E \u043D. \u044D.", "\u043D. \u044D."],
		  wide: ["\u0434\u043E \u043D\u0430\u0448\u0435\u0439 \u044D\u0440\u044B", "\u043D\u0430\u0448\u0435\u0439 \u044D\u0440\u044B"]
		};
		var quarterValues17 = {
		  narrow: ["1", "2", "3", "4"],
		  abbreviated: ["1-\u0439 \u043A\u0432.", "2-\u0439 \u043A\u0432.", "3-\u0439 \u043A\u0432.", "4-\u0439 \u043A\u0432."],
		  wide: ["1-\u0439 \u043A\u0432\u0430\u0440\u0442\u0430\u043B", "2-\u0439 \u043A\u0432\u0430\u0440\u0442\u0430\u043B", "3-\u0439 \u043A\u0432\u0430\u0440\u0442\u0430\u043B", "4-\u0439 \u043A\u0432\u0430\u0440\u0442\u0430\u043B"]
		};
		var monthValues17 = {
		  narrow: ["\u042F", "\u0424", "\u041C", "\u0410", "\u041C", "\u0418", "\u0418", "\u0410", "\u0421", "\u041E", "\u041D", "\u0414"],
		  abbreviated: [
			 "\u044F\u043D\u0432.",
			 "\u0444\u0435\u0432.",
			 "\u043C\u0430\u0440\u0442",
			 "\u0430\u043F\u0440.",
			 "\u043C\u0430\u0439",
			 "\u0438\u044E\u043D\u044C",
			 "\u0438\u044E\u043B\u044C",
			 "\u0430\u0432\u0433.",
			 "\u0441\u0435\u043D\u0442.",
			 "\u043E\u043A\u0442.",
			 "\u043D\u043E\u044F\u0431.",
			 "\u0434\u0435\u043A."
		  ],
		  wide: [
			 "\u044F\u043D\u0432\u0430\u0440\u044C",
			 "\u0444\u0435\u0432\u0440\u0430\u043B\u044C",
			 "\u043C\u0430\u0440\u0442",
			 "\u0430\u043F\u0440\u0435\u043B\u044C",
			 "\u043C\u0430\u0439",
			 "\u0438\u044E\u043D\u044C",
			 "\u0438\u044E\u043B\u044C",
			 "\u0430\u0432\u0433\u0443\u0441\u0442",
			 "\u0441\u0435\u043D\u0442\u044F\u0431\u0440\u044C",
			 "\u043E\u043A\u0442\u044F\u0431\u0440\u044C",
			 "\u043D\u043E\u044F\u0431\u0440\u044C",
			 "\u0434\u0435\u043A\u0430\u0431\u0440\u044C"
		  ]
		};
		var formattingMonthValues5 = {
		  narrow: ["\u042F", "\u0424", "\u041C", "\u0410", "\u041C", "\u0418", "\u0418", "\u0410", "\u0421", "\u041E", "\u041D", "\u0414"],
		  abbreviated: [
			 "\u044F\u043D\u0432.",
			 "\u0444\u0435\u0432.",
			 "\u043C\u0430\u0440.",
			 "\u0430\u043F\u0440.",
			 "\u043C\u0430\u044F",
			 "\u0438\u044E\u043D.",
			 "\u0438\u044E\u043B.",
			 "\u0430\u0432\u0433.",
			 "\u0441\u0435\u043D\u0442.",
			 "\u043E\u043A\u0442.",
			 "\u043D\u043E\u044F\u0431.",
			 "\u0434\u0435\u043A."
		  ],
		  wide: [
			 "\u044F\u043D\u0432\u0430\u0440\u044F",
			 "\u0444\u0435\u0432\u0440\u0430\u043B\u044F",
			 "\u043C\u0430\u0440\u0442\u0430",
			 "\u0430\u043F\u0440\u0435\u043B\u044F",
			 "\u043C\u0430\u044F",
			 "\u0438\u044E\u043D\u044F",
			 "\u0438\u044E\u043B\u044F",
			 "\u0430\u0432\u0433\u0443\u0441\u0442\u0430",
			 "\u0441\u0435\u043D\u0442\u044F\u0431\u0440\u044F",
			 "\u043E\u043A\u0442\u044F\u0431\u0440\u044F",
			 "\u043D\u043E\u044F\u0431\u0440\u044F",
			 "\u0434\u0435\u043A\u0430\u0431\u0440\u044F"
		  ]
		};
		var dayValues17 = {
		  narrow: ["\u0412", "\u041F", "\u0412", "\u0421", "\u0427", "\u041F", "\u0421"],
		  short: ["\u0432\u0441", "\u043F\u043D", "\u0432\u0442", "\u0441\u0440", "\u0447\u0442", "\u043F\u0442", "\u0441\u0431"],
		  abbreviated: ["\u0432\u0441\u043A", "\u043F\u043D\u0434", "\u0432\u0442\u0440", "\u0441\u0440\u0434", "\u0447\u0442\u0432", "\u043F\u0442\u043D", "\u0441\u0443\u0431"],
		  wide: [
			 "\u0432\u043E\u0441\u043A\u0440\u0435\u0441\u0435\u043D\u044C\u0435",
			 "\u043F\u043E\u043D\u0435\u0434\u0435\u043B\u044C\u043D\u0438\u043A",
			 "\u0432\u0442\u043E\u0440\u043D\u0438\u043A",
			 "\u0441\u0440\u0435\u0434\u0430",
			 "\u0447\u0435\u0442\u0432\u0435\u0440\u0433",
			 "\u043F\u044F\u0442\u043D\u0438\u0446\u0430",
			 "\u0441\u0443\u0431\u0431\u043E\u0442\u0430"
		  ]
		};
		var dayPeriodValues17 = {
		  narrow: {
			 am: "\u0414\u041F",
			 pm: "\u041F\u041F",
			 midnight: "\u043F\u043E\u043B\u043D.",
			 noon: "\u043F\u043E\u043B\u0434.",
			 morning: "\u0443\u0442\u0440\u043E",
			 afternoon: "\u0434\u0435\u043D\u044C",
			 evening: "\u0432\u0435\u0447.",
			 night: "\u043D\u043E\u0447\u044C"
		  },
		  abbreviated: {
			 am: "\u0414\u041F",
			 pm: "\u041F\u041F",
			 midnight: "\u043F\u043E\u043B\u043D.",
			 noon: "\u043F\u043E\u043B\u0434.",
			 morning: "\u0443\u0442\u0440\u043E",
			 afternoon: "\u0434\u0435\u043D\u044C",
			 evening: "\u0432\u0435\u0447.",
			 night: "\u043D\u043E\u0447\u044C"
		  },
		  wide: {
			 am: "\u0414\u041F",
			 pm: "\u041F\u041F",
			 midnight: "\u043F\u043E\u043B\u043D\u043E\u0447\u044C",
			 noon: "\u043F\u043E\u043B\u0434\u0435\u043D\u044C",
			 morning: "\u0443\u0442\u0440\u043E",
			 afternoon: "\u0434\u0435\u043D\u044C",
			 evening: "\u0432\u0435\u0447\u0435\u0440",
			 night: "\u043D\u043E\u0447\u044C"
		  }
		};
		var formattingDayPeriodValues12 = {
		  narrow: {
			 am: "\u0414\u041F",
			 pm: "\u041F\u041F",
			 midnight: "\u043F\u043E\u043B\u043D.",
			 noon: "\u043F\u043E\u043B\u0434.",
			 morning: "\u0443\u0442\u0440\u0430",
			 afternoon: "\u0434\u043D\u044F",
			 evening: "\u0432\u0435\u0447.",
			 night: "\u043D\u043E\u0447\u0438"
		  },
		  abbreviated: {
			 am: "\u0414\u041F",
			 pm: "\u041F\u041F",
			 midnight: "\u043F\u043E\u043B\u043D.",
			 noon: "\u043F\u043E\u043B\u0434.",
			 morning: "\u0443\u0442\u0440\u0430",
			 afternoon: "\u0434\u043D\u044F",
			 evening: "\u0432\u0435\u0447.",
			 night: "\u043D\u043E\u0447\u0438"
		  },
		  wide: {
			 am: "\u0414\u041F",
			 pm: "\u041F\u041F",
			 midnight: "\u043F\u043E\u043B\u043D\u043E\u0447\u044C",
			 noon: "\u043F\u043E\u043B\u0434\u0435\u043D\u044C",
			 morning: "\u0443\u0442\u0440\u0430",
			 afternoon: "\u0434\u043D\u044F",
			 evening: "\u0432\u0435\u0447\u0435\u0440\u0430",
			 night: "\u043D\u043E\u0447\u0438"
		  }
		};
		var ordinalNumber17 = (dirtyNumber, options) => {
		  const number5 = Number(dirtyNumber);
		  const unit2 = options?.unit;
		  let suffix;
		  if (unit2 === "date") {
			 suffix = "-\u0435";
		  } else if (unit2 === "week" || unit2 === "minute" || unit2 === "second") {
			 suffix = "-\u044F";
		  } else {
			 suffix = "-\u0439";
		  }
		  return number5 + suffix;
		};
		var localize17 = {
		  ordinalNumber: ordinalNumber17,
		  era: buildLocalizeFn({
			 values: eraValues17,
			 defaultWidth: "wide"
		  }),
		  quarter: buildLocalizeFn({
			 values: quarterValues17,
			 defaultWidth: "wide",
			 argumentCallback: (quarter) => quarter - 1
		  }),
		  month: buildLocalizeFn({
			 values: monthValues17,
			 defaultWidth: "wide",
			 formattingValues: formattingMonthValues5,
			 defaultFormattingWidth: "wide"
		  }),
		  day: buildLocalizeFn({
			 values: dayValues17,
			 defaultWidth: "wide"
		  }),
		  dayPeriod: buildLocalizeFn({
			 values: dayPeriodValues17,
			 defaultWidth: "any",
			 formattingValues: formattingDayPeriodValues12,
			 defaultFormattingWidth: "wide"
		  })
		};

		// node_modules/date-fns/locale/ru/_lib/match.mjs
		var matchOrdinalNumberPattern17 = /^(\d+)(-?(||||||||||))?/i;
		var parseOrdinalNumberPattern17 = /\d+/i;
		var matchEraPatterns17 = {
		  narrow: /^(( )?\.?\s?\.?)/i,
		  abbreviated: /^(( )?\.?\s?\.?)/i,
		  wide: /^(  | | )/i
		};
		var parseEraPatterns17 = {
		  any: [/^/i, /^/i]
		};
		var matchQuarterPatterns17 = {
		  narrow: /^[1234]/i,
		  abbreviated: /^[1234](-?[]??)? .?/i,
		  wide: /^[1234](-?[]??)? /i
		};
		var parseQuarterPatterns17 = {
		  any: [/1/i, /2/i, /3/i, /4/i]
		};
		var matchMonthPatterns17 = {
		  narrow: /^[]/i,
		  abbreviated: /^(||?||[]|[]?|[]?||?||?|)\.?/i,
		  wide: /^([]|[]|?|[]|[]|[]|[]|?|[]|[]|[]|[]|[])/i
		};
		var parseMonthPatterns17 = {
		  narrow: [
			 /^/i,
			 /^/i,
			 /^/i,
			 /^/i,
			 /^/i,
			 /^/i,
			 /^/i,
			 /^/i,
			 /^/i,
			 /^/i,
			 /^/i,
			 /^/i
		  ],
		  any: [
			 /^/i,
			 /^/i,
			 /^/i,
			 /^/i,
			 /^[]/i,
			 /^/i,
			 /^/i,
			 /^/i,
			 /^/i,
			 /^/i,
			 /^/i,
			 /^/i
		  ]
		};
		var matchDayPatterns17 = {
		  narrow: /^[]/i,
		  short: /^(|||||||||||)\.?/i,
		  abbreviated: /^(||||||||||||).?/i,
		  wide: /^([]|?|?|[]|?|[]|[])/i
		};
		var parseDayPatterns17 = {
		  narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
		  any: [/^[]/i, /^[]/i, /^/i, /^/i, /^/i, /^[]/i, /^[]/i]
		};
		var matchDayPeriodPatterns17 = {
		  narrow: /^([]|\.?|\.?|[]|||\.?|[])/i,
		  abbreviated: /^([]|\.?|\.?|[]|||\.?|[])/i,
		  wide: /^([]|||[]|||?|[])/i
		};
		var parseDayPeriodPatterns17 = {
		  any: {
			 am: /^/i,
			 pm: /^/i,
			 midnight: /^/i,
			 noon: /^/i,
			 morning: /^/i,
			 afternoon: /^[]/i,
			 evening: /^/i,
			 night: /^/i
		  }
		};
		var match17 = {
		  ordinalNumber: buildMatchPatternFn({
			 matchPattern: matchOrdinalNumberPattern17,
			 parsePattern: parseOrdinalNumberPattern17,
			 valueCallback: (value) => parseInt(value, 10)
		  }),
		  era: buildMatchFn({
			 matchPatterns: matchEraPatterns17,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseEraPatterns17,
			 defaultParseWidth: "any"
		  }),
		  quarter: buildMatchFn({
			 matchPatterns: matchQuarterPatterns17,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseQuarterPatterns17,
			 defaultParseWidth: "any",
			 valueCallback: (index) => index + 1
		  }),
		  month: buildMatchFn({
			 matchPatterns: matchMonthPatterns17,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseMonthPatterns17,
			 defaultParseWidth: "any"
		  }),
		  day: buildMatchFn({
			 matchPatterns: matchDayPatterns17,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseDayPatterns17,
			 defaultParseWidth: "any"
		  }),
		  dayPeriod: buildMatchFn({
			 matchPatterns: matchDayPeriodPatterns17,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseDayPeriodPatterns17,
			 defaultParseWidth: "any"
		  })
		};

		// node_modules/date-fns/locale/ru.mjs
		var ru = {
		  code: "ru",
		  formatDistance: formatDistance17,
		  formatLong: formatLong20,
		  formatRelative: formatRelative18,
		  localize: localize17,
		  match: match17,
		  options: {
			 weekStartsOn: 1,
			 firstWeekContainsDate: 1
		  }
		};

		// node_modules/date-fns/locale/sv/_lib/formatDistance.mjs
		var formatDistanceLocale18 = {
		  lessThanXSeconds: {
			 one: "mindre \xE4n en sekund",
			 other: "mindre \xE4n {{count}} sekunder"
		  },
		  xSeconds: {
			 one: "en sekund",
			 other: "{{count}} sekunder"
		  },
		  halfAMinute: "en halv minut",
		  lessThanXMinutes: {
			 one: "mindre \xE4n en minut",
			 other: "mindre \xE4n {{count}} minuter"
		  },
		  xMinutes: {
			 one: "en minut",
			 other: "{{count}} minuter"
		  },
		  aboutXHours: {
			 one: "ungef\xE4r en timme",
			 other: "ungef\xE4r {{count}} timmar"
		  },
		  xHours: {
			 one: "en timme",
			 other: "{{count}} timmar"
		  },
		  xDays: {
			 one: "en dag",
			 other: "{{count}} dagar"
		  },
		  aboutXWeeks: {
			 one: "ungef\xE4r en vecka",
			 other: "ungef\xE4r {{count}} veckor"
		  },
		  xWeeks: {
			 one: "en vecka",
			 other: "{{count}} veckor"
		  },
		  aboutXMonths: {
			 one: "ungef\xE4r en m\xE5nad",
			 other: "ungef\xE4r {{count}} m\xE5nader"
		  },
		  xMonths: {
			 one: "en m\xE5nad",
			 other: "{{count}} m\xE5nader"
		  },
		  aboutXYears: {
			 one: "ungef\xE4r ett \xE5r",
			 other: "ungef\xE4r {{count}} \xE5r"
		  },
		  xYears: {
			 one: "ett \xE5r",
			 other: "{{count}} \xE5r"
		  },
		  overXYears: {
			 one: "\xF6ver ett \xE5r",
			 other: "\xF6ver {{count}} \xE5r"
		  },
		  almostXYears: {
			 one: "n\xE4stan ett \xE5r",
			 other: "n\xE4stan {{count}} \xE5r"
		  }
		};
		var wordMapping = [
		  "noll",
		  "en",
		  "tv\xE5",
		  "tre",
		  "fyra",
		  "fem",
		  "sex",
		  "sju",
		  "\xE5tta",
		  "nio",
		  "tio",
		  "elva",
		  "tolv"
		];
		var formatDistance18 = (token, count, options) => {
		  let result;
		  const tokenValue = formatDistanceLocale18[token];
		  if (typeof tokenValue === "string") {
			 result = tokenValue;
		  } else if (count === 1) {
			 result = tokenValue.one;
		  } else {
			 result = tokenValue.other.replace(
				"{{count}}",
				count < 13 ? wordMapping[count] : String(count)
			 );
		  }
		  if (options?.addSuffix) {
			 if (options.comparison && options.comparison > 0) {
				return "om " + result;
			 } else {
				return result + " sedan";
			 }
		  }
		  return result;
		};

		// node_modules/date-fns/locale/sv/_lib/formatLong.mjs
		var dateFormats21 = {
		  full: "EEEE d MMMM y",
		  long: "d MMMM y",
		  medium: "d MMM y",
		  short: "y-MM-dd"
		};
		var timeFormats21 = {
		  full: "'kl'. HH:mm:ss zzzz",
		  long: "HH:mm:ss z",
		  medium: "HH:mm:ss",
		  short: "HH:mm"
		};
		var dateTimeFormats21 = {
		  full: "{{date}} 'kl.' {{time}}",
		  long: "{{date}} 'kl.' {{time}}",
		  medium: "{{date}} {{time}}",
		  short: "{{date}} {{time}}"
		};
		var formatLong21 = {
		  date: buildFormatLongFn({
			 formats: dateFormats21,
			 defaultWidth: "full"
		  }),
		  time: buildFormatLongFn({
			 formats: timeFormats21,
			 defaultWidth: "full"
		  }),
		  dateTime: buildFormatLongFn({
			 formats: dateTimeFormats21,
			 defaultWidth: "full"
		  })
		};

		// node_modules/date-fns/locale/sv/_lib/formatRelative.mjs
		var formatRelativeLocale19 = {
		  lastWeek: "'i' EEEE's kl.' p",
		  yesterday: "'ig\xE5r kl.' p",
		  today: "'idag kl.' p",
		  tomorrow: "'imorgon kl.' p",
		  nextWeek: "EEEE 'kl.' p",
		  other: "P"
		};
		var formatRelative19 = (token, _date, _baseDate, _options) => formatRelativeLocale19[token];

		// node_modules/date-fns/locale/sv/_lib/localize.mjs
		var eraValues18 = {
		  narrow: ["f.Kr.", "e.Kr."],
		  abbreviated: ["f.Kr.", "e.Kr."],
		  wide: ["f\xF6re Kristus", "efter Kristus"]
		};
		var quarterValues18 = {
		  narrow: ["1", "2", "3", "4"],
		  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
		  wide: ["1:a kvartalet", "2:a kvartalet", "3:e kvartalet", "4:e kvartalet"]
		};
		var monthValues18 = {
		  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
		  abbreviated: [
			 "jan.",
			 "feb.",
			 "mars",
			 "apr.",
			 "maj",
			 "juni",
			 "juli",
			 "aug.",
			 "sep.",
			 "okt.",
			 "nov.",
			 "dec."
		  ],
		  wide: [
			 "januari",
			 "februari",
			 "mars",
			 "april",
			 "maj",
			 "juni",
			 "juli",
			 "augusti",
			 "september",
			 "oktober",
			 "november",
			 "december"
		  ]
		};
		var dayValues18 = {
		  narrow: ["S", "M", "T", "O", "T", "F", "L"],
		  short: ["s\xF6", "m\xE5", "ti", "on", "to", "fr", "l\xF6"],
		  abbreviated: ["s\xF6n", "m\xE5n", "tis", "ons", "tors", "fre", "l\xF6r"],
		  wide: ["s\xF6ndag", "m\xE5ndag", "tisdag", "onsdag", "torsdag", "fredag", "l\xF6rdag"]
		};
		var dayPeriodValues18 = {
		  narrow: {
			 am: "fm",
			 pm: "em",
			 midnight: "midnatt",
			 noon: "middag",
			 morning: "morg.",
			 afternoon: "efterm.",
			 evening: "kv\xE4ll",
			 night: "natt"
		  },
		  abbreviated: {
			 am: "f.m.",
			 pm: "e.m.",
			 midnight: "midnatt",
			 noon: "middag",
			 morning: "morgon",
			 afternoon: "efterm.",
			 evening: "kv\xE4ll",
			 night: "natt"
		  },
		  wide: {
			 am: "f\xF6rmiddag",
			 pm: "eftermiddag",
			 midnight: "midnatt",
			 noon: "middag",
			 morning: "morgon",
			 afternoon: "eftermiddag",
			 evening: "kv\xE4ll",
			 night: "natt"
		  }
		};
		var formattingDayPeriodValues13 = {
		  narrow: {
			 am: "fm",
			 pm: "em",
			 midnight: "midnatt",
			 noon: "middag",
			 morning: "p\xE5 morg.",
			 afternoon: "p\xE5 efterm.",
			 evening: "p\xE5 kv\xE4llen",
			 night: "p\xE5 natten"
		  },
		  abbreviated: {
			 am: "fm",
			 pm: "em",
			 midnight: "midnatt",
			 noon: "middag",
			 morning: "p\xE5 morg.",
			 afternoon: "p\xE5 efterm.",
			 evening: "p\xE5 kv\xE4llen",
			 night: "p\xE5 natten"
		  },
		  wide: {
			 am: "fm",
			 pm: "em",
			 midnight: "midnatt",
			 noon: "middag",
			 morning: "p\xE5 morgonen",
			 afternoon: "p\xE5 eftermiddagen",
			 evening: "p\xE5 kv\xE4llen",
			 night: "p\xE5 natten"
		  }
		};
		var ordinalNumber18 = (dirtyNumber, _options) => {
		  const number5 = Number(dirtyNumber);
		  const rem100 = number5 % 100;
		  if (rem100 > 20 || rem100 < 10) {
			 switch (rem100 % 10) {
				case 1:
				case 2:
				  return number5 + ":a";
			 }
		  }
		  return number5 + ":e";
		};
		var localize18 = {
		  ordinalNumber: ordinalNumber18,
		  era: buildLocalizeFn({
			 values: eraValues18,
			 defaultWidth: "wide"
		  }),
		  quarter: buildLocalizeFn({
			 values: quarterValues18,
			 defaultWidth: "wide",
			 argumentCallback: (quarter) => quarter - 1
		  }),
		  month: buildLocalizeFn({
			 values: monthValues18,
			 defaultWidth: "wide"
		  }),
		  day: buildLocalizeFn({
			 values: dayValues18,
			 defaultWidth: "wide"
		  }),
		  dayPeriod: buildLocalizeFn({
			 values: dayPeriodValues18,
			 defaultWidth: "wide",
			 formattingValues: formattingDayPeriodValues13,
			 defaultFormattingWidth: "wide"
		  })
		};

		// node_modules/date-fns/locale/sv/_lib/match.mjs
		var matchOrdinalNumberPattern18 = /^(\d+)(:a|:e)?/i;
		var parseOrdinalNumberPattern18 = /\d+/i;
		var matchEraPatterns18 = {
		  narrow: /^(f\.? ?Kr\.?|f\.? ?v\.? ?t\.?|e\.? ?Kr\.?|v\.? ?t\.?)/i,
		  abbreviated: /^(f\.? ?Kr\.?|f\.? ?v\.? ?t\.?|e\.? ?Kr\.?|v\.? ?t\.?)/i,
		  wide: /^(fre Kristus|fre vr tid|efter Kristus|vr tid)/i
		};
		var parseEraPatterns18 = {
		  any: [/^f/i, /^[ev]/i]
		};
		var matchQuarterPatterns18 = {
		  narrow: /^[1234]/i,
		  abbreviated: /^q[1234]/i,
		  wide: /^[1234](:a|:e)? kvartalet/i
		};
		var parseQuarterPatterns18 = {
		  any: [/1/i, /2/i, /3/i, /4/i]
		};
		var matchMonthPatterns18 = {
		  narrow: /^[jfmasond]/i,
		  abbreviated: /^(jan|feb|mar[s]?|apr|maj|jun[i]?|jul[i]?|aug|sep|okt|nov|dec)\.?/i,
		  wide: /^(januari|februari|mars|april|maj|juni|juli|augusti|september|oktober|november|december)/i
		};
		var parseMonthPatterns18 = {
		  narrow: [
			 /^j/i,
			 /^f/i,
			 /^m/i,
			 /^a/i,
			 /^m/i,
			 /^j/i,
			 /^j/i,
			 /^a/i,
			 /^s/i,
			 /^o/i,
			 /^n/i,
			 /^d/i
		  ],
		  any: [
			 /^ja/i,
			 /^f/i,
			 /^mar/i,
			 /^ap/i,
			 /^maj/i,
			 /^jun/i,
			 /^jul/i,
			 /^au/i,
			 /^s/i,
			 /^o/i,
			 /^n/i,
			 /^d/i
		  ]
		};
		var matchDayPatterns18 = {
		  narrow: /^[smtofl]/i,
		  short: /^(s|m|ti|on|to|fr|l)/i,
		  abbreviated: /^(sn|mn|tis|ons|tors|fre|lr)/i,
		  wide: /^(sndag|mndag|tisdag|onsdag|torsdag|fredag|lrdag)/i
		};
		var parseDayPatterns18 = {
		  any: [/^s/i, /^m/i, /^ti/i, /^o/i, /^to/i, /^f/i, /^l/i]
		};
		var matchDayPeriodPatterns18 = {
		  any: /^([fe]\.?\s?m\.?|midn(att)?|midd(ag)?|(p) (morgonen|eftermiddagen|kvllen|natten))/i
		};
		var parseDayPeriodPatterns18 = {
		  any: {
			 am: /^f/i,
			 pm: /^e/i,
			 midnight: /^midn/i,
			 noon: /^midd/i,
			 morning: /morgon/i,
			 afternoon: /eftermiddag/i,
			 evening: /kvll/i,
			 night: /natt/i
		  }
		};
		var match18 = {
		  ordinalNumber: buildMatchPatternFn({
			 matchPattern: matchOrdinalNumberPattern18,
			 parsePattern: parseOrdinalNumberPattern18,
			 valueCallback: (value) => parseInt(value, 10)
		  }),
		  era: buildMatchFn({
			 matchPatterns: matchEraPatterns18,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseEraPatterns18,
			 defaultParseWidth: "any"
		  }),
		  quarter: buildMatchFn({
			 matchPatterns: matchQuarterPatterns18,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseQuarterPatterns18,
			 defaultParseWidth: "any",
			 valueCallback: (index) => index + 1
		  }),
		  month: buildMatchFn({
			 matchPatterns: matchMonthPatterns18,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseMonthPatterns18,
			 defaultParseWidth: "any"
		  }),
		  day: buildMatchFn({
			 matchPatterns: matchDayPatterns18,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseDayPatterns18,
			 defaultParseWidth: "any"
		  }),
		  dayPeriod: buildMatchFn({
			 matchPatterns: matchDayPeriodPatterns18,
			 defaultMatchWidth: "any",
			 parsePatterns: parseDayPeriodPatterns18,
			 defaultParseWidth: "any"
		  })
		};

		// node_modules/date-fns/locale/sv.mjs
		var sv = {
		  code: "sv",
		  formatDistance: formatDistance18,
		  formatLong: formatLong21,
		  formatRelative: formatRelative19,
		  localize: localize18,
		  match: match18,
		  options: {
			 weekStartsOn: 1,
			 firstWeekContainsDate: 4
		  }
		};

		// node_modules/date-fns/locale/th/_lib/formatDistance.mjs
		var formatDistanceLocale19 = {
		  lessThanXSeconds: {
			 one: "\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32 1 \u0E27\u0E34\u0E19\u0E32\u0E17\u0E35",
			 other: "\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32 {{count}} \u0E27\u0E34\u0E19\u0E32\u0E17\u0E35"
		  },
		  xSeconds: {
			 one: "1 \u0E27\u0E34\u0E19\u0E32\u0E17\u0E35",
			 other: "{{count}} \u0E27\u0E34\u0E19\u0E32\u0E17\u0E35"
		  },
		  halfAMinute: "\u0E04\u0E23\u0E36\u0E48\u0E07\u0E19\u0E32\u0E17\u0E35",
		  lessThanXMinutes: {
			 one: "\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32 1 \u0E19\u0E32\u0E17\u0E35",
			 other: "\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32 {{count}} \u0E19\u0E32\u0E17\u0E35"
		  },
		  xMinutes: {
			 one: "1 \u0E19\u0E32\u0E17\u0E35",
			 other: "{{count}} \u0E19\u0E32\u0E17\u0E35"
		  },
		  aboutXHours: {
			 one: "\u0E1B\u0E23\u0E30\u0E21\u0E32\u0E13 1 \u0E0A\u0E31\u0E48\u0E27\u0E42\u0E21\u0E07",
			 other: "\u0E1B\u0E23\u0E30\u0E21\u0E32\u0E13 {{count}} \u0E0A\u0E31\u0E48\u0E27\u0E42\u0E21\u0E07"
		  },
		  xHours: {
			 one: "1 \u0E0A\u0E31\u0E48\u0E27\u0E42\u0E21\u0E07",
			 other: "{{count}} \u0E0A\u0E31\u0E48\u0E27\u0E42\u0E21\u0E07"
		  },
		  xDays: {
			 one: "1 \u0E27\u0E31\u0E19",
			 other: "{{count}} \u0E27\u0E31\u0E19"
		  },
		  aboutXWeeks: {
			 one: "\u0E1B\u0E23\u0E30\u0E21\u0E32\u0E13 1 \u0E2A\u0E31\u0E1B\u0E14\u0E32\u0E2B\u0E4C",
			 other: "\u0E1B\u0E23\u0E30\u0E21\u0E32\u0E13 {{count}} \u0E2A\u0E31\u0E1B\u0E14\u0E32\u0E2B\u0E4C"
		  },
		  xWeeks: {
			 one: "1 \u0E2A\u0E31\u0E1B\u0E14\u0E32\u0E2B\u0E4C",
			 other: "{{count}} \u0E2A\u0E31\u0E1B\u0E14\u0E32\u0E2B\u0E4C"
		  },
		  aboutXMonths: {
			 one: "\u0E1B\u0E23\u0E30\u0E21\u0E32\u0E13 1 \u0E40\u0E14\u0E37\u0E2D\u0E19",
			 other: "\u0E1B\u0E23\u0E30\u0E21\u0E32\u0E13 {{count}} \u0E40\u0E14\u0E37\u0E2D\u0E19"
		  },
		  xMonths: {
			 one: "1 \u0E40\u0E14\u0E37\u0E2D\u0E19",
			 other: "{{count}} \u0E40\u0E14\u0E37\u0E2D\u0E19"
		  },
		  aboutXYears: {
			 one: "\u0E1B\u0E23\u0E30\u0E21\u0E32\u0E13 1 \u0E1B\u0E35",
			 other: "\u0E1B\u0E23\u0E30\u0E21\u0E32\u0E13 {{count}} \u0E1B\u0E35"
		  },
		  xYears: {
			 one: "1 \u0E1B\u0E35",
			 other: "{{count}} \u0E1B\u0E35"
		  },
		  overXYears: {
			 one: "\u0E21\u0E32\u0E01\u0E01\u0E27\u0E48\u0E32 1 \u0E1B\u0E35",
			 other: "\u0E21\u0E32\u0E01\u0E01\u0E27\u0E48\u0E32 {{count}} \u0E1B\u0E35"
		  },
		  almostXYears: {
			 one: "\u0E40\u0E01\u0E37\u0E2D\u0E1A 1 \u0E1B\u0E35",
			 other: "\u0E40\u0E01\u0E37\u0E2D\u0E1A {{count}} \u0E1B\u0E35"
		  }
		};
		var formatDistance19 = (token, count, options) => {
		  let result;
		  const tokenValue = formatDistanceLocale19[token];
		  if (typeof tokenValue === "string") {
			 result = tokenValue;
		  } else if (count === 1) {
			 result = tokenValue.one;
		  } else {
			 result = tokenValue.other.replace("{{count}}", String(count));
		  }
		  if (options?.addSuffix) {
			 if (options.comparison && options.comparison > 0) {
				if (token === "halfAMinute") {
				  return "\u0E43\u0E19" + result;
				} else {
				  return "\u0E43\u0E19 " + result;
				}
			 } else {
				return result + "\u0E17\u0E35\u0E48\u0E1C\u0E48\u0E32\u0E19\u0E21\u0E32";
			 }
		  }
		  return result;
		};

		// node_modules/date-fns/locale/th/_lib/formatLong.mjs
		var dateFormats22 = {
		  full: "\u0E27\u0E31\u0E19EEEE\u0E17\u0E35\u0E48 do MMMM y",
		  long: "do MMMM y",
		  medium: "d MMM y",
		  short: "dd/MM/yyyy"
		};
		var timeFormats22 = {
		  full: "H:mm:ss \u0E19. zzzz",
		  long: "H:mm:ss \u0E19. z",
		  medium: "H:mm:ss \u0E19.",
		  short: "H:mm \u0E19."
		};
		var dateTimeFormats22 = {
		  full: "{{date}} '\u0E40\u0E27\u0E25\u0E32' {{time}}",
		  long: "{{date}} '\u0E40\u0E27\u0E25\u0E32' {{time}}",
		  medium: "{{date}}, {{time}}",
		  short: "{{date}}, {{time}}"
		};
		var formatLong22 = {
		  date: buildFormatLongFn({
			 formats: dateFormats22,
			 defaultWidth: "full"
		  }),
		  time: buildFormatLongFn({
			 formats: timeFormats22,
			 defaultWidth: "medium"
		  }),
		  dateTime: buildFormatLongFn({
			 formats: dateTimeFormats22,
			 defaultWidth: "full"
		  })
		};

		// node_modules/date-fns/locale/th/_lib/formatRelative.mjs
		var formatRelativeLocale20 = {
		  lastWeek: "eeee'\u0E17\u0E35\u0E48\u0E41\u0E25\u0E49\u0E27\u0E40\u0E27\u0E25\u0E32' p",
		  yesterday: "'\u0E40\u0E21\u0E37\u0E48\u0E2D\u0E27\u0E32\u0E19\u0E19\u0E35\u0E49\u0E40\u0E27\u0E25\u0E32' p",
		  today: "'\u0E27\u0E31\u0E19\u0E19\u0E35\u0E49\u0E40\u0E27\u0E25\u0E32' p",
		  tomorrow: "'\u0E1E\u0E23\u0E38\u0E48\u0E07\u0E19\u0E35\u0E49\u0E40\u0E27\u0E25\u0E32' p",
		  nextWeek: "eeee '\u0E40\u0E27\u0E25\u0E32' p",
		  other: "P"
		};
		var formatRelative20 = (token, _date, _baseDate, _options) => formatRelativeLocale20[token];

		// node_modules/date-fns/locale/th/_lib/localize.mjs
		var eraValues19 = {
		  narrow: ["B", "\u0E04\u0E28"],
		  abbreviated: ["BC", "\u0E04.\u0E28."],
		  wide: ["\u0E1B\u0E35\u0E01\u0E48\u0E2D\u0E19\u0E04\u0E23\u0E34\u0E2A\u0E15\u0E01\u0E32\u0E25", "\u0E04\u0E23\u0E34\u0E2A\u0E15\u0E4C\u0E28\u0E31\u0E01\u0E23\u0E32\u0E0A"]
		};
		var quarterValues19 = {
		  narrow: ["1", "2", "3", "4"],
		  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
		  wide: ["\u0E44\u0E15\u0E23\u0E21\u0E32\u0E2A\u0E41\u0E23\u0E01", "\u0E44\u0E15\u0E23\u0E21\u0E32\u0E2A\u0E17\u0E35\u0E48\u0E2A\u0E2D\u0E07", "\u0E44\u0E15\u0E23\u0E21\u0E32\u0E2A\u0E17\u0E35\u0E48\u0E2A\u0E32\u0E21", "\u0E44\u0E15\u0E23\u0E21\u0E32\u0E2A\u0E17\u0E35\u0E48\u0E2A\u0E35\u0E48"]
		};
		var dayValues19 = {
		  narrow: ["\u0E2D\u0E32.", "\u0E08.", "\u0E2D.", "\u0E1E.", "\u0E1E\u0E24.", "\u0E28.", "\u0E2A."],
		  short: ["\u0E2D\u0E32.", "\u0E08.", "\u0E2D.", "\u0E1E.", "\u0E1E\u0E24.", "\u0E28.", "\u0E2A."],
		  abbreviated: ["\u0E2D\u0E32.", "\u0E08.", "\u0E2D.", "\u0E1E.", "\u0E1E\u0E24.", "\u0E28.", "\u0E2A."],
		  wide: ["\u0E2D\u0E32\u0E17\u0E34\u0E15\u0E22\u0E4C", "\u0E08\u0E31\u0E19\u0E17\u0E23\u0E4C", "\u0E2D\u0E31\u0E07\u0E04\u0E32\u0E23", "\u0E1E\u0E38\u0E18", "\u0E1E\u0E24\u0E2B\u0E31\u0E2A\u0E1A\u0E14\u0E35", "\u0E28\u0E38\u0E01\u0E23\u0E4C", "\u0E40\u0E2A\u0E32\u0E23\u0E4C"]
		};
		var monthValues19 = {
		  narrow: [
			 "\u0E21.\u0E04.",
			 "\u0E01.\u0E1E.",
			 "\u0E21\u0E35.\u0E04.",
			 "\u0E40\u0E21.\u0E22.",
			 "\u0E1E.\u0E04.",
			 "\u0E21\u0E34.\u0E22.",
			 "\u0E01.\u0E04.",
			 "\u0E2A.\u0E04.",
			 "\u0E01.\u0E22.",
			 "\u0E15.\u0E04.",
			 "\u0E1E.\u0E22.",
			 "\u0E18.\u0E04."
		  ],
		  abbreviated: [
			 "\u0E21.\u0E04.",
			 "\u0E01.\u0E1E.",
			 "\u0E21\u0E35.\u0E04.",
			 "\u0E40\u0E21.\u0E22.",
			 "\u0E1E.\u0E04.",
			 "\u0E21\u0E34.\u0E22.",
			 "\u0E01.\u0E04.",
			 "\u0E2A.\u0E04.",
			 "\u0E01.\u0E22.",
			 "\u0E15.\u0E04.",
			 "\u0E1E.\u0E22.",
			 "\u0E18.\u0E04."
		  ],
		  wide: [
			 "\u0E21\u0E01\u0E23\u0E32\u0E04\u0E21",
			 "\u0E01\u0E38\u0E21\u0E20\u0E32\u0E1E\u0E31\u0E19\u0E18\u0E4C",
			 "\u0E21\u0E35\u0E19\u0E32\u0E04\u0E21",
			 "\u0E40\u0E21\u0E29\u0E32\u0E22\u0E19",
			 "\u0E1E\u0E24\u0E29\u0E20\u0E32\u0E04\u0E21",
			 "\u0E21\u0E34\u0E16\u0E38\u0E19\u0E32\u0E22\u0E19",
			 "\u0E01\u0E23\u0E01\u0E0E\u0E32\u0E04\u0E21",
			 "\u0E2A\u0E34\u0E07\u0E2B\u0E32\u0E04\u0E21",
			 "\u0E01\u0E31\u0E19\u0E22\u0E32\u0E22\u0E19",
			 "\u0E15\u0E38\u0E25\u0E32\u0E04\u0E21",
			 "\u0E1E\u0E24\u0E28\u0E08\u0E34\u0E01\u0E32\u0E22\u0E19",
			 "\u0E18\u0E31\u0E19\u0E27\u0E32\u0E04\u0E21"
		  ]
		};
		var dayPeriodValues19 = {
		  narrow: {
			 am: "\u0E01\u0E48\u0E2D\u0E19\u0E40\u0E17\u0E35\u0E48\u0E22\u0E07",
			 pm: "\u0E2B\u0E25\u0E31\u0E07\u0E40\u0E17\u0E35\u0E48\u0E22\u0E07",
			 midnight: "\u0E40\u0E17\u0E35\u0E48\u0E22\u0E07\u0E04\u0E37\u0E19",
			 noon: "\u0E40\u0E17\u0E35\u0E48\u0E22\u0E07",
			 morning: "\u0E40\u0E0A\u0E49\u0E32",
			 afternoon: "\u0E1A\u0E48\u0E32\u0E22",
			 evening: "\u0E40\u0E22\u0E47\u0E19",
			 night: "\u0E01\u0E25\u0E32\u0E07\u0E04\u0E37\u0E19"
		  },
		  abbreviated: {
			 am: "\u0E01\u0E48\u0E2D\u0E19\u0E40\u0E17\u0E35\u0E48\u0E22\u0E07",
			 pm: "\u0E2B\u0E25\u0E31\u0E07\u0E40\u0E17\u0E35\u0E48\u0E22\u0E07",
			 midnight: "\u0E40\u0E17\u0E35\u0E48\u0E22\u0E07\u0E04\u0E37\u0E19",
			 noon: "\u0E40\u0E17\u0E35\u0E48\u0E22\u0E07",
			 morning: "\u0E40\u0E0A\u0E49\u0E32",
			 afternoon: "\u0E1A\u0E48\u0E32\u0E22",
			 evening: "\u0E40\u0E22\u0E47\u0E19",
			 night: "\u0E01\u0E25\u0E32\u0E07\u0E04\u0E37\u0E19"
		  },
		  wide: {
			 am: "\u0E01\u0E48\u0E2D\u0E19\u0E40\u0E17\u0E35\u0E48\u0E22\u0E07",
			 pm: "\u0E2B\u0E25\u0E31\u0E07\u0E40\u0E17\u0E35\u0E48\u0E22\u0E07",
			 midnight: "\u0E40\u0E17\u0E35\u0E48\u0E22\u0E07\u0E04\u0E37\u0E19",
			 noon: "\u0E40\u0E17\u0E35\u0E48\u0E22\u0E07",
			 morning: "\u0E40\u0E0A\u0E49\u0E32",
			 afternoon: "\u0E1A\u0E48\u0E32\u0E22",
			 evening: "\u0E40\u0E22\u0E47\u0E19",
			 night: "\u0E01\u0E25\u0E32\u0E07\u0E04\u0E37\u0E19"
		  }
		};
		var formattingDayPeriodValues14 = {
		  narrow: {
			 am: "\u0E01\u0E48\u0E2D\u0E19\u0E40\u0E17\u0E35\u0E48\u0E22\u0E07",
			 pm: "\u0E2B\u0E25\u0E31\u0E07\u0E40\u0E17\u0E35\u0E48\u0E22\u0E07",
			 midnight: "\u0E40\u0E17\u0E35\u0E48\u0E22\u0E07\u0E04\u0E37\u0E19",
			 noon: "\u0E40\u0E17\u0E35\u0E48\u0E22\u0E07",
			 morning: "\u0E15\u0E2D\u0E19\u0E40\u0E0A\u0E49\u0E32",
			 afternoon: "\u0E15\u0E2D\u0E19\u0E01\u0E25\u0E32\u0E07\u0E27\u0E31\u0E19",
			 evening: "\u0E15\u0E2D\u0E19\u0E40\u0E22\u0E47\u0E19",
			 night: "\u0E15\u0E2D\u0E19\u0E01\u0E25\u0E32\u0E07\u0E04\u0E37\u0E19"
		  },
		  abbreviated: {
			 am: "\u0E01\u0E48\u0E2D\u0E19\u0E40\u0E17\u0E35\u0E48\u0E22\u0E07",
			 pm: "\u0E2B\u0E25\u0E31\u0E07\u0E40\u0E17\u0E35\u0E48\u0E22\u0E07",
			 midnight: "\u0E40\u0E17\u0E35\u0E48\u0E22\u0E07\u0E04\u0E37\u0E19",
			 noon: "\u0E40\u0E17\u0E35\u0E48\u0E22\u0E07",
			 morning: "\u0E15\u0E2D\u0E19\u0E40\u0E0A\u0E49\u0E32",
			 afternoon: "\u0E15\u0E2D\u0E19\u0E01\u0E25\u0E32\u0E07\u0E27\u0E31\u0E19",
			 evening: "\u0E15\u0E2D\u0E19\u0E40\u0E22\u0E47\u0E19",
			 night: "\u0E15\u0E2D\u0E19\u0E01\u0E25\u0E32\u0E07\u0E04\u0E37\u0E19"
		  },
		  wide: {
			 am: "\u0E01\u0E48\u0E2D\u0E19\u0E40\u0E17\u0E35\u0E48\u0E22\u0E07",
			 pm: "\u0E2B\u0E25\u0E31\u0E07\u0E40\u0E17\u0E35\u0E48\u0E22\u0E07",
			 midnight: "\u0E40\u0E17\u0E35\u0E48\u0E22\u0E07\u0E04\u0E37\u0E19",
			 noon: "\u0E40\u0E17\u0E35\u0E48\u0E22\u0E07",
			 morning: "\u0E15\u0E2D\u0E19\u0E40\u0E0A\u0E49\u0E32",
			 afternoon: "\u0E15\u0E2D\u0E19\u0E01\u0E25\u0E32\u0E07\u0E27\u0E31\u0E19",
			 evening: "\u0E15\u0E2D\u0E19\u0E40\u0E22\u0E47\u0E19",
			 night: "\u0E15\u0E2D\u0E19\u0E01\u0E25\u0E32\u0E07\u0E04\u0E37\u0E19"
		  }
		};
		var ordinalNumber19 = (dirtyNumber, _options) => {
		  return String(dirtyNumber);
		};
		var localize19 = {
		  ordinalNumber: ordinalNumber19,
		  era: buildLocalizeFn({
			 values: eraValues19,
			 defaultWidth: "wide"
		  }),
		  quarter: buildLocalizeFn({
			 values: quarterValues19,
			 defaultWidth: "wide",
			 argumentCallback: (quarter) => quarter - 1
		  }),
		  month: buildLocalizeFn({
			 values: monthValues19,
			 defaultWidth: "wide"
		  }),
		  day: buildLocalizeFn({
			 values: dayValues19,
			 defaultWidth: "wide"
		  }),
		  dayPeriod: buildLocalizeFn({
			 values: dayPeriodValues19,
			 defaultWidth: "wide",
			 formattingValues: formattingDayPeriodValues14,
			 defaultFormattingWidth: "wide"
		  })
		};

		// node_modules/date-fns/locale/th/_lib/match.mjs
		var matchOrdinalNumberPattern19 = /^\d+/i;
		var parseOrdinalNumberPattern19 = /\d+/i;
		var matchEraPatterns19 = {
		  narrow: /^([bB]|[aA]|)/i,
		  abbreviated: /^([bB]\.?\s?[cC]\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?|\.?\.?)/i,
		  wide: /^(||)/i
		};
		var parseEraPatterns19 = {
		  any: [/^[bB]/i, /^(^[aA]|\.?\.?|||)/i]
		};
		var matchQuarterPatterns19 = {
		  narrow: /^[1234]/i,
		  abbreviated: /^q[1234]/i,
		  wide: /^()? ?[1234]/i
		};
		var parseQuarterPatterns19 = {
		  any: [/(1||)/i, /(2|)/i, /(3|)/i, /(4|)/i]
		};
		var matchMonthPatterns19 = {
		  narrow: /^(\.?\.?|\.?\.?|\.?\.?|\.?\.?|\.?\.?|\.?\.?|\.?\.?|\.?\.?|\.?\.?|\.?\.?|\.?\.?|\.?\.?)/i,
		  abbreviated: /^(\.?\.?|\.?\.?|\.?\.?|\.?\.?|\.?\.?|\.?\.?|\.?\.?|\.?\.?|\.?\.?|\.?\.?|\.?\.?|\.?\.?')/i,
		  wide: /^(|||||||||||)/i
		};
		var parseMonthPatterns19 = {
		  wide: [
			 /^/i,
			 /^/i,
			 /^/i,
			 /^/i,
			 /^/i,
			 /^/i,
			 /^/i,
			 /^/i,
			 /^/i,
			 /^/i,
			 /^/i,
			 /^/i
		  ],
		  any: [
			 /^\.?\.?/i,
			 /^\.?\.?/i,
			 /^\.?\.?/i,
			 /^\.?\.?/i,
			 /^\.?\.?/i,
			 /^\.?\.?/i,
			 /^\.?\.?/i,
			 /^\.?\.?/i,
			 /^\.?\.?/i,
			 /^\.?\.?/i,
			 /^\.?\.?/i,
			 /^\.?\.?/i
		  ]
		};
		var matchDayPatterns19 = {
		  narrow: /^(\.?|\.?|\.?|\.?|\.?|\.?|\.?)/i,
		  short: /^(\.?|\.?|\.?|\.?|\.?|\.?|\.?)/i,
		  abbreviated: /^(\.?|\.?|\.?|\.?|\.?|\.?|\.?)/i,
		  wide: /^(||||||)/i
		};
		var parseDayPatterns19 = {
		  wide: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
		  any: [/^/i, /^/i, /^/i, /^(?!)/i, /^/i, /^/i, /^/i]
		};
		var matchDayPeriodPatterns19 = {
		  any: /^(||||(.*?)?.*(||||))/i
		};
		var parseDayPeriodPatterns19 = {
		  any: {
			 am: /^/i,
			 pm: /^/i,
			 midnight: /^/i,
			 noon: /^/i,
			 morning: //i,
			 afternoon: //i,
			 evening: //i,
			 night: //i
		  }
		};
		var match19 = {
		  ordinalNumber: buildMatchPatternFn({
			 matchPattern: matchOrdinalNumberPattern19,
			 parsePattern: parseOrdinalNumberPattern19,
			 valueCallback: (value) => parseInt(value, 10)
		  }),
		  era: buildMatchFn({
			 matchPatterns: matchEraPatterns19,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseEraPatterns19,
			 defaultParseWidth: "any"
		  }),
		  quarter: buildMatchFn({
			 matchPatterns: matchQuarterPatterns19,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseQuarterPatterns19,
			 defaultParseWidth: "any",
			 valueCallback: (index) => index + 1
		  }),
		  month: buildMatchFn({
			 matchPatterns: matchMonthPatterns19,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseMonthPatterns19,
			 defaultParseWidth: "any"
		  }),
		  day: buildMatchFn({
			 matchPatterns: matchDayPatterns19,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseDayPatterns19,
			 defaultParseWidth: "any"
		  }),
		  dayPeriod: buildMatchFn({
			 matchPatterns: matchDayPeriodPatterns19,
			 defaultMatchWidth: "any",
			 parsePatterns: parseDayPeriodPatterns19,
			 defaultParseWidth: "any"
		  })
		};

		// node_modules/date-fns/locale/th.mjs
		var th = {
		  code: "th",
		  formatDistance: formatDistance19,
		  formatLong: formatLong22,
		  formatRelative: formatRelative20,
		  localize: localize19,
		  match: match19,
		  options: {
			 weekStartsOn: 0,
			 firstWeekContainsDate: 1
		  }
		};

		// node_modules/date-fns/locale/vi/_lib/formatDistance.mjs
		var formatDistanceLocale20 = {
		  lessThanXSeconds: {
			 one: "d\u01B0\u1EDBi 1 gi\xE2y",
			 other: "d\u01B0\u1EDBi {{count}} gi\xE2y"
		  },
		  xSeconds: {
			 one: "1 gi\xE2y",
			 other: "{{count}} gi\xE2y"
		  },
		  halfAMinute: "n\u1EEDa ph\xFAt",
		  lessThanXMinutes: {
			 one: "d\u01B0\u1EDBi 1 ph\xFAt",
			 other: "d\u01B0\u1EDBi {{count}} ph\xFAt"
		  },
		  xMinutes: {
			 one: "1 ph\xFAt",
			 other: "{{count}} ph\xFAt"
		  },
		  aboutXHours: {
			 one: "kho\u1EA3ng 1 gi\u1EDD",
			 other: "kho\u1EA3ng {{count}} gi\u1EDD"
		  },
		  xHours: {
			 one: "1 gi\u1EDD",
			 other: "{{count}} gi\u1EDD"
		  },
		  xDays: {
			 one: "1 ng\xE0y",
			 other: "{{count}} ng\xE0y"
		  },
		  aboutXWeeks: {
			 one: "kho\u1EA3ng 1 tu\u1EA7n",
			 other: "kho\u1EA3ng {{count}} tu\u1EA7n"
		  },
		  xWeeks: {
			 one: "1 tu\u1EA7n",
			 other: "{{count}} tu\u1EA7n"
		  },
		  aboutXMonths: {
			 one: "kho\u1EA3ng 1 th\xE1ng",
			 other: "kho\u1EA3ng {{count}} th\xE1ng"
		  },
		  xMonths: {
			 one: "1 th\xE1ng",
			 other: "{{count}} th\xE1ng"
		  },
		  aboutXYears: {
			 one: "kho\u1EA3ng 1 n\u0103m",
			 other: "kho\u1EA3ng {{count}} n\u0103m"
		  },
		  xYears: {
			 one: "1 n\u0103m",
			 other: "{{count}} n\u0103m"
		  },
		  overXYears: {
			 one: "h\u01A1n 1 n\u0103m",
			 other: "h\u01A1n {{count}} n\u0103m"
		  },
		  almostXYears: {
			 one: "g\u1EA7n 1 n\u0103m",
			 other: "g\u1EA7n {{count}} n\u0103m"
		  }
		};
		var formatDistance20 = (token, count, options) => {
		  let result;
		  const tokenValue = formatDistanceLocale20[token];
		  if (typeof tokenValue === "string") {
			 result = tokenValue;
		  } else if (count === 1) {
			 result = tokenValue.one;
		  } else {
			 result = tokenValue.other.replace("{{count}}", String(count));
		  }
		  if (options?.addSuffix) {
			 if (options.comparison && options.comparison > 0) {
				return result + " n\u1EEFa";
			 } else {
				return result + " tr\u01B0\u1EDBc";
			 }
		  }
		  return result;
		};

		// node_modules/date-fns/locale/vi/_lib/formatLong.mjs
		var dateFormats23 = {
		  // th Su, ngy 25 thng 08 nm 2017
		  full: "EEEE, 'ng\xE0y' d MMMM 'n\u0103m' y",
		  // ngy 25 thng 08 nm 2017
		  long: "'ng\xE0y' d MMMM 'n\u0103m' y",
		  // 25 thg 08 nm 2017
		  medium: "d MMM 'n\u0103m' y",
		  // 25/08/2017
		  short: "dd/MM/y"
		};
		var timeFormats23 = {
		  full: "HH:mm:ss zzzz",
		  long: "HH:mm:ss z",
		  medium: "HH:mm:ss",
		  short: "HH:mm"
		};
		var dateTimeFormats23 = {
		  // th Su, ngy 25 thng 08 nm 2017 23:25:59
		  full: "{{date}} {{time}}",
		  // ngy 25 thng 08 nm 2017 23:25
		  long: "{{date}} {{time}}",
		  medium: "{{date}} {{time}}",
		  short: "{{date}} {{time}}"
		};
		var formatLong23 = {
		  date: buildFormatLongFn({
			 formats: dateFormats23,
			 defaultWidth: "full"
		  }),
		  time: buildFormatLongFn({
			 formats: timeFormats23,
			 defaultWidth: "full"
		  }),
		  dateTime: buildFormatLongFn({
			 formats: dateTimeFormats23,
			 defaultWidth: "full"
		  })
		};

		// node_modules/date-fns/locale/vi/_lib/formatRelative.mjs
		var formatRelativeLocale21 = {
		  lastWeek: "eeee 'tu\u1EA7n tr\u01B0\u1EDBc v\xE0o l\xFAc' p",
		  yesterday: "'h\xF4m qua v\xE0o l\xFAc' p",
		  today: "'h\xF4m nay v\xE0o l\xFAc' p",
		  tomorrow: "'ng\xE0y mai v\xE0o l\xFAc' p",
		  nextWeek: "eeee 't\u1EDBi v\xE0o l\xFAc' p",
		  other: "P"
		};
		var formatRelative21 = (token, _date, _baseDate, _options) => formatRelativeLocale21[token];

		// node_modules/date-fns/locale/vi/_lib/localize.mjs
		var eraValues20 = {
		  narrow: ["TCN", "SCN"],
		  abbreviated: ["tr\u01B0\u1EDBc CN", "sau CN"],
		  wide: ["tr\u01B0\u1EDBc C\xF4ng Nguy\xEAn", "sau C\xF4ng Nguy\xEAn"]
		};
		var quarterValues20 = {
		  narrow: ["1", "2", "3", "4"],
		  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
		  wide: ["Qu\xFD 1", "Qu\xFD 2", "Qu\xFD 3", "Qu\xFD 4"]
		};
		var formattingQuarterValues2 = {
		  narrow: ["1", "2", "3", "4"],
		  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
		  // I notice many news outlet use this "qu II/2018"
		  wide: ["qu\xFD I", "qu\xFD II", "qu\xFD III", "qu\xFD IV"]
		};
		var monthValues20 = {
		  narrow: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
		  abbreviated: [
			 "Thg 1",
			 "Thg 2",
			 "Thg 3",
			 "Thg 4",
			 "Thg 5",
			 "Thg 6",
			 "Thg 7",
			 "Thg 8",
			 "Thg 9",
			 "Thg 10",
			 "Thg 11",
			 "Thg 12"
		  ],
		  wide: [
			 "Th\xE1ng M\u1ED9t",
			 "Th\xE1ng Hai",
			 "Th\xE1ng Ba",
			 "Th\xE1ng T\u01B0",
			 "Th\xE1ng N\u0103m",
			 "Th\xE1ng S\xE1u",
			 "Th\xE1ng B\u1EA3y",
			 "Th\xE1ng T\xE1m",
			 "Th\xE1ng Ch\xEDn",
			 "Th\xE1ng M\u01B0\u1EDDi",
			 "Th\xE1ng M\u01B0\u1EDDi M\u1ED9t",
			 "Th\xE1ng M\u01B0\u1EDDi Hai"
		  ]
		};
		var formattingMonthValues6 = {
		  narrow: [
			 "01",
			 "02",
			 "03",
			 "04",
			 "05",
			 "06",
			 "07",
			 "08",
			 "09",
			 "10",
			 "11",
			 "12"
		  ],
		  abbreviated: [
			 "thg 1",
			 "thg 2",
			 "thg 3",
			 "thg 4",
			 "thg 5",
			 "thg 6",
			 "thg 7",
			 "thg 8",
			 "thg 9",
			 "thg 10",
			 "thg 11",
			 "thg 12"
		  ],
		  wide: [
			 "th\xE1ng 01",
			 "th\xE1ng 02",
			 "th\xE1ng 03",
			 "th\xE1ng 04",
			 "th\xE1ng 05",
			 "th\xE1ng 06",
			 "th\xE1ng 07",
			 "th\xE1ng 08",
			 "th\xE1ng 09",
			 "th\xE1ng 10",
			 "th\xE1ng 11",
			 "th\xE1ng 12"
		  ]
		};
		var dayValues20 = {
		  narrow: ["CN", "T2", "T3", "T4", "T5", "T6", "T7"],
		  short: ["CN", "Th 2", "Th 3", "Th 4", "Th 5", "Th 6", "Th 7"],
		  abbreviated: ["CN", "Th\u1EE9 2", "Th\u1EE9 3", "Th\u1EE9 4", "Th\u1EE9 5", "Th\u1EE9 6", "Th\u1EE9 7"],
		  wide: [
			 "Ch\u1EE7 Nh\u1EADt",
			 "Th\u1EE9 Hai",
			 "Th\u1EE9 Ba",
			 "Th\u1EE9 T\u01B0",
			 "Th\u1EE9 N\u0103m",
			 "Th\u1EE9 S\xE1u",
			 "Th\u1EE9 B\u1EA3y"
		  ]
		};
		var dayPeriodValues20 = {
		  // narrow date period is extremely rare in Vietnamese
		  // I used abbreviated form for noon, morning and afternoon
		  // which are regconizable by Vietnamese, others cannot be any shorter
		  narrow: {
			 am: "am",
			 pm: "pm",
			 midnight: "n\u1EEDa \u0111\xEAm",
			 noon: "tr",
			 morning: "sg",
			 afternoon: "ch",
			 evening: "t\u1ED1i",
			 night: "\u0111\xEAm"
		  },
		  abbreviated: {
			 am: "AM",
			 pm: "PM",
			 midnight: "n\u1EEDa \u0111\xEAm",
			 noon: "tr\u01B0a",
			 morning: "s\xE1ng",
			 afternoon: "chi\u1EC1u",
			 evening: "t\u1ED1i",
			 night: "\u0111\xEAm"
		  },
		  wide: {
			 am: "SA",
			 pm: "CH",
			 midnight: "n\u1EEDa \u0111\xEAm",
			 noon: "tr\u01B0a",
			 morning: "s\xE1ng",
			 afternoon: "chi\u1EC1u",
			 evening: "t\u1ED1i",
			 night: "\u0111\xEAm"
		  }
		};
		var formattingDayPeriodValues15 = {
		  narrow: {
			 am: "am",
			 pm: "pm",
			 midnight: "n\u1EEDa \u0111\xEAm",
			 noon: "tr",
			 morning: "sg",
			 afternoon: "ch",
			 evening: "t\u1ED1i",
			 night: "\u0111\xEAm"
		  },
		  abbreviated: {
			 am: "AM",
			 pm: "PM",
			 midnight: "n\u1EEDa \u0111\xEAm",
			 noon: "tr\u01B0a",
			 morning: "s\xE1ng",
			 afternoon: "chi\u1EC1u",
			 evening: "t\u1ED1i",
			 night: "\u0111\xEAm"
		  },
		  wide: {
			 am: "SA",
			 pm: "CH",
			 midnight: "n\u1EEDa \u0111\xEAm",
			 noon: "gi\u1EEFa tr\u01B0a",
			 morning: "v\xE0o bu\u1ED5i s\xE1ng",
			 afternoon: "v\xE0o bu\u1ED5i chi\u1EC1u",
			 evening: "v\xE0o bu\u1ED5i t\u1ED1i",
			 night: "v\xE0o ban \u0111\xEAm"
		  }
		};
		var ordinalNumber20 = (dirtyNumber, options) => {
		  const number5 = Number(dirtyNumber);
		  const unit2 = options?.unit;
		  if (unit2 === "quarter") {
			 switch (number5) {
				case 1:
				  return "I";
				case 2:
				  return "II";
				case 3:
				  return "III";
				case 4:
				  return "IV";
			 }
		  } else if (unit2 === "day") {
			 switch (number5) {
				case 1:
				  return "th\u1EE9 2";
				case 2:
				  return "th\u1EE9 3";
				case 3:
				  return "th\u1EE9 4";
				case 4:
				  return "th\u1EE9 5";
				case 5:
				  return "th\u1EE9 6";
				case 6:
				  return "th\u1EE9 7";
				case 7:
				  return "ch\u1EE7 nh\u1EADt";
			 }
		  } else if (unit2 === "week") {
			 if (number5 === 1) {
				return "th\u1EE9 nh\u1EA5t";
			 } else {
				return "th\u1EE9 " + number5;
			 }
		  } else if (unit2 === "dayOfYear") {
			 if (number5 === 1) {
				return "\u0111\u1EA7u ti\xEAn";
			 } else {
				return "th\u1EE9 " + number5;
			 }
		  }
		  return String(number5);
		};
		var localize20 = {
		  ordinalNumber: ordinalNumber20,
		  era: buildLocalizeFn({
			 values: eraValues20,
			 defaultWidth: "wide"
		  }),
		  quarter: buildLocalizeFn({
			 values: quarterValues20,
			 defaultWidth: "wide",
			 formattingValues: formattingQuarterValues2,
			 defaultFormattingWidth: "wide",
			 argumentCallback: (quarter) => quarter - 1
		  }),
		  month: buildLocalizeFn({
			 values: monthValues20,
			 defaultWidth: "wide",
			 formattingValues: formattingMonthValues6,
			 defaultFormattingWidth: "wide"
		  }),
		  day: buildLocalizeFn({
			 values: dayValues20,
			 defaultWidth: "wide"
		  }),
		  dayPeriod: buildLocalizeFn({
			 values: dayPeriodValues20,
			 defaultWidth: "wide",
			 formattingValues: formattingDayPeriodValues15,
			 defaultFormattingWidth: "wide"
		  })
		};

		// node_modules/date-fns/locale/vi/_lib/match.mjs
		var matchOrdinalNumberPattern20 = /^(\d+)/i;
		var parseOrdinalNumberPattern20 = /\d+/i;
		var matchEraPatterns20 = {
		  narrow: /^(tcn|scn)/i,
		  abbreviated: /^(trc CN|sau CN)/i,
		  wide: /^(trc Cng Nguyn|sau Cng Nguyn)/i
		};
		var parseEraPatterns20 = {
		  any: [/^t/i, /^s/i]
		};
		var matchQuarterPatterns20 = {
		  narrow: /^([1234]|i{1,3}v?)/i,
		  abbreviated: /^q([1234]|i{1,3}v?)/i,
		  wide: /^qu ([1234]|i{1,3}v?)/i
		};
		var parseQuarterPatterns20 = {
		  any: [/(1|i)$/i, /(2|ii)$/i, /(3|iii)$/i, /(4|iv)$/i]
		};
		var matchMonthPatterns20 = {
		  // month number may contain leading 0, 'thg' prefix may have space, underscore or empty before number
		  // note the order of '1' since it is a sub-string of '10', so must be lower priority
		  narrow: /^(0?[2-9]|10|11|12|0?1)/i,
		  // note the order of 'thg 1' since it is sub-string of 'thg 10', so must be lower priority
		  abbreviated: /^thg[ _]?(0?[1-9](?!\d)|10|11|12)/i,
		  // note the order of 'Mi' since it is sub-string of Mi Mt, so must be lower priority
		  wide: /^thng ?(Mt|Hai|Ba|T|Nm|Su|By|Tm|Chn|Mi|Mi ?Mt|Mi ?Hai|0?[1-9](?!\d)|10|11|12)/i
		};
		var parseMonthPatterns20 = {
		  narrow: [
			 /0?1$/i,
			 /0?2/i,
			 /3/,
			 /4/,
			 /5/,
			 /6/,
			 /7/,
			 /8/,
			 /9/,
			 /10/,
			 /11/,
			 /12/
		  ],
		  abbreviated: [
			 /^thg[ _]?0?1(?!\d)/i,
			 /^thg[ _]?0?2/i,
			 /^thg[ _]?0?3/i,
			 /^thg[ _]?0?4/i,
			 /^thg[ _]?0?5/i,
			 /^thg[ _]?0?6/i,
			 /^thg[ _]?0?7/i,
			 /^thg[ _]?0?8/i,
			 /^thg[ _]?0?9/i,
			 /^thg[ _]?10/i,
			 /^thg[ _]?11/i,
			 /^thg[ _]?12/i
		  ],
		  wide: [
			 /^thng ?(Mt|0?1(?!\d))/i,
			 /^thng ?(Hai|0?2)/i,
			 /^thng ?(Ba|0?3)/i,
			 /^thng ?(T|0?4)/i,
			 /^thng ?(Nm|0?5)/i,
			 /^thng ?(Su|0?6)/i,
			 /^thng ?(By|0?7)/i,
			 /^thng ?(Tm|0?8)/i,
			 /^thng ?(Chn|0?9)/i,
			 /^thng ?(Mi|10)/i,
			 /^thng ?(Mi ?Mt|11)/i,
			 /^thng ?(Mi ?Hai|12)/i
		  ]
		};
		var matchDayPatterns20 = {
		  narrow: /^(CN|T2|T3|T4|T5|T6|T7)/i,
		  short: /^(CN|Th ?2|Th ?3|Th ?4|Th ?5|Th ?6|Th ?7)/i,
		  abbreviated: /^(CN|Th ?2|Th ?3|Th ?4|Th ?5|Th ?6|Th ?7)/i,
		  wide: /^(Ch ?Nht|Cha ?Nht|th ?Hai|th ?Ba|th ?T|th ?Nm|th ?Su|th ?By)/i
		};
		var parseDayPatterns20 = {
		  narrow: [/CN/i, /2/i, /3/i, /4/i, /5/i, /6/i, /7/i],
		  short: [/CN/i, /2/i, /3/i, /4/i, /5/i, /6/i, /7/i],
		  abbreviated: [/CN/i, /2/i, /3/i, /4/i, /5/i, /6/i, /7/i],
		  wide: [/(Ch|Cha) ?Nht/i, /Hai/i, /Ba/i, /T/i, /Nm/i, /Su/i, /By/i]
		};
		var matchDayPeriodPatterns20 = {
		  narrow: /^(a|p|na m|tra|(gi) (sng|chiu|ti|m))/i,
		  abbreviated: /^(am|pm|na m|tra|(gi) (sng|chiu|ti|m))/i,
		  wide: /^(ch[^i]*|sa|na m|tra|(gi) (sng|chiu|ti|m))/i
		};
		var parseDayPeriodPatterns20 = {
		  any: {
			 am: /^(a|sa)/i,
			 pm: /^(p|ch[^i]*)/i,
			 midnight: /na m/i,
			 noon: /tra/i,
			 morning: /sng/i,
			 afternoon: /chiu/i,
			 evening: /ti/i,
			 night: /^m/i
		  }
		};
		var match20 = {
		  ordinalNumber: buildMatchPatternFn({
			 matchPattern: matchOrdinalNumberPattern20,
			 parsePattern: parseOrdinalNumberPattern20,
			 valueCallback: (value) => parseInt(value, 10)
		  }),
		  era: buildMatchFn({
			 matchPatterns: matchEraPatterns20,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseEraPatterns20,
			 defaultParseWidth: "any"
		  }),
		  quarter: buildMatchFn({
			 matchPatterns: matchQuarterPatterns20,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseQuarterPatterns20,
			 defaultParseWidth: "any",
			 valueCallback: (index) => index + 1
		  }),
		  month: buildMatchFn({
			 matchPatterns: matchMonthPatterns20,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseMonthPatterns20,
			 defaultParseWidth: "wide"
		  }),
		  day: buildMatchFn({
			 matchPatterns: matchDayPatterns20,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseDayPatterns20,
			 defaultParseWidth: "wide"
		  }),
		  dayPeriod: buildMatchFn({
			 matchPatterns: matchDayPeriodPatterns20,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseDayPeriodPatterns20,
			 defaultParseWidth: "any"
		  })
		};

		// node_modules/date-fns/locale/vi.mjs
		var vi = {
		  code: "vi",
		  formatDistance: formatDistance20,
		  formatLong: formatLong23,
		  formatRelative: formatRelative21,
		  localize: localize20,
		  match: match20,
		  options: {
			 weekStartsOn: 1,
			 firstWeekContainsDate: 1
		  }
		};

		// node_modules/date-fns/locale/zh-CN/_lib/formatDistance.mjs
		var formatDistanceLocale21 = {
		  lessThanXSeconds: {
			 one: "\u4E0D\u5230 1 \u79D2",
			 other: "\u4E0D\u5230 {{count}} \u79D2"
		  },
		  xSeconds: {
			 one: "1 \u79D2",
			 other: "{{count}} \u79D2"
		  },
		  halfAMinute: "\u534A\u5206\u949F",
		  lessThanXMinutes: {
			 one: "\u4E0D\u5230 1 \u5206\u949F",
			 other: "\u4E0D\u5230 {{count}} \u5206\u949F"
		  },
		  xMinutes: {
			 one: "1 \u5206\u949F",
			 other: "{{count}} \u5206\u949F"
		  },
		  xHours: {
			 one: "1 \u5C0F\u65F6",
			 other: "{{count}} \u5C0F\u65F6"
		  },
		  aboutXHours: {
			 one: "\u5927\u7EA6 1 \u5C0F\u65F6",
			 other: "\u5927\u7EA6 {{count}} \u5C0F\u65F6"
		  },
		  xDays: {
			 one: "1 \u5929",
			 other: "{{count}} \u5929"
		  },
		  aboutXWeeks: {
			 one: "\u5927\u7EA6 1 \u4E2A\u661F\u671F",
			 other: "\u5927\u7EA6 {{count}} \u4E2A\u661F\u671F"
		  },
		  xWeeks: {
			 one: "1 \u4E2A\u661F\u671F",
			 other: "{{count}} \u4E2A\u661F\u671F"
		  },
		  aboutXMonths: {
			 one: "\u5927\u7EA6 1 \u4E2A\u6708",
			 other: "\u5927\u7EA6 {{count}} \u4E2A\u6708"
		  },
		  xMonths: {
			 one: "1 \u4E2A\u6708",
			 other: "{{count}} \u4E2A\u6708"
		  },
		  aboutXYears: {
			 one: "\u5927\u7EA6 1 \u5E74",
			 other: "\u5927\u7EA6 {{count}} \u5E74"
		  },
		  xYears: {
			 one: "1 \u5E74",
			 other: "{{count}} \u5E74"
		  },
		  overXYears: {
			 one: "\u8D85\u8FC7 1 \u5E74",
			 other: "\u8D85\u8FC7 {{count}} \u5E74"
		  },
		  almostXYears: {
			 one: "\u5C06\u8FD1 1 \u5E74",
			 other: "\u5C06\u8FD1 {{count}} \u5E74"
		  }
		};
		var formatDistance21 = (token, count, options) => {
		  let result;
		  const tokenValue = formatDistanceLocale21[token];
		  if (typeof tokenValue === "string") {
			 result = tokenValue;
		  } else if (count === 1) {
			 result = tokenValue.one;
		  } else {
			 result = tokenValue.other.replace("{{count}}", String(count));
		  }
		  if (options?.addSuffix) {
			 if (options.comparison && options.comparison > 0) {
				return result + "\u5185";
			 } else {
				return result + "\u524D";
			 }
		  }
		  return result;
		};

		// node_modules/date-fns/locale/zh-CN/_lib/formatLong.mjs
		var dateFormats24 = {
		  full: "y'\u5E74'M'\u6708'd'\u65E5' EEEE",
		  long: "y'\u5E74'M'\u6708'd'\u65E5'",
		  medium: "yyyy-MM-dd",
		  short: "yy-MM-dd"
		};
		var timeFormats24 = {
		  full: "zzzz a h:mm:ss",
		  long: "z a h:mm:ss",
		  medium: "a h:mm:ss",
		  short: "a h:mm"
		};
		var dateTimeFormats24 = {
		  full: "{{date}} {{time}}",
		  long: "{{date}} {{time}}",
		  medium: "{{date}} {{time}}",
		  short: "{{date}} {{time}}"
		};
		var formatLong24 = {
		  date: buildFormatLongFn({
			 formats: dateFormats24,
			 defaultWidth: "full"
		  }),
		  time: buildFormatLongFn({
			 formats: timeFormats24,
			 defaultWidth: "full"
		  }),
		  dateTime: buildFormatLongFn({
			 formats: dateTimeFormats24,
			 defaultWidth: "full"
		  })
		};

		// node_modules/date-fns/locale/zh-CN/_lib/formatRelative.mjs
		function checkWeek(date2, baseDate, options) {
		  const baseFormat = "eeee p";
		  if (isSameWeek(date2, baseDate, options)) {
			 return baseFormat;
		  } else if (date2.getTime() > baseDate.getTime()) {
			 return "'\u4E0B\u4E2A'" + baseFormat;
		  }
		  return "'\u4E0A\u4E2A'" + baseFormat;
		}
		var formatRelativeLocale22 = {
		  lastWeek: checkWeek,
		  // days before yesterday, maybe in this week or last week
		  yesterday: "'\u6628\u5929' p",
		  today: "'\u4ECA\u5929' p",
		  tomorrow: "'\u660E\u5929' p",
		  nextWeek: checkWeek,
		  // days after tomorrow, maybe in this week or next week
		  other: "PP p"
		};
		var formatRelative22 = (token, date2, baseDate, options) => {
		  const format2 = formatRelativeLocale22[token];
		  if (typeof format2 === "function") {
			 return format2(date2, baseDate, options);
		  }
		  return format2;
		};

		// node_modules/date-fns/locale/zh-CN/_lib/localize.mjs
		var eraValues21 = {
		  narrow: ["\u524D", "\u516C\u5143"],
		  abbreviated: ["\u524D", "\u516C\u5143"],
		  wide: ["\u516C\u5143\u524D", "\u516C\u5143"]
		};
		var quarterValues21 = {
		  narrow: ["1", "2", "3", "4"],
		  abbreviated: ["\u7B2C\u4E00\u5B63", "\u7B2C\u4E8C\u5B63", "\u7B2C\u4E09\u5B63", "\u7B2C\u56DB\u5B63"],
		  wide: ["\u7B2C\u4E00\u5B63\u5EA6", "\u7B2C\u4E8C\u5B63\u5EA6", "\u7B2C\u4E09\u5B63\u5EA6", "\u7B2C\u56DB\u5B63\u5EA6"]
		};
		var monthValues21 = {
		  narrow: [
			 "\u4E00",
			 "\u4E8C",
			 "\u4E09",
			 "\u56DB",
			 "\u4E94",
			 "\u516D",
			 "\u4E03",
			 "\u516B",
			 "\u4E5D",
			 "\u5341",
			 "\u5341\u4E00",
			 "\u5341\u4E8C"
		  ],
		  abbreviated: [
			 "1\u6708",
			 "2\u6708",
			 "3\u6708",
			 "4\u6708",
			 "5\u6708",
			 "6\u6708",
			 "7\u6708",
			 "8\u6708",
			 "9\u6708",
			 "10\u6708",
			 "11\u6708",
			 "12\u6708"
		  ],
		  wide: [
			 "\u4E00\u6708",
			 "\u4E8C\u6708",
			 "\u4E09\u6708",
			 "\u56DB\u6708",
			 "\u4E94\u6708",
			 "\u516D\u6708",
			 "\u4E03\u6708",
			 "\u516B\u6708",
			 "\u4E5D\u6708",
			 "\u5341\u6708",
			 "\u5341\u4E00\u6708",
			 "\u5341\u4E8C\u6708"
		  ]
		};
		var dayValues21 = {
		  narrow: ["\u65E5", "\u4E00", "\u4E8C", "\u4E09", "\u56DB", "\u4E94", "\u516D"],
		  short: ["\u65E5", "\u4E00", "\u4E8C", "\u4E09", "\u56DB", "\u4E94", "\u516D"],
		  abbreviated: ["\u5468\u65E5", "\u5468\u4E00", "\u5468\u4E8C", "\u5468\u4E09", "\u5468\u56DB", "\u5468\u4E94", "\u5468\u516D"],
		  wide: ["\u661F\u671F\u65E5", "\u661F\u671F\u4E00", "\u661F\u671F\u4E8C", "\u661F\u671F\u4E09", "\u661F\u671F\u56DB", "\u661F\u671F\u4E94", "\u661F\u671F\u516D"]
		};
		var dayPeriodValues21 = {
		  narrow: {
			 am: "\u4E0A",
			 pm: "\u4E0B",
			 midnight: "\u51CC\u6668",
			 noon: "\u5348",
			 morning: "\u65E9",
			 afternoon: "\u4E0B\u5348",
			 evening: "\u665A",
			 night: "\u591C"
		  },
		  abbreviated: {
			 am: "\u4E0A\u5348",
			 pm: "\u4E0B\u5348",
			 midnight: "\u51CC\u6668",
			 noon: "\u4E2D\u5348",
			 morning: "\u65E9\u6668",
			 afternoon: "\u4E2D\u5348",
			 evening: "\u665A\u4E0A",
			 night: "\u591C\u95F4"
		  },
		  wide: {
			 am: "\u4E0A\u5348",
			 pm: "\u4E0B\u5348",
			 midnight: "\u51CC\u6668",
			 noon: "\u4E2D\u5348",
			 morning: "\u65E9\u6668",
			 afternoon: "\u4E2D\u5348",
			 evening: "\u665A\u4E0A",
			 night: "\u591C\u95F4"
		  }
		};
		var formattingDayPeriodValues16 = {
		  narrow: {
			 am: "\u4E0A",
			 pm: "\u4E0B",
			 midnight: "\u51CC\u6668",
			 noon: "\u5348",
			 morning: "\u65E9",
			 afternoon: "\u4E0B\u5348",
			 evening: "\u665A",
			 night: "\u591C"
		  },
		  abbreviated: {
			 am: "\u4E0A\u5348",
			 pm: "\u4E0B\u5348",
			 midnight: "\u51CC\u6668",
			 noon: "\u4E2D\u5348",
			 morning: "\u65E9\u6668",
			 afternoon: "\u4E2D\u5348",
			 evening: "\u665A\u4E0A",
			 night: "\u591C\u95F4"
		  },
		  wide: {
			 am: "\u4E0A\u5348",
			 pm: "\u4E0B\u5348",
			 midnight: "\u51CC\u6668",
			 noon: "\u4E2D\u5348",
			 morning: "\u65E9\u6668",
			 afternoon: "\u4E2D\u5348",
			 evening: "\u665A\u4E0A",
			 night: "\u591C\u95F4"
		  }
		};
		var ordinalNumber21 = (dirtyNumber, options) => {
		  const number5 = Number(dirtyNumber);
		  switch (options?.unit) {
			 case "date":
				return number5.toString() + "\u65E5";
			 case "hour":
				return number5.toString() + "\u65F6";
			 case "minute":
				return number5.toString() + "\u5206";
			 case "second":
				return number5.toString() + "\u79D2";
			 default:
				return "\u7B2C " + number5.toString();
		  }
		};
		var localize21 = {
		  ordinalNumber: ordinalNumber21,
		  era: buildLocalizeFn({
			 values: eraValues21,
			 defaultWidth: "wide"
		  }),
		  quarter: buildLocalizeFn({
			 values: quarterValues21,
			 defaultWidth: "wide",
			 argumentCallback: (quarter) => quarter - 1
		  }),
		  month: buildLocalizeFn({
			 values: monthValues21,
			 defaultWidth: "wide"
		  }),
		  day: buildLocalizeFn({
			 values: dayValues21,
			 defaultWidth: "wide"
		  }),
		  dayPeriod: buildLocalizeFn({
			 values: dayPeriodValues21,
			 defaultWidth: "wide",
			 formattingValues: formattingDayPeriodValues16,
			 defaultFormattingWidth: "wide"
		  })
		};

		// node_modules/date-fns/locale/zh-CN/_lib/match.mjs
		var matchOrdinalNumberPattern21 = /^(\s*)?\d+(|||)?/i;
		var parseOrdinalNumberPattern21 = /\d+/i;
		var matchEraPatterns21 = {
		  narrow: /^()/i,
		  abbreviated: /^()/i,
		  wide: /^(|)/i
		};
		var parseEraPatterns21 = {
		  any: [/^()/i, /^()/i]
		};
		var matchQuarterPatterns21 = {
		  narrow: /^[1234]/i,
		  abbreviated: /^[]/i,
		  wide: /^[]/i
		};
		var parseQuarterPatterns21 = {
		  any: [/(1|)/i, /(2|)/i, /(3|)/i, /(4|)/i]
		};
		var matchMonthPatterns21 = {
		  narrow: /^(|||||||||[])/i,
		  abbreviated: /^(|||||||||[]|\d|1[12])/i,
		  wide: /^(|||||||||[])/i
		};
		var parseMonthPatterns21 = {
		  narrow: [
			 /^/i,
			 /^/i,
			 /^/i,
			 /^/i,
			 /^/i,
			 /^/i,
			 /^/i,
			 /^/i,
			 /^/i,
			 /^(?!(|))/i,
			 /^/i,
			 /^/i
		  ],
		  any: [
			 /^|1/i,
			 /^|2/i,
			 /^|3/i,
			 /^|4/i,
			 /^|5/i,
			 /^|6/i,
			 /^|7/i,
			 /^|8/i,
			 /^|9/i,
			 /^(?!(|))|10/i,
			 /^|11/i,
			 /^|12/i
		  ]
		};
		var matchDayPatterns21 = {
		  narrow: /^[]/i,
		  short: /^[]/i,
		  abbreviated: /^[]/i,
		  wide: /^[]/i
		};
		var parseDayPatterns21 = {
		  any: [//i, //i, //i, //i, //i, //i, //i]
		};
		var matchDayPeriodPatterns21 = {
		  any: /^(?|?||[]|?||?||)/i
		};
		var parseDayPeriodPatterns21 = {
		  any: {
			 am: /^?/i,
			 pm: /^?/i,
			 midnight: /^/i,
			 noon: /^[]/i,
			 morning: /^/i,
			 afternoon: /^/i,
			 evening: /^?/i,
			 night: /^/i
		  }
		};
		var match21 = {
		  ordinalNumber: buildMatchPatternFn({
			 matchPattern: matchOrdinalNumberPattern21,
			 parsePattern: parseOrdinalNumberPattern21,
			 valueCallback: (value) => parseInt(value, 10)
		  }),
		  era: buildMatchFn({
			 matchPatterns: matchEraPatterns21,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseEraPatterns21,
			 defaultParseWidth: "any"
		  }),
		  quarter: buildMatchFn({
			 matchPatterns: matchQuarterPatterns21,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseQuarterPatterns21,
			 defaultParseWidth: "any",
			 valueCallback: (index) => index + 1
		  }),
		  month: buildMatchFn({
			 matchPatterns: matchMonthPatterns21,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseMonthPatterns21,
			 defaultParseWidth: "any"
		  }),
		  day: buildMatchFn({
			 matchPatterns: matchDayPatterns21,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseDayPatterns21,
			 defaultParseWidth: "any"
		  }),
		  dayPeriod: buildMatchFn({
			 matchPatterns: matchDayPeriodPatterns21,
			 defaultMatchWidth: "any",
			 parsePatterns: parseDayPeriodPatterns21,
			 defaultParseWidth: "any"
		  })
		};

		// node_modules/date-fns/locale/zh-CN.mjs
		var zhCN = {
		  code: "zh-CN",
		  formatDistance: formatDistance21,
		  formatLong: formatLong24,
		  formatRelative: formatRelative22,
		  localize: localize21,
		  match: match21,
		  options: {
			 weekStartsOn: 1,
			 firstWeekContainsDate: 4
		  }
		};

		// node_modules/date-fns/locale/zh-HK/_lib/formatDistance.mjs
		var formatDistanceLocale22 = {
		  lessThanXSeconds: {
			 one: "\u5C11\u65BC 1 \u79D2",
			 other: "\u5C11\u65BC {{count}} \u79D2"
		  },
		  xSeconds: {
			 one: "1 \u79D2",
			 other: "{{count}} \u79D2"
		  },
		  halfAMinute: "\u534A\u5206\u9418",
		  lessThanXMinutes: {
			 one: "\u5C11\u65BC 1 \u5206\u9418",
			 other: "\u5C11\u65BC {{count}} \u5206\u9418"
		  },
		  xMinutes: {
			 one: "1 \u5206\u9418",
			 other: "{{count}} \u5206\u9418"
		  },
		  xHours: {
			 one: "1 \u5C0F\u6642",
			 other: "{{count}} \u5C0F\u6642"
		  },
		  aboutXHours: {
			 one: "\u5927\u7D04 1 \u5C0F\u6642",
			 other: "\u5927\u7D04 {{count}} \u5C0F\u6642"
		  },
		  xDays: {
			 one: "1 \u5929",
			 other: "{{count}} \u5929"
		  },
		  aboutXWeeks: {
			 one: "\u5927\u7D04 1 \u500B\u661F\u671F",
			 other: "\u5927\u7D04 {{count}} \u500B\u661F\u671F"
		  },
		  xWeeks: {
			 one: "1 \u500B\u661F\u671F",
			 other: "{{count}} \u500B\u661F\u671F"
		  },
		  aboutXMonths: {
			 one: "\u5927\u7D04 1 \u500B\u6708",
			 other: "\u5927\u7D04 {{count}} \u500B\u6708"
		  },
		  xMonths: {
			 one: "1 \u500B\u6708",
			 other: "{{count}} \u500B\u6708"
		  },
		  aboutXYears: {
			 one: "\u5927\u7D04 1 \u5E74",
			 other: "\u5927\u7D04 {{count}} \u5E74"
		  },
		  xYears: {
			 one: "1 \u5E74",
			 other: "{{count}} \u5E74"
		  },
		  overXYears: {
			 one: "\u8D85\u904E 1 \u5E74",
			 other: "\u8D85\u904E {{count}} \u5E74"
		  },
		  almostXYears: {
			 one: "\u5C07\u8FD1 1 \u5E74",
			 other: "\u5C07\u8FD1 {{count}} \u5E74"
		  }
		};
		var formatDistance22 = (token, count, options) => {
		  let result;
		  const tokenValue = formatDistanceLocale22[token];
		  if (typeof tokenValue === "string") {
			 result = tokenValue;
		  } else if (count === 1) {
			 result = tokenValue.one;
		  } else {
			 result = tokenValue.other.replace("{{count}}", String(count));
		  }
		  if (options?.addSuffix) {
			 if (options.comparison && options.comparison > 0) {
				return result + "\u5167";
			 } else {
				return result + "\u524D";
			 }
		  }
		  return result;
		};

		// node_modules/date-fns/locale/zh-HK/_lib/formatLong.mjs
		var dateFormats25 = {
		  full: "y'\u5E74'M'\u6708'd'\u65E5' EEEE",
		  long: "y'\u5E74'M'\u6708'd'\u65E5'",
		  medium: "yyyy-MM-dd",
		  short: "yy-MM-dd"
		};
		var timeFormats25 = {
		  full: "zzzz a h:mm:ss",
		  long: "z a h:mm:ss",
		  medium: "a h:mm:ss",
		  short: "a h:mm"
		};
		var dateTimeFormats25 = {
		  full: "{{date}} {{time}}",
		  long: "{{date}} {{time}}",
		  medium: "{{date}} {{time}}",
		  short: "{{date}} {{time}}"
		};
		var formatLong25 = {
		  date: buildFormatLongFn({
			 formats: dateFormats25,
			 defaultWidth: "full"
		  }),
		  time: buildFormatLongFn({
			 formats: timeFormats25,
			 defaultWidth: "full"
		  }),
		  dateTime: buildFormatLongFn({
			 formats: dateTimeFormats25,
			 defaultWidth: "full"
		  })
		};

		// node_modules/date-fns/locale/zh-HK/_lib/formatRelative.mjs
		var formatRelativeLocale23 = {
		  lastWeek: "'\u4E0A\u500B'eeee p",
		  yesterday: "'\u6628\u5929' p",
		  today: "'\u4ECA\u5929' p",
		  tomorrow: "'\u660E\u5929' p",
		  nextWeek: "'\u4E0B\u500B'eeee p",
		  other: "P"
		};
		var formatRelative23 = (token, _date, _baseDate, _options) => formatRelativeLocale23[token];

		// node_modules/date-fns/locale/zh-HK/_lib/localize.mjs
		var eraValues22 = {
		  narrow: ["\u524D", "\u516C\u5143"],
		  abbreviated: ["\u524D", "\u516C\u5143"],
		  wide: ["\u516C\u5143\u524D", "\u516C\u5143"]
		};
		var quarterValues22 = {
		  narrow: ["1", "2", "3", "4"],
		  abbreviated: ["\u7B2C\u4E00\u5B63", "\u7B2C\u4E8C\u5B63", "\u7B2C\u4E09\u5B63", "\u7B2C\u56DB\u5B63"],
		  wide: ["\u7B2C\u4E00\u5B63\u5EA6", "\u7B2C\u4E8C\u5B63\u5EA6", "\u7B2C\u4E09\u5B63\u5EA6", "\u7B2C\u56DB\u5B63\u5EA6"]
		};
		var monthValues22 = {
		  narrow: [
			 "\u4E00",
			 "\u4E8C",
			 "\u4E09",
			 "\u56DB",
			 "\u4E94",
			 "\u516D",
			 "\u4E03",
			 "\u516B",
			 "\u4E5D",
			 "\u5341",
			 "\u5341\u4E00",
			 "\u5341\u4E8C"
		  ],
		  abbreviated: [
			 "1\u6708",
			 "2\u6708",
			 "3\u6708",
			 "4\u6708",
			 "5\u6708",
			 "6\u6708",
			 "7\u6708",
			 "8\u6708",
			 "9\u6708",
			 "10\u6708",
			 "11\u6708",
			 "12\u6708"
		  ],
		  wide: [
			 "\u4E00\u6708",
			 "\u4E8C\u6708",
			 "\u4E09\u6708",
			 "\u56DB\u6708",
			 "\u4E94\u6708",
			 "\u516D\u6708",
			 "\u4E03\u6708",
			 "\u516B\u6708",
			 "\u4E5D\u6708",
			 "\u5341\u6708",
			 "\u5341\u4E00\u6708",
			 "\u5341\u4E8C\u6708"
		  ]
		};
		var dayValues22 = {
		  narrow: ["\u65E5", "\u4E00", "\u4E8C", "\u4E09", "\u56DB", "\u4E94", "\u516D"],
		  short: ["\u65E5", "\u4E00", "\u4E8C", "\u4E09", "\u56DB", "\u4E94", "\u516D"],
		  abbreviated: ["\u9031\u65E5", "\u9031\u4E00", "\u9031\u4E8C", "\u9031\u4E09", "\u9031\u56DB", "\u9031\u4E94", "\u9031\u516D"],
		  wide: ["\u661F\u671F\u65E5", "\u661F\u671F\u4E00", "\u661F\u671F\u4E8C", "\u661F\u671F\u4E09", "\u661F\u671F\u56DB", "\u661F\u671F\u4E94", "\u661F\u671F\u516D"]
		};
		var dayPeriodValues22 = {
		  narrow: {
			 am: "\u4E0A",
			 pm: "\u4E0B",
			 midnight: "\u5348\u591C",
			 noon: "\u664C",
			 morning: "\u65E9",
			 afternoon: "\u5348",
			 evening: "\u665A",
			 night: "\u591C"
		  },
		  abbreviated: {
			 am: "\u4E0A\u5348",
			 pm: "\u4E0B\u5348",
			 midnight: "\u5348\u591C",
			 noon: "\u4E2D\u5348",
			 morning: "\u4E0A\u5348",
			 afternoon: "\u4E0B\u5348",
			 evening: "\u665A\u4E0A",
			 night: "\u591C\u665A"
		  },
		  wide: {
			 am: "\u4E0A\u5348",
			 pm: "\u4E0B\u5348",
			 midnight: "\u5348\u591C",
			 noon: "\u4E2D\u5348",
			 morning: "\u4E0A\u5348",
			 afternoon: "\u4E0B\u5348",
			 evening: "\u665A\u4E0A",
			 night: "\u591C\u665A"
		  }
		};
		var formattingDayPeriodValues17 = {
		  narrow: {
			 am: "\u4E0A",
			 pm: "\u4E0B",
			 midnight: "\u5348\u591C",
			 noon: "\u664C",
			 morning: "\u65E9",
			 afternoon: "\u5348",
			 evening: "\u665A",
			 night: "\u591C"
		  },
		  abbreviated: {
			 am: "\u4E0A\u5348",
			 pm: "\u4E0B\u5348",
			 midnight: "\u5348\u591C",
			 noon: "\u4E2D\u5348",
			 morning: "\u4E0A\u5348",
			 afternoon: "\u4E0B\u5348",
			 evening: "\u665A\u4E0A",
			 night: "\u591C\u665A"
		  },
		  wide: {
			 am: "\u4E0A\u5348",
			 pm: "\u4E0B\u5348",
			 midnight: "\u5348\u591C",
			 noon: "\u4E2D\u5348",
			 morning: "\u4E0A\u5348",
			 afternoon: "\u4E0B\u5348",
			 evening: "\u665A\u4E0A",
			 night: "\u591C\u665A"
		  }
		};
		var ordinalNumber22 = (dirtyNumber, options) => {
		  const number5 = Number(dirtyNumber);
		  switch (options?.unit) {
			 case "date":
				return number5 + "\u65E5";
			 case "hour":
				return number5 + "\u6642";
			 case "minute":
				return number5 + "\u5206";
			 case "second":
				return number5 + "\u79D2";
			 default:
				return "\u7B2C " + number5;
		  }
		};
		var localize22 = {
		  ordinalNumber: ordinalNumber22,
		  era: buildLocalizeFn({
			 values: eraValues22,
			 defaultWidth: "wide"
		  }),
		  quarter: buildLocalizeFn({
			 values: quarterValues22,
			 defaultWidth: "wide",
			 argumentCallback: (quarter) => quarter - 1
		  }),
		  month: buildLocalizeFn({
			 values: monthValues22,
			 defaultWidth: "wide"
		  }),
		  day: buildLocalizeFn({
			 values: dayValues22,
			 defaultWidth: "wide"
		  }),
		  dayPeriod: buildLocalizeFn({
			 values: dayPeriodValues22,
			 defaultWidth: "wide",
			 formattingValues: formattingDayPeriodValues17,
			 defaultFormattingWidth: "wide"
		  })
		};

		// node_modules/date-fns/locale/zh-HK/_lib/match.mjs
		var matchOrdinalNumberPattern22 = /^(\s*)?\d+(|||)?/i;
		var parseOrdinalNumberPattern22 = /\d+/i;
		var matchEraPatterns22 = {
		  narrow: /^()/i,
		  abbreviated: /^()/i,
		  wide: /^(|)/i
		};
		var parseEraPatterns22 = {
		  any: [/^()/i, /^()/i]
		};
		var matchQuarterPatterns22 = {
		  narrow: /^[1234]/i,
		  abbreviated: /^[]/i,
		  wide: /^[]/i
		};
		var parseQuarterPatterns22 = {
		  any: [/(1|)/i, /(2|)/i, /(3|)/i, /(4|)/i]
		};
		var matchMonthPatterns22 = {
		  narrow: /^(|||||||||[])/i,
		  abbreviated: /^(|||||||||[]|\d|1[12])/i,
		  wide: /^(|||||||||[])/i
		};
		var parseMonthPatterns22 = {
		  narrow: [
			 /^/i,
			 /^/i,
			 /^/i,
			 /^/i,
			 /^/i,
			 /^/i,
			 /^/i,
			 /^/i,
			 /^/i,
			 /^(?!(|))/i,
			 /^/i,
			 /^/i
		  ],
		  any: [
			 /^|1/i,
			 /^|2/i,
			 /^|3/i,
			 /^|4/i,
			 /^|5/i,
			 /^|6/i,
			 /^|7/i,
			 /^|8/i,
			 /^|9/i,
			 /^(?!(|))|10/i,
			 /^|11/i,
			 /^|12/i
		  ]
		};
		var matchDayPatterns22 = {
		  narrow: /^[]/i,
		  short: /^[]/i,
		  abbreviated: /^[]/i,
		  wide: /^[]/i
		};
		var parseDayPatterns22 = {
		  any: [//i, //i, //i, //i, //i, //i, //i]
		};
		var matchDayPeriodPatterns22 = {
		  any: /^(?|?||[]|?||?|)/i
		};
		var parseDayPeriodPatterns22 = {
		  any: {
			 am: /^?/i,
			 pm: /^?/i,
			 midnight: /^/i,
			 noon: /^[]/i,
			 morning: /^/i,
			 afternoon: /^/i,
			 evening: /^?/i,
			 night: /^/i
		  }
		};
		var match22 = {
		  ordinalNumber: buildMatchPatternFn({
			 matchPattern: matchOrdinalNumberPattern22,
			 parsePattern: parseOrdinalNumberPattern22,
			 valueCallback: (value) => parseInt(value, 10)
		  }),
		  era: buildMatchFn({
			 matchPatterns: matchEraPatterns22,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseEraPatterns22,
			 defaultParseWidth: "any"
		  }),
		  quarter: buildMatchFn({
			 matchPatterns: matchQuarterPatterns22,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseQuarterPatterns22,
			 defaultParseWidth: "any",
			 valueCallback: (index) => index + 1
		  }),
		  month: buildMatchFn({
			 matchPatterns: matchMonthPatterns22,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseMonthPatterns22,
			 defaultParseWidth: "any"
		  }),
		  day: buildMatchFn({
			 matchPatterns: matchDayPatterns22,
			 defaultMatchWidth: "wide",
			 parsePatterns: parseDayPatterns22,
			 defaultParseWidth: "any"
		  }),
		  dayPeriod: buildMatchFn({
			 matchPatterns: matchDayPeriodPatterns22,
			 defaultMatchWidth: "any",
			 parsePatterns: parseDayPeriodPatterns22,
			 defaultParseWidth: "any"
		  })
		};

		// node_modules/date-fns/locale/zh-HK.mjs
		var zhHK = {
		  code: "zh-HK",
		  formatDistance: formatDistance22,
		  formatLong: formatLong25,
		  formatRelative: formatRelative23,
		  localize: localize22,
		  match: match22,
		  options: {
			 weekStartsOn: 0,
			 firstWeekContainsDate: 1
		  }
		};

		// dist/rib-4.0/planning-board/fesm2022/rib-4.0-planning-board.mjs
		var import_jquery = __toESM(require_jquery(), 1);
		var PlanningBoardExternalServices = class _PlanningBoardExternalServices {
		  constructor(additionalServices) {
			 _PlanningBoardExternalServices.PlatformMessenger = additionalServices.PlatformMessenger;
			 _PlanningBoardExternalServices.platformDataServiceModificationTrackingExtension = additionalServices.platformDataServiceModificationTrackingExtension;
			 _PlanningBoardExternalServices.platformGridAPI = additionalServices.platformGridAPI;
			 _PlanningBoardExternalServices.basicsCustomizeReservationTypeIconService = additionalServices.basicsCustomizeReservationTypeIconService;
			 _PlanningBoardExternalServices.platformDetailControllerService = additionalServices.platformDetailControllerService;
			 _PlanningBoardExternalServices.platformGridControllerService = additionalServices.platformGridControllerService;
			 _PlanningBoardExternalServices.platformChartInterval = additionalServices.platformChartInterval;
			 _PlanningBoardExternalServices.basicsUnitLookupDataService = additionalServices.basicsUnitLookupDataService;
			 _PlanningBoardExternalServices.platformDateshiftHelperService = additionalServices.platformDateshiftHelperService;
			 _PlanningBoardExternalServices.platformToolbarService = additionalServices.platformToolbarService;
			 _PlanningBoardExternalServices.platformDateshiftPlanningboardHelperService = additionalServices.platformDateshiftPlanningboardHelperService;
			 _PlanningBoardExternalServices.mainViewService = additionalServices.mainViewService;
			 _PlanningBoardExternalServices.platformDateshiftCalendarService = additionalServices.platformDateshiftCalendarService;
			 _PlanningBoardExternalServices.calendarUtilitiesService = additionalServices.calendarUtilitiesService;
			 _PlanningBoardExternalServices.angularJScompile = additionalServices.angularJScompile;
			 _PlanningBoardExternalServices.angularJSTimeout = additionalServices.angularJSTimeout;
			 _PlanningBoardExternalServices.convertDateToMoment = additionalServices.convertDateToMoment;
			 _PlanningBoardExternalServices.createNewngJSChildScope = additionalServices.createNewngJSChildScope;
			 _PlanningBoardExternalServices.BasicsSharedStatusIconService = additionalServices.BasicsSharedStatusIconService;
			 _PlanningBoardExternalServices.BasicsSharedChangeStatusService = additionalServices.BasicsSharedChangeStatusService;
			 _PlanningBoardExternalServices.PlatformDragDropService = additionalServices.PlatformDragDropService;
			 _PlanningBoardExternalServices.UiCommonLookupViewService = additionalServices.UiCommonLookupViewService;
			 _PlanningBoardExternalServices.PlatformTranslateService = additionalServices.PlatformTranslateService;
			 _PlanningBoardExternalServices.PlatformConfigurationService = additionalServices.PlatformConfigurationService;
			 _PlanningBoardExternalServices.CloudDesktopSvgIconService = additionalServices.CloudDesktopSvgIconService;
			 _PlanningBoardExternalServices.injector = additionalServices.injector;
			 _PlanningBoardExternalServices.ModuleNavBarService = additionalServices.ModuleNavBarService;
			 _PlanningBoardExternalServices.UiCommonDialogService = additionalServices.UiCommonDialogService;
			 _PlanningBoardExternalServices.UiCommonFormDialogService = additionalServices.UiCommonFormDialogService;
			 _PlanningBoardExternalServices.UiCommonMessageBoxService = additionalServices.UiCommonMessageBoxService;
			 _PlanningBoardExternalServices.PlatformHttpService = additionalServices.PlatformHttpService;
			 _PlanningBoardExternalServices.basicsCommonDrawingUtilitiesService = additionalServices.basicsCommonDrawingUtilitiesService;
		  }
		  static {
			 this.\u0275fac = function PlanningBoardExternalServices_Factory(t) {
				return new (t || _PlanningBoardExternalServices)(\u0275\u0275inject(Object));
			 };
		  }
		  static {
			 this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _PlanningBoardExternalServices, factory: _PlanningBoardExternalServices.\u0275fac, providedIn: "root" });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlanningBoardExternalServices, [{
			 type: Injectable,
			 args: [{
				providedIn: "root"
			 }]
		  }], () => [{ type: void 0, decorators: [{
			 type: Inject,
			 args: [Object]
		  }] }], null);
		})();
		var availableCultureMap = new Map(Object.entries({
		  "en-gb": enGB,
		  "en-us": enUS,
		  "de-de": de,
		  "de-ch": de,
		  "es-es": es,
		  "fi-fi": fi,
		  "fr-fr": fr,
		  "fr-ch": frCH,
		  "nl-nl": nl,
		  "ru-ru": ru,
		  "zh-cn": zhCN,
		  "zh-hant": zhHK,
		  "it-it": it,
		  "it-ch": itCH,
		  "cs-cz": cs,
		  "pl-pl": pl,
		  "sv-se": sv,
		  "nb-no": nb,
		  "lt-lt": lt,
		  "ja-jp": ja,
		  "pt-pt": pt,
		  "da-dk": da,
		  "ko-kr": ko,
		  "vi-vn": vi,
		  "th-th": th,
		  "id-id": id2
		}));
		var userCultureInfo = {
		  availableCultureMap,
		  cultureOfUser: "en-gb"
		  //default - should be us instead?
		};
		var DateExtensionDuration = class _DateExtensionDuration extends Map {
		  constructor(valuesOfDuration, type2) {
			 super();
			 this.years = (value) => import_lodash.default.isUndefined(value) ? this.valuesOfDuration.get("years") : this.valuesOfDuration.set("years", value);
			 this.months = (value) => import_lodash.default.isUndefined(value) ? this.valuesOfDuration.get("months") : this.valuesOfDuration.set("months", value);
			 this.weeks = (value) => import_lodash.default.isUndefined(value) ? this.valuesOfDuration.get("weeks") : this.valuesOfDuration.set("weeks", value);
			 this.days = (value) => import_lodash.default.isUndefined(value) ? this.valuesOfDuration.get("days") : this.valuesOfDuration.set("days", value);
			 this.hours = (value) => import_lodash.default.isUndefined(value) ? this.valuesOfDuration.get("hours") : this.valuesOfDuration.set("hours", value);
			 this.minutes = (value) => import_lodash.default.isUndefined(value) ? this.valuesOfDuration.get("minutes") : this.valuesOfDuration.set("minutes", value);
			 this.seconds = (value) => import_lodash.default.isUndefined(value) ? this.valuesOfDuration.get("seconds") : this.valuesOfDuration.set("seconds", value);
			 this.milliseconds = (value) => import_lodash.default.isUndefined(value) ? this.valuesOfDuration.get("milliseconds") : this.valuesOfDuration.set("milliseconds", value);
			 this.asYears = () => {
				let startDate = new DateExtension();
				let endDate = add(startDate, Object.fromEntries(this.valuesOfDuration.entries()));
				return endDate.diff(startDate, "years");
			 };
			 this.asMonths = () => {
				let startDate = new DateExtension();
				let endDate = add(startDate, Object.fromEntries(this.valuesOfDuration.entries()));
				return endDate.diff(startDate, "months");
			 };
			 this.asWeeks = () => {
				let startDate = new DateExtension();
				let endDate = add(startDate, Object.fromEntries(this.valuesOfDuration.entries()));
				return endDate.diff(startDate, "weeks");
			 };
			 this.asDays = () => {
				let startDate = new DateExtension();
				let endDate = add(startDate, Object.fromEntries(this.valuesOfDuration.entries()));
				return endDate.diff(startDate, "days");
			 };
			 this.asHours = () => {
				let startDate = new DateExtension();
				let endDate = add(startDate, Object.fromEntries(this.valuesOfDuration.entries()));
				return endDate.diff(startDate, "hours");
			 };
			 this.asMinutes = () => {
				let startDate = new DateExtension();
				let endDate = add(startDate, Object.fromEntries(this.valuesOfDuration.entries()));
				return endDate.diff(startDate, "minutes");
			 };
			 this.asSeconds = () => {
				let startDate = new DateExtension();
				let endDate = add(startDate, Object.fromEntries(this.valuesOfDuration.entries()));
				return endDate.diff(startDate, "seconds");
			 };
			 this.asMilliseconds = () => {
				let startDate = new DateExtension();
				let endDate = add(startDate, Object.fromEntries(this.valuesOfDuration.entries()));
				return endDate.diff(startDate, "milliseconds");
			 };
			 this.subtract = (durationToSubtract, unit2) => {
				if (durationToSubtract instanceof _DateExtensionDuration) {
				  this.valuesOfDuration.forEach((v, k) => {
					 v -= durationToSubtract.get(k);
				  });
				} else if (typeof durationToSubtract === "number" && unit2) {
				  const currentValueOfUnit = this.valuesOfDuration.get(unit2);
				  if (currentValueOfUnit) {
					 this.valuesOfDuration.set(unit2, currentValueOfUnit - durationToSubtract);
				  }
				} else if (typeof durationToSubtract === "number" && !unit2) {
				  const startDate = new DateExtension();
				  const endDate = startDate.add(durationToSubtract, "ms");
				  const msToDuration = new _DateExtensionDuration(intervalToDuration({ start: startDate, end: endDate }));
				  this.valuesOfDuration.forEach((v, k) => {
					 v -= msToDuration.get(k);
				  });
				}
				return this.valuesOfDuration;
			 };
			 this.add = (durationToSubtract, unit2) => {
				if (durationToSubtract instanceof _DateExtensionDuration) {
				  this.valuesOfDuration.forEach((v, k) => {
					 v += durationToSubtract.get(k);
				  });
				} else if (typeof durationToSubtract === "number" && unit2) {
				  const currentValueOfUnit = this.valuesOfDuration.get(unit2);
				  if (currentValueOfUnit) {
					 this.valuesOfDuration.set(unit2, currentValueOfUnit + durationToSubtract);
				  }
				} else if (typeof durationToSubtract === "number" && !unit2) {
				  const startDate = new DateExtension();
				  const endDate = startDate.add(durationToSubtract, "ms");
				  const msToDuration = new _DateExtensionDuration(intervalToDuration({ start: startDate, end: endDate }));
				  this.valuesOfDuration.forEach((v, k) => {
					 v += msToDuration.get(k);
				  });
				}
				return this.valuesOfDuration;
			 };
			 if (valuesOfDuration && valuesOfDuration instanceof _DateExtensionDuration) {
				this.valuesOfDuration = valuesOfDuration;
			 } else {
				this.valuesOfDuration = /* @__PURE__ */ new Map();
				this.valuesOfDuration.set("years", 0);
				this.valuesOfDuration.set("months", 0);
				this.valuesOfDuration.set("weeks", 0);
				this.valuesOfDuration.set("days", 0);
				this.valuesOfDuration.set("hours", 0);
				this.valuesOfDuration.set("minutes", 0);
				this.valuesOfDuration.set("seconds", 0);
				this.valuesOfDuration.set("milliseconds", 0);
				if (typeof valuesOfDuration === "number" && type2) {
				  const correctType = getTypeFromString(type2);
				  if (correctType) {
					 this.valuesOfDuration.set(correctType, valuesOfDuration);
				  } else {
					 this.valuesOfDuration.set("milliseconds", valuesOfDuration);
				  }
				} else if (valuesOfDuration instanceof DateExtension) {
				  let value = valuesOfDuration.years();
				  this.valuesOfDuration.set("years", typeof value === "number" ? value : 0);
				  value = valuesOfDuration.months();
				  this.valuesOfDuration.set("months", typeof value === "number" ? value : 0);
				  value = valuesOfDuration.weeks();
				  this.valuesOfDuration.set("weeks", typeof value === "number" ? value : 0);
				  value = valuesOfDuration.days();
				  this.valuesOfDuration.set("days", typeof value === "number" ? value : 0);
				  value = valuesOfDuration.hours();
				  this.valuesOfDuration.set("hours", typeof value === "number" ? value : 0);
				  value = valuesOfDuration.minutes();
				  this.valuesOfDuration.set("minutes", typeof value === "number" ? value : 0);
				  value = valuesOfDuration.seconds();
				  this.valuesOfDuration.set("seconds", typeof value === "number" ? value : 0);
				  value = valuesOfDuration.milliseconds();
				  this.valuesOfDuration.set("milliseconds", typeof value === "number" ? value : 0);
				} else if (valuesOfDuration) {
				  this.valuesOfDuration.forEach((v, k) => {
					 let key = k.toString();
					 if (valuesOfDuration.hasOwnProperty(key)) {
						this.valuesOfDuration.set(k, v);
					 }
				  });
				}
			 }
		  }
		};
		var DateExtension = class _DateExtension extends Date {
		  creationData() {
			 return this.data;
		  }
		  set(durationObject) {
			 let dateToReturn = new _DateExtension(this);
			 Object.keys(durationObject).forEach((key) => {
				if (key === "milliseconds" || key === "millisecond" || key === "ms") {
				  dateToReturn = dateToReturn.milliseconds(durationObject[key]);
				}
				if (key === "seconds" || key === "second" || key === "s") {
				  dateToReturn = dateToReturn.seconds(durationObject[key]);
				}
				if (key === "minutes" || key === "minute" || key === "m") {
				  dateToReturn = dateToReturn.minutes(durationObject[key]);
				}
				if (key === "hours" || key === "hour" || key === "h") {
				  dateToReturn = dateToReturn.hours(durationObject[key]);
				}
				if (key === "days" || key === "day" || key === "d") {
				  dateToReturn = dateToReturn.days(durationObject[key]);
				}
				if (key === "weeks" || key === "week" || key === "w") {
				  dateToReturn = dateToReturn.weeks(durationObject[key]);
				}
				if (key === "months" || key === "month") {
				  dateToReturn = dateToReturn.months(durationObject[key]);
				}
				if (key === "years" || key === "year" || key === "y") {
				  dateToReturn = dateToReturn.years(durationObject[key]);
				}
			 });
			 return dateToReturn;
		  }
		  clone() {
			 return new _DateExtension(this);
		  }
		  // geter setter functions
		  years(value) {
			 if (typeof value !== "undefined") {
				if (typeof value === "number") {
				  return setYear(this, value);
				}
				if (value instanceof _DateExtension) {
				  return setHours(this, getYear(value));
				}
			 }
			 return getYear(this);
		  }
		  months(value) {
			 if (typeof value !== "undefined") {
				if (typeof value === "number") {
				  return setMonth(this, value);
				}
				if (value instanceof _DateExtension) {
				  return setMonth(this, getMonth(value));
				}
			 }
			 return getMonth(this);
		  }
		  weeks(value) {
			 if (typeof value !== "undefined") {
				if (typeof value === "number") {
				  return setWeek(this, value);
				}
				if (value instanceof _DateExtension) {
				  return setHours(this, getWeek(value));
				}
			 }
			 return getWeek(this);
		  }
		  days(value) {
			 if (typeof value !== "undefined") {
				if (typeof value === "number") {
				  return setDay(this, value);
				}
				if (value instanceof _DateExtension) {
				  return setHours(this, getDay(value));
				}
			 }
			 return getDay(this);
		  }
		  hours(value) {
			 if (typeof value !== "undefined") {
				if (typeof value === "number") {
				  return setHours(this, value);
				}
				if (value instanceof _DateExtension) {
				  return setHours(this, getHours(value));
				}
			 }
			 return getHours(this);
		  }
		  minutes(value) {
			 if (typeof value !== "undefined") {
				if (typeof value === "number") {
				  return setMinutes(this, value);
				}
				if (value instanceof _DateExtension) {
				  return setMinutes(this, getMinutes(value));
				}
			 }
			 return getMinutes(this);
		  }
		  seconds(value) {
			 if (typeof value !== "undefined") {
				if (typeof value === "number") {
				  return setSeconds(this, value);
				}
				if (value instanceof _DateExtension) {
				  return setMinutes(this, getSeconds(value));
				}
			 }
			 return getSeconds(this);
		  }
		  milliseconds(value) {
			 if (typeof value !== "undefined") {
				if (typeof value === "number") {
				  return setMilliseconds(this, value);
				}
				if (value instanceof _DateExtension) {
				  return setMilliseconds(this, getMilliseconds(value));
				}
			 }
			 return getMilliseconds(this);
		  }
		  asYears(date2) {
			 return date2.getTime() / (365 * 24 * 60 * 60 * 1e3);
		  }
		  asMonths(date2) {
			 return date2.getTime() / (30 * 24 * 60 * 60 * 1e3);
		  }
		  asWeeks(date2) {
			 return date2.getTime() / (52 * 24 * 60 * 60 * 1e3);
		  }
		  asDays(date2) {
			 return date2.getTime() / (24 * 60 * 60 * 1e3);
		  }
		  asHours(date2) {
			 return date2.getTime() / (60 * 60 * 1e3);
		  }
		  asMinutes(date2) {
			 return date2.getTime() / (60 * 1e3);
		  }
		  asSeconds(date2) {
			 return date2.getTime() / 1e3;
		  }
		  asMilliseconds(date2) {
			 return date2.getTime();
		  }
		  // end geter setter functions
		  subtract(value, type2) {
			 return this.add(-value, type2);
		  }
		  add(value, type2) {
			 let valuesToAdd = new DateExtensionDuration();
			 let durationObjMap = new Map(Object.entries(valuesToAdd));
			 if (typeof value !== "number") {
				valuesToAdd = new DateExtensionDuration(value);
				durationObjMap = new Map(Object.entries(valuesToAdd));
			 } else {
				if (!type2) {
				  type2 = "ms";
				}
				let correctType = getTypeFromString(type2);
				if (durationObjMap.get(correctType) !== void 0) {
				  durationObjMap.get(correctType)(value);
				}
			 }
			 return add(this, {
				years: durationObjMap.get(getTypeFromString("years"))(),
				months: durationObjMap.get(getTypeFromString("months"))(),
				weeks: durationObjMap.get(getTypeFromString("weeks"))(),
				days: durationObjMap.get(getTypeFromString("days"))(),
				hours: durationObjMap.get(getTypeFromString("hours"))(),
				minutes: durationObjMap.get(getTypeFromString("minutes"))(),
				seconds: durationObjMap.get(getTypeFromString("seconds"))()
			 });
		  }
		  diff(dateToCompare, type2) {
			 let differenceInUnit = 0;
			 if (type2) {
				switch (getTypeFromString(type2)) {
				  case "years":
					 differenceInUnit = differenceInYears(this, dateToCompare);
					 break;
				  case "months":
					 differenceInUnit = differenceInMonths(this, dateToCompare);
					 break;
				  case "weeks":
					 differenceInUnit = differenceInWeeks(this, dateToCompare);
					 break;
				  case "days":
					 differenceInUnit = differenceInDays(this, dateToCompare);
					 break;
				  case "hours":
					 differenceInUnit = differenceInHours(this, dateToCompare);
					 break;
				  case "minutes":
					 differenceInUnit = differenceInMinutes(this, dateToCompare);
					 break;
				  case "seconds":
					 differenceInUnit = differenceInSeconds(this, dateToCompare);
					 break;
				  case "milliseconds":
				  default:
					 differenceInUnit = differenceInMilliseconds(this, dateToCompare);
					 break;
				}
			 } else {
				differenceInUnit = differenceInMilliseconds(this, dateToCompare);
			 }
			 return differenceInUnit;
		  }
		  format(format2, options) {
			 const optionsValue = options || {};
			 if (format2) {
				if (!options || !options.locale) {
				  optionsValue.locale = userCultureInfo.availableCultureMap.get(userCultureInfo.cultureOfUser);
				}
				return format(new _DateExtension(this.getTime() + this.getTimezoneOffset() * 1e3 * 60), format2, optionsValue);
			 }
			 return this.toISOString();
		  }
		  utc() {
			 return this;
		  }
		  startOf(type2, nonUTC = false) {
			 let dateToReturn = new _DateExtension();
			 switch (type2) {
				case "year":
				  dateToReturn = startOfYear(this);
				  break;
				case "month":
				  startOfMonth(this);
				  break;
				case "quarter":
				  dateToReturn = startOfQuarter(this);
				  break;
				case "week":
				  dateToReturn = startOfWeek(this);
				  break;
				case "isoWeek":
				  dateToReturn = startOfISOWeek(this);
				  break;
				case "day":
				  dateToReturn = startOfDay(this);
				  break;
				case "date":
				  dateToReturn = this;
				  break;
				case "hour":
				  dateToReturn = startOfHour(this);
				  break;
				case "minute":
				  dateToReturn = startOfMinute(this);
				  break;
				case "second":
				  dateToReturn = startOfSecond(this);
				  break;
				default:
				  dateToReturn = this;
				  break;
			 }
			 if (!nonUTC) {
				dateToReturn = new _DateExtension(dateToReturn.getTime() - dateToReturn.getTimezoneOffset() * 1e3 * 60);
			 }
			 return dateToReturn;
		  }
		  endOf(type2, nonUTC = false) {
			 let dateToReturn = new _DateExtension();
			 switch (type2) {
				case "year":
				  dateToReturn = endOfYear(this);
				  break;
				case "month":
				  endOfMonth(this);
				  break;
				case "quarter":
				  dateToReturn = endOfQuarter(this);
				  break;
				case "week":
				  dateToReturn = endOfWeek(this);
				  break;
				case "isoWeek":
				  dateToReturn = endOfISOWeek(this);
				  break;
				case "day":
				  dateToReturn = endOfDay(this);
				  break;
				case "date":
				  dateToReturn = this;
				  break;
				case "hour":
				  dateToReturn = endOfHour(this);
				  break;
				case "minute":
				  dateToReturn = endOfMinute(this);
				  break;
				case "second":
				  dateToReturn = endOfSecond(this);
				  break;
				default:
				  dateToReturn = this;
				  break;
			 }
			 if (!nonUTC) {
				dateToReturn = new _DateExtension(dateToReturn.getTime() - dateToReturn.getTimezoneOffset() * 1e3 * 60);
			 }
			 return dateToReturn;
		  }
		  isBefore(dateToComapre, precision) {
			 if (precision) {
				switch (precision) {
				  case "second":
					 dateToComapre = new _DateExtension(dateToComapre.setMilliseconds(0));
					 break;
				  case "minute":
					 dateToComapre = new _DateExtension(dateToComapre.setMilliseconds(0));
					 dateToComapre = new _DateExtension(dateToComapre.setSeconds(0));
					 break;
				  case "hour":
					 dateToComapre = new _DateExtension(dateToComapre.setMilliseconds(0));
					 dateToComapre = new _DateExtension(dateToComapre.setSeconds(0));
					 dateToComapre = new _DateExtension(dateToComapre.setMinutes(0));
					 break;
				  case "day":
					 dateToComapre = new _DateExtension(dateToComapre.setMilliseconds(0));
					 dateToComapre = new _DateExtension(dateToComapre.setSeconds(0));
					 dateToComapre = new _DateExtension(dateToComapre.setMinutes(0));
					 dateToComapre = new _DateExtension(dateToComapre.setHours(0));
					 break;
				  case "year":
					 dateToComapre = new _DateExtension(dateToComapre.setMilliseconds(0));
					 dateToComapre = new _DateExtension(dateToComapre.setSeconds(0));
					 dateToComapre = new _DateExtension(dateToComapre.setMinutes(0));
					 dateToComapre = new _DateExtension(dateToComapre.setHours(0));
					 dateToComapre = new _DateExtension(dateToComapre.setDate(0));
					 break;
				}
			 }
			 return isBefore(this, dateToComapre);
		  }
		  isAfter(dateToComapre, precision) {
			 if (precision) {
				switch (precision) {
				  case "second":
					 dateToComapre = new _DateExtension(dateToComapre.setMilliseconds(0));
					 break;
				  case "minute":
					 dateToComapre = new _DateExtension(dateToComapre.setMilliseconds(0));
					 dateToComapre = new _DateExtension(dateToComapre.setSeconds(0));
					 break;
				  case "hour":
					 dateToComapre = new _DateExtension(dateToComapre.setMilliseconds(0));
					 dateToComapre = new _DateExtension(dateToComapre.setSeconds(0));
					 dateToComapre = new _DateExtension(dateToComapre.setMinutes(0));
					 break;
				  case "day":
					 dateToComapre = new _DateExtension(dateToComapre.setMilliseconds(0));
					 dateToComapre = new _DateExtension(dateToComapre.setSeconds(0));
					 dateToComapre = new _DateExtension(dateToComapre.setMinutes(0));
					 dateToComapre = new _DateExtension(dateToComapre.setHours(0));
					 break;
				  case "year":
					 dateToComapre = new _DateExtension(dateToComapre.setMilliseconds(0));
					 dateToComapre = new _DateExtension(dateToComapre.setSeconds(0));
					 dateToComapre = new _DateExtension(dateToComapre.setMinutes(0));
					 dateToComapre = new _DateExtension(dateToComapre.setHours(0));
					 dateToComapre = new _DateExtension(dateToComapre.setDate(0));
					 break;
				}
			 }
			 return isAfter(this, dateToComapre);
		  }
		  isSame(dateToComapre, unit2) {
			 if (unit2) {
				switch (unit2) {
				  case "year":
					 return this.getFullYear() === dateToComapre.getFullYear();
				  case "month":
					 return this.getUTCMonth() === dateToComapre.getUTCMonth();
				  case "week":
					 return getWeek(this) === getWeek(dateToComapre);
				  case "day":
					 return this.getUTCDay() === dateToComapre.getUTCDay();
				  case "minute":
					 return this.getUTCMinutes() === dateToComapre.getUTCMinutes();
				  case "second":
					 return this.getUTCSeconds() === dateToComapre.getUTCSeconds();
				  case "hour":
					 return this.getUTCHours() === dateToComapre.getUTCHours();
				  case "isoWeek":
					 return getISOWeek(this) === getISOWeek(dateToComapre);
				  case "quarter":
					 return getQuarter(this) === getQuarter(dateToComapre);
				  default:
					 return this.getTime() === dateToComapre.getTime();
				}
			 }
			 return this.toDate().getTime() === dateToComapre.toDate().getTime();
		  }
		  isSameOrBefore(dateToComapre) {
			 return this.isBefore(dateToComapre) || this.isSame(dateToComapre);
		  }
		  isSameOrAfter(dateToComapre) {
			 return this.isAfter(dateToComapre) || this.isSame(dateToComapre);
		  }
		  isBetween(dateStart, dateEnd, unit2) {
			 return this.isSameOrAfter(dateStart) && this.isSameOrBefore(dateEnd);
		  }
		  toMoment() {
			 let result = null;
			 if (PlanningBoardExternalServices.convertDateToMoment) {
				result = PlanningBoardExternalServices.convertDateToMoment(this.getTime());
			 }
			 return result;
		  }
		  toDate() {
			 return this;
		  }
		  toString() {
			 return this.toLocaleString(userCultureInfo.cultureOfUser);
		  }
		  isValid() {
			 return !!this && !!this.valueOf();
		  }
		  isUTC() {
			 return true;
		  }
		  static {
			 this.duration = DateExtensionDuration;
		  }
		  static {
			 this.max = (dates) => {
				return max2(dates);
			 };
		  }
		  static {
			 this.min = (dates) => {
				return min2(dates);
			 };
		  }
		  static {
			 this.closestTo = (dateToCompare, dates) => {
				return closestTo(dateToCompare, dates);
			 };
		  }
		  static {
			 this.isMoment = (d) => {
				return !!d.toDate;
			 };
		  }
		  static {
			 this.isDate = (d) => {
				return d instanceof Date || d instanceof _DateExtension;
			 };
		  }
		  static {
			 this.isValid = (d) => {
				return !!d && !!d.valueOf();
			 };
		  }
		  static {
			 this.utc = (date2) => {
				if (date2) {
				  return new _DateExtension(date2);
				}
				return new _DateExtension();
			 };
		  }
		  static locale(val) {
			 if (val && availableCultureMap.has(val)) {
				userCultureInfo.cultureOfUser = val;
				let dFnsOptions = {
				  locale: availableCultureMap.get(val)
				};
				setDefaultOptions2(dFnsOptions);
			 }
			 return userCultureInfo.cultureOfUser;
		  }
		  constructor(data = null, format2) {
			 if (typeof data === "string" && format2) {
				super(parse(data, format2, /* @__PURE__ */ new Date()));
			 } else if (data !== null) {
				let dataObj = data;
				if (data.toDate) {
				  dataObj = data.toDate();
				}
				super(dataObj);
			 } else {
				super();
			 }
		  }
		};
		function getTypeFromString(type2) {
		  let correctType = "";
		  switch (type2) {
			 case "year":
			 case "years":
			 case "y":
				correctType = "years";
				break;
			 case "month":
			 case "months":
				correctType = "months";
				break;
			 case "week":
			 case "weeks":
			 case "isoWeek":
			 case "w":
				correctType = "weeks";
				break;
			 case "day":
			 case "days":
			 case "d":
				correctType = "days";
				break;
			 case "hour":
			 case "hours":
			 case "h":
				correctType = "hours";
				break;
			 case "minute":
			 case "minutes":
			 case "m":
				correctType = "minutes";
				break;
			 case "second":
			 case "seconds":
			 case "s":
				correctType = "seconds";
				break;
			 case "millisecond":
			 case "milliseconds":
			 case "ms":
				correctType = "milliseconds";
				break;
			 default:
				console.warn("The unit is not recognized!");
				break;
		  }
		  return correctType;
		}
		var AggregationInterval = class {
		  constructor(startDate, endDate, capacity, currentAggregationData, getAggregationTrafficLightsFn) {
			 this.startDate = DateExtension.utc(startDate);
			 this.endDate = DateExtension.utc(endDate);
			 this.startDateInMs = this.startDate.toDate().getTime();
			 this.endDateInMs = this.endDate.toDate().getTime();
			 this.capacityLevels = {
				underload: {
				  value: currentAggregationData.aggregationTrafficLightsConfigValuesConfig.underload,
				  color: getAggregationTrafficLightsFn("underload")
				},
				goodload: {
				  value: currentAggregationData.aggregationTrafficLightsConfigValuesConfig.goodload,
				  color: getAggregationTrafficLightsFn("goodload")
				},
				maxload: {
				  value: currentAggregationData.aggregationTrafficLightsConfigValuesConfig.maxload,
				  color: getAggregationTrafficLightsFn("maxload")
				},
				overload: {
				  value: currentAggregationData.aggregationTrafficLightsConfigValuesConfig.overload,
				  color: getAggregationTrafficLightsFn("overload")
				}
			 };
			 this.capacity = capacity;
		  }
		};
		var Interval = class {
		  constructor(startDate, endDate) {
			 this.startDate = startDate.utc();
			 this.endDate = endDate.utc();
			 this.start = startDate.utc();
			 this.end = endDate.utc();
		  }
		};
		var _c0$h = ["scrollContent"];
		var PlanningBoardChartbaseComponent = class _PlanningBoardChartbaseComponent {
		  ngOnInit() {
			 if (!selection_default.prototype.parent) {
				selection_default.prototype.parent = function selectParent() {
				  return this.select(() => {
					 return this.parentNode;
				  });
				};
			 }
		  }
		  static {
			 this.chartbase = () => {
				const defaultrowheight = 25;
				const defaultrowheightprint = 15;
				let globalMainTickValues;
				let globalTickValues = [];
				const vector = {
				  length: function length(p1) {
					 return Math.sqrt(Math.pow(p1.x, 2) + Math.pow(p1.y, 2));
				  },
				  unitVector: function unitVector(p1) {
					 const l = vector.length(p1);
					 return {
						x: p1.x / l,
						y: p1.y / l
					 };
				  },
				  dotProduct: function dotProduct(p1, p2) {
					 const _p1 = vector.unitVector(p1);
					 const _p2 = vector.unitVector(p2);
					 return _p1.x * _p2.x + _p1.y * _p2.y;
				  },
				  add: function add2(p1, p2) {
					 return {
						x: p1.x + p2.x,
						y: p1.y + p2.y
					 };
				  },
				  sub: function sub(p1, p2) {
					 return {
						x: p2.x - p1.x,
						y: p2.y - p1.y
					 };
				  },
				  mul: function mul(p1, value) {
					 return {
						x: p1.x * value,
						y: p1.y * value
					 };
				  },
				  middlepoint: function middlepoint(p1, p2) {
					 if (p1.x === p2.x && p1.y === p2.y) {
						return p1;
					 }
					 const myvector = vector.sub(p1, p2);
					 const distance = vector.length(myvector);
					 const unitv = vector.unitVector(myvector);
					 return vector.add(vector.mul(unitv, distance / 2), p1);
				  },
				  slope: function calcSlope(start2, end, noDegrees) {
					 let m, alpha;
					 const deltaX = end.x - start2.x;
					 const deltaY = end.y - start2.y;
					 if (deltaX === 0) {
						return 0;
					 }
					 m = deltaY / deltaX;
					 if (noDegrees) {
						return m;
					 }
					 alpha = Math.atan(Math.abs(m)) * (180 / Math.PI);
					 return alpha;
				  },
				  base: function base(start2, end, m) {
					 m = m || vector.slope(start2, end, true);
					 const b = start2.y - m * start2.x;
					 return b;
				  }
				};
				function itemId(item) {
				  return item.Id || item.id;
				}
				function validDate(date2) {
				  return DateExtension.isDate(date2) || DateExtension.isMoment(date2);
				}
				function decimalToHex(decimal, chars) {
				  return "#" + (decimal + Math.pow(16, chars)).toString(16).slice(-chars).toUpperCase();
				}
				function configureWorkdays(weekenddays, exceptions, startDate, endDate) {
				  weekenddays = weekenddays || [6, 7];
				  exceptions = exceptions || [];
				  const numberOfWeekdays = 7 - weekenddays.length;
				  const numberOfWeekenddays = weekenddays.length;
				  const week = [1, 1, 1, 1, 1, 1, 1];
				  weekenddays.forEach(function(item) {
					 if (item === 7) {
						week[0] = 0;
					 } else {
						week[item] = 0;
					 }
				  });
				  if (numberOfWeekdays === 0) {
					 throw "need at least one workday per week";
				  }
				  function isDateOnWeekend(date2) {
					 for (let i = numberOfWeekenddays - 1; i >= 0; i--) {
						if (date2.getUTCDay() === weekenddays[i]) {
						  return true;
						}
					 }
					 return false;
				  }
				  const exceptionsWithoutWeekends = exceptions.filter(function(item) {
					 return !isDateOnWeekend(item);
				  });
				  const exceptionsWithinRange = exceptionsWithoutWeekends.filter(function(exceptionday) {
					 return exceptionday.isSame(endDate, "day") || exceptionday.isSame(startDate, "day") || exceptionday.isBetween(startDate, endDate, "day");
				  });
				  const hasExceptionDays = exceptionsWithinRange.length > 0;
				  let businessDays = {
					 add: function(date2, days) {
						throw new Error("Function not implemented.");
					 },
					 diff: function(mystartDate, myendDate, countStartDay) {
						throw new Error("Function not implemented.");
					 }
				  };
				  businessDays.add = (date2, days) => {
					 function addWorkdays(date3, days2) {
						const increment = days2 / Math.abs(days2);
						const internaldate = date3.clone().add(Math.floor(Math.abs(days2) / numberOfWeekdays) * 7 * increment, "days");
						let remaining = days2 % numberOfWeekdays;
						while (remaining !== 0) {
						  internaldate.add(increment, "days");
						  remaining -= isDateOnWeekend(internaldate) ? 0 : increment;
						}
						return internaldate;
					 }
					 const newDate2 = addWorkdays(date2, days);
					 if (hasExceptionDays) {
						return addWorkdays(newDate2, exceptionsWithinRange.length);
					 } else {
						return newDate2;
					 }
				  };
				  businessDays.diff = (mystartDate, myendDate, countStartDay) => {
					 let startDate2;
					 let direction = 1;
					 if (mystartDate.isBefore(myendDate, "day")) {
						startDate2 = mystartDate;
						endDate = myendDate;
					 } else {
						startDate2 = myendDate;
						endDate = mystartDate;
						direction = -1;
					 }
					 let startWeekday = startDate2.getUTCDay(), endOffset = endDate.getUTCDay() + 1, endSunday = new DateExtension(endDate.clone().startOf("week")).startOf("day"), startSunday = new DateExtension(startDate2.clone().endOf("week")).startOf("day"), weeks = endSunday.diff(startSunday, "weeks"), firstWeek, lastWeek3;
					 firstWeek = week.slice(startWeekday + 1).reduce((a, b) => a + b, 0);
					 lastWeek3 = week.slice(0, endOffset).reduce((a, b) => a + b, 0);
					 const exceptionsWithinRange2 = exceptionsWithoutWeekends.filter(function(exceptionday) {
						return exceptionday.isSame(endDate, "day") || exceptionday.isSame(startDate2, "day") || exceptionday.isBetween(startDate2, endDate, "day");
					 });
					 return (weeks * numberOfWeekdays + firstWeek + lastWeek3 + (countStartDay ? week[startWeekday] : 0) - exceptionsWithinRange2.length) * direction;
				  };
				  return businessDays;
				}
				function getZoomLevel(timeaxis) {
				  const ticks2 = timeaxis ? timeaxis.getTickValues() : globalTickValues;
				  const tickDiffSeconds = new DateExtension(ticks2[1]).diff(new DateExtension(ticks2[0]), "seconds");
				  let zoomLevel = "hour";
				  if (tickDiffSeconds < 86400) {
					 zoomLevel = "hour";
				  } else if (tickDiffSeconds >= 86400 && tickDiffSeconds < 604800) {
					 zoomLevel = "day";
				  } else if (tickDiffSeconds >= 604800) {
					 zoomLevel = "week";
				  } else if (tickDiffSeconds >= 2592e3) {
					 zoomLevel = "month";
				  } else if (tickDiffSeconds >= 31536e3) {
					 zoomLevel = "year";
				  }
				  return zoomLevel;
				}
				function calculateIntervals(tickValues, levelOfIntervals) {
				  let newInterval = null;
				  let intervals = [];
				  let spanAboveMin = true;
				  const defalutLevel = { value: 1, type: "hour" };
				  if (tickValues.length >= 2) {
					 let tempLevelOfIntervals = levelOfIntervals ? levelOfIntervals : defalutLevel;
					 if (tempLevelOfIntervals.type === "week") {
						tempLevelOfIntervals.type = "isoWeek";
					 }
					 let minDuration = new DateExtension.duration(tempLevelOfIntervals.value, tempLevelOfIntervals.type).asSeconds();
					 let tickSpan = new DateExtension(tickValues[1]).diff(tickValues[0], "seconds");
					 let firstTick = new DateExtension(tickValues[0]).subtract(tickSpan, "seconds").toDate();
					 tickValues.unshift(firstTick);
					 let lastTick = new DateExtension(tickValues[tickValues.length - 1]).add(tickSpan, "seconds").toDate();
					 tickValues.push(lastTick);
					 spanAboveMin = tickSpan - minDuration >= 0;
				  }
				  const hourUnit = "hour";
				  if (levelOfIntervals && levelOfIntervals.type !== hourUnit && !spanAboveMin) {
					 let actualMomentStart = null;
					 let actualMomentEnd = null;
					 let tempIntervalArray = [];
					 for (let tickValue of tickValues) {
						actualMomentStart = DateExtension.utc(tickValue).startOf(levelOfIntervals.type);
						actualMomentEnd = DateExtension.utc(tickValue).endOf(levelOfIntervals.type);
						if (!(0, import_lodash.find)(tempIntervalArray, actualMomentStart)) {
						  tempIntervalArray.push(actualMomentStart);
						  newInterval = new Interval(actualMomentStart, actualMomentEnd);
						  intervals.push(newInterval);
						}
					 }
				  } else {
					 for (let i = 0; i < tickValues.length - 1; i++) {
						if (!(0, import_lodash.find)(intervals, { startDate: tickValues[i], endDate: tickValues[i + 1] })) {
						  newInterval = new Interval(new DateExtension(tickValues[i]), new DateExtension(tickValues[i + 1]));
						  intervals.push(newInterval);
						}
					 }
				  }
				  return intervals;
				}
				const chartBaseComponent = {
				  configureWorkdays,
				  timescale: function timescale() {
					 return modifyTimescale(utcTime(), [2, 3, 4, 5, 6], true, [], true, DateExtension.utc(), DateExtension.utc().add(30, "d"), null);
					 function modifyTimescale(originalscale, workingDays, showWeekends, holidays, showHolidays, basedate, baseenddate, cache) {
						let ISOworkingdays, JSworkingdays, weekend = [];
						function setupWeek(workingDays2) {
						  const weekdaymap = [7, 1, 2, 3, 4, 5, 6];
						  ISOworkingdays = workingDays2.map(function(item) {
							 return weekdaymap[item] ? weekdaymap[item] : 0;
						  });
						  JSworkingdays = workingDays2.map(function(item) {
							 return item - 1;
						  });
						  weekend = [1, 2, 3, 4, 5, 6, 7].filter((day) => !ISOworkingdays.includes(day));
						}
						setupWeek(workingDays);
						let businessDays = configureWorkdays(showWeekends ? [] : weekend, showHolidays ? [] : holidays, basedate, baseenddate);
						function filterIsActive() {
						  return !showWeekends && workingDays.length < 7 || !showHolidays && holidays.length > 0;
						}
						function extendedscale(date2) {
						  function setResultScaleWithOriginal(originalscale2, startdate2) {
							 let tempresultScale = {};
							 Object.assign(resultScale, originalscale2);
							 originalscale2(startdate2);
							 resultScale(startdate2);
							 return tempresultScale;
						  }
						  let resultScale;
						  if ((0, import_lodash.isUndefined)(date2) || (0, import_lodash.isNull)(date2)) {
							 return 0;
						  }
						  if ((0, import_lodash.isNumber)(date2)) {
							 return date2;
						  }
						  if (!validDate(date2)) {
							 throw new Error("No valid date. Unparsed string?");
						  }
						  if (cache) {
							 resultScale = cache[date2.valueOf()];
							 if (resultScale) {
								return resultScale;
							 }
						  }
						  if (!filterIsActive()) {
							 resultScale = setResultScaleWithOriginal(originalscale, date2);
							 if (cache) {
								cache[date2.valueOf()] = resultScale;
							 }
							 return resultScale;
						  }
						  let startdate;
						  date2 = DateExtension.utc(date2);
						  startdate = new DateExtension(basedate);
						  const noOfWorkingDays = businessDays.diff(basedate, date2, false);
						  startdate.add(noOfWorkingDays, "d");
						  startdate.hours(date2.hours());
						  startdate.minutes(date2.minutes());
						  startdate.seconds(date2.seconds());
						  resultScale = setResultScaleWithOriginal(originalscale, startdate);
						  if (cache) {
							 cache[date2.valueOf()] = resultScale;
						  }
						  resultScale.extendeddomain = function(x) {
							 if (!arguments.length) {
								const range = originalscale.range();
								return [
								  resultScale.extendedinvert(range[0]),
								  resultScale.extendedinvert(range[1])
								];
							 }
							 if (x) {
								originalscale.domain(x);
							 }
							 return resultScale;
						  };
						  resultScale.extendedinvert = function extendedinvert(x) {
							 const originaldate = DateExtension.utc(originalscale.invert(x.startOffset));
							 if (!filterIsActive()) {
								return originaldate;
							 }
							 const startdate2 = DateExtension.utc(originalscale.domain()[0]);
							 const x2 = resultScale(originaldate);
							 const differenceinpixels = x.startOffset - x2;
							 const differenceindays = DateExtension.utc(originalscale.invert(differenceinpixels)).diff(startdate2, "d");
							 return businessDays.add(originaldate, differenceindays);
						  };
						  resultScale.ticks = function() {
							 if (arguments[0] === 0) {
								return [];
							 }
							 let result;
							 const start2 = resultScale.extendedinvert(resultScale.getRange()[0]).add(-3, "month");
							 const stop = resultScale.extendedinvert(resultScale.getRange()[1]).add(1, "day");
							 let step = arguments[1] || 1;
							 const name = arguments[2];
							 const originalstep = step;
							 if (originalstep === 2 || originalstep === 5 || originalstep === 6) {
								step = 1;
							 }
							 switch (name) {
								case "sunday":
								  result = utcSundays(start2, stop, step);
								  break;
								case "monday":
								  result = utcMondays(start2, stop, step);
								  break;
								case "tuesday":
								  result = utcTuesdays(start2, stop, step);
								  break;
								case "wednesday":
								  result = utcWednesdays(start2, stop, step);
								  break;
								case "thursday":
								  result = utcThursdays(start2, stop, step);
								  break;
								case "friday":
								  result = utcFridays(start2, stop, step);
								  break;
								case "saturday":
								  result = utcSaturdays(start2, stop, step);
								  break;
								case "hour":
								  result = utcHours(start2, stop, step);
								  break;
								case "day":
								  result = utcDays(start2, stop, step);
								  break;
								case "week":
								  result = utcSundays(start2, stop, step);
								  break;
								case "month":
								  result = utcMonths(start2, stop, step);
								  break;
								case "year":
								  result = utcYears(start2, stop, step);
								  break;
								default:
								  result = utcYears(start2, stop, 5);
							 }
							 if (originalstep === 6) {
								result = result.filter(function(item) {
								  return item.getMonth() === 0 || item.getMonth() === 6;
								});
							 }
							 if (!showWeekends && name === "day") {
								result = result.filter(function(item) {
								  return JSworkingdays.find(function(subitem) {
									 return subitem === item.getDay();
								  });
								});
							 }
							 if (!showHolidays && name === "day") {
								result = result.filter((item) => {
								  return !holidays.find((subitem) => {
									 return subitem.isSame(new DateExtension(item), "day");
								  });
								});
							 }
							 return result;
						  };
						  resultScale.modifiedCopy = function() {
							 return modifyTimescale(originalscale.copy(), workingDays, showWeekends, holidays, showHolidays, basedate, baseenddate, cache);
						  };
						  resultScale.invert = (args) => {
							 return originalscale.invert.call(originalscale, args);
						  };
						  resultScale.domain = (args) => {
							 return originalscale.domain.apply(originalscale, [args]);
						  };
						  resultScale.setWorkingDays = (x) => {
							 if (!(0, import_lodash.isEqual)(workingDays, x)) {
								workingDays = x;
								setupWeek(workingDays);
								businessDays = configureWorkdays(showWeekends ? [] : weekend, showHolidays ? [] : holidays, basedate, baseenddate);
							 }
							 return resultScale;
						  };
						  resultScale.setShowWeekends = (x) => {
							 if (!(0, import_lodash.isEqual)(showWeekends, x)) {
								showWeekends = x;
								businessDays = configureWorkdays(showWeekends ? [] : weekend, showHolidays ? [] : holidays, basedate, baseenddate);
							 }
							 return resultScale;
						  };
						  resultScale.setHolidays = (x) => {
							 if (!(0, import_lodash.isEqual)(holidays, x)) {
								holidays = x;
								businessDays = configureWorkdays(showWeekends ? [] : weekend, showHolidays ? [] : holidays, basedate, baseenddate);
							 }
							 return resultScale;
						  };
						  resultScale.setShowHolidays = (x) => {
							 if (!(0, import_lodash.isEqual)(showHolidays, x)) {
								showHolidays = x;
								businessDays = configureWorkdays(showWeekends ? [] : weekend, showHolidays ? [] : holidays, basedate, baseenddate);
							 }
							 return resultScale;
						  };
						  resultScale.setStartDate = (x) => {
							 basedate = new DateExtension(DateExtension.utc(x));
							 businessDays = configureWorkdays(showWeekends ? [] : weekend, showHolidays ? [] : holidays, basedate, baseenddate);
							 return resultScale;
						  };
						  resultScale.setEndDate = (x) => {
							 baseenddate = new DateExtension(DateExtension.utc(x));
							 businessDays = configureWorkdays(showWeekends ? [] : weekend, showHolidays ? [] : holidays, basedate, baseenddate);
							 return resultScale;
						  };
						  resultScale.setCache = (x) => {
							 cache = x;
							 return resultScale;
						  };
						  resultScale.setRange = (args) => {
							 originalscale.range.apply(originalscale, [args]);
							 return resultScale;
						  };
						  resultScale.getWorkingDays = () => {
							 return workingDays;
						  };
						  resultScale.getShowWeekends = () => {
							 return showWeekends;
						  };
						  resultScale.getHolidays = () => {
							 return holidays;
						  };
						  resultScale.getShowHolidays = () => {
							 return showHolidays;
						  };
						  resultScale.getStartDate = () => {
							 return basedate;
						  };
						  resultScale.getEndDate = () => {
							 return baseenddate;
						  };
						  resultScale.getCache = () => {
							 return cache;
						  };
						  resultScale.getRange = () => {
							 return originalscale.range();
						  };
						  return resultScale;
						}
						return extendedscale;
					 }
				  },
				  timeaxis: function timeaxis() {
					 let scale = utcTime(), axisheight = 20, orientation = "top", tickvalues = [], tickvaluesDateExtenstion = [], maintickvalues = [], maintickvaluesDateExtenstion = [], translations2 = {
						weekAbbreviation: "W",
						weekNumberFormat: "w"
					 };
					 function formatDate2(raw) {
						if (typeof raw === "string") {
						  let myfunction = function(dateToFormat) {
							 const mymoment = DateExtension.utc(dateToFormat);
							 return mymoment.format(raw);
						  };
						  return myfunction;
						} else {
						  return raw;
						}
					 }
					 const timeaxis_ = function(selection2) {
						let time1 = selection2.select("g.time1");
						if (time1.empty()) {
						  time1 = selection2.append("g").classed("time1", true);
						}
						let time2 = selection2.select("g.time2");
						if (time2.empty()) {
						  time2 = selection2.append("g").classed("time2", true);
						}
						let time3 = selection2.select("g.time3");
						if (time3.empty()) {
						  time3 = selection2.append("g").classed("time3", true);
						}
						let t = scaleTime();
						const currentwidth = scale.range()[1];
						const tickvalues3 = currentwidth <= 490 ? [] : tickValues(t.ticks[2]);
						tickvalues = tickvalues3;
						tickvaluesDateExtenstion = tickvalues.map((date2) => new DateExtension(date2));
						maintickvalues = tickValues(t.ticks[1]);
						maintickvaluesDateExtenstion = maintickvalues.map((date2) => new DateExtension(date2));
						let currenttext = "";
						currenttext = function getcurrenttext() {
						  const formatter = t.format[0];
						  if ((0, import_lodash.isString)(formatter)) {
							 currenttext = DateExtension.utc(scale.domain()[0]).format(formatter);
						  }
						  if ((0, import_lodash.isFunction)(formatter)) {
							 currenttext = formatter(DateExtension.utc(scale.domain()[0]));
						  }
						  return currenttext;
						}();
						let currenttextlength = currenttext.length * 5 + 2;
						time1.attr("transform", "translate(0,2)");
						time2.attr("transform", "translate(0," + axisheight + ")");
						time3.attr("transform", "translate(0," + 2 * axisheight + ")");
						let timeaxis1 = axisBottom(scale).scale(scale).tickValues(tickValues(t.ticks[0]).filter((tick) => scale(tick) > currenttextlength)).tickFormat(formatDate2(t.format[0]));
						let timeaxis2 = axisBottom(scale).scale(scale).tickValues(tickValues(t.ticks[1])).tickFormat(formatDate2(t.format[1]));
						let timeaxis3 = axisBottom(scale).scale(scale).tickValues(tickvalues3).tickFormat(formatDate2(t.format[2]));
						if (orientation === "bottom") {
						  time3.attr("transform", "translate(0,2)");
						  time2.attr("transform", "translate(0," + axisheight + ")");
						  time1.attr("transform", "translate(0," + 2 * axisheight + ")");
						  timeaxis1 = axisBottom(scale).scale(scale).tickValues(tickValues(t.ticks[0]).filter((tick) => scale(tick) > currenttextlength)).tickFormat(formatDate2(t.format[0]));
						  timeaxis2 = axisBottom(scale).scale(scale).tickValues(tickValues(t.ticks[1])).tickFormat(formatDate2(t.format[1]));
						  timeaxis3 = axisBottom(scale).scale(scale).tickValues(tickvalues3).tickFormat(formatDate2(t.format[2]));
						}
						time1.call(timeaxis1);
						const extralabel = selection2.select("g.extralabel");
						if (extralabel.empty()) {
						  let mySel = selection2.append("g").classed("extralabel", true);
						  mySel.attr("transform", "translate(0,8)").append("rect").attr("width", 100).attr("height", 12).attr("fill", "white");
						  mySel.parent().append("text").attr("transform", "translate(0,10)").style("font-size", "10px").style("font-family", "sans-serif");
						}
						extralabel.select("text").text(currenttext);
						extralabel.select("rect").attr("width", currenttextlength);
						time2.call(timeaxis2);
						time3.call(timeaxis3);
						selection2.selectAll("text").style("text-anchor", "start");
					 };
					 timeaxis_.setScale = (newscale) => {
						scale = newscale;
						return timeaxis_;
					 };
					 timeaxis_.getScale = () => {
						return scale;
					 };
					 timeaxis_.setOrientation = (x) => {
						orientation = x;
						return timeaxis_;
					 };
					 timeaxis_.getOrientation = () => {
						return orientation;
					 };
					 timeaxis_.getTickValues = () => {
						return tickvaluesDateExtenstion;
					 };
					 timeaxis_.getMainTickValues = () => {
						return maintickvaluesDateExtenstion;
					 };
					 timeaxis_.setTranslations = (x) => {
						translations2 = x;
						return timeaxis_;
					 };
					 timeaxis_.getTranslations = () => {
						return translations2;
					 };
					 return timeaxis_;
					 function scaleTime() {
						const currentwidth = scale.range()[1];
						const rangeDiffInSec = (scale.domain()[1].getTime() - scale.domain()[0].getTime()) / 1e3;
						const currentrange = new DateExtensionDuration(rangeDiffInSec, "s");
						let ticks2 = [{
						  t: 0
						}, {
						  t: 0
						}, {
						  t: 0
						}];
						let format2 = ["", "", ""];
						const displaymonths = currentwidth < 900 ? "MMM yyyy" : "MMMM yyyy";
						const weekspan = currentwidth < 700 ? 2 : 1;
						const weekTranslation = `'${translations2.weekAbbreviation}' ${translations2.weekNumberFormat}`;
						switch (true) {
						  case currentrange.asHours() <= 12:
							 ticks2 = [{
								t: utcMonth,
								n: "month"
							 }, {
								t: utcDay,
								n: "day",
								s: weekspan
							 }, {
								t: utcHour,
								n: "hour"
							 }];
							 format2 = [displaymonths, "EEEE d", "H"];
							 break;
						  case currentrange.asHours() <= 17.5:
							 ticks2 = [{
								t: utcDay,
								n: "day"
							 }, {
								t: utcHour,
								n: "hour"
							 }, {
								t: 25
							 }];
							 format2 = ["EEEE d", "H", "mm"];
							 break;
						  case currentrange.asDays() <= 7:
							 ticks2 = [{
								t: utcMonday,
								n: "monday",
								s: weekspan
							 }, {
								t: utcDay,
								n: "day"
							 }, {
								t: 30
							 }];
							 format2 = [weekTranslation + " MMMM yyyy", "EEEE d", "H"];
							 break;
						  case currentrange.asMonths() <= 1:
							 ticks2 = [{
								t: utcMonth,
								n: "month"
							 }, {
								t: utcMonday,
								n: "monday",
								s: weekspan
							 }, {
								t: utcDay,
								n: "day",
								s: weekspan
							 }];
							 format2 = [displaymonths, weekTranslation, "dd EEEEEE"];
							 break;
						  case currentrange.asMonths() <= 1.8:
							 ticks2 = [{
								t: utcMonth,
								n: "month"
							 }, {
								t: utcMonday,
								n: "monday",
								s: weekspan
							 }, {
								t: utcDay,
								n: "day",
								s: weekspan
							 }];
							 format2 = [displaymonths, weekTranslation, "EEEEEE"];
							 break;
						  case currentrange.asMonths() <= 6.6:
							 ticks2 = [{
								t: utcYear,
								n: "year"
							 }, {
								t: utcMonth,
								n: "month"
							 }, {
								t: utcMonday,
								n: "monday",
								s: weekspan
							 }];
							 format2 = ["yyyy", displaymonths, weekTranslation];
							 break;
						  case currentrange.asMonths() <= 9.5:
							 ticks2 = [{
								t: utcYear,
								n: "year"
							 }, {
								t: utcMonth,
								n: "month"
							 }, {
								t: utcMonday,
								n: "monday",
								s: 2
							 }];
							 format2 = ["yyyy", displaymonths, translations2.weekNumberFormat];
							 break;
						  case currentrange.asYears() <= 1:
							 ticks2 = [{
								t: utcYear,
								n: "year"
							 }, {
								t: utcMonth,
								s: 6,
								n: "month"
							 }, {
								t: utcMonth,
								n: "month"
							 }];
							 format2 = ["yyyy", halfYear(), displaymonths];
							 break;
						  case currentrange.asYears() <= 5:
							 ticks2 = [{
								t: utcYear,
								s: 5,
								n: "year"
							 }, {
								t: utcYear,
								n: "year"
							 }, {
								t: utcMonth,
								s: 6,
								n: "month"
							 }];
							 format2[0] = formattimespan;
							 format2[1] = "yyyy";
							 format2[2] = halfYear();
							 break;
						  default:
							 ticks2 = [{
								t: utcYear,
								s: 5
							 }, {
								t: 0
							 }, {
								t: 0
							 }];
							 format2 = [formattimespan, "", ""];
						}
						return {
						  ticks: ticks2,
						  format: format2
						};
						function formattimespan(d) {
						  let seconddate;
						  let mysuperstep;
						  const localdate = new Date(d);
						  if (ticks2[0].s && currentrange.asYears() > 1 && localdate.getFullYear() % ticks2[0].s !== 0) {
							 mysuperstep = Math.floor(localdate.getFullYear() / ticks2[0].s) * ticks2[0].s;
							 localdate.setFullYear(mysuperstep);
						  }
						  seconddate = new Date(localdate);
						  seconddate.setFullYear(localdate.getFullYear() + (ticks2[0] && ticks2[0].s ? ticks2[0].s : 0));
						  return localdate.getFullYear() + "-" + seconddate.getFullYear();
						}
						function halfYear() {
						  return function(d) {
							 const subyear = d.getFullYear();
							 let result;
							 if (d.getMonth() < 6) {
								result = "I/" + subyear;
							 } else {
								result = "II/" + subyear;
							 }
							 return result;
						  };
						}
					 }
					 function tickValues(tt) {
						return scale.ticks(tt.t);
					 }
				  },
				  // handles are drawn above activity arrows. it's data source
				  // is the selecteditem in union with the currently displayed activities. dragging results in triggering the async validation service. resulting new data is displayed via the normal update mechanism
				  /* screen only */
				  handles: function handles() {
					 let getY = /* @__PURE__ */ new Map(), middleadjust = [0, 1], offset = 0, onMovedMax, onMovedMed, onMovedMilestone, onMovedMin, onMoving, moveCanvas, originalscale = utcTime(), radius = 5, selectedIds = [-1], zoom$1 = zoom_default2(), scale = utcTime(), timer$1 = timer(import_lodash.noop), lobMode = false, moveMode = "day";
					 let dragStartBarValues = {
						barStart: new DateExtension(),
						barEnd: new DateExtension()
					 }, oldXMoment = new DateExtension(), rootElement;
					 function start2(e, d) {
						oldXMoment = new DateExtension();
						adjustCircleObj.movedUnits = 0;
						if (!(0, import_lodash.isUndefined)(d)) {
						  dragStartBarValues = {
							 barStart: new DateExtension(d.barStart),
							 barEnd: new DateExtension(d.barEnd)
						  };
						}
						e.stopPropagation();
					 }
					 function findMiddle(d) {
						let yStart, yEnd;
						let adjustwidth = middleadjust[1] - middleadjust[0];
						adjustwidth = adjustwidth ? adjustwidth : 1;
						const cachedY = getY.get(d.id) || 0;
						const adjust = cachedY + (adjustwidth * 0.5 + middleadjust[0]) * defaultrowheight;
						yStart = adjust;
						yEnd = adjust;
						const plannedStart = d._tempBarStart || scale(d.barStart);
						const plannedFinish = d._tempBarEnd || scale(d.barEnd);
						const start3 = {
						  x: plannedStart,
						  y: yStart
						};
						const end = {
						  x: plannedFinish,
						  y: yEnd
						};
						const middle = vector.middlepoint(start3, end);
						return {
						  plannedStart,
						  plannedFinish,
						  yStart,
						  yEnd,
						  middle
						};
					 }
					 const adjustCircleObj = {
						zoomLevel: "day",
						zoomLevelSeconds: 86400,
						movedUnits: 0,
						move: function move(element, movedX, circle, zl) {
						  if (zl === "auto" || (0, import_lodash.isUndefined)(zl)) {
							 this.zoomLevel = getZoomLevel();
						  } else {
							 this.zoomLevel = zl;
						  }
						  let movedXMoment = new DateExtension();
						  switch (this.zoomLevel) {
							 case "hour":
								movedXMoment = new DateExtension(scale.invert(movedX)).utc().set({
								  minute: 0,
								  second: 0
								});
								this.zoomLevelSeconds = 3600;
								break;
							 case "day":
								movedXMoment = new DateExtension(scale.invert(movedX)).utc().set({
								  hour: 0,
								  minute: 0,
								  second: 0
								});
								this.zoomLevelSeconds = 86400;
								break;
							 case "week":
								movedXMoment = new DateExtension(scale.invert(movedX)).utc().set({
								  hour: 0,
								  minute: 0,
								  second: 0
								});
								break;
							 default:
								console.warn("No definitions for [" + this.zoomLevel + "] this zoom level.");
								break;
						  }
						  if ((0, import_lodash.isUndefined)(oldXMoment) || !(0, import_lodash.isUndefined)(oldXMoment) && !movedXMoment.isSame(oldXMoment, this.zoomLevel)) {
							 if ((0, import_lodash.isUndefined)(oldXMoment)) {
								oldXMoment = new DateExtension(movedXMoment);
							 }
							 const movedDiff = movedXMoment.diff(oldXMoment, "seconds");
							 oldXMoment = new DateExtension(movedXMoment);
							 if (movedDiff > 0) {
								if (this.zoomLevel === "week") {
								  this.movedUnits++;
								} else {
								  this.movedUnits += Math.ceil(movedDiff / this.zoomLevelSeconds);
								}
							 } else {
								if (this.zoomLevel === "week") {
								  this.movedUnits--;
								} else {
								  this.movedUnits += Math.floor(movedDiff / this.zoomLevelSeconds);
								}
							 }
							 switch (this.zoomLevel) {
								case "hour":
								  if (circle === "max") {
									 movedXMoment.set({
										minutes: +dragStartBarValues.barEnd.format("mm"),
										seconds: +dragStartBarValues.barEnd.format("ss")
									 });
								  } else if (circle === "min") {
									 movedXMoment.set({
										minutes: +dragStartBarValues.barStart.format("mm"),
										seconds: +dragStartBarValues.barStart.format("ss")
									 });
								  }
								  break;
								case "day":
								  this.setStartBarValues(movedXMoment, circle);
								  break;
								case "week":
								  this.setStartBarValues(movedXMoment, circle);
								  movedXMoment.days(dragStartBarValues.barStart.days());
								  break;
							 }
							 this.setBarDates(element, movedXMoment, movedDiff, circle);
							 element.circle = circle;
							 onMoving(element);
						  }
						},
						setBarDates: function setBarDates(element, movedXMoment, movedDiff, circle) {
						  switch (circle) {
							 case "min":
								element.BarStart = new DateExtension(movedXMoment);
								element.BarEnd = new DateExtension(element.barEnd);
								break;
							 case "max":
								element.BarStart = new DateExtension(element.barStart);
								element.BarEnd = new DateExtension(movedXMoment);
								break;
							 case "mid":
								element.BarStart = new DateExtension(dragStartBarValues.barStart).add(this.movedUnits, this.zoomLevel);
								element.BarEnd = new DateExtension(dragStartBarValues.barEnd).add(this.movedUnits, this.zoomLevel);
								break;
						  }
						},
						setStartBarValues: function setStartBarValues(movedXMoment, circle) {
						  if (circle === "max") {
							 movedXMoment.set({
								hour: +dragStartBarValues.barEnd.format("HH"),
								minutes: +dragStartBarValues.barEnd.format("mm"),
								seconds: +dragStartBarValues.barEnd.format("ss")
							 });
						  } else if (circle === "min") {
							 movedXMoment.set({
								hour: +dragStartBarValues.barStart.format("HH"),
								minutes: +dragStartBarValues.barStart.format("mm"),
								seconds: +dragStartBarValues.barStart.format("ss")
							 });
						  }
						}
					 };
					 const dragMin = drag_default().on("start", function(e, d) {
						start2(e, d);
					 }).on("end", function(d) {
						timer$1.stop();
						d.BarStart = scale.invert(d._tempBarStart);
						d._tempBarStart = null;
						onMovedMin(d);
					 }).on("drag", function(event, d) {
						let movedX = event.x;
						const stop = d._tempBarEnd || scale(d.barEnd);
						if (movedX < scale.range()[0] + radius) {
						  timer$1.restart(autoScrollLeft, 500, 1e3);
						} else if (movedX > scale.range()[1] - radius) {
						  timer$1.restart(autoScrollRight, 500, 1e3);
						} else {
						  timer$1.stop();
						}
						movedX = movedX > stop ? stop : movedX;
						movedX = movedX < scale.range()[0] + radius ? scale.range()[0] + radius : movedX;
						if (event.movementX !== 0) {
						  adjustCircleObj.move(d, movedX, "min", moveMode);
						}
						function autoScrollLeft() {
						  return autoScroll(false, d);
						}
						function autoScrollRight() {
						  return autoScroll(true, d);
						}
					 });
					 const dragMax = drag_default().on("start", function(e, d) {
						start2(e, d);
					 }).on("end", function(d) {
						timer$1.stop();
						d.BarEnd = scale.invert(d._tempBarEnd);
						d._tempBarEnd = null;
						onMovedMax(d);
					 }).on("drag", function(event, d) {
						let movedX = event.x;
						const stop = d._tempBarStart || scale(d.barStart);
						if (movedX > scale.range()[1] - radius) {
						  timer$1.restart(autoScrollRight, 500, 1e3);
						} else if (movedX < scale.range()[0] + radius) {
						  timer$1.restart(autoScrollLeft, 500, 1e3);
						} else {
						  timer$1.stop();
						}
						movedX = movedX < stop ? stop : movedX;
						movedX = movedX > scale.range()[1] + radius ? scale.range()[1] + radius : movedX;
						if (event.movementX !== 0) {
						  adjustCircleObj.move(d, movedX, "max", moveMode);
						}
						function autoScrollLeft() {
						  return autoScroll(false, d);
						}
						function autoScrollRight() {
						  return autoScroll(true, d);
						}
					 });
					 const dragMed = drag_default().on("start", function(event, d) {
						start2(event, d);
					 }).on("end", function(d) {
						timer$1.stop();
						d.BarStart = scale.invert(d._tempBarStart);
						d.BarEnd = scale.invert(d._tempBarEnd);
						d._tempBarStart = null;
						d._tempBarEnd = null;
						onMovedMed(d);
					 }).on("drag", function(event, d) {
						let movedX = event.x;
						if (movedX > scale.range()[1] - radius) {
						  timer$1.restart(autoScrollRight, 500, 1e3);
						} else if (movedX < scale.range()[0]) {
						  timer$1.restart(autoScrollLeft, 500, 1e3);
						} else {
						  timer$1.stop();
						}
						movedX = movedX < scale.range()[0] + radius ? scale.range()[0] + radius : movedX;
						movedX = movedX > scale.range()[1] - radius ? scale.range()[1] - radius : movedX;
						if (event.dx !== 0) {
						  adjustCircleObj.move(d, movedX, "mid", moveMode);
						}
						function autoScrollLeft() {
						  return autoScroll2(false);
						}
						function autoScrollRight() {
						  return autoScroll2(true);
						}
						function autoScroll2(direction) {
						  let transform2 = transform(rootElement.node());
						  const difference2 = direction ? -5 : 5;
						  transform2.applyX(transform2.x + difference2);
						  const time1 = new DateExtension(scale.invert(0));
						  const time2 = new DateExtension(scale.invert(difference2));
						  const timediff = time1.diff(time2);
						  d.barStart.add(timediff, "ms");
						  d.barEnd.add(timediff, "ms");
						  onMoving(d);
						  moveCanvas(transform2);
						}
					 });
					 function autoScroll(direction, d) {
						const transform2 = transform(rootElement.node());
						const difference2 = direction ? -5 : 5;
						transform2.applyX(transform2.x + difference2);
						const time1 = new DateExtension(scale.invert(0));
						const time2 = new DateExtension(scale.invert(difference2));
						const timediff = time1.diff(time2);
						if (direction) {
						  d.BarEnd = d.BarEnd.add(timediff, "ms");
						} else {
						  d.BarStart = d.BarStart.add(timediff, "ms");
						}
						onMoving(d);
						moveCanvas(transform2);
					 }
					 const handles_ = function(selection2) {
						if (!selection2.datum) {
						  return;
						}
						const data = selection2.datum()[0];
						const handlegroup = selection2.selectAll("g.handle").data(data.filter(function(item) {
						  return !item._relationshipmode && item.isSelectable && (0, import_lodash.find)(selectedIds, function(what) {
							 return what === item.id;
						  });
						}), itemId);
						handlegroup.exit().remove();
						const newhandlegroup = handlegroup.enter().append("g").classed("handle", true);
						newhandlegroup.append("circle").classed("min", true).attr("r", radius).call(dragMin).parent().append("circle").classed("max", true).attr("r", radius).call(dragMax).parent().append("circle").classed("med", true).attr("r", radius * 1.5).call(dragMed);
						const allhandlegroup = newhandlegroup.merge(handlegroup);
						allhandlegroup.each(function(d) {
						  const g = select_default2(allhandlegroup.data([d]).node());
						  const __ret = findMiddle(d);
						  const plannedStart = __ret.plannedStart;
						  const plannedFinish = __ret.plannedFinish;
						  const yStart = __ret.yStart;
						  const yEnd = __ret.yEnd;
						  const middle = __ret.middle;
						  g.select("circle.min").attr("cx", plannedStart).attr("cy", yStart);
						  g.select("circle.med").attr("cx", middle.x).attr("cy", middle.y);
						  g.select("circle.max").attr("cx", plannedFinish).attr("cy", yEnd);
						});
						return;
					 };
					 handles_.setScale = (x) => {
						scale = x;
						return handles_;
					 };
					 handles_.setOriginalscale = (x) => {
						originalscale = x;
						return handles_;
					 };
					 handles_.setVerticalIndex = (x) => {
						getY = x;
						return handles_;
					 };
					 handles_.setSelectedIds = (x) => {
						selectedIds = x;
						return handles_;
					 };
					 handles_.setLobMode = (newLobMode) => {
						lobMode = newLobMode;
						return handles_;
					 };
					 handles_.setRadius = (newradius) => {
						radius = newradius;
						return handles_;
					 };
					 handles_.setOnMoving = (newOnMoving) => {
						onMoving = newOnMoving;
						return handles_;
					 };
					 handles_.setMoveCanvas = (x) => {
						moveCanvas = x;
						return handles_;
					 };
					 handles_.setOnMovedMin = (newOnMovedMin) => {
						onMovedMin = newOnMovedMin;
						return handles_;
					 };
					 handles_.setOnMovedMed = (newOnMovedMed) => {
						onMovedMed = newOnMovedMed;
						return handles_;
					 };
					 handles_.setOnMovedMax = (newOnMovedMax) => {
						onMovedMax = newOnMovedMax;
						return handles_;
					 };
					 handles_.setOnMovedMilestone = (x) => {
						onMovedMilestone = x;
						return handles_;
					 };
					 handles_.setZoom = (x) => {
						zoom$1 = x;
						return handles_;
					 };
					 handles_.setMiddle = (x) => {
						middleadjust = x;
						return handles_;
					 };
					 handles_.setOffset = (newOffset) => {
						offset = newOffset;
						return handles_;
					 };
					 handles_.setRootElement = (x) => {
						rootElement = x;
						return handles_;
					 };
					 handles_.setMoveMode = (mode) => {
						moveMode = mode;
						return handles_;
					 };
					 handles_.getScale = () => {
						return scale;
					 };
					 handles_.getOriginalscale = () => {
						return originalscale;
					 };
					 handles_.getVerticalIndex = () => {
						return getY;
					 };
					 handles_.getSelectedIds = () => {
						return selectedIds;
					 };
					 handles_.getLobMode = () => {
						return lobMode;
					 };
					 handles_.getRadius = () => {
						return radius;
					 };
					 handles_.getOnMoving = () => {
						return onMoving;
					 };
					 handles_.getMoveCanvas = () => {
						return moveCanvas;
					 };
					 handles_.getOnMovedMin = () => {
						return onMovedMin;
					 };
					 handles_.getOnMovedMed = () => {
						return onMovedMed;
					 };
					 handles_.getOnMovedMax = () => {
						return onMovedMax;
					 };
					 handles_.getOnMovedMilestone = () => {
						return onMovedMilestone;
					 };
					 handles_.getZoom = () => {
						return zoom$1;
					 };
					 handles_.getMiddle = () => {
						return middleadjust;
					 };
					 handles_.getOffset = () => {
						return offset;
					 };
					 handles_.getRootElement = () => {
						return rootElement;
					 };
					 handles_.getMoveMode = () => {
						return moveMode;
					 };
					 return handles_;
				  },
				  locks: function locks() {
					 let scalex = utcTime(), verticalIndex = /* @__PURE__ */ new Map();
					 function attachIcons(selection2) {
						let defblock = selection2.select("defs");
						if (defblock.empty()) {
						  defblock = selection2.append("defs");
						}
						const locksymbol = selection2.select("defs symbol#locks");
						if (locksymbol.empty()) {
						  defblock.append("symbol").attr("id", "locks").append("g").append("path").attr("d", "M1.5,5l0,-1c0,-2.208 1.792,-4 4,-4c2.208,0 4,1.792 4,4l0,1l0.5,0l0,6l-9,0l0,-6l0.5,0Zm4,1.5c0.552,0 1,0.56 1,1.25c0,0.69 -0.448,1.25 -1,1.25c-0.552,0 -1,-0.56 -1,-1.25c0,-0.69 0.448,-1.25 1,-1.25Zm-2.5,-1.5l5,0l0,-1c0,-1.38 -1.12,-2.5 -2.5,-2.5c-1.38,0 -2.5,1.12 -2.5,2.5l0,1Z");
						}
					 }
					 function getStart(d) {
						return d._tempBarStart - 20 || scalex(d.barStart) - 20;
					 }
					 const locks_ = function(selection2) {
						attachIcons(selection2);
						if (!selection2.datum) {
						  return;
						}
						const groups = selection2.selectAll("g.locks").data(selection2.datum().filter(function(item, i) {
						  return i === 0;
						}));
						groups.exit().remove();
						const newgroups = groups.enter().append("g").classed("locks", true);
						const allgroups = newgroups.merge(groups);
						const locks2 = allgroups.selectAll("use.lock").data(function(subarray) {
						  return subarray.filter(function(item) {
							 return item.isLocked && verticalIndex.has(item.id);
						  });
						}, itemId);
						locks2.exit().remove();
						const newlocks = locks2.enter().append("use").classed("lock", true).attr("xlink:href", "#locks");
						const alllocks = newlocks.merge(locks2);
						alllocks.attr("x", getStart).attr("y", function(d) {
						  return verticalIndex.get(d.id) || 0 + 4.5;
						});
					 };
					 locks_.setScaleX = (x) => {
						scalex = x;
						return locks_;
					 };
					 locks_.setVerticalIndex = (x) => {
						verticalIndex = x;
						return locks_;
					 };
					 locks_.getScaleX = () => {
						return scalex;
					 };
					 locks_.getVerticalIndex = () => {
						return verticalIndex;
					 };
					 return locks_;
				  },
				  calendarlines: function calendarlines() {
					 let scale = utcTime(), height = 500, offset = 0, defaultopt = [new DateExtension().utc(), true, true], globaltickvalues = [], maintickvalues = [], linedata = [], verticalIndex = /* @__PURE__ */ new Map(), showVerticalLines, showHorizontalLines, printadjustment = 0;
					 function makeLineData() {
						linedata.length = 0;
						linedata.push(0);
						let outervalue = 0;
						verticalIndex.forEach(function(value) {
						  outervalue += defaultrowheight;
						  linedata.push(outervalue);
						});
					 }
					 const _calendarlines = (selection2) => {
						if (!selection2.datum) {
						  return;
						}
						let todayline;
						const opt = selection2.datum() || defaultopt;
						const tickvalues1 = opt[1] ? scale.ticks(utcMonday) : [];
						const tickvalues2 = opt[2] ? scale.ticks(utcMonth) : [];
						const tickvalues = tickvalues1.concat(tickvalues2);
						if (tickvalues.length > 1400) {
						  tickvalues.length = 0;
						  const tickWide = selection2.select("g.tick-wide");
						  if (tickWide.empty()) {
							 selection2.append("g").classed("tick-wide", true).attr("transform", "translate(0,0) scale (" + scale.range()[1] * 2 + ", 1)").append("line").attrs({
								x1: 0,
								x2: 0,
								y1: 0,
								y2: height
							 });
						  }
						} else {
						  selection2.select("g.tick-wide").remove();
						}
						const timeaxis = axisBottom(scale).scale(scale).tickSize(height).tickValues(tickvalues).tickFormat((domainValue, index) => {
						  return new DateExtension(domainValue).format("EEEEEE d");
						});
						selection2.call(timeaxis);
						let horizontallines = selection2.selectAll("line.horizontal").data(showHorizontalLines ? linedata : []);
						horizontallines.exit().remove();
						const newhorizontallines = horizontallines.enter().append("line").classed("horizontal", true);
						const combinedhorizontallines = newhorizontallines.merge(horizontallines);
						combinedhorizontallines.attrs({
						  y1: function(item) {
							 return item;
						  },
						  y2: function(item) {
							 return item;
						  },
						  x1: scale.range()[0],
						  x2: scale.range()[1]
						});
						todayline = selection2.select("line.today");
						if (opt[0]) {
						  if (todayline.empty()) {
							 todayline = selection2.append("line").classed("today", true);
						  }
						  const today = DateExtension.utc().startOf("day");
						  todayline.attrs({
							 x1: scale(today),
							 x2: scale(today),
							 y1: 0,
							 y2: height
						  });
						} else {
						  todayline.remove();
						}
						let verticallines = selection2.selectAll("line.vertical").data(showVerticalLines ? globaltickvalues : []);
						verticallines.exit().remove();
						const newverticallines = verticallines.enter().append("line").classed("vertical", true).attrs({
						  y1: 0,
						  y2: height
						});
						const combinedverticallines = newverticallines.merge(verticallines);
						combinedverticallines.attrs({
						  x1: function(item) {
							 return scale(item);
						  },
						  x2: function(item) {
							 return scale(item);
						  },
						  y1: 0,
						  y2: height
						});
						const boldverticallines = selection2.selectAll("line.bold").data(showVerticalLines ? maintickvalues : []);
						boldverticallines.exit().remove();
						const newboldverticallines = boldverticallines.enter().append("line").classed("bold", true).attrs({
						  y1: 0,
						  y2: height
						}).style("stroke", "black").style("stroke-width", "1px");
						const combinedboldverticallines = newboldverticallines.merge(boldverticallines);
						combinedboldverticallines.attrs({
						  x1: function(item) {
							 return scale(item);
						  },
						  x2: function(item) {
							 return scale(item);
						  },
						  y1: 0,
						  y2: height
						});
						selection2.attr("transform", "translate(0," + offset + ")");
					 };
					 _calendarlines.getScale = () => {
						return scale;
					 };
					 _calendarlines.getHeight = () => {
						return height;
					 };
					 _calendarlines.getOffset = () => {
						return offset;
					 };
					 _calendarlines.getTickvalues = () => {
						return globaltickvalues;
					 };
					 _calendarlines.getMaintickvalues = () => {
						return maintickvalues;
					 };
					 _calendarlines.getShowVerticalLines = () => {
						return showVerticalLines;
					 };
					 _calendarlines.getShowHorizontalLines = () => {
						return showHorizontalLines;
					 };
					 _calendarlines.getPrintmode = () => {
						return printadjustment !== 0;
					 };
					 _calendarlines.getVerticalIndex = function() {
						return verticalIndex;
					 };
					 _calendarlines.setScale = function(x) {
						scale = x;
						return this;
					 };
					 _calendarlines.setHeight = function(x) {
						height = x;
						return this;
					 };
					 _calendarlines.setOffset = function(x) {
						offset = x;
						return this;
					 };
					 _calendarlines.setTickvalues = function(x) {
						globaltickvalues = x;
						return this;
					 };
					 _calendarlines.setMaintickvalues = function(x) {
						maintickvalues = x;
						return this;
					 };
					 _calendarlines.setShowVerticalLines = function(x) {
						showVerticalLines = x;
						return this;
					 };
					 _calendarlines.setShowHorizontalLines = function(x) {
						showHorizontalLines = x;
						return this;
					 };
					 _calendarlines.setPrintmode = function(x) {
						printadjustment = x ? -0.5 : 0;
						return this;
					 };
					 _calendarlines.setVerticalIndex = function(x) {
						verticalIndex = x;
						makeLineData();
						return this;
					 };
					 return _calendarlines;
				  },
				  holidays: function holidays() {
					 let scale, height = 500, offset = 0, scroll = false;
					 const holidays_ = function(selection2) {
						const modifiedoffset = scroll ? offset - 1e3 : offset;
						const modifiedheight = scroll ? height + 2e3 : height;
						let holidayrects;
						const domain = scale.extendeddomain();
						holidayrects = selection2.selectAll("rect.holiday").data(selection2.datum().filter(function(item) {
						  return item.End > domain[0] && item.Start < domain[1];
						}));
						holidayrects.exit().remove();
						const newholidayrects = holidayrects.enter().append("rect").classed("holiday", true);
						const combinedholidayrects = newholidayrects.merge(holidayrects);
						combinedholidayrects.attr("x", function(d) {
						  return scale(d.Start);
						}).attr("y", 0).attr("height", modifiedheight).attr("width", function(d) {
						  return scale(d.End) - scale(d.Start);
						}).style("fill", function(d) {
						  return decimalToHex(d.Color, 6);
						});
						selection2.attr("transform", "translate(0," + modifiedoffset + ")");
					 };
					 holidays_.setScale = function(newscale) {
						scale = newscale;
						return this;
					 };
					 holidays_.setHeight = function(newheight) {
						height = newheight;
						return this;
					 };
					 holidays_.setOffset = function(newOffset) {
						offset = newOffset;
						return this;
					 };
					 holidays_.setScrollOptimization = function(newscrollOptimization) {
						scroll = newscrollOptimization;
						return this;
					 };
					 holidays_.getScale = () => {
						return scale;
					 };
					 holidays_.getHeight = () => {
						return height;
					 };
					 holidays_.getOffset = () => {
						return offset;
					 };
					 holidays_.getScrollOptimization = () => {
						return scroll;
					 };
					 return holidays_;
				  },
				  // NOTE: CANNOT use ES6 map on server
				  weekends: function weekends() {
					 let scale = utcTime(), height = 500, offset = 0, scroll = false, weekdaymap = [
						utcSunday,
						utcMonday,
						utcTuesday,
						utcWednesday,
						utcThursday,
						utcFriday,
						utcSaturday
					 ];
					 const weekdaynames = [
						null,
						// sunday is index1, monday is 2 ... saturday is 7.
						"sunday",
						"monday",
						"tuesday",
						"wednesday",
						"thursday",
						"friday",
						"saturday"
					 ];
					 const weekends_ = function(selection2) {
						const modifiedoffset = scroll ? offset - 1e3 : offset;
						const modifiedheight = scroll ? height + 2e3 : height;
						const a = new DateExtension().utc().startOf("isoWeek");
						const b = new DateExtension(a).endOf("day");
						const width = scale(b) - scale(a);
						let weekenddata = [];
						const dates = selection2.datum() || [];
						dates.forEach(function(index) {
						  weekenddata = weekenddata.concat(scale.ticks(weekdaymap[index]));
						});
						const weekends2 = selection2.selectAll("rect.weekend").data(weekenddata);
						weekends2.exit().remove();
						const newweekends = weekends2.enter().append("rect").classed("weekend", true);
						const allweekends = newweekends.merge(weekends2);
						allweekends.attr("x", function(d) {
						  return scale(d);
						}).attr("y", 0).attr("height", modifiedheight).attr("width", width);
						selection2.attr("transform", "translate(0," + modifiedoffset + ")");
					 };
					 weekends_.setScale = (newscale) => {
						scale = newscale;
						return weekends_;
					 };
					 weekends_.setHeight = (newheight) => {
						height = newheight;
						return weekends_;
					 };
					 weekends_.setOffset = (newOffset) => {
						offset = newOffset;
						return weekends_;
					 };
					 weekends_.setScrollOptimization = (newscrollOptimization) => {
						scroll = newscrollOptimization;
						return weekends_;
					 };
					 weekends_.getScale = () => {
						return scale;
					 };
					 weekends_.getHeight = () => {
						return height;
					 };
					 weekends_.getOffset = () => {
						return offset;
					 };
					 weekends_.getScrollOptimization = () => {
						return scroll;
					 };
					 return weekends_;
				  },
				  timelines: function timelines() {
					 let scale = utcTime(), height = 500, offset = 0, scroll = false, printadjustment = -13;
					 const colorscale = ordinal(category10_default);
					 function getColor(timeline) {
						if (!(0, import_lodash.isNull)(timeline.Color)) {
						  return decimalToHex(timeline.Color, 6);
						} else {
						  return colorscale(timeline.Date.toString());
						}
					 }
					 const timelines_ = function(selection2) {
						const modifiedoffset = scroll ? offset - 1e3 : offset;
						const modifiedheight = scroll ? height + 2e3 : height;
						const todaylines = selection2.selectAll("g.timeline").data(selection2.datum()[0].filter(function(item) {
						  return scale(item.Date) > scale.range()[0] - 500 && scale(item.Date) < scale.range()[1] + 500;
						}));
						todaylines.exit().remove();
						const newtodaylines = todaylines.enter().append("g").classed("timeline", true);
						newtodaylines.append("line").parent().append("g").append("rect").parent().append("text");
						const alltodaylines = newtodaylines.merge(todaylines);
						alltodaylines.each(function(d) {
						  const g = select_default2(alltodaylines.data([d]).node());
						  const xvalue = getXValue(d);
						  attrs(g.select("line"), {
							 x1: xvalue,
							 y1: 0,
							 x2: xvalue,
							 y2: modifiedheight
						  }).styles({
							 stroke: getColor(d),
							 "stroke-width": getStrokeWidth(d),
							 "opacity": d.EndDate ? "0.5" : "1.0"
						  });
						  attrs(g.select("g text"), {
							 x: xvalue,
							 y: 4
						  }).text(function(d2) {
							 return d2 && d2.Text ? decodeURIComponent(d2.Text) : "";
						  }).style("alignment-baseline", "middle", "font-size", "8px");
						  const bboxouter = g.select("g text");
						  if (!bboxouter.empty()) {
							 const bbox = bboxouter.node().getBBox();
							 attrs(g.select("g rect"), {
								x: bbox.x - 5,
								y: bbox.y - 2,
								width: bbox.width + 10,
								height: bbox.height + 4,
								rx: 5,
								ry: 5,
								"opacity": d.EndDate ? "0" : "1"
							 }).styles({
								fill: getColor(d),
								"shape-rendering": "auto"
							 });
							 g.select("g").attr("transform", "rotate (270 " + bbox.x + " " + bbox.y + ") translate(" + (-bbox.width + printadjustment) + " " + -bbox.height / 2 + ")");
						  }
						});
						function getStrokeWidth(d) {
						  if (!d.EndDate) {
							 return "2.5px";
						  }
						  const result = Math.abs(scale(d.EndDate) - scale(d.Date));
						  return result + "px";
						}
						function getXValue(d) {
						  if (!d.EndDate) {
							 return scale(d.Date);
						  }
						  const a = scale(d.Date);
						  const b = scale(d.EndDate);
						  return a + 0.5 * (b - a);
						}
						function attrs(sel, object) {
						  Object.entries(object).forEach((entry) => {
							 sel.attr(entry[0], entry[1]);
						  });
						  return sel;
						}
						;
						selection2.selectAll("g.timeline line").attr("transform", "translate(0," + modifiedoffset + ")");
					 };
					 timelines_.setScale = (newscale) => {
						scale = newscale;
						return timelines_;
					 };
					 timelines_.getScale = () => {
						return scale;
					 };
					 timelines_.setHeight = (newheight) => {
						height = newheight;
						return timelines_;
					 };
					 timelines_.getHeight = () => {
						return height;
					 };
					 timelines_.setOffset = (newOffset) => {
						offset = newOffset;
						return timelines_;
					 };
					 timelines_.getOffset = () => {
						return offset;
					 };
					 timelines_.setScrollOptimization = (newscrollOptimization) => {
						scroll = newscrollOptimization;
						return timelines_;
					 };
					 timelines_.getScrollOptimization = () => {
						return scroll;
					 };
					 timelines_.setPrintmode = (x) => {
						printadjustment = x ? -11 : -13;
						return timelines_;
					 };
					 timelines_.getPrintmode = () => {
						return printadjustment !== -13;
					 };
					 return timelines_;
				  },
				  getZoomLevel,
				  calculateIntervals
				};
				return chartBaseComponent;
			 };
		  }
		  static {
			 this.\u0275fac = function PlanningBoardChartbaseComponent_Factory(t) {
				return new (t || _PlanningBoardChartbaseComponent)();
			 };
		  }
		  static {
			 this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _PlanningBoardChartbaseComponent, selectors: [["lib-planning-board-chartbase"]], viewQuery: function PlanningBoardChartbaseComponent_Query(rf, ctx) {
				if (rf & 1) {
				  \u0275\u0275viewQuery(_c0$h, 7);
				}
				if (rf & 2) {
				  let _t;
				  \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.scrollContent = _t.first);
				}
			 }, standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 2, vars: 0, template: function PlanningBoardChartbaseComponent_Template(rf, ctx) {
				if (rf & 1) {
				  \u0275\u0275elementStart(0, "p");
				  \u0275\u0275text(1, "planning-board-chartbase works!");
				  \u0275\u0275elementEnd();
				}
			 } });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlanningBoardChartbaseComponent, [{
			 type: Component,
			 args: [{ selector: "lib-planning-board-chartbase", standalone: true, imports: [], template: "<p>planning-board-chartbase works!</p>\r\n" }]
		  }], null, { scrollContent: [{
			 type: ViewChild,
			 args: ["scrollContent", { static: true }]
		  }] });
		})();
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(PlanningBoardChartbaseComponent, { className: "PlanningBoardChartbaseComponent", filePath: "lib\\components\\planning-board-chartbase\\planning-board-chartbase.component.ts", lineNumber: 71 });
		})();
		var PlanningBoardAssignmentGroupingComponentConstants;
		(function(PlanningBoardAssignmentGroupingComponentConstants2) {
		  PlanningBoardAssignmentGroupingComponentConstants2["defualtDraggingFillColor"] = "rgba(0, 123, 255, 0.41)";
		  PlanningBoardAssignmentGroupingComponentConstants2["defualtFillColor"] = "#69a3b2";
		})(PlanningBoardAssignmentGroupingComponentConstants || (PlanningBoardAssignmentGroupingComponentConstants = {}));
		var AssignmentData = class extends Object {
		  constructor(originalEntity) {
			 super();
			 this.originalEntity = originalEntity;
			 this.modificationData = {
				pBoardModified: false,
				Disabled: false,
				selectedFlag: false,
				isDragging: false,
				areRelated: false,
				activeFlag: false
			 };
			 this.collisionData = {
				scale: 1,
				collisionId: 0,
				top: 0,
				collisions: [],
				// : make those fields private - create object with meta dat,
				_assignmentHeight: 0,
				_rowId: 0,
				_start: new DateExtension().getTime(),
				_end: new DateExtension().getTime(),
				_scalabelCollisionsCount: 1,
				_collisionsArray: []
			 };
			 this.validationData = {
				isValid: true,
				invalidItems: []
			 };
			 this.collectionData = {
				collectionStart: new DateExtension(),
				isVerticallyCollected: false
			 };
			 this.groupingData = {
				height: null,
				fillColor: PlanningBoardAssignmentGroupingComponentConstants.defualtFillColor,
				width: null,
				positionY: null,
				positionX: null,
				linePositionY1: null,
				linePositionY2: null,
				linePositionX1: null,
				linePositionX2: null
			 };
			 this.statusData = {
				originalStatusFrom: null,
				StatusFrom: 0,
				EntityId: {
				  id: 0
				}
			 };
			 this.timeData = {
				startDateInMs: 0,
				endDateInMs: 0
			 };
		  }
		};
		var DemandData = class {
		  constructor(originalEntity) {
			 this.originalEntity = originalEntity;
		  }
		};
		var PlanningBoardCalendarService = class _PlanningBoardCalendarService {
		  static {
			 this.calendarCache = /* @__PURE__ */ new Map();
		  }
		  static openCalendarDayEditDialog(dateObject, planningboardDataService) {
			 return __async(this, null, function* () {
				let isNonExceptionDay = true;
				let description = "";
				const dateObjDayDateExtenstion = new DateExtension(dateObject.day);
				let workEnd = dateObjDayDateExtenstion.endOf("day", true);
				let workStart = dateObjDayDateExtenstion.startOf("day", true);
				let backgroundColor = null;
				const formConfig = {
				  fid: "productionplanning.productionplace.phase.integration.dialog",
				  version: "1.0.0",
				  groups: [{
					 gid: "1",
					 isOpen: true
				  }],
				  rows: [
					 {
						gid: "1",
						rid: "isNonExceptionDay",
						model: "isNonExceptionDay",
						type: "boolean",
						label: "Working day",
						visible: true
					 },
					 {
						gid: "1",
						rid: "Description",
						model: "description",
						type: "description",
						label: "Description",
						visible: true
					 },
					 {
						gid: "1",
						rid: "WorkStart",
						model: "workStart",
						type: "time",
						label: "Work Start",
						visible: true
					 },
					 {
						gid: "1",
						rid: "WorkEnd",
						model: "workEnd",
						type: "time",
						label: "Work End",
						visible: true
					 },
					 {
						gid: "1",
						rid: "BackgroundColor",
						model: "backgroundColor",
						type: "color",
						label: "Background Color",
						visible: true
					 }
				  ]
				};
				const supplierCalendar = _PlanningBoardCalendarService.getCachedCalendars(planningboardDataService.getSupplierConfig().uuid)?.get(dateObject.calendarId) || planningboardDataService.calendarInUse;
				let clickedexceptionDay = supplierCalendar.ExceptionDays.find((x) => dateObjDayDateExtenstion.getUTCDate() === x.ExceptDate.toDate().getUTCDate() && dateObjDayDateExtenstion.getUTCMonth() === x.ExceptDate.toDate().getUTCMonth() && dateObjDayDateExtenstion.getUTCFullYear() === x.ExceptDate.toDate().getUTCFullYear());
				if (clickedexceptionDay) {
				  isNonExceptionDay = clickedexceptionDay.IsWorkday;
				  description = clickedexceptionDay.DescriptionInfo.Description;
				  workEnd = clickedexceptionDay.WorkEnd ? new DateExtension(clickedexceptionDay.WorkEnd, "HH:mm:ss") : workEnd;
				  workStart = clickedexceptionDay.WorkStart ? new DateExtension(clickedexceptionDay.WorkStart, "HH:mm:ss") : workStart;
				  backgroundColor = clickedexceptionDay.BackgroundColor;
				}
				if (!clickedexceptionDay) {
				  const dayIndex = dateObjDayDateExtenstion.getUTCDay() + 1;
				  const weekDay = supplierCalendar.WeekDays.find((weekDay2) => weekDay2.WeekdayIndex === dayIndex);
				  backgroundColor = weekDay.BackgroundColor;
				  isNonExceptionDay = !weekDay.IsWeekend;
				}
				const editedDayItem = {
				  isNonExceptionDay,
				  description,
				  workEnd,
				  workStart,
				  backgroundColor
				};
				const dialogConfig = {
				  title: dateObjDayDateExtenstion.format("dd/MM/yyyy"),
				  resizeable: true,
				  showOkButton: true,
				  formConfiguration: formConfig,
				  dataItem: editedDayItem
				};
				PlanningBoardExternalServices.UiCommonFormDialogService.show(dialogConfig).then((result) => {
				  if (result.ok) {
					 const http = PlanningBoardExternalServices.PlatformHttpService;
					 const globals = PlanningBoardExternalServices.PlatformConfigurationService;
					 const doRequest = (promise) => {
						return Promise.resolve(promise).then((calendarObject) => {
						  const foundExceptionDay = (0, import_lodash.isArray)(calendarObject.data) ? calendarObject.data.find((y) => new DateExtension(y.ExceptDate).isSame(dateObjDayDateExtenstion)) : calendarObject.data;
						  if (foundExceptionDay) {
							 foundExceptionDay.IsWorkday = result.data.isNonExceptionDay;
							 foundExceptionDay.WorkStart = result.data.workStart.format("HH:mm:ss");
							 foundExceptionDay.WorkEnd = result.data.workEnd.format("HH:mm:ss");
							 foundExceptionDay.ExceptDate = dateObjDayDateExtenstion.toISOString();
							 foundExceptionDay.DescriptionInfo.Description = result.data.description;
							 if (result.data.backgroundColor) {
								foundExceptionDay.BackgroundColor = result.data.backgroundColor;
							 }
							 let updateObject = {
								EntitiesCount: 1,
								ExceptionDaysToSave: [foundExceptionDay],
								MainItemId: supplierCalendar.CalendarId
							 };
							 let promiseUpdate = http.post(globals.webApiBaseUrl + "scheduling/calendar/update", updateObject);
							 return Promise.resolve(promiseUpdate).then(() => {
								const dsConfig = planningboardDataService.getDateshiftConfig();
								if (dsConfig) {
								  const calendarData = dsConfig.dateShiftHelperService.getCalendarData(dsConfig.dataService.getServiceName());
								  dsConfig.dataService.updateCalendarData(calendarData, dsConfig.dataService.getServiceName());
								}
								planningboardDataService.loadCalendarOnly(true, true);
							 });
						  }
						  return Promise.resolve();
						});
					 };
					 if (dateObject.type === "exday" && supplierCalendar.ExceptionDays.map((x) => new DateExtension(x.ExceptDate).format("yyyyMMdd")).includes(new DateExtension(dateObject.day).format("yyyyMMdd"))) {
						let promiseGet = http.get(globals.webApiBaseUrl + "scheduling/calendar/exceptionday/list?mainItemId=" + supplierCalendar.CalendarId);
						return doRequest(promiseGet);
					 } else {
						let promiseCreate = http.post(globals.webApiBaseUrl + "scheduling/calendar/exceptionday/create", { PKey1: supplierCalendar.CalendarId });
						return doRequest(promiseCreate);
					 }
				  }
				  return Promise.resolve();
				});
			 });
		  }
		  static getCalendarsByIds(_0) {
			 return __async(this, arguments, function* (serviceId, calendarIds = [], startDate = null, endDate = null, reloadAllCalendars = false) {
				let promiseList = [];
				if (!_PlanningBoardCalendarService.calendarCache.has(serviceId) || reloadAllCalendars) {
				  _PlanningBoardCalendarService.calendarCache.set(serviceId, /* @__PURE__ */ new Map());
				}
				const filteredCalendars = calendarIds.filter((cId) => !_PlanningBoardCalendarService.calendarCache.get(serviceId).has(cId));
				filteredCalendars.forEach((cId) => {
				  promiseList.push(PlanningBoardExternalServices.calendarUtilitiesService.getCalendarChartDataInRange(cId, startDate, endDate).then((calendar2) => {
					 _PlanningBoardCalendarService.calendarCache.get(serviceId).set(cId, calendar2);
				  }));
				});
				return Promise.all(promiseList).then(() => {
				  return _PlanningBoardCalendarService.calendarCache.get(serviceId);
				});
			 });
		  }
		  static getCachedCalendars(serviceId) {
			 return _PlanningBoardCalendarService.calendarCache.get(serviceId);
		  }
		  static {
			 this.\u0275fac = function PlanningBoardCalendarService_Factory(t) {
				return new (t || _PlanningBoardCalendarService)();
			 };
		  }
		  static {
			 this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _PlanningBoardCalendarService, factory: _PlanningBoardCalendarService.\u0275fac, providedIn: "root" });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlanningBoardCalendarService, [{
			 type: Injectable,
			 args: [{
				providedIn: "root"
			 }]
		  }], null, null);
		})();
		var Aggregate = class {
		  constructor(aggregateData) {
			 this.id = aggregateData.setId ? aggregateData.id : -1;
			 this.startDate = aggregateData.interval.startDate;
			 this.endDate = aggregateData.interval.endDate;
			 this.sum = aggregateData.sum || 0;
			 this.sums = aggregateData.sums;
			 this.displayFactor = aggregateData.displayFactor || 1;
			 this.uomDescription = aggregateData.uomDescription || "";
			 this.type = aggregateData.type;
			 this.reference = aggregateData.reference;
			 this.aggregates = aggregateData.aggregates;
			 this.targetValue = aggregateData.interval.capacity;
			 this.amount = aggregateData.amount;
			 this.color = aggregateData.color;
		  }
		};
		var PlanningBoardAggregationService = class {
		  constructor(planningBoardDataService) {
			 const service = this;
			 const MS_IN_DAY = 864e5;
			 const HOURS_IN_DAY = 24;
			 const currentAggregationData = {
				assignmentAggregations: [],
				sumAggregations: [],
				assignmentDurationObject: {},
				capacityList: [],
				intervals: [],
				newTickValues: [],
				prevUseMinAggregation: false,
				prevMinAggregationLevel: void 0,
				idMachine: {
				  internalCounter: 0,
				  getId: function() {
					 return this.internalCounter++;
				  },
				  resetId: function() {
					 this.internalCounter = 0;
				  }
				},
				calendarInUse: void 0,
				aggregationTrafficLightsConfig: void 0,
				aggregationTrafficLightsConfigValuesConfig: void 0
			 };
			 service.getAggregationValue = (aggregate, value) => {
				let text = "";
				switch (value) {
				  case "amount":
					 text = aggregate.amount;
					 break;
				  case "targetValue":
					 text = `${(aggregate.targetValue / aggregate.displayFactor).toFixed(2)} ${aggregate.uomDescription}`;
					 break;
				  case "actualValue":
					 text = `${(aggregate.sum / aggregate.displayFactor).toFixed(2)} ${aggregate.uomDescription}`;
					 break;
				  case "residualValue":
					 text = `${(aggregate.targetValue / aggregate.displayFactor - aggregate.sum / aggregate.displayFactor).toFixed(2)} ${aggregate.uomDescription}`;
					 break;
				  default:
					 text = (0, import_lodash.isFunction)(planningBoardDataService.getAssignmentConfig().mappingService.getAggregationText) ? planningBoardDataService.getAssignmentConfig().mappingService.getAggregationText(value, aggregate) : "";
					 break;
				}
				return text;
			 };
			 service.updateAssignmentAggregations = (updateAssignmentAggregationData) => {
				currentAggregationData.idMachine.resetId();
				let spanAboveMin = true;
				const needsUpdate = currentAggregationData.prevUseMinAggregation !== updateAssignmentAggregationData.useMinAggregation || !(0, import_lodash.isEqual)(currentAggregationData.prevMinAggregationLevel, updateAssignmentAggregationData.minAggregationLevel);
				const minDuration = new DateExtensionDuration(updateAssignmentAggregationData.minAggregationLevel.value, updateAssignmentAggregationData.minAggregationLevel.type).asSeconds();
				if (updateAssignmentAggregationData.tickValues.length >= 2) {
				  const tickSpan = new DateExtension(updateAssignmentAggregationData.tickValues[1]).diff(updateAssignmentAggregationData.tickValues[0], "seconds");
				  const firstTick = new DateExtension(updateAssignmentAggregationData.tickValues[0]).subtract(tickSpan, "seconds");
				  updateAssignmentAggregationData.tickValues.unshift(firstTick);
				  const lastTick = new DateExtension(updateAssignmentAggregationData.tickValues[updateAssignmentAggregationData.tickValues.length - 1]).add(tickSpan, "seconds");
				  updateAssignmentAggregationData.tickValues.push(lastTick);
				  spanAboveMin = tickSpan - minDuration >= 0;
				}
				if (!(0, import_lodash.isEqual)(updateAssignmentAggregationData.tickValues, currentAggregationData.newTickValues) || needsUpdate) {
				  currentAggregationData.prevUseMinAggregation = updateAssignmentAggregationData.useMinAggregation;
				  currentAggregationData.prevMinAggregationLevel = updateAssignmentAggregationData.minAggregationLevel;
				  currentAggregationData.newTickValues = updateAssignmentAggregationData.tickValues;
				  clearIntervals();
				  updateIntervals(updateAssignmentAggregationData.tickValues, updateAssignmentAggregationData.useMinAggregation && !spanAboveMin ? updateAssignmentAggregationData.minAggregationLevel : null);
				}
				if (service) {
				  setAssignmentRealDuarion(updateAssignmentAggregationData.assignments);
				  updateAggregations(updateAssignmentAggregationData.assignments, updateAssignmentAggregationData.doUpdateSumAggregations);
				} else {
				  console.warn("Mapping service is not set!");
				}
			 };
			 service.getSumAggregations = () => {
				return currentAggregationData.sumAggregations;
			 };
			 service.updateCapacities = (capacities) => {
				const capacitiesKeys = Object.keys(capacities);
				if ((0, import_lodash.isFunction)(planningBoardDataService.getAssignmentConfig().mappingService.useCapacities) && planningBoardDataService.getAssignmentConfig().mappingService.useCapacities() && capacitiesKeys.length > 0) {
				  currentAggregationData.capacityList = capacities[capacitiesKeys[0]];
				  clearIntervals();
				  const minAggregation = planningBoardDataService.useMinAggregation() ? planningBoardDataService.minAggregationLevel() : null;
				  updateIntervals(currentAggregationData.newTickValues, minAggregation);
				}
			 };
			 service.getAssignmentAggregations = () => {
				return currentAggregationData.assignmentAggregations;
			 };
			 service.clearData = () => {
				clearIntervals();
				clearAssignmentAggregations();
			 };
			 function getAggregationTrafficLights(type2) {
				let basicsCommonDrawingUtilitiesService = PlanningBoardExternalServices.basicsCommonDrawingUtilitiesService;
				let color2 = "rgb(170,170,170)";
				switch (type2) {
				  case "underload":
					 color2 = currentAggregationData.aggregationTrafficLightsConfig ? basicsCommonDrawingUtilitiesService.intToRgbColor(currentAggregationData.aggregationTrafficLightsConfig["underload"]).toString() : "rgb(23,176,39, 1)";
					 break;
				  case "goodload":
					 color2 = currentAggregationData.aggregationTrafficLightsConfig ? basicsCommonDrawingUtilitiesService.intToRgbColor(currentAggregationData.aggregationTrafficLightsConfig["goodload"]).toString() : "rgb(226,116,14, 1)";
					 break;
				  case "maxload":
					 color2 = currentAggregationData.aggregationTrafficLightsConfig ? basicsCommonDrawingUtilitiesService.intToRgbColor(currentAggregationData.aggregationTrafficLightsConfig["maxload"]).toString() : "rgb(214,28,28, 1)";
					 break;
				  case "overload":
					 color2 = currentAggregationData.aggregationTrafficLightsConfig ? basicsCommonDrawingUtilitiesService.intToRgbColor(currentAggregationData.aggregationTrafficLightsConfig["overload"]).toString() : "rgb(115,2,2, 1)";
					 break;
				  default:
					 break;
				}
				return color2;
			 }
			 function updateSumAggregations(interval2, intervalIdx, intervalAggregations) {
				let sums = {};
				const aggregationProperties = (0, import_lodash.isFunction)(planningBoardDataService.getAssignmentConfig().mappingService.getAggregationProperties) ? planningBoardDataService.getAssignmentConfig().mappingService.getAggregationProperties() : [];
				aggregationProperties.forEach((property) => {
				  if (!sums.hasOwnProperty(property)) {
					 sums[property] = 0;
				  }
				});
				const aggregationPropertiesWithDomain = (0, import_lodash.isFunction)(planningBoardDataService.getAssignmentConfig().mappingService.getPropertiesWithDomain) ? planningBoardDataService.getAssignmentConfig().mappingService.getPropertiesWithDomain() : {};
				let aggregationQtyAndDecPropsWDomainObj = {};
				(0, import_lodash.forEach)(aggregationPropertiesWithDomain, function(value, key) {
				  if (value.domain === "decimal" || value.domain === "quantity") {
					 aggregationQtyAndDecPropsWDomainObj[key] = value;
				  }
				});
				let intervalAggregationAmount = 0;
				if (!(0, import_lodash.isUndefined)(intervalAggregations) && intervalAggregations.length > 0) {
				  let subSumAggregations = [];
				  intervalAggregations.forEach((aggregate) => {
					 if (aggregate.aggregates) {
						(0, import_lodash.forEach)(aggregate.aggregates, function(subAggregate) {
						  subSumAggregations.push(subAggregate);
						});
					 }
					 const aggregateSumsMap = new Map(Object.entries(aggregate.sums));
					 aggregationProperties.forEach((property) => {
						let tempValues = [sums[property]];
						let aggregatePropValue = aggregate.sums[property];
						if (aggregatePropValue) {
						  tempValues.push(aggregatePropValue);
						}
						let foundDomain = aggregationQtyAndDecPropsWDomainObj[property];
						if (foundDomain) {
						  switch (foundDomain.domain) {
							 case "integer":
							 case "decimal":
							 case "quantity":
								sums[property] = sum(tempValues);
								break;
							 default:
								break;
						  }
						} else {
						  sums[property] = sum(tempValues);
						}
					 });
					 intervalAggregationAmount += aggregate.amount;
				  });
				  let aggregateDisplayFactor = (0, import_lodash.map)(intervalAggregations, "displayFactor")[0];
				  let aggregateUomDescription = (0, import_lodash.map)(intervalAggregations, "uomDescription")[0];
				  const creationData = {
					 setId: true,
					 id: currentAggregationData.idMachine.getId(),
					 interval: interval2,
					 sum: sumAggregates(intervalAggregations),
					 sums,
					 type: "sum",
					 reference: intervalIdx,
					 aggregates: intervalAggregations,
					 displayFactor: aggregateDisplayFactor,
					 uomDescription: aggregateUomDescription,
					 amount: intervalAggregationAmount,
					 color: getAggregationColor(0, interval2)
				  };
				  const sumAggregation = new Aggregate(creationData);
				  sumAggregation.aggregates = subSumAggregations.length > 0 ? subSumAggregations : [];
				  currentAggregationData.sumAggregations.push(sumAggregation);
				}
			 }
			 function clearIntervals() {
				currentAggregationData.intervals = [];
			 }
			 function clearAssignmentAggregations() {
				currentAggregationData.assignmentAggregations = [];
				currentAggregationData.sumAggregations = [];
			 }
			 function updateIntervals(tickValues, minAggregation = null) {
				currentAggregationData.calendarInUse = PlanningBoardExternalServices.platformDateshiftCalendarService.parseCalendarData(planningBoardDataService.calendarInUse);
				currentAggregationData.aggregationTrafficLightsConfig = planningBoardDataService.aggregationTrafficLightsConfig();
				currentAggregationData.aggregationTrafficLightsConfigValuesConfig = planningBoardDataService.aggregationTrafficLightsValuesConfig();
				let newInterval = null;
				if (minAggregation !== null && minAggregation.type !== "hour") {
				  let actualMomentStart = null;
				  let actualMomentEnd = null;
				  const tempIntervalArray = [];
				  let tickValueType = minAggregation.type;
				  if (tickValueType === "week") {
					 tickValueType = "isoWeek";
				  }
				  for (const tickValue of tickValues) {
					 actualMomentStart = DateExtension.utc(new DateExtension(tickValue)).startOf(tickValueType);
					 actualMomentEnd = DateExtension.utc(new DateExtension(tickValue)).endOf(tickValueType);
					 if (!(0, import_lodash.find)(tempIntervalArray, actualMomentStart)) {
						tempIntervalArray.push(actualMomentStart);
						newInterval = new AggregationInterval(actualMomentStart, actualMomentEnd, getCapacity(actualMomentStart, actualMomentEnd), currentAggregationData, getAggregationTrafficLights);
						currentAggregationData.intervals.push(newInterval);
					 }
				  }
				} else {
				  for (let i = 0; i < tickValues.length - 1; i++) {
					 if (!(0, import_lodash.find)(currentAggregationData.intervals, { startDate: tickValues[i], endDate: tickValues[i + 1] })) {
						newInterval = new AggregationInterval(new DateExtension(tickValues[i]), new DateExtension(tickValues[i + 1]), getCapacity(new DateExtension(tickValues[i]), new DateExtension(tickValues[i + 1])), currentAggregationData, getAggregationTrafficLights);
						currentAggregationData.intervals.push(newInterval);
					 }
				  }
				}
				return currentAggregationData.intervals;
			 }
			 function updateAggregations(assignments, doUpdateSumAggregations) {
				clearAssignmentAggregations();
				const currentPBSettings = planningBoardDataService.getPlanningBoardSettingsList();
				const selectedAggregationProperties = [];
				selectedAggregationProperties.push(currentPBSettings["planningBoard.chart.presentation.settings"].sumAggregationLine1.value);
				selectedAggregationProperties.push(currentPBSettings["planningBoard.chart.presentation.settings"].sumAggregationLine2.value);
				selectedAggregationProperties.push(currentPBSettings["planningBoard.chart.presentation.settings"].sumAggregationLine3.value);
				let aggregationPropertiesSet = new Set((0, import_lodash.isFunction)(planningBoardDataService.getAssignmentConfig().mappingService.getAggregationProperties) ? planningBoardDataService.getAssignmentConfig().mappingService.getAggregationProperties() : []);
				let intervalAggregations = /* @__PURE__ */ new Map();
				let supplierAssignments = /* @__PURE__ */ new Map();
				let supplierId = 0;
				assignments.forEach((assignment) => {
				  supplierId = planningBoardDataService.getAssignmentConfig().mappingService.supplier(assignment.originalEntity);
				  if (!supplierAssignments.has(supplierId)) {
					 supplierAssignments.set(supplierId, []);
				  }
				  supplierAssignments.get(supplierId).push(assignment);
				});
				currentAggregationData.intervals.forEach((interval2, intervalIdx) => {
				  intervalAggregations.set(interval2.startDate, []);
				  supplierAssignments.forEach((assignmentsBySupplierAll, supplierId2) => {
					 let assignmentsBySupplier = [];
					 assignmentsBySupplier = assignmentsBySupplierAll.filter((assignment) => {
						return assignment.timeData.endDateInMs > interval2.startDateInMs && assignment.timeData.startDateInMs < interval2.endDateInMs;
					 });
					 let supplierAggregate;
					 let aggregateDisplayFactor = 1;
					 if ((0, import_lodash.isFunction)(planningBoardDataService.getAssignmentConfig().mappingService.aggregationUomFactor)) {
						aggregateDisplayFactor = (0, import_lodash.map)(assignmentsBySupplier, function(assignment) {
						  return planningBoardDataService.getAssignmentConfig().mappingService.aggregationUomFactor(assignment.originalEntity);
						})[0];
					 } else {
						console.warn("There is no [aggregationUomFactor] mapping defined for this service.", planningBoardDataService.getAssignmentConfig().mappingService);
					 }
					 let aggregateUomDescription = "";
					 if ((0, import_lodash.isFunction)(planningBoardDataService.getAssignmentConfig().mappingService.aggregationUomDescription)) {
						aggregateUomDescription = (0, import_lodash.map)(assignmentsBySupplier, function(assignment) {
						  return planningBoardDataService.getAssignmentConfig().mappingService.aggregationUomDescription(assignment.originalEntity);
						})[0];
					 } else {
						console.warn("There is no [aggregationUomDescription] mapping defined for this service.", planningBoardDataService.getAssignmentConfig().mappingService);
					 }
					 if (planningBoardDataService.getAssignmentConfig().mappingService.aggregateType) {
						let typeAggregates = [];
						const typeAssignments = {};
						if (planningBoardDataService.getAssignmentConfig().mappingService.aggregateType) {
						  const aggregateTypeFn = planningBoardDataService.getAssignmentConfig().mappingService.aggregateType;
						  if (aggregateTypeFn) {
							 (0, import_lodash.forEach)(assignmentsBySupplier, function(assignment) {
								let type2 = aggregateTypeFn(assignment.originalEntity);
								if ((0, import_lodash.isUndefined)(typeAssignments[type2])) {
								  typeAssignments[type2] = [];
								}
								typeAssignments[aggregateTypeFn(assignment.originalEntity)].push(assignment);
							 });
						  }
						}
						(0, import_lodash.forEach)(typeAssignments, function(assignmentsByType, type2) {
						  let sumValue = sum((0, import_lodash.map)(assignmentsByType, function(assignment) {
							 return getFractionQuantity(assignment, interval2, "default");
						  }));
						  const creationData2 = {
							 setId: false,
							 id: -1,
							 interval: interval2,
							 sum: sumValue,
							 sums: {},
							 type: "type",
							 reference: type2,
							 aggregates: [],
							 displayFactor: aggregateDisplayFactor,
							 uomDescription: aggregateUomDescription,
							 amount: 0,
							 //typeAssignments.length, // typeAssignments is an object, it cannot have lenght function...
							 color: getAggregationColor(sumValue, interval2)
						  };
						  const typeAggregate = new Aggregate(creationData2);
						  typeAggregates.push(typeAggregate);
						});
						const creationData = {
						  setId: true,
						  id: currentAggregationData.idMachine.getId(),
						  interval: interval2,
						  sum: sumAggregates(typeAggregates),
						  sums: {},
						  type: "supplier",
						  reference: (0, import_lodash.toNumber)(supplierId2),
						  aggregates: typeAggregates,
						  displayFactor: aggregateDisplayFactor,
						  uomDescription: aggregateUomDescription,
						  amount: assignmentsBySupplier.length,
						  color: getAggregationColor(0, interval2)
						};
						supplierAggregate = new Aggregate(creationData);
					 } else {
						let aggregationProperties = [];
						selectedAggregationProperties.forEach((selectedProp) => {
						  if (aggregationPropertiesSet.has(selectedProp)) {
							 aggregationProperties.push(selectedProp);
						  }
						});
						let sums = {};
						(0, import_lodash.forEach)(aggregationProperties, (property) => {
						  sums[property] = sum((0, import_lodash.map)(assignmentsBySupplier, (assignment) => {
							 return getFractionQuantity(assignment, interval2, property);
						  }));
						});
						const creationData = {
						  setId: true,
						  id: currentAggregationData.idMachine.getId(),
						  interval: interval2,
						  sum: sums[Object.keys(sums)[0]],
						  sums,
						  type: "supplier",
						  reference: (0, import_lodash.toNumber)(supplierId2),
						  aggregates: [],
						  displayFactor: aggregateDisplayFactor,
						  uomDescription: aggregateUomDescription,
						  amount: assignmentsBySupplier.length,
						  color: getAggregationColor(sums[Object.keys(sums)[0]], interval2)
						};
						supplierAggregate = new Aggregate(creationData);
					 }
					 intervalAggregations.get(interval2.startDate).push(supplierAggregate);
					 currentAggregationData.assignmentAggregations.push(supplierAggregate);
				  });
				  if (doUpdateSumAggregations) {
					 updateSumAggregations(interval2, intervalIdx, intervalAggregations.get(interval2.startDate) || []);
				  }
				});
			 }
			 function sumAggregates(aggregates) {
				return sum((0, import_lodash.map)(aggregates, "sum"));
			 }
			 function getFractionQuantity(assignment, interval2, property = "default") {
				let totalQuantity = property !== "default" ? assignment.originalEntity[property] : planningBoardDataService.getAssignmentConfig().mappingService.quantity(assignment.originalEntity);
				if (totalQuantity === void 0 && (0, import_lodash.isFunction)(planningBoardDataService.getAssignmentConfig().mappingService.valueToSelectedAggregation)) {
				  totalQuantity = planningBoardDataService.getAssignmentConfig().mappingService.valueToSelectedAggregation(assignment.originalEntity, property);
				}
				if (totalQuantity === void 0) {
				  console.warn("The property is not  found in the assignment.", property);
				  return 0;
				}
				let fractionFactor = getFractionFactor(interval2, assignment.timeData.startDateInMs, assignment.timeData.endDateInMs);
				let fraction = fractionFactor !== -1 ? Math.abs(fractionFactor / currentAggregationData.assignmentDurationObject[planningBoardDataService.getAssignmentConfig().mappingService.id(assignment.originalEntity)]) : 1;
				if (interval2.capacity === 0) {
				  fraction = 0;
				}
				let uomFactor = 1;
				if ((0, import_lodash.isFunction)(planningBoardDataService.getAssignmentConfig().mappingService.uomFactor)) {
				  uomFactor = planningBoardDataService.getAssignmentConfig().mappingService.uomFactor(assignment.originalEntity);
				} else {
				  console.warn("There is no [uomFactor] mapping defined for this service.", planningBoardDataService.getAssignmentConfig().mappingService);
				}
				return totalQuantity * fraction * uomFactor;
			 }
			 function getFractionFactor(interval2, startDateInMs, endDateInMs) {
				if (interval2.capacity === 0) {
				  return -1;
				}
				let intersectingTime = -1;
				const msInSec = 1e3;
				const assignmentIsEarlier = startDateInMs < interval2.startDateInMs;
				const assignmentIsLater = endDateInMs > interval2.endDateInMs;
				if (assignmentIsEarlier && assignmentIsLater) {
				  intersectingTime = (interval2.endDateInMs - interval2.startDateInMs) / msInSec;
				} else if (assignmentIsEarlier && !assignmentIsLater) {
				  intersectingTime = (endDateInMs - interval2.startDateInMs) / msInSec;
				} else if (!assignmentIsEarlier && assignmentIsLater) {
				  intersectingTime = (interval2.endDateInMs - startDateInMs) / msInSec;
				} else if (!assignmentIsEarlier && !assignmentIsLater) {
				  return -1;
				}
				return intersectingTime;
			 }
			 function setAssignmentRealDuarion(assignments) {
				assignments.forEach((assignment) => {
				  const assignmentStartDate = planningBoardDataService.getAssignmentConfig().mappingService.from(assignment.originalEntity).getTime();
				  const assignmentEndDate = planningBoardDataService.getAssignmentConfig().mappingService.to(assignment.originalEntity).getTime();
				  let realDuration = (assignmentEndDate - assignmentStartDate) / 1e3;
				  currentAggregationData.intervals.forEach((interval2) => {
					 if (interval2.capacity === 0 && !(interval2.endDateInMs < assignment.timeData.startDateInMs || interval2.startDateInMs > assignment.timeData.endDateInMs)) {
						let assignmentIsEarlier = assignment.timeData.startDateInMs < interval2.startDateInMs;
						let assignmentIsLater = assignment.timeData.endDateInMs > interval2.endDate.getTime();
						if (assignmentIsEarlier && assignmentIsLater) {
						  realDuration -= (interval2.endDateInMs - interval2.startDateInMs) / 1e3;
						} else if (assignmentIsEarlier && !assignmentIsLater) {
						  realDuration -= (assignment.timeData.endDateInMs - interval2.startDateInMs) / 1e3;
						} else if (!assignmentIsEarlier && assignmentIsLater) {
						  realDuration -= (interval2.endDateInMs - assignment.timeData.startDateInMs) / 1e3;
						}
					 }
					 currentAggregationData.assignmentDurationObject[planningBoardDataService.getAssignmentConfig().mappingService.id(assignment.originalEntity)] = realDuration;
				  });
				});
			 }
			 function getCapacity(startDate, endDate) {
				let capacity = 0;
				if (currentAggregationData.capacityList.length && currentAggregationData.capacityList.length > 0) {
				  (0, import_lodash.forEach)(currentAggregationData.capacityList, (value, date2) => {
					 if (new DateExtension(date2).isSame(startDate) || new DateExtension(date2).isBetween(startDate, endDate)) {
						capacity += value;
					 }
				  });
				} else {
				  if (PlanningBoardExternalServices.platformDateshiftCalendarService.isExceptionDay(currentAggregationData.calendarInUse, startDate) && isMidnightExceptionOrExceptionDay(currentAggregationData.calendarInUse, endDate)) {
					 capacity = 0;
				  } else {
					 capacity = 1;
				  }
				}
				return capacity;
			 }
			 function isMidnightExceptionOrExceptionDay(calendar2, date2) {
				let result = PlanningBoardExternalServices.platformDateshiftCalendarService.isExceptionDay(calendar2, date2);
				if (result === false && date2.getTime() === new DateExtension(date2).startOf("day").getTime()) {
				  result = PlanningBoardExternalServices.platformDateshiftCalendarService.isExceptionDay(calendar2, new DateExtension(date2.getTime() - MS_IN_DAY));
				}
				return result;
			 }
			 function getAggregationColor(sum2, interval2) {
				let color2 = "rgb(170,170,170)";
				if (interval2.capacity !== 0 && planningBoardDataService.getAssignmentConfig().mappingService.useCapacities && planningBoardDataService.getAssignmentConfig().mappingService.useCapacities()) {
				  const realIntervalCapacity = interval2.capacity / (HOURS_IN_DAY / interval2.endDate.diff(interval2.startDate, "h"));
				  let capacityPercent = Math.round(sum2 / realIntervalCapacity * 100);
				  if (capacityPercent < interval2.capacityLevels.underload.value) {
					 color2 = getAggregationTrafficLights("underload");
				  } else if (capacityPercent <= interval2.capacityLevels.goodload.value) {
					 color2 = getAggregationTrafficLights("goodload");
				  } else if (capacityPercent <= interval2.capacityLevels.maxload.value) {
					 color2 = getAggregationTrafficLights("maxload");
				  } else if (capacityPercent <= interval2.capacityLevels.overload.value || capacityPercent > interval2.capacityLevels.overload.value) {
					 color2 = getAggregationTrafficLights("overload");
				  }
				}
				return color2;
			 }
			 function sum(arr) {
				let sum2 = 0;
				for (let e of arr) {
				  sum2 += e;
				}
				return sum2;
			 }
		  }
		};
		var PlanningBoardTagGridConfigService = class _PlanningBoardTagGridConfigService {
		  static {
			 this.uuid = "0e735eceaa2411eabb370242ac130002";
		  }
		  //static createTagGrid(data?: ) {
		  static createTagGrid() {
			 const uuid = this.uuid;
			 const columns = [
				{
				  id: "description",
				  formatter: "description",
				  field: "name",
				  name: "Description*",
				  name$tr$: "platform.planningboard.description",
				  width: 120,
				  readonly: true
				},
				{
				  id: "color",
				  formatter: "color",
				  editor: "color",
				  field: "color",
				  name: "Color*",
				  name$tr$: "platform.planningboard.color"
				},
				{
				  id: "sort",
				  field: "sort",
				  editor: "integer",
				  formatter: "integer",
				  name: "Order*",
				  name$tr$: "platform.planningboard.order"
				},
				{
				  id: "visible",
				  field: "visible",
				  editor: "boolean",
				  formatter: "boolean",
				  name: "Visible*",
				  name$tr$: "platform.planningboard.visible",
				  width: 80
				}
			 ];
			 const gridConfig = {
				columns: (0, import_lodash.cloneDeep)(columns),
				//data: data,
				id: uuid,
				lazyInit: false,
				options: {
				  idProperty: "id",
				  indicator: true,
				  skipPermissionCheck: true,
				  tools: null
				}
			 };
			 return gridConfig;
		  }
		  static updateData(gridData, platformGridAPI) {
			 platformGridAPI.items.data(this.uuid, gridData);
		  }
		  constructor() {
		  }
		  static {
			 this.\u0275fac = function PlanningBoardTagGridConfigService_Factory(t) {
				return new (t || _PlanningBoardTagGridConfigService)();
			 };
		  }
		  static {
			 this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _PlanningBoardTagGridConfigService, factory: _PlanningBoardTagGridConfigService.\u0275fac, providedIn: "root" });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlanningBoardTagGridConfigService, [{
			 type: Injectable,
			 args: [{
				providedIn: "root"
			 }]
		  }], () => [], null);
		})();
		var PlanningBoardCalculationUtilitiesService = class _PlanningBoardCalculationUtilitiesService {
		  static {
			 this.objectToKeyValueMap = (value) => {
				const entries = Object.entries(value);
				const objectToMap = new Map(entries);
				return objectToMap;
			 };
		  }
		  static getMin(data) {
			 let min3 = data.at(0) || 0;
			 data.forEach((num) => {
				if (num < min3) {
				  min3 = num;
				}
			 });
			 return min3;
		  }
		  static getMax(data) {
			 let max3 = data.at(0) || 0;
			 data.forEach((num) => {
				if (num > max3) {
				  max3 = num;
				}
			 });
			 return max3;
		  }
		  static getDistinctArray(data) {
			 return [...new Set(data).values()];
		  }
		  constructor() {
		  }
		  static {
			 this.\u0275fac = function PlanningBoardCalculationUtilitiesService_Factory(t) {
				return new (t || _PlanningBoardCalculationUtilitiesService)();
			 };
		  }
		  static {
			 this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _PlanningBoardCalculationUtilitiesService, factory: _PlanningBoardCalculationUtilitiesService.\u0275fac, providedIn: "root" });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlanningBoardCalculationUtilitiesService, [{
			 type: Injectable,
			 args: [{
				providedIn: "root"
			 }]
		  }], () => [], null);
		})();
		var PlanningBoardLabelConfigService = class _PlanningBoardLabelConfigService {
		  static setTextLabelDropDowns(labelInputs) {
			 labelInputs.main = {
				gid: "2",
				rid: "mainInfoLabel",
				label: "Main Label",
				label$tr$: "platform.planningboard.mainLabelText",
				type: "text",
				model: "mainInfoLabel",
				visible: true,
				sortOrder: 2
			 };
			 labelInputs.info1 = {
				gid: "2",
				rid: "info1Label",
				label: "Info Label 1",
				// label$tr$: 'platform.planningboard.showInfo1Text',
				type: "text",
				model: "info1Label",
				visible: true,
				sortOrder: 4
			 };
			 labelInputs.info2 = {
				gid: "2",
				rid: "info2Label",
				label: "Info Label 2",
				// label$tr$: 'platform.planningboard.showInfo2Text',
				type: "text",
				model: "info2Label",
				visible: true,
				sortOrder: 6
			 };
			 labelInputs.info3 = {
				gid: "2",
				rid: "info3Label",
				label: "Info Label 3",
				// label$tr$: 'platform.planningboard.showInfo3Text',
				type: "text",
				model: "info3Label",
				visible: true,
				sortOrder: 8
			 };
		  }
		  static setDirectiveLabelDropDowns(labelInputs, labelLookupServiceName) {
			 labelInputs.main = {
				gid: "2",
				rid: "mainInfoLabel",
				label: "Main Label",
				label$tr$: "platform.planningboard.mainLabelText",
				type: "directive",
				directive: "basics-lookup-data-by-custom-data-service",
				options: {
				  disableDataCaching: true,
				  dataServiceName: labelLookupServiceName,
				  displayMember: "NodePath",
				  isTextEditable: true,
				  lookupModuleQualifier: labelLookupServiceName,
				  lookupType: labelLookupServiceName,
				  showClearButton: true,
				  valueMember: "NodePath",
				  columns: [
					 {
						id: "NodePath",
						field: "SymbolPath",
						name: "SymbolPath",
						formatter: "ASCIISymbolPath",
						name$tr$: "cloud.common.entityDescription",
						width: 150
					 }
				  ],
				  uuid: "edecf107103f4b2ea72a511e5e2f915c"
				},
				model: "mainInfoLabel",
				visible: true,
				sortOrder: 2
			 };
			 labelInputs.info1 = {
				gid: "2",
				rid: "info1Label",
				label: "Info Label 1",
				// label$tr$: 'platform.planningboard.showInfo1Text',
				type: "directive",
				directive: "basics-lookup-data-by-custom-data-service",
				options: {
				  dataServiceName: labelLookupServiceName,
				  disableDataCaching: true,
				  displayMember: "NodePath",
				  isTextEditable: true,
				  lookupModuleQualifier: labelLookupServiceName,
				  lookupType: labelLookupServiceName,
				  showClearButton: true,
				  valueMember: "NodePath",
				  columns: [
					 {
						id: "NodePath",
						field: "SymbolPath",
						name: "SymbolPath",
						formatter: "ASCIISymbolPath",
						name$tr$: "cloud.common.entityDescription",
						width: 150
					 }
				  ],
				  uuid: "0df065ae301742f6977707834777e568"
				},
				model: "info1Label",
				visible: true,
				sortOrder: 4
			 };
			 labelInputs.info2 = {
				gid: "2",
				rid: "info2Label",
				label: "Info Label 2",
				// label$tr$: 'platform.planningboard.showInfo2Text',
				type: "directive",
				directive: "basics-lookup-data-by-custom-data-service",
				options: {
				  dataServiceName: labelLookupServiceName,
				  disableDataCaching: true,
				  displayMember: "NodePath",
				  isTextEditable: true,
				  lookupModuleQualifier: labelLookupServiceName,
				  lookupType: labelLookupServiceName,
				  showClearButton: true,
				  valueMember: "NodePath",
				  columns: [
					 {
						id: "NodePath",
						field: "SymbolPath",
						name: "SymbolPath",
						formatter: "SymbolPath",
						name$tr$: "cloud.common.entityDescription",
						width: 150
					 }
				  ],
				  uuid: "0df065ae301742f6977707852777e568"
				},
				model: "info2Label",
				visible: true,
				sortOrder: 6
			 };
			 labelInputs.info3 = {
				gid: "2",
				rid: "info3Label",
				label: "Info Label 3",
				// label$tr$: 'platform.planningboard.showInfo3Text',
				type: "directive",
				directive: "basics-lookup-data-by-custom-data-service",
				options: {
				  dataServiceName: labelLookupServiceName,
				  disableDataCaching: true,
				  displayMember: "NodePath",
				  isTextEditable: true,
				  lookupModuleQualifier: labelLookupServiceName,
				  lookupType: labelLookupServiceName,
				  showClearButton: true,
				  valueMember: "NodePath",
				  columns: [
					 {
						id: "NodePath",
						field: "SymbolPath",
						name: "SymbolPath",
						formatter: "SymbolPath",
						name$tr$: "cloud.common.entityDescription",
						width: 150
					 }
				  ],
				  uuid: "0df065ae301742f6977707812677e568"
				},
				model: "info3Label",
				visible: true,
				sortOrder: 8
			 };
		  }
		  static getTextLineOfType(getTextLineOfTypeData) {
			 let result = "";
			 const infoFieldByProperty = getTextLineOfTypeData.mapService.infoField(getTextLineOfTypeData.assignmentOriginal, getTextLineOfTypeData.property);
			 if (this.isJson(getTextLineOfTypeData.property)) {
				const finalProperty = JSON.parse(getTextLineOfTypeData.property);
				const finalInfoField = this.getPropertiesInfo(finalProperty, getTextLineOfTypeData.assignmentOriginal, getTextLineOfTypeData.mapService);
				if (finalInfoField.length > 0) {
				  finalInfoField.forEach((element) => {
					 if (element.match(/\{|\}/gi)) {
						element = element.replace(/\{|\}/gi, "");
						let origAssignmentPropMap = PlanningBoardCalculationUtilitiesService.objectToKeyValueMap(getTextLineOfTypeData.assignmentOriginal);
						if (/(.*)uom(.*)fk/.test(element.toLowerCase()) && origAssignmentPropMap.has(element)) {
						  let uom = getTextLineOfTypeData.basicsUnitLookupDataService.getItemById(origAssignmentPropMap.get(element), {
							 "lookupType": "Uom",
							 "dataServiceName": "basicsUnitLookupDataService"
						  });
						  uom = uom ? uom.Unit : "";
						  result = result + uom;
						} else if (/(.*):(.*)./.test(element.toLowerCase())) {
						  const elementValue = this.getPhaseRequimentsProperty(getTextLineOfTypeData.assignmentOriginal, element, getTextLineOfTypeData.mapService);
						  result = result + elementValue;
						} else {
						  let elementValue = getTextLineOfTypeData.mapService.infoField(getTextLineOfTypeData.assignmentOriginal, element);
						  elementValue = elementValue === null ? "" : elementValue;
						  result = result + elementValue;
						}
					 } else {
						result = result + element;
					 }
				  });
				}
			 } else if (getTextLineOfTypeData.isMainInfoLabel) {
				result = infoFieldByProperty === "" ? getTextLineOfTypeData.mapService.description(getTextLineOfTypeData.assignmentOriginal) : infoFieldByProperty;
			 } else {
				result = infoFieldByProperty;
			 }
			 return result;
		  }
		  static isJson(str) {
			 str = typeof str !== "string" ? JSON.stringify(str) : str;
			 if (str.startsWith("{")) {
				try {
				  str = JSON.parse(str);
				} catch (e) {
				  return false;
				}
				if (typeof str === "object" && str !== null && Object.keys(str).length > 0) {
				  return true;
				}
			 }
			 return false;
		  }
		  static getPropertiesInfo(finalProperty, assignmentOriginal, mapService) {
			 let result = [];
			 if (finalProperty && assignmentOriginal) {
				const finalPropertyKeys = Object.keys(finalProperty);
				const finalPropertyKeyValueMap = PlanningBoardCalculationUtilitiesService.objectToKeyValueMap(finalProperty);
				const finalPropertyKey = finalPropertyKeys.find((key) => key.toLowerCase() === mapService.assignmentTypeDescription(assignmentOriginal).toLowerCase()) || "";
				if ((0, import_lodash.isFunction)(mapService.assignmentTypeDescription) && mapService.assignmentTypeDescription(assignmentOriginal) && finalPropertyKeyValueMap.has(finalPropertyKey)) {
				  result = finalPropertyKeyValueMap.get(finalPropertyKey);
				} else {
				  const defaultJSONProp = finalPropertyKeys.find((key) => key.toLowerCase() === "Default".toLowerCase());
				  result = finalPropertyKeyValueMap.get(defaultJSONProp) || "";
				}
			 }
			 if (typeof result === "undefined") {
				result = [];
			 }
			 return result;
		  }
		  static getPhaseRequimentsProperty(assignmentOriginal, property, mapService) {
			 if (/[.]/.test(property.toLowerCase())) {
				const properties = property.split(".");
				if (properties.length === 2) {
				  const val = (0, import_lodash.isFunction)(mapService.valueToSelectedAggregation) ? mapService.valueToSelectedAggregation(assignmentOriginal, properties[0], properties[1]) : "";
				  return val;
				}
			 }
			 return null;
		  }
		  constructor() {
		  }
		  static {
			 this.\u0275fac = function PlanningBoardLabelConfigService_Factory(t) {
				return new (t || _PlanningBoardLabelConfigService)();
			 };
		  }
		  static {
			 this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _PlanningBoardLabelConfigService, factory: _PlanningBoardLabelConfigService.\u0275fac, providedIn: "root" });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlanningBoardLabelConfigService, [{
			 type: Injectable,
			 args: [{
				providedIn: "root"
			 }]
		  }], () => [], null);
		})();
		var PlanningBoardDialogConfigService = class {
		  constructor() {
			 const dialogConfigs = /* @__PURE__ */ new Map();
			 let dialogConfig;
			 this.setDialogConfig = (uuid, assignmentMappingService, demandMappingService) => {
				const labelInputs = {
				  main: {},
				  info1: {},
				  info2: {},
				  info3: {}
				};
				let labelLookupServiceName = "";
				if (assignmentMappingService && (0, import_lodash.isFunction)(assignmentMappingService.getLabelLookupServiceName)) {
				  labelLookupServiceName = assignmentMappingService.getLabelLookupServiceName();
				  PlanningBoardLabelConfigService.setDirectiveLabelDropDowns(labelInputs, labelLookupServiceName);
				} else {
				  PlanningBoardLabelConfigService.setTextLabelDropDowns(labelInputs);
				}
				if (!dialogConfig && !dialogConfigs.get(uuid)) {
				  if (assignmentMappingService) {
					 dialogConfig = getConfig(assignmentMappingService, labelInputs);
					 demandMappingService ? addGridFilterConfig(dialogConfig, demandMappingService) : false;
					 dialogConfigs.set(uuid, dialogConfig);
				  }
				} else if (assignmentMappingService && (0, import_lodash.isFunction)(assignmentMappingService.getExtraDropdownProperties)) {
				  dialogConfig = getConfig(assignmentMappingService, labelInputs);
				  demandMappingService ? addGridFilterConfig(dialogConfig, demandMappingService) : false;
				  dialogConfigs.set(uuid, dialogConfig);
				}
			 };
			 this.getDialogConfig = () => {
				return dialogConfig;
			 };
			 function addGridFilterConfig(dialogConfig2, demandMappingService) {
				if (demandMappingService && (0, import_lodash.isFunction)(demandMappingService.filterDemands)) {
				  const gridSettingsItem = dialogConfig2.items.find((item) => (0, import_lodash.isEqual)(item.id, "planningBoard.chart.gridSettings"));
				  gridSettingsItem.form.groups.push({
					 gid: "2",
					 header: "*Filter",
					 header$tr$: "platform.planningboard.filter",
					 isOpen: true,
					 visible: true,
					 sortOrder: 2
				  });
				  let sortOrder = 1;
				  gridSettingsItem.form.rows.push({
					 gid: "2",
					 rid: "filterDemands",
					 label: "*Filter Demands",
					 label$tr$: "platform.planningboard.filterDemands",
					 type: "boolean",
					 model: "filterDemands",
					 visible: true,
					 sortOrder: sortOrder++
				  });
				}
			 }
			 function getConfig(assignmentMappingService, labelInputs) {
				const getSumAggrgationLinePropertiesFn = assignmentMappingService.getSumAggrgationLineProperties;
				const properties = getSumAggrgationLinePropertiesFn ? getSumAggrgationLinePropertiesFn() : /* @__PURE__ */ new Map();
				let line1 = [];
				let line2 = [];
				let line3 = [];
				if (properties && properties.size !== 0) {
				  let line1Custom = properties.get("line1");
				  let line2Custom = properties.get("line2");
				  let line3Custom = properties.get("line3");
				  if (line1Custom) {
					 line1 = line1Custom;
				  }
				  if (line2Custom) {
					 line2 = line2Custom;
				  }
				  if (line3Custom) {
					 line3 = line3Custom;
				  }
				}
				const showLine1Property = line1.length > 0;
				const showLine2Property = line2.length > 0;
				const showLine3Property = line3.length > 0;
				let sumAggregationOptions = [
				  { value: "empty", id: "empty", caption: " " },
				  { value: "amount", id: "amount", caption: PlanningBoardExternalServices.PlatformTranslateService ? PlanningBoardExternalServices.PlatformTranslateService.instant("platform.planningboard.amount") : "*Amount" }
				];
				let backgroundColorOptions = [
				  { value: "default", id: "defaultcolor", caption: PlanningBoardExternalServices.PlatformTranslateService ? PlanningBoardExternalServices.PlatformTranslateService.instant("platform.planningboard.backgroundColorConfig.default") : "*Default" },
				  { value: "status", id: "statuscolor", caption: PlanningBoardExternalServices.PlatformTranslateService ? PlanningBoardExternalServices.PlatformTranslateService.instant("platform.planningboard.backgroundColorConfig.status") : "*Status" },
				  { value: "project", id: "projectcolor", caption: PlanningBoardExternalServices.PlatformTranslateService ? PlanningBoardExternalServices.PlatformTranslateService.instant("platform.planningboard.backgroundColorConfig.project") : "*Project" }
				];
				if ((0, import_lodash.isFunction)(assignmentMappingService.useCapacities) && assignmentMappingService.useCapacities()) {
				  const quantityOptions = [
					 { value: "targetValue", id: "targetValue", caption: PlanningBoardExternalServices.PlatformTranslateService ? PlanningBoardExternalServices.PlatformTranslateService.instant("platform.planningboard.targetValue") : "*targetValue" },
					 { value: "actualValue", id: "actualValue", caption: PlanningBoardExternalServices.PlatformTranslateService ? PlanningBoardExternalServices.PlatformTranslateService.instant("platform.planningboard.actualValue") : "*actualValue" },
					 { value: "residualValue", id: "residualValue", caption: PlanningBoardExternalServices.PlatformTranslateService ? PlanningBoardExternalServices.PlatformTranslateService.instant("platform.planningboard.residualValue") : "*residualValue" }
				  ];
				  sumAggregationOptions = [...sumAggregationOptions, ...quantityOptions];
				}
				if ((0, import_lodash.isFunction)(assignmentMappingService.getCustomAggregationDropdownOptions)) {
				  sumAggregationOptions = [...sumAggregationOptions, ...assignmentMappingService.getCustomAggregationDropdownOptions()];
				}
				if ((0, import_lodash.isFunction)(assignmentMappingService.getCustomBackgroundColorDropdownOptions)) {
				  backgroundColorOptions = [...backgroundColorOptions, ...assignmentMappingService.getCustomBackgroundColorDropdownOptions()];
				}
				let form = {
				  fid: "platform.planningBoard.configDetail",
				  version: "1.0.0",
				  showGrouping: true,
				  change: "change",
				  groups: [
					 {
						gid: "4",
						header: "*General",
						header$tr$: "platform.planningboard.general",
						isOpen: true,
						visible: true,
						sortOrder: 1
					 },
					 {
						gid: "7",
						header: "*Collection",
						header$tr$: "platform.planningboard.collection",
						isOpen: true,
						visible: true,
						sortOrder: 10
					 },
					 {
						gid: "1",
						header: "Assignment",
						header$tr$: "platform.planningboard.assignment",
						isOpen: true,
						visible: true,
						sortOrder: 20
					 },
					 {
						gid: "8",
						header: "*Aggregation",
						header$tr$: "platform.planningboard.aggregation",
						isOpen: true,
						visible: true,
						sortOrder: 25
					 },
					 {
						gid: "9",
						header: "*Sum Aggregation",
						header$tr$: "platform.planningboard.sumAggregation",
						isOpen: true,
						visible: true,
						sortOrder: 26
					 },
					 {
						gid: "5",
						header: "Tagging",
						header$tr$: "platform.planningboard.tagging",
						isOpen: true,
						visible: true,
						sortOrder: 30
					 },
					 {
						gid: "2",
						header: "Text",
						header$tr$: "platform.planningboard.text",
						isOpen: false,
						visible: true,
						sortOrder: 40
					 },
					 {
						gid: "3",
						header: "Misc",
						header$tr$: "platform.planningboard.misc",
						isOpen: false,
						visible: true,
						sortOrder: 50
					 },
					 {
						gid: "6",
						header: "*Zoom",
						header$tr$: "platform.planningboard.zoom",
						isOpen: false,
						visible: true,
						sortOrder: 60
					 },
					 {
						gid: "10",
						header: "*Aggregation Traffic Lights",
						header$tr$: "platform.planningboard.aggregationTrafficLightsConfig",
						isOpen: true,
						visible: true,
						sortOrder: 27
					 }
				  ],
				  rows: [
					 {
						gid: "1",
						rid: "ShowHeaderColor",
						label$tr$: "platform.planningboard.showHeaderColor",
						type: "boolean",
						model: "showHeaderColor",
						visible: true,
						sortOrder: 1
					 },
					 {
						gid: "1",
						rid: "ShowSameAssignments",
						label$tr$: "platform.planningboard.showSameAssignments",
						type: "boolean",
						model: "showSameAssignments",
						visible: true,
						sortOrder: 2
					 },
					 {
						gid: "1",
						rid: "ShowStatusIcon",
						label$tr$: "platform.planningboard.showStatusIcon",
						type: "boolean",
						model: "showStatusIcon",
						visible: true,
						sortOrder: 3
					 },
					 {
						gid: "1",
						rid: "showInTransportIcon",
						label$tr$: "platform.planningboard.showInTransportIcon",
						type: "boolean",
						model: "showInTransportIcon",
						visible: true,
						sortOrder: 4
					 },
					 {
						gid: "1",
						rid: "BackgroundColorConfig",
						label: "*Backgroundcolor",
						label$tr$: "platform.planningboard.setBackgroundColorConfig",
						type: "select",
						options: {
						  displayMember: "caption",
						  valueMember: "id",
						  items: backgroundColorOptions
						},
						model: "backgroundColorConfig",
						visible: true,
						sortOrder: 5,
						readonly: false
					 },
					 {
						gid: "1",
						rid: "ShowTypeIcon",
						label$tr$: "platform.planningboard.showTypeIcon",
						type: "boolean",
						model: "showTypeIcon",
						visible: true,
						sortOrder: 6
					 },
					 {
						gid: "1",
						rid: "IgnoreIsFullyCovered",
						label$tr$: "platform.planningboard.ignoreIsFullyCovered",
						// platform.planningboard.ignoreIsFullyCovered
						type: "boolean",
						model: "ignoreIsFullyCovered",
						visible: true,
						sortOrder: 7
					 },
					 {
						gid: "1",
						rid: "IgnoreIsNotFullyCovered",
						label$tr$: "platform.planningboard.ignoreIsNotFullyCovered",
						// platform.planningboard.ignoreIsNotFullyCovered
						type: "boolean",
						model: "ignoreIsNotFullyCovered",
						visible: true,
						sortOrder: 8
					 },
					 {
						gid: "1",
						rid: "useDemandTimesForReservation",
						label$tr$: "platform.planningboard.useDemandTimesForReservation",
						label: "*Use Demand Times For Reservation",
						type: "boolean",
						model: "useDemandTimesForReservation",
						visible: true,
						sortOrder: 9
					 },
					 {
						gid: "1",
						rid: "useFixedAssignmentHeight",
						label$tr$: "platform.planningboard.useFixedAssignmentHeight",
						label: "*Minimal Height",
						type: "boolean",
						model: "useFixedAssignmentHeight",
						visible: true,
						sortOrder: 10
					 },
					 {
						gid: "4",
						rid: "ShowHeaderBackground",
						label$tr$: "platform.planningboard.showHeaderBackground",
						type: "boolean",
						model: "showHeaderBackground",
						visible: true,
						sortOrder: 11
					 },
					 {
						gid: "4",
						rid: "ValidateAssignments",
						label$tr$: "platform.planningboard.validateAssignments",
						type: "boolean",
						model: "validateAssignments",
						visible: true,
						sortOrder: 15
					 },
					 {
						gid: "4",
						rid: "rowHeight",
						label$tr$: "platform.planningboard.rowHeight",
						type: "integer",
						model: "rowHeight",
						visible: true,
						sortOrder: 20,
						validator: (entity, modelValue, field) => {
						  if (modelValue > 0 && modelValue < window.innerHeight) {
							 entity[field] = modelValue;
						  } else {
							 entity[field] = 55;
						  }
						  return true;
						}
					 },
					 {
						gid: "4",
						rid: "showDemandPreview",
						label: "*Show Demand Preview",
						label$tr$: "platform.planningboard.demandpreview",
						type: "boolean",
						model: "showDemandPreview",
						visible: true,
						sortOrder: 16
					 },
					 {
						gid: "4",
						rid: "useFlexibleRowHeight",
						label: "*Flexible Row height",
						label$tr$: "platform.planningboard.flexibleRowHeight",
						type: "boolean",
						model: "useFlexibleRowHeight",
						visible: true,
						sortOrder: 17
					 },
					 {
						gid: "4",
						rid: "reloadOnChangeFullyCovered",
						label: "Reload on Change to fully covered",
						label$tr$: "platform.planningboard.reloadOnChangeFullyCovered",
						type: "boolean",
						model: "reloadOnChangeFullyCovered",
						visible: true,
						sortOrder: 18
					 },
					 {
						gid: "7",
						rid: "background",
						label$tr$: "platform.planningboard.background",
						label: "*Background",
						type: "color",
						model: "collectionConfig.background",
						visible: true,
						sortOrder: 1
					 },
					 {
						gid: "7",
						rid: "font",
						label$tr$: "platform.planningboard.font",
						label: "*Font",
						type: "color",
						model: "collectionConfig.font",
						visible: true,
						sortOrder: 2
					 },
					 {
						gid: "7",
						rid: "border",
						label$tr$: "platform.planningboard.border",
						label: "*Border",
						type: "color",
						model: "collectionConfig.border",
						visible: true,
						sortOrder: 3
					 },
					 {
						gid: "2",
						rid: "ShowMainText",
						label: "*Show Main Text",
						label$tr$: "platform.planningboard.showMainLabelText",
						type: "boolean",
						model: "showMainText",
						visible: true,
						sortOrder: 1
					 },
					 labelInputs.main,
					 {
						gid: "2",
						rid: "ShowInfo1Text",
						label$tr$: "platform.planningboard.showInfo1Text",
						type: "boolean",
						model: "showInfo1Text",
						visible: true,
						sortOrder: 3
					 },
					 labelInputs.info1,
					 {
						gid: "2",
						rid: "ShowInfo2Text",
						label$tr$: "platform.planningboard.showInfo2Text",
						type: "boolean",
						model: "showInfo2Text",
						visible: true,
						sortOrder: 5
					 },
					 labelInputs.info2,
					 {
						gid: "2",
						rid: "ShowInfo3Text",
						label$tr$: "platform.planningboard.showInfo3Text",
						type: "boolean",
						model: "showInfo3Text",
						visible: true,
						sortOrder: 7
					 },
					 labelInputs.info3,
					 {
						gid: "3",
						rid: "snapToDays",
						label$tr$: "platform.planningboard.snapToDays",
						type: "boolean",
						model: "snapToDays",
						visible: true,
						sortOrder: 1
					 },
					 {
						gid: "3",
						rid: "showExtendedDemands",
						label$tr$: "platform.planningboard.showExtendedDemands",
						type: "boolean",
						model: "showExtendedDemands",
						visible: true,
						sortOrder: 2
					 },
					 {
						gid: "4",
						rid: "useTaggingSystem",
						label$tr$: "platform.planningboard.useTaggingSystem",
						type: "boolean",
						model: "useTaggingSystem",
						visible: true,
						sortOrder: 1
					 },
					 {
						gid: "5",
						rid: "tagConfig",
						label$tr$: "platform.planningboard.tagConfig",
						type: "directive",
						directive: "platform-grid-form-control",
						options: {
						  height: "150px",
						  gridConfig: PlanningBoardTagGridConfigService.createTagGrid()
						},
						model: "tagConfig",
						visible: true,
						sortOrder: 2
					 },
					 {
						gid: "6",
						rid: "selectedZoomLevel",
						label$tr$: "platform.planningboard.setDefaultZoomLevel",
						label: "*Set Default Zoom Level",
						type: "select",
						options: {
						  displayMember: "caption",
						  valueMember: "id",
						  items: [
							 { value: 1, type: "month", id: "saveLastZoom", caption: PlanningBoardExternalServices.PlatformTranslateService ? PlanningBoardExternalServices.PlatformTranslateService.instant("platform.planningboard.saveLastZoom") : "*saveLastZoom" },
							 { value: 1, type: "week", id: "oneweek", caption: PlanningBoardExternalServices.PlatformTranslateService ? PlanningBoardExternalServices.PlatformTranslateService.instant("platform.planningboard.zoomOneWeek") : "*zoomOneWeek" },
							 { value: 2, type: "week", id: "twoweeks", caption: PlanningBoardExternalServices.PlatformTranslateService ? PlanningBoardExternalServices.PlatformTranslateService.instant("platform.planningboard.zoomTwoWeek") : "*zoomTwoWeek" },
							 { value: 1, type: "month", id: "onemonth", caption: PlanningBoardExternalServices.PlatformTranslateService ? PlanningBoardExternalServices.PlatformTranslateService.instant("platform.planningboard.zoomOneMonth") : "*zoomOneMonth" }
						  ]
						},
						model: "selectedZoomLevel",
						visible: true,
						sortOrder: 2,
						readonly: false,
						change: (entity) => {
						  if (entity.selectedZoomLevel.id === "saveLastZoom") {
							 entity.saveLastZoom = true;
						  } else {
							 entity.saveLastZoom = false;
						  }
						}
					 },
					 {
						gid: "8",
						rid: "showAggregations",
						label$tr$: "platform.planningboard.showAggregations",
						type: "boolean",
						model: "showAggregations",
						visible: true,
						sortOrder: 1
					 },
					 {
						gid: "8",
						rid: "useMinAggregation",
						label: "*Use Minimal Aggregation",
						label$tr$: "platform.planningboard.useMinAggregation",
						type: "boolean",
						model: "useMinAggregation",
						visible: true,
						sortOrder: 3
					 },
					 {
						gid: "8",
						rid: "minAggregationLevel",
						label: "*Set Min Aggregation Level",
						label$tr$: "platform.planningboard.setMinAggregationLevel",
						type: "select",
						options: {
						  displayMember: "caption",
						  valueMember: "id",
						  items: [
							 { value: 1, type: "hour", id: "onehour", caption: PlanningBoardExternalServices.PlatformTranslateService ? PlanningBoardExternalServices.PlatformTranslateService.instant("platform.planningboard.minAggregationLevel.hour") : "*hour" },
							 { value: 1, type: "day", id: "oneday", caption: PlanningBoardExternalServices.PlatformTranslateService ? PlanningBoardExternalServices.PlatformTranslateService.instant("platform.planningboard.minAggregationLevel.day") : "*day" },
							 { value: 1, type: "week", id: "oneweek", caption: PlanningBoardExternalServices.PlatformTranslateService ? PlanningBoardExternalServices.PlatformTranslateService.instant("platform.planningboard.minAggregationLevel.week") : "*week" },
							 { value: 1, type: "month", id: "onemonth", caption: PlanningBoardExternalServices.PlatformTranslateService ? PlanningBoardExternalServices.PlatformTranslateService.instant("platform.planningboard.minAggregationLevel.month") : "*month" }
						  ]
						},
						model: "minAggregationLevel",
						visible: true,
						sortOrder: 4,
						readonly: false
					 },
					 {
						gid: "9",
						rid: "showSumAggregations",
						label$tr$: "platform.planningboard.showSumAggregations",
						type: "boolean",
						model: "showSumAggregations",
						visible: true,
						sortOrder: 1
					 },
					 {
						gid: "9",
						rid: "sumAggregationLine1",
						label: "*Sum Aggregation Line 1 Properties",
						label$tr$: "platform.planningboard.sumAggregationsPropertiesLine1",
						type: "select",
						options: {
						  displayMember: "caption",
						  valueMember: "id",
						  items: line1
						},
						model: "sumAggregationPropertyLine1",
						sortOrder: 2,
						visible: showLine1Property
					 },
					 {
						gid: "9",
						rid: "sumAggregationLine1",
						label: "*Sum Aggregation Line 1",
						label$tr$: "platform.planningboard.sumAggregationLine1",
						type: "select",
						options: {
						  displayMember: "caption",
						  valueMember: "id",
						  items: sumAggregationOptions
						},
						model: "sumAggregationLine1",
						visible: true,
						sortOrder: 3,
						readonly: false
					 },
					 {
						gid: "9",
						rid: "sumAggregationLine2",
						label: "*Sum Aggregation Line 2 Properties",
						label$tr$: "platform.planningboard.sumAggregationsPropertiesLine2",
						type: "select",
						options: {
						  displayMember: "caption",
						  valueMember: "id",
						  items: line2
						},
						sortOrder: 4,
						visible: showLine2Property,
						model: "sumAggregationPropertyLine2"
					 },
					 {
						gid: "9",
						rid: "sumAggregationLine2",
						label: "*Sum Aggregation Line 2",
						label$tr$: "platform.planningboard.sumAggregationLine2",
						type: "select",
						options: {
						  displayMember: "caption",
						  valueMember: "id",
						  items: sumAggregationOptions
						},
						model: "sumAggregationLine2",
						visible: true,
						sortOrder: 5,
						readonly: false
					 },
					 {
						gid: "9",
						rid: "sumAggregationLine3",
						label: "*Sum Aggregation Line 3 Properties",
						label$tr$: "platform.planningboard.sumAggregationsPropertiesLine3",
						type: "select",
						options: {
						  displayMember: "caption",
						  valueMember: "id",
						  items: line3
						},
						sortOrder: 6,
						visible: showLine3Property,
						model: "sumAggregationPropertyLine3"
					 },
					 {
						gid: "9",
						rid: "sumAggregationLine3",
						label: "*Sum Aggregation Line 3",
						label$tr$: "platform.planningboard.sumAggregationLine3",
						type: "select",
						options: {
						  displayMember: "caption",
						  valueMember: "id",
						  items: sumAggregationOptions
						},
						model: "sumAggregationLine3",
						visible: true,
						sortOrder: 7,
						readonly: false
					 },
					 // underload
					 {
						gid: "10",
						rid: "underloadvalue",
						label$tr$: "platform.planningboard.underloadvalue",
						label: "*Underload Value",
						type: "integer",
						model: "aggregationTrafficLightsValuesConfig.underload",
						visible: true,
						sortOrder: 1
					 },
					 {
						gid: "10",
						rid: "underload",
						label$tr$: "platform.planningboard.underload",
						label: "*Underload",
						type: "color",
						model: "aggregationTrafficLightsConfig.underload",
						visible: true,
						sortOrder: 2
					 },
					 // goodload
					 {
						gid: "10",
						rid: "goodloadvalue",
						label$tr$: "platform.planningboard.goodloadvalue",
						label: "*Good Load Value",
						type: "integer",
						model: "aggregationTrafficLightsValuesConfig.goodload",
						visible: true,
						sortOrder: 3
					 },
					 {
						gid: "10",
						rid: "goodload",
						label$tr$: "platform.planningboard.goodload",
						label: "*Good Load",
						type: "color",
						model: "aggregationTrafficLightsConfig.goodload",
						visible: true,
						sortOrder: 4
					 },
					 // maxload
					 {
						gid: "10",
						rid: "maxloadvalue",
						label$tr$: "platform.planningboard.maxloadvalue",
						label: "*Maxload Value",
						type: "integer",
						model: "aggregationTrafficLightsValuesConfig.maxload",
						visible: true,
						sortOrder: 5
					 },
					 {
						gid: "10",
						rid: "maxload",
						label$tr$: "platform.planningboard.maxload",
						label: "*Max Load",
						type: "color",
						model: "aggregationTrafficLightsConfig.maxload",
						visible: true,
						sortOrder: 6
					 },
					 // overload
					 {
						gid: "10",
						rid: "overloadvalue",
						label$tr$: "platform.planningboard.overloadvalue",
						label: "*Overload Value",
						type: "integer",
						model: "aggregationTrafficLightsValuesConfig.overload",
						visible: true,
						sortOrder: 7
					 },
					 {
						gid: "10",
						rid: "overload",
						label$tr$: "platform.planningboard.overload",
						label: "*Overload",
						type: "color",
						model: "aggregationTrafficLightsConfig.overload",
						visible: true,
						sortOrder: 8
					 }
				  ]
				};
				let dialogConfig2 = {
				  dialogTitle: "platform.planningboard.configDialog",
				  itemDisplayMember: "description",
				  resizeable: true,
				  width: 800,
				  height: 500,
				  items: [
					 {
						id: "planningBoard.chart.presentation.settings",
						version: "1.0.0",
						description: PlanningBoardExternalServices.PlatformTranslateService ? PlanningBoardExternalServices.PlatformTranslateService.instant("platform.planningboard.chartPresentation") : "*chartPresentation",
						form
					 },
					 {
						id: "planningBoard.chart.gridSettings",
						version: "1.0.0",
						description: PlanningBoardExternalServices.PlatformTranslateService ? PlanningBoardExternalServices.PlatformTranslateService.instant("platform.planningboard.gridSettings") : "*gridSettings",
						form: {
						  fid: "platform.planningBoard.gridSettings",
						  version: "1.0.0",
						  showGrouping: true,
						  groups: [
							 {
								gid: "1",
								header$tr$: "platform.planningboard.validation",
								isOpen: true,
								visible: true,
								sortOrder: 1
							 }
						  ],
						  rows: [
							 {
								gid: "1",
								rid: "ValidateDemandAgainstSuppliers",
								label$tr$: "platform.planningboard.validateSelectedDemand",
								type: "boolean",
								model: "validateDemandAgainstSuppliers",
								visible: true,
								sortOrder: 1
							 }
						  ]
						}
					 }
				  ]
				};
				return dialogConfig2;
			 }
		  }
		};
		var PlanningBoardAssignmentTagComponentConstants;
		(function(PlanningBoardAssignmentTagComponentConstants2) {
		  PlanningBoardAssignmentTagComponentConstants2[PlanningBoardAssignmentTagComponentConstants2["marginLeft"] = 12] = "marginLeft";
		  PlanningBoardAssignmentTagComponentConstants2[PlanningBoardAssignmentTagComponentConstants2["tagHeight"] = 12] = "tagHeight";
		  PlanningBoardAssignmentTagComponentConstants2[PlanningBoardAssignmentTagComponentConstants2["tagWidth"] = 12] = "tagWidth";
		  PlanningBoardAssignmentTagComponentConstants2[PlanningBoardAssignmentTagComponentConstants2["tagWidthBig"] = 20] = "tagWidthBig";
		  PlanningBoardAssignmentTagComponentConstants2["defaultTagColor"] = "rgba(180,180,180)";
		  PlanningBoardAssignmentTagComponentConstants2["defaultEmptyColor"] = "rgba(100,100,100, .7)";
		})(PlanningBoardAssignmentTagComponentConstants || (PlanningBoardAssignmentTagComponentConstants = {}));
		var PlanningBoardCollisionService = class {
		  constructor(assignmentMappingService) {
			 const TAG_COMPONENT_HEIGHT = PlanningBoardAssignmentTagComponentConstants.tagHeight;
			 let items = /* @__PURE__ */ new Map(), collisionMaxHeight = 0, collisionId = 0, collisionFixedAssignmentNumber = 0, collisionUseFixedAssignmentHeight = false;
			 this.clearAll = () => {
				items = /* @__PURE__ */ new Map();
				collisionMaxHeight = 0;
				collisionFixedAssignmentNumber = 0;
				collisionId = 0;
			 };
			 this.setMaxHeight = (mh) => {
				collisionMaxHeight = mh;
			 };
			 this.setAssignmentsNumberInRow = (count) => {
				collisionFixedAssignmentNumber = count;
			 };
			 this.setUseFixedAssignmentHeight = (value) => {
				collisionUseFixedAssignmentHeight = value;
			 };
			 this.setDefaultItemValues = (group) => {
				group.filter((item) => {
				  item.collisionData.scale = 1;
				  item.collectionData.isVerticallyCollected = false;
				  item.collisionData.collisionId = 0;
				  item.collisionData.top = 0;
				  item.collisionData.collisions = [];
				  item.collisionData._collisionsArray = [];
				  item.collisionData._assignmentHeight = 0;
				  item.collisionData._rowId = 0;
				  item.collisionData._start = assignmentMappingService.from(item.originalEntity).getTime();
				  item.collisionData._end = assignmentMappingService.to(item.originalEntity).getTime();
				  item.collisionData._scalabelCollisionsCount = 1;
				});
			 };
			 let maxAssignmentsInRow = 1;
			 this.addItems = (group) => {
				maxAssignmentsInRow = Math.floor(collisionMaxHeight / TAG_COMPONENT_HEIGHT);
				calculateCollisions(group);
				calculateScalableCollisionsCount(group);
				group.forEach((item) => {
				  updateMinScaleAndRow(item);
				});
				group.forEach((item) => {
				  if (item.collisionData.scale === 1 && item.collisionData._collisionsArray.length > 1) {
					 const collisionsOfCollisions = PlanningBoardCalculationUtilitiesService.getDistinctArray(item.collisionData._collisionsArray.flatMap((x) => x.collisionData._collisionsArray));
					 item.collisionData.scale = PlanningBoardCalculationUtilitiesService.getMin(PlanningBoardCalculationUtilitiesService.getDistinctArray(collisionsOfCollisions.map((assignment) => assignment.collisionData.scale)));
				  }
				  if (!items.has(assignmentMappingService.id(item.originalEntity))) {
					 const intArray = [...Array(item.collisionData.collisions.length).keys()];
					 item.collisionData._rowId = intArray.find((x) => !item.collisionData._collisionsArray.filter((x2) => assignmentMappingService.id(x2.originalEntity) !== assignmentMappingService.id(item.originalEntity)).map((y) => y.collisionData._rowId).includes(x)) || 0;
				  }
				});
				group.filter((item) => {
				  if (collisionUseFixedAssignmentHeight && item.collisionData._rowId >= collisionFixedAssignmentNumber) {
					 item.collectionData.isVerticallyCollected = true;
				  } else {
					 updateHeight(item);
					 updateTop(item, item.collisionData._rowId);
				  }
				  if (item.collisionData.collisions.length > 0) {
					 item.collisionData.collisions = item.collisionData._collisionsArray.map((collision) => {
						return assignmentMappingService.id(collision.originalEntity) ? assignmentMappingService.id(collision.originalEntity) : -1;
					 });
				  } else {
					 item.collisionData.collisions = [];
				  }
				});
			 };
			 function calculateCollisions(group) {
				group.forEach((i) => {
				  const iId = assignmentMappingService.id(i.originalEntity);
				  i.collisionData._collisionsArray.push(i);
				  group.forEach((item) => {
					 const itemId = assignmentMappingService.id(item.originalEntity);
					 if (areColliding(item, i) && iId !== itemId) {
						i.collisionData._collisionsArray.push(item);
						item.collisionData._collisionsArray.push(i);
					 }
				  });
				});
				group.filter((item) => {
				  item.collisionData._collisionsArray = [...new Map(item.collisionData._collisionsArray.map((x) => [assignmentMappingService.id(x.originalEntity), x])).values()];
				});
			 }
			 function calculateScalableCollisionsCount(group) {
				if (!collisionUseFixedAssignmentHeight) {
				  const unevenlyColliding = group.filter((item) => PlanningBoardCalculationUtilitiesService.getMax(item.collisionData._collisionsArray.map((x) => x.collisionData._collisionsArray.length)) !== PlanningBoardCalculationUtilitiesService.getMin(item.collisionData._collisionsArray.map((x) => x.collisionData._collisionsArray.length)));
				  unevenlyColliding.forEach((item) => {
					 item.collisionData._scalabelCollisionsCount = PlanningBoardCalculationUtilitiesService.getMin(item.collisionData._collisionsArray.map((x) => x.collisionData._collisionsArray.length));
					 item.collisionData._collisionsArray.forEach((col) => col.collisionData._scalabelCollisionsCount = item.collisionData._scalabelCollisionsCount);
				  });
				} else {
				  group.forEach((item) => item.collisionData._scalabelCollisionsCount = collisionFixedAssignmentNumber + 1);
				}
			 }
			 function calculateScale(basis2, collisionCount) {
				let visibleColCount = maxAssignmentsInRow < collisionCount ? maxAssignmentsInRow : collisionCount;
				return basis2 / visibleColCount;
			 }
			 function areColliding(i1, i2) {
				return i1.collisionData._end > i2.collisionData._start && i1.collisionData._start < i2.collisionData._end;
			 }
			 function updateHeight(item) {
				if (collisionUseFixedAssignmentHeight && item.collisionData.scale > 1 / collisionFixedAssignmentNumber) {
				  item.collisionData._assignmentHeight = collisionMaxHeight / collisionFixedAssignmentNumber;
				} else {
				  item.collisionData._assignmentHeight = collisionMaxHeight * item.collisionData.scale;
				}
				if (!item.collectionData.isVerticallyCollected && item.collisionData._rowId + 1 > maxAssignmentsInRow) {
				  item.collectionData.isVerticallyCollected = true;
				}
			 }
			 function updateTop(item, row) {
				row = isNaN(row) ? 0 : row;
				item.collisionData._rowId = row;
				item.collisionData.top = row * item.collisionData._assignmentHeight;
			 }
			 function getMaxCollidingItem(collisions) {
				const maxCollisionsCount = PlanningBoardCalculationUtilitiesService.getMax(collisions.map((x) => x.collisionData._collisionsArray.length));
				const maxCollidingItem = collisions.find((collidingItem) => collidingItem.collisionData._collisionsArray.length === maxCollisionsCount);
				return maxCollidingItem;
			 }
			 function updateMinScaleAndRow(item) {
				if (!items.has(assignmentMappingService.id(item.originalEntity))) {
				  const maxCollidingItem = getMaxCollidingItem(item.collisionData._collisionsArray);
				  if (maxCollidingItem === item) {
					 let scale = collisionUseFixedAssignmentHeight ? calculateScale(1, collisionFixedAssignmentNumber) : 1;
					 const row = 0;
					 if (item.collisionData._collisionsArray.length > 1) {
						let _scalabelCollisionsCount = PlanningBoardCalculationUtilitiesService.getMax(item.collisionData._collisionsArray.map((x) => x.collisionData._scalabelCollisionsCount));
						if (collisionUseFixedAssignmentHeight) {
						  _scalabelCollisionsCount = collisionFixedAssignmentNumber;
						}
						scale = calculateScale(1, _scalabelCollisionsCount);
						const minScale = PlanningBoardCalculationUtilitiesService.getMin(item.collisionData._collisionsArray.map((x) => x.collisionData.scale));
						if (minScale < scale) {
						  scale = minScale;
						}
						const intArray = [...Array(item.collisionData._collisionsArray.length).keys()];
						let otherCollisions = item.collisionData._collisionsArray.filter((x) => assignmentMappingService.id(x.originalEntity) !== assignmentMappingService.id(item.originalEntity));
						otherCollisions = otherCollisions.sort((a, b) => b.collisionData._collisionsArray.length - a.collisionData._collisionsArray.length);
						otherCollisions.forEach((otherItem) => {
						  let otherId = assignmentMappingService.id(otherItem.originalEntity);
						  if (otherId !== assignmentMappingService.id(item.originalEntity) && !items.has(otherId)) {
							 otherItem.collisionData._rowId = 0;
							 let rowIdAlreadySet = new Map(otherItem.collisionData._collisionsArray.map((y) => [y.collisionData._rowId, y.collisionData._rowId]));
							 let isAlreadySet = false;
							 for (let i = 0; !isAlreadySet && i < intArray.length; i++) {
								if (!rowIdAlreadySet.has(intArray[i])) {
								  otherItem.collisionData._rowId = intArray[i];
								  isAlreadySet = true;
								}
							 }
							 if (otherItem.collisionData._rowId >= _scalabelCollisionsCount && !collisionUseFixedAssignmentHeight) {
								scale = calculateScale(1, otherItem.collisionData._rowId + 1);
							 }
							 otherItem.collisionData._collisionsArray.forEach((x) => x.collisionData.scale = scale);
							 items.set(otherId, otherItem);
						  }
						});
					 }
					 item.collisionData.scale = scale;
					 item.collisionData._rowId = row;
					 items.set(assignmentMappingService.id(item.originalEntity), item);
				  }
				}
			 }
		  }
		};
		var PlanningBoardValidationService = class {
		  constructor(assignmentMappingService, supplierMappingService, demandMappingService) {
			 let suppliers = [];
			 const mappingServices = {
				assignment: assignmentMappingService,
				supplier: supplierMappingService,
				demand: demandMappingService
			 };
			 this.validateEntityAgainstSupplier = (entity, type2, supplierId, pbGridDefaultSettingForValidation) => {
				const result = new Result();
				const idMapFn = supplierMappingService.actualId || supplierMappingService.id;
				if ((0, import_lodash.isNil)(supplierId)) {
				  return result;
				}
				const supplier = suppliers.find((supplier2) => idMapFn(supplier2) === supplierId);
				if (!(0, import_lodash.isFunction)(mappingServices.supplier.validateWith)) {
				  console.warn("There is no validateWith method in mappingServices.supplier.");
				  return result;
				}
				const supplierValidationArray = mappingServices.supplier.validateWith(supplier, pbGridDefaultSettingForValidation);
				if ((type2 === "assignment" || type2 === "demand") && !(0, import_lodash.isFunction)(mappingServices[type2].validateAgainst)) {
				  console.warn("There is no validateAgainst method in mappingServices." + type2 + ".");
				  return result;
				}
				const entityValidationArray = type2 === "assignment" || type2 === "demand" ? mappingServices[type2].validateAgainst(entity, pbGridDefaultSettingForValidation) : null;
				if ((0, import_lodash.isNull)(entityValidationArray)) {
				  return result;
				}
				if (!(0, import_lodash.isNull)(entityValidationArray) && (0, import_lodash.isNull)(supplierValidationArray)) {
				  (0, import_lodash.forEach)(entityValidationArray, (entity2) => {
					 if (entity2 && (type2 === "supplier" || type2 === "demand") && callMappingFnByEntityType(type2, entity2, "isMandatory")) {
						result.isValid = false;
						result.invalidItems.push(entity2);
					 }
				  });
				  return result;
				}
				if (entityValidationArray.length > 0 && supplierValidationArray.length > 0) {
				  if ((0, import_lodash.isFunction)(mappingServices.demand.compareWith)) {
					 let providedList = supplierValidationArray.filter((entity2) => callMappingFnByEntityType("supplier", entity2, "isMandatory"));
					 let requiredList = entityValidationArray.filter((entity2) => callMappingFnByEntityType(type2, entity2, "isMandatory"));
					 for (let i = 0; i < requiredList.length; i++) {
						let requiredSkill = requiredList[i];
						let coveredBy = providedList.find((providedSkill) => {
						  return mappingServices.demand.compareWith(requiredSkill, providedSkill);
						});
						if (typeof coveredBy === "undefined") {
						  result.isValid = false;
						  result.invalidItems.push(requiredSkill);
						}
					 }
				  } else {
					 if (entityValidationArray.length > 0 && supplierValidationArray.length > 0) {
						const entityValidationIds = (0, import_lodash.map)(entityValidationArray, (entity2) => {
						  return callMappingFnByEntityType(type2, entity2, "id");
						});
						const supplierValidationIds = (0, import_lodash.map)(supplierValidationArray, (validation) => {
						  return callMappingFnByEntityType("supplier", validation, "id");
						});
						const diffIds = (0, import_lodash.difference)(entityValidationIds, supplierValidationIds);
						if (diffIds.length > 0) {
						  (0, import_lodash.forEach)(diffIds, (id3) => {
							 const invalidItem = (0, import_lodash.find)(entityValidationArray, function(validation) {
								return id3 === callMappingFnByEntityType(type2, validation, "id");
							 });
							 if (invalidItem) {
								result.invalidItems.push(invalidItem);
								if (result.isValid === true) {
								  result.isValid = !callMappingFnByEntityType("demand", invalidItem, "isMandatory");
								}
							 }
						  });
						}
					 }
				  }
				}
				return result;
			 };
			 this.validateSelectedAgainstList = (item, entities, itemType, entityType, pbGridDefaultSettingForValidation) => {
				const validItemList = [];
				let validationArray = [];
				if (!(0, import_lodash.isFunction)(mappingServices.demand.validateAgainst)) {
				  console.warn("There is no validateAgainst method in mappingServices.demand.");
				  return entities;
				}
				if (!(0, import_lodash.isFunction)(mappingServices.supplier.validateWith)) {
				  console.warn("There is no validateWith method in mappingServices.supplier.");
				  return entities;
				}
				if (itemType === "supplier") {
				  validationArray = mappingServices.supplier.validateWith(item, pbGridDefaultSettingForValidation);
				  if ((0, import_lodash.isNull)(validationArray)) {
					 validationArray = [];
				  }
				} else if (itemType === "demand") {
				  validationArray = mappingServices.demand.validateAgainst(item, pbGridDefaultSettingForValidation);
				  if ((0, import_lodash.isNull)(validationArray)) {
					 validationArray = [];
				  }
				} else {
				  console.warn("There is no [" + itemType + "] type for this validation.");
				  return entities;
				}
				if (validationArray.length === 0) {
				  return entities;
				}
				entities.forEach((entity) => {
				  let entityArray = [];
				  if (entityType === "supplier") {
					 entityArray = entityArray = mappingServices.supplier.validateWith(entity, pbGridDefaultSettingForValidation);
					 mappingServices.supplier.validateWith(entity, pbGridDefaultSettingForValidation);
				  } else if (entityType === "demand") {
					 entityArray = mappingServices.demand.validateAgainst(entity, pbGridDefaultSettingForValidation);
				  }
				  const mandatoryIndex = (0, import_lodash.findIndex)(validationArray, (validation) => {
					 return callMappingFnByEntityType(itemType, validation, "isMandatory");
				  });
				  if (mandatoryIndex < 0) {
					 validItemList.push(entity);
				  } else {
					 entityArray = entityArray.filter((entity2) => callMappingFnByEntityType(entityType, entity2, "isMandatory"));
					 validationArray = validationArray.filter((entity2) => callMappingFnByEntityType(itemType, entity2, "isMandatory"));
					 if ((0, import_lodash.isFunction)(mappingServices.demand.compareWith)) {
						let requiredList = itemType === "demand" ? validationArray : entityArray;
						let providedList = entityType === "supplier" ? entityArray : validationArray;
						for (let i = 0; i < requiredList.length; i++) {
						  let requiredSkill = requiredList[i];
						  let coveredBy = (0, import_lodash.find)(providedList, (providedSkill) => {
							 return mappingServices.demand.compareWith(requiredSkill, providedSkill);
						  });
						  if (typeof coveredBy === "undefined") {
							 return;
						  }
						}
						validItemList.push(entity);
					 } else {
						const entityValidationIds = (0, import_lodash.map)(entityArray, (entity2) => {
						  return callMappingFnByEntityType(entityType, entity2, "id");
						});
						const itemValidationIds = (0, import_lodash.map)(validationArray, (validation) => {
						  return callMappingFnByEntityType(itemType, validation, "id");
						});
						const diffIds = (0, import_lodash.difference)(itemValidationIds, entityValidationIds);
						if (diffIds.length === 0) {
						  validItemList.push(entity);
						}
					 }
				  }
				});
				return validItemList;
			 };
			 this.setSuppliers = (values) => {
				suppliers = values;
			 };
			 this.supplierMapService = () => {
				return mappingServices.supplier;
			 };
			 this.assignmentMapService = () => {
				return mappingServices.assignment;
			 };
			 this.demandMapService = () => {
				return mappingServices.demand;
			 };
			 function callMappingFnByEntityType(entityType, entity, fnName) {
				let value;
				let fnRef;
				switch (entityType) {
				  case "assignment":
					 const assignment = entity;
					 let castAssignmentFnName = fnName;
					 fnRef = mappingServices.assignment[castAssignmentFnName];
					 value = fnRef(assignment);
					 break;
				  case "demand":
					 const demand = entity;
					 let castDemandFnName = fnName;
					 fnRef = mappingServices.demand[castDemandFnName];
					 value = fnRef(demand);
					 break;
				  case "supplier":
					 const supplier = entity;
					 let castSupplierFnName = fnName;
					 fnRef = mappingServices.supplier[castSupplierFnName];
					 value = fnRef(supplier);
					 break;
				  default:
					 break;
				}
				return value;
			 }
		  }
		};
		var Result = class {
		  constructor() {
			 this.isValid = true;
			 this.invalidItems = [];
		  }
		};
		var PlanningBoardLevelOfDetailService = class {
		  constructor(assignmentMappinService) {
			 let assignmentCollections = /* @__PURE__ */ new Map();
			 let collectPixelLimit = 15;
			 this.isCollected = (isCollectedDataInterface) => {
				const assignment = checkAssignmentLevelOfDetail(isCollectedDataInterface);
				if (assignment !== false) {
				  const supplier = assignmentMappinService.supplier(assignment.originalEntity);
				  const collectionStart = assignment.collectionData.collectionStart.valueOf();
				  if (!assignmentCollections.has(supplier + collectionStart)) {
					 assignmentCollections.set(supplier + collectionStart, []);
				  }
				  assignmentCollections.get(supplier + collectionStart).push(isCollectedDataInterface.assignment);
				  return true;
				}
				return false;
			 };
			 this.getAssignmentCollections = () => {
				return [...assignmentCollections.values()];
			 };
			 this.clearAssignmentCollections = () => {
				assignmentCollections = /* @__PURE__ */ new Map();
			 };
			 function checkAssignmentLevelOfDetail(isCollectedDataInterface) {
				const onePixelRatio = isCollectedDataInterface.panelWidth / isCollectedDataInterface.calendarDiffSeconds;
				const assignmentDuration = (assignmentMappinService.to(isCollectedDataInterface.assignment.originalEntity).getTime() - assignmentMappinService.from(isCollectedDataInterface.assignment.originalEntity).getTime()) / 1e3;
				const assignmentPixel = assignmentDuration * onePixelRatio;
				if (assignmentPixel < collectPixelLimit || isCollectedDataInterface.assignment.collectionData.isVerticallyCollected) {
				  isCollectedDataInterface.assignment.collectionData.collectionStart = isCollectedDataInterface.assignmentTickStart;
				  return isCollectedDataInterface.assignment;
				} else {
				  return false;
				}
			 }
		  }
		};
		var PlanningBoardSettingsList = class {
		  constructor(planningBoardSettingsList) {
			 this["planningBoard.chart.presentation.settings"] = new PlanningBoardChartPresentationSettings();
			 this["planningBoard.chart.gridSettings"] = new PlanningBoardChartGridSettings();
			 if (planningBoardSettingsList) {
				this["planningBoard.chart.presentation.settings"] = new PlanningBoardChartPresentationSettings(planningBoardSettingsList["planningBoard.chart.presentation.settings"]);
				this["planningBoard.chart.gridSettings"] = new PlanningBoardChartGridSettings(planningBoardSettingsList["planningBoard.chart.gridSettings"]);
			 }
		  }
		};
		var PlanningBoardChartPresentationSettings = class {
		  //#endregion default values
		  constructor(chartPresentationSettings) {
			 this.mainInfoLabel = "Description";
			 this.info1Label = "InfoField1";
			 this.info2Label = "InfoField2";
			 this.info3Label = "InfoField3";
			 this.showHeaderBackground = true;
			 this.validateAssignments = true;
			 this.showDemandPreview = false;
			 this.useFlexibleRowHeight = false;
			 this.rowHeight = 55;
			 this.useTaggingSystem = true;
			 this.showExtendedDemands = true;
			 this.showSameAssignments = true;
			 this.showMainText = true;
			 this.showInfo1Text = true;
			 this.showInfo2Text = true;
			 this.showInfo3Text = true;
			 this.showHeaderColor = true;
			 this.backgroundColorConfig = {
				type: "default",
				id: "defaultcolor",
				caption: PlanningBoardExternalServices.PlatformTranslateService ? PlanningBoardExternalServices.PlatformTranslateService.instant("platform.planningboard.backgroundColorConfig.default") : "*Default"
			 };
			 this.showStatusIcon = true;
			 this.showInTransportIcon = true;
			 this.showTypeIcon = true;
			 this.showAggregations = false;
			 this.showSumAggregations = false;
			 this.sumAggregationLine1 = {
				value: "empty",
				id: "empty",
				caption: " "
			 };
			 this.sumAggregationLine2 = {
				value: "actualValue",
				id: "actualValue",
				caption: PlanningBoardExternalServices.PlatformTranslateService ? PlanningBoardExternalServices.PlatformTranslateService.instant("platform.planningboard.actualValue") : "*Actual Value"
			 };
			 this.sumAggregationLine3 = {
				value: "empty",
				id: "empty",
				caption: " "
			 };
			 this.sumAggregationPropertyLine1 = {
				value: "empty",
				id: "empty",
				caption: " "
			 };
			 this.sumAggregationPropertyLine2 = {
				value: "empty",
				id: "empty",
				caption: " "
			 };
			 this.sumAggregationPropertyLine3 = {
				value: "empty",
				id: "empty",
				caption: " "
			 };
			 this.useMinAggregation = false;
			 this.saveLastZoom = false;
			 this.minAggregationLevel = {
				value: 1,
				type: "hour",
				id: "onehour",
				caption: PlanningBoardExternalServices.PlatformTranslateService ? PlanningBoardExternalServices.PlatformTranslateService.instant("platform.planningboard.minAggregationLevel.hour") : "*hour"
			 };
			 this.selectedZoomLevel = {
				value: 1,
				type: "month",
				id: "onemonth",
				caption: PlanningBoardExternalServices.PlatformTranslateService ? PlanningBoardExternalServices.PlatformTranslateService.instant("platform.planningboard.zoomOneMonth") : "*One Month"
			 };
			 this.collectionConfig = {
				"background": 16777215,
				// '#FFFFFF'
				"font": 0,
				// '#000000'
				"border": 0
				// '#000000'
			 };
			 this.useDemandTimesForReservation = false;
			 this.aggregationTrafficLightsConfig = {
				"underload": 1552423,
				// '#17B027'
				"goodload": 14840846,
				// '#E2740E'
				"maxload": 14031900,
				// '#D61C1C'
				"overload": 7537154
				// '#730202'
			 };
			 this.aggregationTrafficLightsValuesConfig = {
				"underload": 50,
				// 0-50
				"goodload": 90,
				// 51-90
				"maxload": 100,
				// 91-100
				"overload": 110
				// 101-110
			 };
			 this.useFixedAssignmentHeight = false;
			 this.tagConfig = [{
				id: "project",
				name: PlanningBoardExternalServices.PlatformTranslateService ? PlanningBoardExternalServices.PlatformTranslateService.instant("platform.planningboard.project") : "*Project",
				color: "#FFFFFF",
				customColor: false,
				icon: false,
				visible: true,
				sort: 0
			 }, {
				id: "status",
				name: PlanningBoardExternalServices.PlatformTranslateService ? PlanningBoardExternalServices.PlatformTranslateService.instant("platform.planningboard.status") : "*Status",
				color: "#FFFFFF",
				customColor: false,
				icon: true,
				visible: true,
				sort: 1
			 }, {
				id: "type",
				name: PlanningBoardExternalServices.PlatformTranslateService ? PlanningBoardExternalServices.PlatformTranslateService.instant("platform.planningboard.type") : "*Type",
				color: "#786735",
				customColor: true,
				icon: true,
				visible: true,
				sort: 2
			 }, {
				id: "validation",
				name: PlanningBoardExternalServices.PlatformTranslateService ? PlanningBoardExternalServices.PlatformTranslateService.instant("platform.planningboard.validation") : "*Validation",
				color: "#FFFFFF",
				customColor: false,
				icon: true,
				visible: true,
				sort: 3
			 }];
			 this.rowHeightAssignments = 50;
			 this.snapToDays = false;
			 this.reloadOnChangeFullyCovered = false;
			 this.ignoreIsNotFullyCovered = false;
			 this.ignoreIsFullyCovered = false;
			 if (chartPresentationSettings) {
				this.showHeaderBackground = chartPresentationSettings.showHeaderBackground;
				this.validateAssignments = chartPresentationSettings.validateAssignments;
				this.showSameAssignments = chartPresentationSettings.showSameAssignments;
				this.showDemandPreview = chartPresentationSettings.showDemandPreview;
				this.useFlexibleRowHeight = chartPresentationSettings.useFlexibleRowHeight;
				this.rowHeight = chartPresentationSettings.rowHeight;
				this.useTaggingSystem = chartPresentationSettings.useTaggingSystem;
				this.showExtendedDemands = chartPresentationSettings.showExtendedDemands;
				this.showMainText = chartPresentationSettings.showMainText;
				this.showInfo1Text = chartPresentationSettings.showInfo1Text;
				this.showInfo2Text = chartPresentationSettings.showInfo2Text;
				this.showInfo3Text = chartPresentationSettings.showInfo3Text;
				this.mainInfoLabel = chartPresentationSettings.mainInfoLabel;
				this.info1Label = chartPresentationSettings.info1Label;
				this.info2Label = chartPresentationSettings.info2Label;
				this.info3Label = chartPresentationSettings.info3Label;
				this.showHeaderColor = chartPresentationSettings.showHeaderColor;
				this.backgroundColorConfig = chartPresentationSettings.backgroundColorConfig;
				this.showStatusIcon = chartPresentationSettings.showStatusIcon;
				this.showTypeIcon = chartPresentationSettings.showTypeIcon;
				this.showAggregations = chartPresentationSettings.showAggregations;
				this.showSumAggregations = chartPresentationSettings.showSumAggregations;
				this.useMinAggregation = chartPresentationSettings.useMinAggregation;
				this.sumAggregationLine1 = chartPresentationSettings.sumAggregationLine1;
				this.sumAggregationLine2 = chartPresentationSettings.sumAggregationLine2;
				this.sumAggregationLine3 = chartPresentationSettings.sumAggregationLine3;
				this.sumAggregationPropertyLine1 = chartPresentationSettings.sumAggregationPropertyLine1;
				this.sumAggregationPropertyLine2 = chartPresentationSettings.sumAggregationPropertyLine2;
				this.sumAggregationPropertyLine3 = chartPresentationSettings.sumAggregationPropertyLine3;
				this.minAggregationLevel = chartPresentationSettings.minAggregationLevel;
				this.saveLastZoom = chartPresentationSettings.saveLastZoom;
				this.selectedZoomLevel = chartPresentationSettings.selectedZoomLevel;
				this.collectionConfig = chartPresentationSettings.collectionConfig;
				this.useDemandTimesForReservation = chartPresentationSettings.useDemandTimesForReservation;
				this.aggregationTrafficLightsConfig = chartPresentationSettings.aggregationTrafficLightsConfig;
				this.aggregationTrafficLightsValuesConfig = chartPresentationSettings.aggregationTrafficLightsValuesConfig;
				this.useFixedAssignmentHeight = chartPresentationSettings.useFixedAssignmentHeight;
				this.tagConfig = chartPresentationSettings.tagConfig;
				this.rowHeightAssignments = chartPresentationSettings.rowHeightAssignments ? chartPresentationSettings.rowHeightAssignments : 50;
				this.snapToDays = chartPresentationSettings.snapToDays;
				this.reloadOnChangeFullyCovered = chartPresentationSettings.reloadOnChangeFullyCovered;
				this.ignoreIsNotFullyCovered = chartPresentationSettings.ignoreIsNotFullyCovered;
				this.ignoreIsFullyCovered = chartPresentationSettings.ignoreIsFullyCovered;
			 }
		  }
		};
		var PlanningBoardChartGridSettings = class {
		  constructor(chartGridSettings) {
			 if (chartGridSettings) {
				this.validateDemandAgainstSuppliers = chartGridSettings.validateDemandAgainstSuppliers instanceof Function ? chartGridSettings.validateDemandAgainstSuppliers() : chartGridSettings.validateDemandAgainstSuppliers;
				this.filterDemands = chartGridSettings.filterDemands instanceof Function ? chartGridSettings.filterDemands() : chartGridSettings.filterDemands;
			 }
		  }
		};
		var PlanningBoardConfigService = class {
		  constructor(planningBoardDataService) {
			 let mainViewService = PlanningBoardExternalServices.mainViewService;
			 let platformMasterDetailDialogService = PlanningBoardExternalServices.UiCommonDialogService;
			 let platformGridAPI = PlanningBoardExternalServices.platformGridAPI;
			 let PlatformMessenger = PlanningBoardExternalServices.PlatformMessenger;
			 let $translate = PlanningBoardExternalServices.PlatformTranslateService;
			 const self2 = this;
			 let delayedSaveTimeout;
			 let containerUUID;
			 self2.onSettingsChanged = new PlatformMessenger();
			 self2.onSettingsChangedStarted = new PlatformMessenger();
			 self2.registerOnSettingsChanged = (fn) => {
				self2.onSettingsChanged.register(fn);
			 };
			 self2.unregisterOnSettingsChanged = (fn) => {
				self2.onSettingsChanged.unregister(fn);
			 };
			 self2.registerOnSettingsChangedStarted = (fn) => {
				self2.onSettingsChangedStarted.register(fn);
			 };
			 self2.unregisterOnSettingsChangedStarted = (fn) => {
				self2.onSettingsChangedStarted.unregister(fn);
			 };
			 const defaultValues = new PlanningBoardSettingsList();
			 let defaultValuesByUUID = /* @__PURE__ */ new Map();
			 self2.getUUID = function getUUID(uuid) {
				if (uuid) {
				  containerUUID = uuid;
				}
				return containerUUID;
			 };
			 self2.getConfigByUUID = (containerUUID2, assignmentMappingService, demandMappingService) => {
				planningBoardDataService.getHelperServices().dialogConfigService.setDialogConfig(containerUUID2, assignmentMappingService, demandMappingService);
				let dialogConfig = planningBoardDataService.getHelperServices().dialogConfigService.getDialogConfig();
				self2.getUUID(containerUUID2);
				let settings = mainViewService.customData(containerUUID2, "planningBoardSettings");
				mainViewService.customData(containerUUID2, "planningBoardSettings", settings);
				(0, import_lodash.forEach)(dialogConfig.items, function(dconfig) {
				  if (defaultValuesByUUID.get(containerUUID2)?.hasOwnProperty(dconfig.id)) {
					 (0, import_lodash.assign)(dconfig, defaultValuesByUUID.get(containerUUID2)[dconfig.id]);
				  }
				});
				if ((0, import_lodash.isUndefined)(settings)) {
				  settings = prepareCustomData(dialogConfig.items);
				  mainViewService.customData(containerUUID2, "planningBoardSettings", settings);
				} else {
				  meregeNewSettings(settings, defaultValuesByUUID.get(containerUUID2)["planningBoard.chart.presentation.settings"]);
				}
				let tagConfig = defaultValuesByUUID.get(containerUUID2)["planningBoard.chart.presentation.settings"].tagConfig;
				(0, import_lodash.forEach)(tagConfig, function(config2) {
				  config2.name = $translate.instant((0, import_lodash.find)(tagConfig, { id: config2.id }).name);
				});
				return convertSettingsArrayToObject(settings);
			 };
			 function meregeNewSettings(settings, defaultValues2) {
				function recursiveSettingMerge(mergedSettings, savedSettings) {
				  if (!(0, import_lodash.isArray)(mergedSettings) && !(0, import_lodash.isObject)(mergedSettings)) {
					 mergedSettings = savedSettings;
				  } else {
					 let defaultMerged = /* @__PURE__ */ new Map();
					 let savedMerged = /* @__PURE__ */ new Map();
					 if ((0, import_lodash.isArray)(mergedSettings)) {
						defaultMerged = new Map(mergedSettings.map((value, index) => [value.id || index, value]));
						savedMerged = new Map(savedSettings.map((value, index) => [value.id || index, value]));
					 } else {
						defaultMerged = new Map(Object.entries(mergedSettings));
						savedMerged = new Map(Object.entries(savedSettings));
					 }
					 for (let [key, val] of defaultMerged) {
						if (savedMerged.has(key)) {
						  mergedSettings[key] = recursiveSettingMerge(val, savedMerged.get(key));
						}
					 }
				  }
				  return mergedSettings;
				}
				;
				const flatSettingList = settings.reduce((r, c2) => Object.assign(r, c2), {});
				let mergedSetting = recursiveSettingMerge((0, import_lodash.cloneDeep)(defaultValues2), flatSettingList);
				mergedSetting["id"] = "planningBoard.chart.presentation.settings";
				return mergedSetting;
			 }
			 self2.show = (containerUUID2) => {
				let dialogConfig = planningBoardDataService.getHelperServices().dialogConfigService.getDialogConfig();
				const assignmentMappingService = PlanningBoardDataServiceInterfaceService.getPlanningBoardDataServiceByUUID(containerUUID2).getAssignmentConfig().mappingService;
				const planningBoardSettingsList = self2.getConfigByUUID(containerUUID2, assignmentMappingService);
				const dialogConfigItemsMap = new Map(dialogConfig.items.map((x) => [x.id, x]));
				const supplierConfig = PlanningBoardDataServiceInterfaceService.getPlanningBoardDataServiceByUUID(containerUUID2).getSupplierConfig();
				if (planningBoardSettingsList) {
				  (0, import_lodash.each)(planningBoardSettingsList, function(planningBoardSetting, index) {
					 Object.assign(dialogConfigItemsMap.get(index), planningBoardSetting);
					 const confMap = PlanningBoardCalculationUtilitiesService.objectToKeyValueMap(dialogConfigItemsMap.get(index));
					 if (confMap.has("tagConfig")) {
						setTagConfigForGrid(confMap.get("tagConfig"));
						confMap.get("tagConfig").state = PlanningBoardTagGridConfigService.uuid;
					 }
				  });
				} else {
				  Object.assign(dialogConfigItemsMap.get("planningBoard.chart.presentation.settings"), defaultValuesByUUID.get(containerUUID2));
				}
				addCustomSupplierConfig(dialogConfig, supplierConfig);
				return platformMasterDetailDialogService.show(dialogConfig).then(function(result) {
				  if (result.ok === true) {
					 const customData = prepareCustomData(result.value.items);
					 return saveContainerCustomData(containerUUID2, customData);
				  }
				}, function(result) {
				  if (result === "cancel") {
					 platformGridAPI.grids.unregister(PlanningBoardTagGridConfigService.uuid);
				  }
				});
			 };
			 self2.updateSettingsRowHeight = (containerUUID2, newLineHeight) => {
				clearTimeout(delayedSaveTimeout);
				delayedSaveTimeout = setTimeout(delayedSaveSetting, 300, containerUUID2, newLineHeight);
			 };
			 self2.prepareCustomDataAndSaveSettings = (settingsList, containerUUID2, saveOnly) => {
				const customData = prepareCustomData(settingsList);
				return saveContainerCustomData(containerUUID2, customData, saveOnly);
			 };
			 function addCustomSupplierConfig(dialogConfig, supplierConfig) {
				const gridSettings = (0, import_lodash.find)(dialogConfig.items, { id: "planningBoard.chart.gridSettings" });
				if (!(0, import_lodash.isNil)(gridSettings) && !(0, import_lodash.isNil)(supplierConfig.customSupplierConfig) && !(0, import_lodash.isNil)(supplierConfig.customSupplierConfig.rows)) {
				  gridSettings.form.rows = (0, import_lodash.unionBy)(gridSettings.form.rows, supplierConfig.customSupplierConfig.rows);
				}
			 }
			 function saveContainerCustomData(containerUUID2, customData, saveOnly) {
				if (!saveOnly) {
				  self2.onSettingsChangedStarted.fire(convertSettingsArrayToObject(customData), containerUUID2);
				}
				return mainViewService.customData(containerUUID2, "planningBoardSettings", customData).then(function() {
				  if (!saveOnly) {
					 self2.onSettingsChanged.fire(convertSettingsArrayToObject(customData), containerUUID2);
				  }
				});
			 }
			 function delayedSaveSetting(containerUUID2, newLineHeight) {
				const assignmentMappingService = PlanningBoardDataServiceInterfaceService.getPlanningBoardDataServiceByUUID(containerUUID2).getAssignmentConfig().mappingService;
				const planningBoardSettingsList = self2.getConfigByUUID(containerUUID2, assignmentMappingService);
				if (planningBoardSettingsList) {
				  planningBoardSettingsList["planningBoard.chart.presentation.settings"].rowHeight = newLineHeight;
				  return saveContainerCustomData(containerUUID2, planningBoardSettingsList);
				}
			 }
			 function prepareCustomData(changedSettingsList) {
				if (changedSettingsList) {
				  const chartSettingsList = (0, import_lodash.cloneDeep)(changedSettingsList);
				  const settings2Save = [];
				  (0, import_lodash.each)(chartSettingsList, function prepareCustomData2(chartSetting) {
					 delete chartSetting.form;
					 delete chartSetting.$$hashKey;
					 settings2Save.push(chartSetting);
				  });
				  return settings2Save;
				}
				return [];
			 }
			 function setTagConfigForGrid(config2) {
				const data = [];
				(0, import_lodash.forEach)(config2, function(d, idx) {
				  if (idx !== "state") {
					 data.push(d);
				  }
				});
				if (platformGridAPI.grids.exist(PlanningBoardTagGridConfigService.uuid)) {
				  PlanningBoardTagGridConfigService.updateData(data, platformGridAPI);
				}
			 }
			 self2.getDefaultConfigValues = (uuid) => {
				if (uuid) {
				  return (0, import_lodash.cloneDeep)(defaultValuesByUUID.get(uuid));
				}
				return (0, import_lodash.cloneDeep)(defaultValues);
			 };
			 self2.setDefaultConfigValues = (customDefaultValues, uuid) => {
				defaultValuesByUUID.set(uuid, customDefaultValues);
			 };
			 function convertSettingsArrayToObject(configListArr) {
				return Object.fromEntries(configListArr.map((prop) => [prop.id, prop]));
			 }
			 return self2;
		  }
		};
		var CustomSubject = class _CustomSubject {
		  //#region private functions
		  _subscribeToSubject(subFnsToAdd) {
			 const fnsToAdd = subFnsToAdd.filter((fn) => !this._subjectSubscribers.has(fn));
			 const fnsAlreadySubcribing = subFnsToAdd.filter((fn) => this._subjectSubscribers.has(fn));
			 this._subscribingError(fnsAlreadySubcribing);
			 const createdSubscriptions = /* @__PURE__ */ new Map();
			 fnsToAdd.forEach((subFnToAdd) => {
				const createdSubscription = this._subject$.subscribe((...values) => {
				  subFnToAdd(...values.flatMap((value) => value));
				});
				this._subjectSubscribers.set(subFnToAdd, createdSubscription);
				createdSubscriptions.set(subFnToAdd, createdSubscription);
			 });
			 return createdSubscriptions;
		  }
		  _subscribingError(alreadySubscribingFns) {
			 if (alreadySubscribingFns.length > 0) {
				let self2 = this;
				console.warn(`Errors when trying to subscribe to subject ${Object.keys({ self: self2 })[0]}:`);
				alreadySubscribingFns.forEach((errorFn) => {
				  console.warn(`Function ${errorFn.name} is already a subcriber!`);
				});
			 }
		  }
		  _unsubscribeFromSubject(listOfUnsubcribing) {
			 const fnsNeverSubcribing = listOfUnsubcribing.filter((fn) => !this._subjectSubscribers.has(fn));
			 this._unsubscribingError(fnsNeverSubcribing);
			 listOfUnsubcribing.forEach((unsubFn) => {
				this._subjectSubscribers.get(unsubFn)?.unsubscribe();
			 });
			 return fnsNeverSubcribing;
		  }
		  _unsubscribingError(neverSubscribingFns) {
			 if (neverSubscribingFns.length > 0) {
				const self2 = this;
				console.warn(`Errors when trying to unsubscribe to subject ${Object.keys({ self: self2 })[0]}:`);
				neverSubscribingFns.forEach((errorFn) => {
				  console.warn(`Function ${errorFn.name} is not a subcriber!`);
				});
			 }
		  }
		  _triggerTheSubject(triggerFn, ...values) {
			 const self2 = this;
			 if (!self2._subjectSubscribers.has(triggerFn)) {
				self2._subject$.next(values);
				return true;
			 } else {
				console.warn(`Errors when trying to trigger the subject ${Object.keys({ self: self2 })[0]}:`);
				console.warn(`Function ${triggerFn.name} is already a subcriber. Function cannot subscribe and trigger the same subject!`);
			 }
			 return false;
		  }
		  //#endregion private functions
		  constructor() {
			 this._subject$ = new Subject();
			 this._subjectSubscribers = /* @__PURE__ */ new Map();
			 this.subscribe = this._subscribeToSubject;
			 this.unsubscribe = this._unsubscribeFromSubject;
			 this.isSubscribing = this._subjectSubscribers.has;
			 this.fire = this._triggerTheSubject;
		  }
		  static {
			 this.\u0275fac = function CustomSubject_Factory(t) {
				return new (t || _CustomSubject)();
			 };
		  }
		  static {
			 this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _CustomSubject, factory: _CustomSubject.\u0275fac, providedIn: PlanningBoardDataService });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CustomSubject, [{
			 type: Injectable,
			 args: [{
				providedIn: PlanningBoardDataService
			 }]
		  }], () => [], null);
		})();
		var SubjectManagmentService = class {
		  constructor() {
			 this.onSettingsChanged$ = new CustomSubject();
			 this.onSettingsChangedStarted$ = new CustomSubject();
			 this.onPlanningBoardDataLoaded$ = new CustomSubject();
			 this.onLoadedCalendarOnly$ = new CustomSubject();
			 this.onPlanningBoardRedraw$ = new CustomSubject();
			 this.onAssignmentDataLoaded$ = new CustomSubject();
			 this.onAssignmentCreated$ = new CustomSubject();
			 this.onAssignmentChanged$ = new CustomSubject();
			 this.onAssignmentDeleted$ = new CustomSubject();
			 this.onAssignmentDragEnd$ = new CustomSubject();
			 this.onAdaptHeadersDone$ = new CustomSubject();
			 this.onPlaceholderHeightCorrectionDone$ = new CustomSubject();
			 this.onPlaceholderHeightCorrectionStart$ = new CustomSubject();
			 this.onCalendarClicked$ = new CustomSubject();
			 this.onCalendarDragStepChanged$ = new CustomSubject();
			 this.onMouseZoom$ = new CustomSubject();
			 this.onWindowResized$ = new CustomSubject();
			 this.onSupplierSortOrFilter$ = new CustomSubject();
			 this.onUpdatePlanningBoardCanvasSizeDone$ = new CustomSubject();
			 this.onAssignmentFilterButtonClicked$ = new CustomSubject();
			 this.onAssignmentFilterSearchChanged$ = new CustomSubject();
			 this.onAssignmentFilterUpdateDone$ = new CustomSubject();
			 this.onShowAssignmentFilterPanel$ = new CustomSubject();
			 this.onExternalUpdateDone$ = new CustomSubject();
		  }
		};
		var PlanningBoardDataService = class PlanningBoardDataService2 {
		  constructor(containerLink, additionalServices) {
			 const planningBoardConfigService = new PlanningBoardConfigService(this);
			 const chartBaseComponent = PlanningBoardChartbaseComponent.chartbase();
			 const eventHandligSubjectService = new SubjectManagmentService();
			 this.sharedData = {};
			 this.sharedData.status = "";
			 this.sharedData.defaultFooterHeight = 0;
			 let currentCalendarConfig = {
				value: 1,
				type: "month",
				id: "onemonth",
				caption: PlanningBoardExternalServices.PlatformTranslateService ? PlanningBoardExternalServices.PlatformTranslateService.instant("platform.planningboard.zoomOneMonth") : "Month"
			 };
			 let dateStart = DateExtension.utc(new DateExtension()).startOf(currentCalendarConfig.type);
			 let dateEnd = new DateExtension(dateStart).add(currentCalendarConfig.value, "month");
			 let lastGridStartDate, lastGridEndDate;
			 let assignmentMapInitialized = false;
			 let extendedDemandsLoaded;
			 let lastDemandDateStart;
			 let lastDemandDateEnd;
			 let busyOverlay;
			 let isCalendarLocked = false;
			 let timeaxis;
			 let verticalIndex;
			 const defaultAggregationHeight = 20;
			 let viewportHeightOnlyTmp = 0;
			 let currentDimensions = { height: 0, width: 0 };
			 let OnZoomTimeOut;
			 const msZoomTimeOut = 150;
			 let helperServices;
			 const infoChangedMessenger = new PlanningBoardExternalServices.PlatformMessenger();
			 let unRegisterFn;
			 this.exceptionDays = [];
			 this.weekDays = [];
			 this.suppliers = [];
			 this.demands = [];
			 this.assignments = /* @__PURE__ */ new Map();
			 this.deletedAssignments = /* @__PURE__ */ new Map();
			 this.assignmentStatusItems = [];
			 this.assignmentTypeItems = [];
			 this.assignmentAvailableStatusMatrix = /* @__PURE__ */ new Map();
			 this.supplierCapacityPerBaseUnit = {};
			 const setInitialValues = () => {
				this.exceptionDays = [];
				this.weekDays = [];
				this.suppliers = [];
				this.demands = [];
				this.assignments = /* @__PURE__ */ new Map();
				this.deletedAssignments = /* @__PURE__ */ new Map();
				this.assignmentStatusItems = [];
				this.assignmentTypeItems = [];
				this.assignmentAvailableStatusMatrix = /* @__PURE__ */ new Map();
				this.supplierCapacityPerBaseUnit = {};
			 };
			 const defaultPlanningBoardMode = {
				"id": "",
				"actionType": "setDefault"
			 };
			 this.sharedData.planningBoardMode = defaultPlanningBoardMode;
			 this.sharedData.activeSearchMode = "";
			 let options;
			 this.registerPlanningBoardEvents = (planningBoardOptions) => {
				if (planningBoardOptions.registerOnMainDataServiceReload) {
				  registerMainDataServiceReload();
				}
				registerUpdateDone();
				if (planningBoardOptions.demand && !planningBoardOptions.demand.demandDependOnExternal || !planningBoardOptions.demand) {
				  registerSupplierListLoaded();
				}
				registerAssignmentListLoaded();
				registerSelectedAssignmentChanged();
				this.registerSelectionChanged = this.assignmentDataService.registerSelectionChanged;
				this.unregisterSelectionChanged = this.assignmentDataService.unregisterSelectionChanged;
			 };
			 function unshiftIfNotExists(arr, newElement) {
				if (Array.isArray(arr) && newElement && newElement.id && !arr.some((e) => e.id === newElement.id)) {
				  arr.splice(3, 0, newElement);
				}
			 }
			 this.setPlanningBoardScopeProperties = (planningBoardOptions, scope) => {
				if (planningBoardOptions && scope) {
				  if (!(0, import_lodash.isNil)(planningBoardOptions.dateShift)) {
					 this.sharedData.dateShiftConfig = planningBoardOptions.dateShift;
				  }
				  if (!(0, import_lodash.isUndefined)(planningBoardOptions.toolbarConfig)) {
					 this.sharedData.toolbarConfig = planningBoardOptions.toolbarConfig;
					 if ((0, import_lodash.isFunction)(this.sharedData.toolbarConfig.customTools)) {
						this.sharedData.toolbarConfig.customTools(planningBoardOptions.uuid).then(function(tools) {
						  if ((0, import_lodash.isUndefined)(scope.tools)) {
							 scope.setTools({
								showImages: true,
								showTitles: true,
								cssClass: "tools",
								items: tools
							 });
						  } else {
							 const toolsFromConatinerLink = scope.tools.items;
							 if ((0, import_lodash.isArray)(tools)) {
								tools.forEach((tool) => unshiftIfNotExists(toolsFromConatinerLink, tool));
							 } else {
								unshiftIfNotExists(toolsFromConatinerLink, tools);
							 }
						  }
						  scope.tools.update();
						});
					 }
				  }
				  this.sharedData.defaultFooterHeight = 40;
				}
				this.sharedData.planningBoardMode = {
				  "id": "",
				  "actionType": "setDefault"
				};
				const uiAddOns = scope.getUiAddOns();
				busyOverlay = uiAddOns.getBusyOverlay();
				const demandMappingService = !!options.demandConfig && options.demandConfig.mappingService;
				updatePlanningBoardSettings(planningBoardOptions.uuid, options.assignmentConfig.mappingService, demandMappingService ? demandMappingService : void 0);
			 };
			 this.setPlanningBoardConfiguration = function setPlanningBoardConfiguration(planningBoardOptions, scope) {
				setInitialValues();
				let tempOptions = {
				  planningBoardSettingsList: {},
				  uuid: "",
				  timeScale: void 0,
				  supplierConfig: planningBoardOptions.supplier,
				  assignmentConfig: planningBoardOptions.assignment,
				  toolbarConfig: void 0
				};
				options = tempOptions;
				if (!(0, import_lodash.isNil)(planningBoardOptions.demand)) {
				  options.demandConfig = planningBoardOptions.demand;
				}
				this.sharedData.defaultFooterHeight = 40;
				let defaultConfigValues = planningBoardConfigService.getDefaultConfigValues();
				const assignmentMappingService = options.assignmentConfig.mappingService;
				if ((0, import_lodash.isFunction)(assignmentMappingService.manipulateDefaultConfigValues)) {
				  const customConfigValues = assignmentMappingService.manipulateDefaultConfigValues(defaultConfigValues);
				  planningBoardConfigService.setDefaultConfigValues(customConfigValues, planningBoardOptions.uuid);
				} else {
				  defaultConfigValues = planningBoardConfigService.getDefaultConfigValues();
				  planningBoardConfigService.setDefaultConfigValues(defaultConfigValues, planningBoardOptions.uuid);
				}
				const demandMappingService = !!options.demandConfig && options.demandConfig.mappingService;
				this.timeScaleDataService = planningBoardOptions.timeScale;
				this.supplierDataService = options.supplierConfig.dataService;
				if (!(0, import_lodash.isNil)(options.demandConfig)) {
				  this.demandDataService = options.demandConfig.dataService;
				}
				this.assignmentDataService = options.assignmentConfig.dataService;
				options.supplierConfig.toolbarItemsDisabled = true;
				options.supplierConfig.skipToolbarCreation = true;
				if (!(0, import_lodash.isNil)(options.demandConfig)) {
				  options.demandConfig.toolbarItemsDisabled = true;
				  options.demandConfig.skipToolbarCreation = true;
				}
				if (!(0, import_lodash.isNil)(planningBoardOptions.dateShift)) {
				  options.dateShift = planningBoardOptions.dateShift;
				  scope.dateShiftConfig = options.dateShift;
				}
				helperServices = {
				  aggregationService: new PlanningBoardAggregationService(this),
				  dialogConfigService: new PlanningBoardDialogConfigService(),
				  assignmentCollisionService: new PlanningBoardCollisionService(this.getAssignmentConfig().mappingService),
				  validationService: new PlanningBoardValidationService(this.getAssignmentConfig().mappingService, this.getSupplierConfig().mappingService, this.getDemandConfig() ? this.getDemandConfig().mappingService : void 0),
				  levelOfDetailService: new PlanningBoardLevelOfDetailService(this.getAssignmentConfig().mappingService),
				  eventHandligSubjectService
				};
				if (!(0, import_lodash.isUndefined)(planningBoardOptions.toolbarConfig)) {
				  this.sharedData.toolbarConfig = planningBoardOptions.toolbarConfig;
				  if ((0, import_lodash.isFunction)(this.sharedData.toolbarConfig.customTools)) {
					 this.sharedData.toolbarConfig.customTools().then(function(tools) {
						if ((0, import_lodash.isUndefined)(scope.tools)) {
						  scope.setTools({
							 showImages: true,
							 showTitles: true,
							 cssClass: "tools",
							 items: tools
						  });
						} else {
						  if ((0, import_lodash.isArray)(tools)) {
							 tools.forEach((e) => unshiftIfNotExists(scope.tools.items, e));
						  } else {
							 unshiftIfNotExists(scope.tools.items, tools);
						  }
						}
						scope.tools.update();
					 });
				  }
				}
				updatePlanningBoardSettings(planningBoardOptions.uuid, options.assignmentConfig.mappingService, demandMappingService ? demandMappingService : void 0);
				this.registerSelectionChanged = this.assignmentDataService.registerSelectionChanged;
				this.unregisterSelectionChanged = this.assignmentDataService.unregisterSelectionChanged;
				if (this.assignmentDataService.getContainerData) {
				  this.assignmentDataService.getContainerData()["supportUpdateOnSelectionChanging"] = false;
				}
				const uiAddOns = scope.getUiAddOns();
				busyOverlay = uiAddOns.getBusyOverlay();
				busyOverlay.setVisible(true);
				this.load();
				this.registerPlanningBoardEvents(planningBoardOptions);
			 };
			 const updatePlanningBoardSettings = (uuid, assignmentMappingService, demandMappingService) => {
				const configList = planningBoardConfigService.getConfigByUUID(uuid, assignmentMappingService, demandMappingService);
				options.planningBoardSettingsList = configList;
				if (!_getSettingValue("backgroundColorConfig")) {
				  this.backgroundColorConfig();
				}
				if (!(0, import_lodash.isUndefined)(configList) && !(0, import_lodash.isUndefined)(configList["planningBoard.chart.presentation.settings"].selectedZoomLevel)) {
				  let startOfType = configList["planningBoard.chart.presentation.settings"].selectedZoomLevel.type;
				  let durationType = configList["planningBoard.chart.presentation.settings"].selectedZoomLevel.type;
				  dateStart = DateExtension.utc(new DateExtension()).startOf(startOfType);
				  dateEnd = new DateExtension(dateStart).add(configList["planningBoard.chart.presentation.settings"].selectedZoomLevel.value, durationType);
				  this.setCurrentZoomLevel(null, null, configList["planningBoard.chart.presentation.settings"].selectedZoomLevel);
				}
				applyPlanningBoardSettings(configList);
			 };
			 this.onParentServiceUpdateDone = () => {
				assignmentMapInitialized = false;
				clearModifications();
				this.loadRest().then(function() {
				  infoChangedMessenger.fire();
				});
			 };
			 const registerMainDataServiceReload = () => {
				findParentDataService(this.assignmentDataService);
				this.parentDataService.registerListLoaded(reloadPlanningBoard);
			 };
			 this.unregisterParentDataServiceListLoadStarted = function unregisterParentDataServiceListLoadStarted() {
				if (this.parentDataService) {
				  this.parentDataService.unregisterListLoaded(reloadPlanningBoard);
				}
			 };
			 const findParentDataService = (serv) => {
				if (serv.parentService() === null) {
				  this.parentDataService = serv;
				} else {
				  findParentDataService(serv.parentService());
				}
			 };
			 const registerSupplierListLoaded = () => {
				this.supplierDataService.registerListLoaded(supplierListChanged);
			 };
			 this.unregisterSupplierListLoaded = function unregisterSupplierListLoaded() {
				this.supplierDataService.unregisterListLoaded(supplierListChanged);
			 };
			 const registerSelectedAssignmentChanged = () => {
				if ((0, import_lodash.isFunction)(this.assignmentDataService.registerSelectedAssignmentChanged)) {
				  this.assignmentDataService.registerSelectedAssignmentChanged(this.planningBoardReDraw);
				}
			 };
			 this.unregisterSelectedAssignmentChanged = function unregisterSelectedAssignmentChanged() {
				if ((0, import_lodash.isFunction)(this.assignmentDataService.unregisterSelectedAssignmentChanged)) {
				  this.assignmentDataService.unregisterSelectedAssignmentChanged(this.planningBoardReDraw);
				}
			 };
			 const registerAssignmentListLoaded = () => {
				this.assignmentDataService.registerListLoaded(this.planningBoardReDraw);
			 };
			 this.unregisterAssignmentListLoaded = function unregisterAssignmentListLoaded() {
				this.assignmentDataService.unregisterListLoaded(this.planningBoardReDraw);
			 };
			 const registerUpdateDone = () => {
				unRegisterFn = additionalServices.mainContainerLink.$on("updateDone", this.onParentServiceUpdateDone);
			 };
			 this.unregisterUpdateDone = function unregisterUpdateDone() {
				if ((0, import_lodash.isFunction)(unRegisterFn)) {
				  unRegisterFn();
				}
			 };
			 const clearModifications = () => {
				this.assignments.clear();
				this.deletedAssignments.clear();
				PlanningBoardExternalServices.platformDataServiceModificationTrackingExtension.clearModificationsInRoot(this.assignmentDataService);
			 };
			 function applyPlanningBoardSettings(configList) {
				options.supplierConfig.planningBoardSettingsList = configList;
				options.planningBoardSettingsList = configList;
			 }
			 const loadDemands = (loadExtended, reloadAll) => {
				let demandDateStart = new DateExtension(dateStart);
				let demandDateEnd = new DateExtension(dateEnd);
				if (loadExtended) {
				  demandDateStart = demandDateStart.add(-4, "week");
				  demandDateEnd = demandDateEnd.add(4, "week");
				}
				if (reloadAll || (0, import_lodash.isUndefined)(lastDemandDateStart) || (lastDemandDateStart.diff(dateStart, "days") > 0 || lastDemandDateEnd.diff(dateEnd, "days") < 0) || extendedDemandsLoaded !== loadExtended) {
				  lastDemandDateStart = demandDateStart;
				  lastDemandDateEnd = demandDateEnd;
				  extendedDemandsLoaded = loadExtended;
				  this.demandDataService.setFilter({ From: demandDateStart.format(), To: demandDateEnd.format() });
				  return this.demandDataService.load().then(() => {
					 this.demands = this.demandDataService.getList().map((originalDemandEntity) => new DemandData(originalDemandEntity));
				  });
				} else {
				  return resolvePromise();
				}
			 };
			 const onSettingsChanged = (configList, uuid) => {
				if (uuid === containerLink.getContainerUUID()) {
				  if (!(0, import_lodash.isNil)(options.demandConfig) && extendedDemandsLoaded !== configList["planningBoard.chart.presentation.settings"].showExtendedDemands) {
					 loadDemands(configList["planningBoard.chart.presentation.settings"].showExtendedDemands, true);
				  }
				  if (!(0, import_lodash.isNil)(options.planningBoardSettingsList)) {
					 const currentSettings = options.planningBoardSettingsList;
					 if (!currentSettings["planningBoard.chart.presentation.settings"].selectedZoomLevel || configList["planningBoard.chart.presentation.settings"].selectedZoomLevel.id !== "saveLastZoom" && currentSettings["planningBoard.chart.presentation.settings"].selectedZoomLevel.id !== configList["planningBoard.chart.presentation.settings"].selectedZoomLevel.id) {
						this.setCurrentZoomLevel(null, null, configList["planningBoard.chart.presentation.settings"].selectedZoomLevel);
						currentSettings["planningBoard.chart.presentation.settings"].saveLastZoom = configList["planningBoard.chart.presentation.settings"].saveLastZoom;
						const value = configList["planningBoard.chart.presentation.settings"].selectedZoomLevel.value;
						const startOfType = configList["planningBoard.chart.presentation.settings"].selectedZoomLevel.type;
						const durationType = configList["planningBoard.chart.presentation.settings"].selectedZoomLevel.type;
						dateStart = dateStart.startOf(startOfType);
						dateEnd = new DateExtension(dateStart).add(value, durationType);
						this.planningBoardReDraw();
						this.loadRest();
					 } else {
						currentSettings["planningBoard.chart.presentation.settings"].saveLastZoom = configList["planningBoard.chart.presentation.settings"].saveLastZoom;
					 }
				  }
				  applyPlanningBoardSettings(configList);
				  PlanningBoardExternalServices.platformGridAPI.grids.unregister(PlanningBoardTagGridConfigService.uuid);
				}
			 };
			 const calcFlexibleRowHeight = (size = 1) => {
				let gridHeight = 0;
				const currentSettings = options.planningBoardSettingsList;
				if (size === 0) {
				  return currentSettings["planningBoard.chart.presentation.settings"].rowHeight;
				}
				if (!PlanningBoardExternalServices.platformGridAPI.grids.getGridState(this.getSupplierConfig().uuid).viewportHeight) {
				  gridHeight = viewportHeightOnlyTmp === 0 ? containerLink.getCurrentDimensions().height : viewportHeightOnlyTmp;
				} else {
				  gridHeight = PlanningBoardExternalServices.platformGridAPI.grids.getGridState(this.getSupplierConfig().uuid).viewportHeight.height;
				}
				return Math.ceil(gridHeight / size) <= currentSettings["planningBoard.chart.presentation.settings"].rowHeight ? currentSettings["planningBoard.chart.presentation.settings"].rowHeight : Math.ceil(gridHeight / size);
			 };
			 const onSettingsChangedStarted = (configList, uuid) => {
				if (uuid === containerLink.getContainerUUID()) {
				  switch (configList["planningBoard.chart.presentation.settings"].selectedZoomLevel.id) {
					 case "onemonth":
						configList["planningBoard.chart.presentation.settings"].selectedZoomLevel.value = 1;
						configList["planningBoard.chart.presentation.settings"].selectedZoomLevel.type = "month";
						break;
					 case "oneweek":
						configList["planningBoard.chart.presentation.settings"].selectedZoomLevel.value = 1;
						configList["planningBoard.chart.presentation.settings"].selectedZoomLevel.type = "week";
						break;
					 case "twoweeks":
						configList["planningBoard.chart.presentation.settings"].selectedZoomLevel.value = 2;
						configList["planningBoard.chart.presentation.settings"].selectedZoomLevel.type = "week";
						break;
					 case "saveLastZoom":
						configList["planningBoard.chart.presentation.settings"].selectedZoomLevel.value = currentCalendarConfig.value;
						configList["planningBoard.chart.presentation.settings"].selectedZoomLevel.type = currentCalendarConfig.type;
						break;
					 default:
						configList["planningBoard.chart.presentation.settings"].selectedZoomLevel.value = 1;
						configList["planningBoard.chart.presentation.settings"].selectedZoomLevel.type = "month";
						break;
				  }
				  viewportHeightOnlyTmp = PlanningBoardExternalServices.platformGridAPI.grids.getGridState(this.getSupplierConfig().uuid).viewportHeight.height;
				}
			 };
			 planningBoardConfigService.registerOnSettingsChanged(onSettingsChanged);
			 planningBoardConfigService.registerOnSettingsChangedStarted(onSettingsChangedStarted);
			 this.registerOnSettingsChanged = planningBoardConfigService.registerOnSettingsChanged;
			 this.unregisterOnSettingsChanged = planningBoardConfigService.unregisterOnSettingsChanged;
			 this.registerOnSettingsChangedStarted = planningBoardConfigService.registerOnSettingsChangedStarted;
			 this.unregisterOnSettingsChangedStarted = planningBoardConfigService.unregisterOnSettingsChangedStarted;
			 this.getDateStart = function getDateStart(ds) {
				if (ds) {
				  dateStart = new DateExtension(ds);
				}
				return dateStart;
			 };
			 this.getDateEnd = function getDateEnd(de2) {
				if (de2) {
				  dateEnd = new DateExtension(de2);
				}
				return dateEnd;
			 };
			 this.loadCalendarOnly = function loadCalendarOnly(triggerChangesDoneEvent = false, reloadAllCalendars = false) {
				const supplierDataServ = this.getSupplierConfig()?.dataService;
				const supplierMapServ = this.getSupplierConfig()?.mappingService;
				const getCalendarIdFromCompanyFn = this.timeScaleDataService?.getCalendarIdFromCompany;
				const setCalendarInfoFn = (result) => {
				  this.calendarInUse = result;
				  this.exceptionDays = result.ExceptionDays;
				  this.weekDays = result.WeekDays;
				  if (triggerChangesDoneEvent) {
					 infoChangedMessenger.fire();
				  }
				  return result;
				};
				const filteredSupplierList = supplierDataServ.getList ? supplierDataServ.getList() : [];
				if (filteredSupplierList.length > 0 && supplierMapServ && supplierMapServ.calendar) {
				  let calendarIds = Array.from(new Set(filteredSupplierList.map((supplier) => supplierMapServ.calendar(supplier))).values());
				  if (this.getDateshiftConfig()) {
					 this.getDateshiftConfig().dataService.loadCalendarsByIds(calendarIds);
				  }
				  return resolvePromise(PlanningBoardCalendarService.getCalendarsByIds(this.getSupplierConfig().uuid, calendarIds, dateStart, dateEnd, reloadAllCalendars).then((calendarMap) => {
					 let calOfFirstSupp = supplierMapServ.calendar(filteredSupplierList[0]);
					 return setCalendarInfoFn(calendarMap.get(calOfFirstSupp));
				  }));
				} else if (getCalendarIdFromCompanyFn) {
				  return getCalendarIdFromCompanyFn().then((calendarId) => {
					 resolvePromise(PlanningBoardCalendarService.getCalendarsByIds(this.getSupplierConfig().uuid, [calendarId], dateStart, dateEnd, reloadAllCalendars).then((calendarMap) => {
						return setCalendarInfoFn(calendarMap.get(calendarId));
					 }));
				  });
				} else {
				  return resolvePromise();
				}
			 };
			 this.loadRest = (reloadAll = false) => {
				const promiseList = [];
				const statusSrv = options.assignmentConfig.mappingService.getStatusService();
				promiseList.push(statusSrv.getAssignmentStatus().then((list) => {
				  this.assignmentStatusItems = list;
				  return this.assignmentStatusItems;
				}));
				const typeSrv = options.assignmentConfig.mappingService.getTypeService();
				promiseList.push(typeSrv.getAssignmentType().then((list) => {
				  this.assignmentTypeItems = list;
				  return this.assignmentTypeItems;
				}));
				if (!assignmentMapInitialized) {
				  promiseList.push(PlanningBoardExternalServices.basicsUnitLookupDataService.getList({
					 "lookupType": "Uom",
					 "dataServiceName": "basicsUnitLookupDataService"
				  }));
				}
				if (!assignmentMapInitialized || (0, import_lodash.isUndefined)(lastGridStartDate) || (0, import_lodash.isUndefined)(lastGridEndDate) || lastGridStartDate.diff(dateStart, "days") > 0 || lastGridEndDate.diff(dateEnd, "days") < 0) {
				  if (!(0, import_lodash.isNil)(options.demandConfig)) {
					 let reloadDemands = reloadAll;
					 if ((0, import_lodash.isNil)(reloadAll)) {
						reloadDemands = true;
					 }
					 promiseList.push(loadDemands(this.showExtendedDemands(), reloadDemands));
				  }
				  const readExtension = Math.max(5, dateEnd.diff(dateStart, "day") / 2);
				  lastGridStartDate = new DateExtension(dateStart).add(-readExtension, "day");
				  lastGridEndDate = new DateExtension(dateEnd).add(readExtension, "days");
				  this.assignmentDataService.setFilter({ From: lastGridStartDate.format(), To: lastGridEndDate.format() });
				  if ((0, import_lodash.isFunction)(this.assignmentDataService.loadLinkedSupplierIds)) {
					 return this.assignmentDataService.loadLinkedSupplierIds().then(function() {
						return assignmentDataPromise(promiseList, reloadAll);
					 });
				  } else {
					 return assignmentDataPromise(promiseList, reloadAll);
				  }
				} else {
				  busyOverlay.setVisible(false);
				  return resolvePromise();
				}
			 };
			 function resolvePromise(data) {
				return new Promise((resolve, reject) => {
				  try {
					 resolve(data);
				  } catch {
					 reject("Oops... something went wrong");
				  }
				});
			 }
			 this.load = function load2() {
				assignmentMapInitialized = false;
				this.loadCalendarOnly().then(function() {
				  infoChangedMessenger.fire();
				  helperServices.eventHandligSubjectService.onLoadedCalendarOnly$.fire(load2);
				});
				const items = this.supplierDataService.getList();
				busyOverlay.setVisible(true);
				return reloadPlanningBoard(items).then(function() {
				  busyOverlay.setVisible(false);
				  return resolvePromise();
				});
			 };
			 this.reloadPlanningBoardCalendar = function reloadPlanningBoardCalendar() {
				this.loadCalendarOnly().then(() => {
				  if (!assignmentMapInitialized) {
					 this.loadRest(true);
				  } else {
					 this.assignmentDataService.load().then(() => {
						return resolvePromise();
					 });
				  }
				  infoChangedMessenger.fire();
				  helperServices.eventHandligSubjectService.onLoadedCalendarOnly$.fire(reloadPlanningBoardCalendar);
				});
			 };
			 this.planningBoardReDraw = function planningBoardReDraw(redrawOnly = false, isHighlight = false) {
				if (!redrawOnly) {
				  setAssignmentMap();
				}
				if (isHighlight) {
				  infoChangedMessenger.fire(false, isHighlight);
				  helperServices.eventHandligSubjectService.onPlanningBoardRedraw$.fire(planningBoardReDraw, false, isHighlight);
				} else {
				  infoChangedMessenger.fire();
				  helperServices.eventHandligSubjectService.onPlanningBoardRedraw$.fire(planningBoardReDraw);
				}
			 };
			 const assignmentDataPromise = (promiseList, reloadAll) => {
				const addAvailableStatiToMatrix = (response) => {
				  const statusFromIds = /* @__PURE__ */ new Set();
				  response.map((responseItem) => {
					 statusFromIds.add(responseItem.StatusFrom);
				  });
				  statusFromIds.forEach((status) => {
					 if (!this.assignmentAvailableStatusMatrix.has(status)) {
						this.assignmentAvailableStatusMatrix.set(status, response.find((stati) => stati.StatusFrom === status).AvailableStatusIds || []);
					 }
				  });
				};
				promiseList.push(this.assignmentDataService.load().then(() => {
				  setAssignmentMap(reloadAll);
				  const assignmentMapService = this.getAssignmentConfig().mappingService;
				  if (this.assignmentDataService.additionalAssignments && this.assignmentDataService.additionalAssignments.length > 0) {
					 (0, import_lodash.each)(this.assignmentDataService.additionalAssignments, (originalAssignmentEntity) => {
						if (!this.assignments.has(assignmentMapService.id(originalAssignmentEntity))) {
						  const addidionalAssignmentEntity = new AssignmentData(originalAssignmentEntity);
						  assignmentMapService.from(addidionalAssignmentEntity.originalEntity, new DateExtension(assignmentMapService.from(addidionalAssignmentEntity.originalEntity)));
						  assignmentMapService.to(addidionalAssignmentEntity.originalEntity, new DateExtension(assignmentMapService.to(addidionalAssignmentEntity.originalEntity)));
						  this.assignments.set(assignmentMapService.id(addidionalAssignmentEntity.originalEntity), addidionalAssignmentEntity);
						}
					 });
				  }
				  if (this.getAssignmentConfig().mappingService.supplier && this.getAssignmentConfig().mappingService.grouping && this.getAssignmentConfig().mappingService.getSupplierCapacityPerDay) {
					 const resourceIds = Array.from([...this.assignments.values()]).map((assignment) => this.getAssignmentConfig().mappingService.supplier(assignment.originalEntity));
					 this.getAssignmentConfig().mappingService.getSupplierCapacityPerDay(resourceIds, lastGridStartDate, lastGridEndDate).then((response) => {
						this.supplierCapacityPerBaseUnit = {};
						for (const supplierId in response.data) {
						  this.supplierCapacityPerBaseUnit[supplierId] = /* @__PURE__ */ new Map();
						  for (const day in response.data[supplierId]) {
							 this.supplierCapacityPerBaseUnit[supplierId].set(new DateExtension(day).format("yyyy-MM-dd"), response.data[supplierId][day]);
						  }
						}
						return resolvePromise();
					 });
				  }
				  return resolvePromise();
				}));
				return Promise.all(promiseList).then(() => {
				  if ((0, import_lodash.isFunction)(this.getAssignmentConfig().mappingService.entityTypeName)) {
					 const assigmentArray = Array.from(this.assignments.values());
					 let filteredAssignmentArray = /* @__PURE__ */ new Map();
					 assigmentArray.forEach((assignment) => {
						const assignmentKeyValueMap = PlanningBoardCalculationUtilitiesService.objectToKeyValueMap(assignment.originalEntity);
						assignment.statusData.StatusFrom = assignmentKeyValueMap.get(options.assignmentConfig.mappingService.statusKey());
						assignment.statusData.EntityId = {
						  id: assignmentKeyValueMap.get("Id")
						};
						if (!this.assignmentAvailableStatusMatrix.has(assignmentKeyValueMap.get(options.assignmentConfig.mappingService.statusKey()))) {
						  if (!filteredAssignmentArray.has(assignment.statusData.StatusFrom)) {
							 filteredAssignmentArray.set(assignment.statusData.StatusFrom, assignment);
						  }
						}
					 });
					 return PlanningBoardExternalServices.BasicsSharedChangeStatusService.getAvailableStatusList({
						StatusName: this.getAssignmentConfig().mappingService.entityTypeName(),
						DataItems: [...filteredAssignmentArray.values()].map((assignment) => assignment.statusData)
					 }).then((result) => {
						if (result.status && result.status === 200) {
						  result.data.DataItems.map((item) => item.AvailableStatusIds === null ? item.AvailableStatusIds = [] : item.AvailableStatusIds);
						  addAvailableStatiToMatrix(result.data.DataItems);
						}
					 });
				  }
				  return resolvePromise();
				}).finally(() => {
				  busyOverlay.setVisible(false);
				  infoChangedMessenger.fire();
				  helperServices.eventHandligSubjectService.onAssignmentDataLoaded$.fire(assignmentDataPromise);
				});
			 };
			 const setAssignmentMap = (reloadAll) => {
				const assignmentMappingService = this.getAssignmentConfig().mappingService;
				if (!assignmentMapInitialized) {
				  assignmentMapInitialized = true;
				}
				const newLoadedAssignments = this.assignmentDataService.getList();
				this.assignments.forEach((oldAssignment, key) => {
				  if (reloadAll || !this.assignments.get(assignmentMappingService.id(oldAssignment.originalEntity)).modificationData.pBoardModified) {
					 this.assignments.delete(key);
				  } else {
					 this.assignmentDataService.markItemAsModified(oldAssignment.originalEntity);
				  }
				});
				(0, import_lodash.each)(newLoadedAssignments, (assignment) => {
				  if (!this.assignments.has(assignmentMappingService.id(assignment))) {
					 this.assignments.set(assignmentMappingService.id(assignment), new AssignmentData(assignment));
					 this.deletedAssignments.forEach((delAssignment, delId) => {
						if (delId === assignmentMappingService.id(assignment)) {
						  this.assignments.delete(delId);
						}
					 });
				  }
				});
				const assignmentMapServ = this.getAssignmentConfig().mappingService;
				const supplierMapServ = this.getSupplierConfig().mappingService;
				const supplierDataServ = this.getSupplierConfig().dataService;
				if (assignmentMapServ.calendar && supplierMapServ && supplierMapServ.calendar) {
				  const calendarToSupplier = new Map(supplierDataServ.getList().map((sup) => [supplierMapServ.id(sup), supplierMapServ.calendar(sup)]));
				  if (calendarToSupplier) {
					 newLoadedAssignments.forEach((nA) => assignmentMapServ.calendar(nA, calendarToSupplier.get(assignmentMapServ.supplier(nA)), this));
				  }
				}
			 };
			 const reloadPlanningBoard = (items) => {
				clearModifications();
				if (!(0, import_lodash.isArray)(items)) {
				  return resolvePromise();
				}
				if (items.length > 0) {
				  assignmentMapInitialized = false;
				  if (this.getSupplierConfig().dataService.getCalendarIdByFiltered) {
					 return this.loadCalendarOnly().then(() => this.loadRest(true));
				  } else {
					 return this.loadRest(true);
				  }
				} else {
				  return resolvePromise(items);
				}
			 };
			 const supplierListChanged = (items) => {
				this.suppliers = this.supplierDataService.getList();
				if ((0, import_lodash.isArray)(items) && items.length > 0) {
				  assignmentMapInitialized = false;
				  this.loadRest(true);
				}
			 };
			 this.createAssignment = function createAssignment(demands, supplierId = 0, creationData) {
				if (options.dateShift) {
				  options.dateShift.dataService.isMulticreationInProgress = true;
				}
				const currentSettings = options.planningBoardSettingsList;
				const assignmentMapService = options.assignmentConfig.mappingService;
				const demandMapService = options.demandConfig.mappingService;
				const supplierDataServ = options.supplierConfig.dataService;
				const supplierMapService = options.supplierConfig.mappingService;
				if (demandMapService) {
				  const assignments = [];
				  let newAssignments = [];
				  const promiseList = [];
				  demands.forEach((demand) => {
					 const assignment = {};
					 assignments.push(assignment);
					 assignmentMapService.supplier(assignment, supplierId);
					 assignmentMapService.demand(assignment, demandMapService.id(demand));
					 assignmentMapService.quantity(assignment, demandMapService.quantity(demand));
					 assignmentMapService.unitOfMeasurement(assignment, demandMapService.unitOfMeasurement(demand));
					 assignmentMapService.description(assignment, demandMapService.description(demand));
					 if ((0, import_lodash.isFunction)(assignmentMapService.intersectSequence) && creationData.intersectSequence) {
						assignmentMapService.intersectSequence(assignment, creationData.intersectSequence);
					 }
					 if ((0, import_lodash.isNull)(creationData.to)) {
						const demandDateStart = new DateExtension(demandMapService.from(demand));
						if (currentSettings["planningBoard.chart.presentation.settings"].useDemandTimesForReservation) {
						  creationData.from = new DateExtension(demandDateStart);
						}
						const demandDateEnd = new DateExtension(demandMapService.to(demand));
						let newFromDate = new DateExtension(creationData.from);
						newFromDate = newFromDate.toMoment().toUTC();
						const from2 = assignmentMapService.from(assignment, newFromDate);
						from2.hours(demandDateStart.getUTCHours());
						from2.minutes(demandDateStart.getUTCMinutes());
						from2.seconds(demandDateStart.getUTCSeconds());
						const minsLength = demandDateEnd.diff(demandDateStart, "minutes");
						let newEndDate = new DateExtension(from2).add(minsLength, "minutes");
						newEndDate = newEndDate.toMoment().toUTC();
						assignmentMapService.to(assignment, newEndDate);
					 } else {
						assignmentMapService.from(assignment, creationData.from?.toMoment());
						assignmentMapService.to(assignment, creationData.to?.toMoment());
					 }
					 assignmentMapService.demand(assignment, demandMapService.id(demand));
					 const supplier = supplierDataServ.getItemById(supplierId);
					 creationData.calendarId = supplierMapService.calendar(supplier) || null;
					 creationData.type = chartBaseComponent.getZoomLevel(timeaxis);
					 if ((0, import_lodash.isFunction)(this.assignmentDataService.createItems)) {
						promiseList.push(this.assignmentDataService.createItems(assignment, this, creationData).then((multipleAssignments) => {
						  if ((0, import_lodash.isFunction)(assignmentMapService.createAssignments)) {
							 newAssignments = assignmentMapService.createAssignments(assignment, multipleAssignments, creationData, this.getDateshiftConfig(), {
								useCustomPostCreation: (0, import_lodash.isFunction)(assignmentMapService.postAssignmentCreation)
							 }, this);
							 newAssignments.forEach(function(newAssignment) {
								postAssignmentCreation(newAssignment);
							 });
						  }
						  setTimeout(() => areCreatedNotVisible(newAssignments.map((nA) => this.assignments.get(assignmentMapService.id(nA)).originalEntity)), 1e3);
						}));
					 } else {
						promiseList.push(this.assignmentDataService.createItem(assignment, this).then((newAssignment) => {
						  newAssignment = assignmentMapService.createAssignment(assignment, newAssignment, creationData, this.getDateshiftConfig(), {
							 useCustomPostCreation: (0, import_lodash.isFunction)(assignmentMapService.postAssignmentCreation)
						  }, this);
						  postAssignmentCreation(newAssignment);
						  setTimeout(() => areCreatedNotVisible(newAssignments.map((nA) => this.assignments.get(assignmentMapService.id(nA)).originalEntity)), 1e3);
						}));
					 }
				  });
				  const postAssignmentCreation = (newAssignment) => {
					 assignmentMapService.validateAssignment(newAssignment, this.assignmentDataService);
					 if (!this.assignments.get(assignmentMapService.id(newAssignment))) {
						let createdAssignmentData = new AssignmentData(newAssignment);
						this.assignments.set(assignmentMapService.id(newAssignment), createdAssignmentData);
						this.assignments.get(assignmentMapService.id(newAssignment)).modificationData.pBoardModified = true;
						createdAssignmentData.timeData.startDateInMs = assignmentMapService.from(newAssignment).toDate().getTime();
						createdAssignmentData.timeData.endDateInMs = assignmentMapService.from(newAssignment).toDate().getTime();
						if (!newAssignments.includes(newAssignment)) {
						  newAssignments.push(newAssignment);
						}
					 } else {
						let foundAssignmentData = this.assignments.get(assignmentMapService.id(newAssignment));
						if (foundAssignmentData) {
						  foundAssignmentData.modificationData.pBoardModified = true;
						  this.updateAssignment(foundAssignmentData);
						}
					 }
				  };
				  const areCreatedNotVisible = (createdItems) => {
					 let earliestStart = DateExtension.utc(createdItems.map((createdItem) => assignmentMapService.from(createdItem).toDate().getTime()).sort().at(0));
					 let latestEnd = DateExtension.utc(createdItems.map((createdItem) => assignmentMapService.to(createdItem).toDate().getTime()).sort().at(-1));
					 if (earliestStart.isAfter(this.getDateEnd()) || latestEnd.isBefore(this.getDateStart())) {
						let timer2 = 3e3;
						const toastTemplate = `
								<div class="alarm-overlay not-visible-message">
									<div class="alert" role="alert" style="text-align:center">
									${PlanningBoardExternalServices.PlatformTranslateService.instant("platform.planningboard.createdDateMsg").replace("${0}", earliestStart.format(`dddd DD, MMMM yyyy, hh:mm${earliestStart.seconds() > 0 ? ":ss" : ""}`))}
									<p class="timer">(${timer2 / 1e3}s)<p>
									</div>
								</div>`;
						let toastElem = new DOMParser().parseFromString(toastTemplate, "text/html").getElementsByClassName("not-visible-message")[0];
						let timerElem = toastElem.getElementsByClassName("timer")[0];
						toastElem.firstElementChild.addEventListener("click", (event) => {
						  this.calendarSnapToDate(earliestStart);
						});
						let activeElem = document.getElementsByTagName("body")[0].appendChild(toastElem);
						if (activeElem !== toastElem) {
						  activeElem.appendChild(toastElem);
						}
						let timerInterval = setInterval(() => {
						  timer2 -= 1e3;
						  timerElem.innerHTML = `(${timer2 / 1e3}s)`;
						}, 1e3);
						setTimeout(() => {
						  clearInterval(timerInterval);
						  toastElem.remove();
						}, timer2);
					 }
				  };
				  return Promise.all(promiseList).then(() => {
					 if (options.dateShift) {
						options.dateShift.dataService.isMulticreationInProgress = false;
						options.dateShift.dataService.mergeChangedVirtualData(newAssignments, options.dateShift.entityName);
						options.dateShift.dateShiftHelperService.resetDateshift(options.dateShift.dataService.getServiceName());
						if (options.assignmentConfig.mappingService.postAssignmentCreation && !creationData.intersectSequence) {
						  if (creationData.from && creationData.from.toMoment) {
							 creationData.from = creationData.from.toMoment().toUTC();
						  }
						  if (creationData.to && creationData.to.toMoment) {
							 creationData.to = creationData.to.toMoment().toUTC();
						  }
						  options.assignmentConfig.mappingService.postAssignmentCreation(newAssignments, creationData, this, options.dateShift);
						  options.dateShift.dataService.mergeChangedVirtualData(newAssignments, options.dateShift.entityName);
						  options.dateShift.dateShiftHelperService.resetDateshift(options.dateShift.dataService.getServiceName());
						}
						options.dateShift.dateShiftHelperService.updateSequenceData(options.dateShift.dataService.getServiceName());
					 }
					 infoChangedMessenger.fire();
					 helperServices.eventHandligSubjectService.onAssignmentCreated$.fire(createAssignment);
				  });
				}
				;
				return resolvePromise();
			 };
			 this.updateAssignment = (assignment) => {
				this.assignments.set(this.getAssignmentConfig().mappingService.id(assignment.originalEntity), assignment);
				const assignmentToUpdate = this.assignments.get(this.getAssignmentConfig().mappingService.id(assignment.originalEntity));
				if (assignmentToUpdate) {
				  assignmentToUpdate.modificationData.pBoardModified = true;
				  this.assignmentDataService.markItemAsModified(assignmentToUpdate.originalEntity);
				}
			 };
			 this.updateAssignments = function updateAssignments(assignments) {
				assignments.forEach((value) => {
				  this.updateAssignment(value);
				});
				this.planningBoardReDraw(true);
			 };
			 this.setSelectedAssignment = function setSelectedAssignment(assignment) {
				this.assignmentDataService.setSelected(assignment.originalEntity);
			 };
			 this.addToSelectedAssignment = function addToSelectedAssignment(assignment) {
				if (assignment) {
				  const assignmentMappingService = this.getAssignmentConfig().mappingService;
				  const oldSelItems = this.assignmentDataService.getSelectedEntities();
				  if (!oldSelItems || oldSelItems.length === 0) {
					 this.assignmentDataService.setSelected(assignment.originalEntity);
				  } else {
					 const newSelItems = [];
					 let alreadyContained = false;
					 (0, import_lodash.forEach)(oldSelItems, function(i) {
						if (assignmentMappingService.id(i) === assignmentMappingService.id(assignment.originalEntity)) {
						  alreadyContained = true;
						} else {
						  newSelItems.push(i);
						}
					 });
					 if (!alreadyContained) {
						newSelItems.push(assignment.originalEntity);
					 }
					 this.assignmentDataService.setSelectedEntities(newSelItems);
				  }
				} else {
				  this.assignmentDataService.setSelected(null, []);
				}
			 };
			 this.deleteSelectedAssignment = function deleteSelectedAssignment() {
				const selItems = this.assignmentDataService.getSelectedEntities();
				const assignmentMappingService = options.assignmentConfig.mappingService;
				const demandMapService = options.demandConfig.mappingService;
				const originalEntities = [...this.assignments.values()].map((assignment) => assignment.originalEntity);
				let deletionSucceded = true;
				let defaultDeleteDeniedText = "Selected item(s) cannot be deleted";
				let updateDemandGridPromise = Promise.resolve();
				if ((0, import_lodash.isFunction)(demandMapService.updateDemandGrid)) {
				  const itemIds = selItems.map((assignment) => assignmentMappingService.demand(assignment));
				  const demands = this.demandDataService.getList() ? this.demandDataService.getList() : [];
				  const demandIds = new Set(demands.map((demand) => demandMapService.id(demand)));
				  const missingDemandIds = itemIds.filter((id3) => !demandIds.has(id3));
				  if (missingDemandIds.length > 0) {
					 updateDemandGridPromise = demandMapService.updateDemandGrid(itemIds, this.demandDataService);
				  }
				}
				return updateDemandGridPromise.then(() => {
				  selItems.forEach((assignment) => {
					 if (deletionSucceded && (0, import_lodash.isFunction)(assignmentMappingService.canDelete) && !assignmentMappingService.canDelete(assignment, originalEntities, options.dateShift) || (0, import_lodash.isFunction)(assignmentMappingService.isReadOnly) && assignmentMappingService.isReadOnly(assignment)) {
						if ((0, import_lodash.isFunction)(assignmentMappingService.getDeniedDeleteMessage)) {
						  defaultDeleteDeniedText = assignmentMappingService.getDeniedDeleteMessage();
						}
						containerLink.getUiAddOns().getAlarm().show(defaultDeleteDeniedText);
						deletionSucceded = false;
					 }
					 if (deletionSucceded) {
						const entityId = assignmentMappingService.id(assignment);
						let foundAssignment = this.assignments.get(entityId);
						if (foundAssignment) {
						  this.deletedAssignments.set(entityId, foundAssignment);
						  this.assignments.delete(entityId);
						}
					 }
				  });
				  if (deletionSucceded) {
					 if (this.assignmentDataService.deleteSelection instanceof Promise) {
						this.assignmentDataService.deleteSelection().then(() => {
						  this.assignmentDataService.setSelected(null, []);
						  infoChangedMessenger.fire();
						  helperServices.eventHandligSubjectService.onAssignmentDeleted$.fire(deleteSelectedAssignment);
						});
					 } else {
						this.assignmentDataService.deleteSelection(options.dateShift);
						this.assignmentDataService.setSelected(null, []);
						infoChangedMessenger.fire();
						helperServices.eventHandligSubjectService.onAssignmentDeleted$.fire(deleteSelectedAssignment);
					 }
				  }
				  return deletionSucceded;
				});
			 };
			 this.updateDemand = function updateDemand(demand) {
				this.demandDataService.markItemAsModified(demand);
				this.demandDataService.update();
			 };
			 this.isCalendarLocked = (isLocked) => {
				if (!(0, import_lodash.isNil)(isLocked)) {
				  isCalendarLocked = isLocked;
				}
				return isCalendarLocked;
			 };
			 this.clickToday = function clickToday() {
				const hourDiff = dateEnd.diff(dateStart, "hour");
				dateStart = DateExtension.utc(new DateExtension()).startOf("day");
				if (hourDiff > 10 * 24) {
				  dateStart.subtract(1, "weeks");
				} else if (hourDiff > 2 * 24) {
				  dateStart.subtract(1, "days");
				} else {
				  dateStart.subtract(12, "hours");
				}
				dateEnd = new DateExtension(dateStart).add(hourDiff, "hour");
				busyOverlay.setVisible(true);
				this.loadRest().then(() => {
				  this.planningBoardReDraw(true);
				});
			 };
			 this.getTimeScaleHoursX = function getTimeScaleHoursX() {
				let hoursX = 0;
				const dayDiff = dateEnd.diff(dateStart, "day");
				if (dayDiff <= 2) {
				  hoursX = 1;
				} else if (dayDiff <= 4) {
				  hoursX = 3;
				} else if (dayDiff <= 7) {
				  hoursX = 6;
				} else if (dayDiff <= 21) {
				  hoursX = 12;
				} else {
				  hoursX = 24;
				}
				return hoursX;
			 };
			 this.setCurrentZoomLevel = (startDate, endDate, selectedZoomLevel) => {
				if (this.isCalendarLocked()) {
				  return false;
				}
				const currentZoomLevel = selectedZoomLevel && selectedZoomLevel.type ? selectedZoomLevel.type : chartBaseComponent.getZoomLevel(timeaxis);
				if (startDate === null || endDate === null) {
				  startDate = new DateExtension();
				  endDate = new DateExtension();
				}
				const currentPBsettings = options.planningBoardSettingsList;
				const value = selectedZoomLevel && selectedZoomLevel.value ? selectedZoomLevel.value : endDate.diff(startDate, currentZoomLevel);
				const id3 = selectedZoomLevel && selectedZoomLevel.id ? selectedZoomLevel.id : currentPBsettings["planningBoard.chart.presentation.settings"].selectedZoomLevel.id;
				currentCalendarConfig = { caption: "customZoom", value, type: currentZoomLevel, id: id3 };
				if (!(0, import_lodash.isNil)(currentPBsettings) && !(0, import_lodash.isUndefined)(currentPBsettings["planningBoard.chart.presentation.settings"].selectedZoomLevel)) {
				  currentPBsettings["planningBoard.chart.presentation.settings"].selectedZoomLevel = currentCalendarConfig;
				}
				return true;
			 };
			 this.saveCurrentZoomLevel = () => {
				if (this.isCalendarLocked()) {
				  return false;
				}
				const currentPBsettings = options.planningBoardSettingsList;
				if (currentPBsettings["planningBoard.chart.presentation.settings"].saveLastZoom) {
				  planningBoardConfigService.prepareCustomDataAndSaveSettings(this.getPlanningBoardSettingsList(), planningBoardConfigService.getUUID(), true);
				}
				return true;
			 };
			 this.zoomIn = () => {
				if (this.isCalendarLocked()) {
				  return false;
				}
				const dayDiff = dateEnd.diff(dateStart, "day");
				if (dayDiff >= 2) {
				  const zoomStep = this.getTimeScaleHoursX() * 4;
				  dateStart = dateStart.add(zoomStep, "hour");
				  dateEnd = dateEnd.add(-zoomStep, "hour");
				  this.setCurrentZoomLevel(dateStart, dateEnd);
				  this.saveCurrentZoomLevel();
				  clearTimeout(OnZoomTimeOut);
				  OnZoomTimeOut = setTimeout(() => this.planningBoardReDraw(), msZoomTimeOut);
				}
				return true;
			 };
			 this.zoomReset = (value, startType) => {
				if (this.isCalendarLocked()) {
				  return false;
				}
				dateStart = dateStart.startOf(startType);
				const durationType = startType;
				if (startType) {
				  dateEnd = new DateExtension(dateStart).add(value, durationType);
				}
				const selectedZoomLevelVal = {
				  value,
				  type: startType,
				  id: "",
				  caption: ""
				};
				this.setCurrentZoomLevel(dateStart, dateEnd, selectedZoomLevelVal);
				if (assignmentMapInitialized) {
				  this.saveCurrentZoomLevel();
				}
				clearTimeout(OnZoomTimeOut);
				OnZoomTimeOut = setTimeout(() => this.planningBoardReDraw(), msZoomTimeOut);
				this.loadRest();
				return true;
			 };
			 this.zoomOut = () => {
				if (this.isCalendarLocked()) {
				  return false;
				}
				const zoomStep = this.getTimeScaleHoursX() * 4;
				dateStart = dateStart.add(-zoomStep, "hour");
				dateEnd = dateEnd.add(zoomStep, "hour");
				this.setCurrentZoomLevel(dateStart, dateEnd);
				this.saveCurrentZoomLevel();
				clearTimeout(OnZoomTimeOut);
				OnZoomTimeOut = setTimeout(() => this.planningBoardReDraw(), msZoomTimeOut);
				this.loadRest();
				return true;
			 };
			 this.calendarSnapToDate = (date2) => {
				if (this.isCalendarLocked()) {
				  return false;
				}
				const startEndDiff = dateEnd.diff(dateStart, "hour");
				dateStart = new DateExtension(date2).subtract(startEndDiff / 2, "hour");
				dateEnd = new DateExtension(dateStart).add(startEndDiff, "hour");
				this.setCurrentZoomLevel(dateStart, dateEnd);
				this.saveCurrentZoomLevel();
				clearTimeout(OnZoomTimeOut);
				OnZoomTimeOut = setTimeout(() => this.planningBoardReDraw(), msZoomTimeOut);
				this.loadRest();
				return true;
			 };
			 this.registerInfoChanged = function registerInfoChanged(handler) {
				infoChangedMessenger.register(handler);
			 };
			 this.unregisterInfoChanged = function unregisterInfoChanged(handler) {
				infoChangedMessenger.unregister(handler);
			 };
			 this.getSupplierConfig = function getSupplierConfig() {
				return options.supplierConfig;
			 };
			 this.getAssignmentConfig = function getAssignmentConfig() {
				return options.assignmentConfig;
			 };
			 this.getDemandConfig = function getDemandConfig() {
				return options.demandConfig;
			 };
			 this.getDateshiftConfig = function getDateshiftConfig() {
				return options.dateShift;
			 };
			 this.showDemandPreview = () => {
				return _getSettingValue("showDemandPreview");
			 };
			 this.showHeaderColor = function showHeaderColor() {
				return _getSettingValue("showHeaderColor");
			 };
			 this.showStatusIcon = function showStatusIcon() {
				return _getSettingValue("showStatusIcon");
			 };
			 this.showInTransportIcon = function showInTransportIcon() {
				return _getSettingValue("showInTransportIcon");
			 };
			 this.backgroundColorConfig = function backgroundColorConfig() {
				const defaultConfig = planningBoardConfigService.getDefaultConfigValues(options.uuid);
				let defaultBackgroundConfig = defaultConfig["planningBoard.chart.presentation.settings"].backgroundColorConfig;
				const currentPlanningBoardSettingsList = this.getPlanningBoardSettingsList();
				if (!currentPlanningBoardSettingsList["planningBoard.chart.presentation.settings"]["backgroundColorConfig"]) {
				  const inUseStatusAsBg = _getSettingValue("showStatusAsBGColor");
				  delete currentPlanningBoardSettingsList["planningBoard.chart.presentation.settings"].showStatusAsBGColor;
				  if (inUseStatusAsBg) {
					 defaultBackgroundConfig = { type: "status", id: "statuscolor", caption: PlanningBoardExternalServices.PlatformTranslateService.instant("platform.planningboard.backgroundColorConfig.status") };
				  }
				  currentPlanningBoardSettingsList["planningBoard.chart.presentation.settings"].backgroundColorConfig = defaultBackgroundConfig;
				}
				return _getSettingValue("backgroundColorConfig");
			 };
			 this.showTypeIcon = function showTypeIcon() {
				return _getSettingValue("showTypeIcon");
			 };
			 this.ignoreIsFullyCovered = function ignoreIsFullyCovered() {
				return _getSettingValue("ignoreIsFullyCovered");
			 };
			 this.ignoreIsNotFullyCovered = function ignoreIsNotFullyCovered() {
				return _getSettingValue("ignoreIsNotFullyCovered");
			 };
			 this.showHeaderBackground = function showHeaderBackground() {
				return _getSettingValue("showHeaderBackground");
			 };
			 this.showSameAssignments = function showSameAssignments() {
				return _getSettingValue("showSameAssignments");
			 };
			 this.showMainText = function showMainText() {
				return _getSettingValue("showMainText");
			 };
			 this.showInfo1Text = function showInfo1Text() {
				return _getSettingValue("showInfo1Text");
			 };
			 this.showInfo2Text = function showInfo2Text() {
				return _getSettingValue("showInfo2Text");
			 };
			 this.showInfo3Text = function showInfo3Text() {
				return _getSettingValue("showInfo3Text");
			 };
			 this.mainInfoLabel = function mainInfoLabel() {
				return _getSettingValue("mainInfoLabel");
			 };
			 this.info1Label = function info1Label() {
				return _getSettingValue("info1Label");
			 };
			 this.info2Label = function info2Label() {
				return _getSettingValue("info2Label");
			 };
			 this.info3Label = function info3Label() {
				return _getSettingValue("info3Label");
			 };
			 this.snapToDays = function snapToDays() {
				return _getSettingValue("snapToDays");
			 };
			 this.showExtendedDemands = function showExtendedDemands() {
				return _getSettingValue("showExtendedDemands");
			 };
			 this.validateAssignments = function validateAssignments() {
				return _getSettingValue("validateAssignments");
			 };
			 this.useMinAggregation = function useMinAggregation() {
				return _getSettingValue("useMinAggregation");
			 };
			 this.showAggregations = function showAggregations() {
				return _getSettingValue("showAggregations");
			 };
			 this.showSumAggregations = function showSumAggregations() {
				return _getSettingValue("showSumAggregations");
			 };
			 this.useTaggingSystem = function useTaggingSystem() {
				return _getSettingValue("useTaggingSystem");
			 };
			 this.tagConfig = function tagConfig() {
				return _getSettingValue("tagConfig");
			 };
			 this.collectionConfig = function collectionConfig() {
				return _getSettingValue("collectionConfig");
			 };
			 this.aggregationTrafficLightsConfig = function aggregationTrafficLightsConfig() {
				return _getSettingValue("aggregationTrafficLightsConfig");
			 };
			 this.aggregationTrafficLightsValuesConfig = function aggregationTrafficLightsValuesConfig() {
				return _getSettingValue("aggregationTrafficLightsValuesConfig");
			 };
			 this.saveLastZoom = function saveLastZoom() {
				return _getSettingValue("saveLastZoom");
			 };
			 this.useDemandTimesForReservation = function useDemandTimesForReservation() {
				return _getSettingValue("useDemandTimesForReservation");
			 };
			 this.selectedZoomLevel = function selectedZoomLevel() {
				return _getSettingValue("selectedZoomLevel");
			 };
			 this.minAggregationLevel = function minAggregationLevel() {
				return _getSettingValue("minAggregationLevel");
			 };
			 this.sumAggregationLine1 = () => {
				return _getSettingValue("sumAggregationLine1");
			 };
			 this.sumAggregationLine2 = () => {
				return _getSettingValue("sumAggregationLine2");
			 };
			 this.sumAggregationLine3 = () => {
				return _getSettingValue("sumAggregationLine3");
			 };
			 this.useFixedAssignmentHeight = () => {
				return _getSettingValue("useFixedAssignmentHeight");
			 };
			 this.rowHeight = () => {
				if (this.useFlexibleRowHeight()) {
				  return calcFlexibleRowHeight(this.supplierDataService.getList().length);
				}
				return _getSettingValue("rowHeight");
			 };
			 this.rowHeightAssignments = () => {
				if (this.showAggregations()) {
				  return this.rowHeight() - defaultAggregationHeight;
				}
				return this.rowHeight();
			 };
			 this.getRowHeightFromSettings = function getRowHeightFromSettings() {
				return this.rowHeight();
			 };
			 this.useFlexibleRowHeight = function useFlexibleRowHeight() {
				return _getSettingValue("useFlexibleRowHeight");
			 };
			 this.reloadOnChangeFullyCovered = () => {
				return _getSettingValue("reloadOnChangeFullyCovered");
			 };
			 this.defaultAggregationHeight = () => {
				return defaultAggregationHeight;
			 };
			 this.gridSettings = {
				validateDemandAgainstSuppliers: () => {
				  return _getSettingValue("validateDemandAgainstSuppliers");
				},
				filterDemands: () => {
				  return _getSettingValue("filterDemands");
				}
			 };
			 this.verticalIndex = (value) => {
				if (value) {
				  verticalIndex = value;
				}
				return verticalIndex;
			 };
			 this.getCurrentDimensions = (value) => {
				if (value) {
				  currentDimensions = value;
				}
				return currentDimensions;
			 };
			 this.canDeleteAssignment = function canDeleteAssignment() {
				const mapService = options.assignmentConfig.mappingService;
				let canDelete = false;
				if ((0, import_lodash.isFunction)(mapService.isReadOnly)) {
				  (0, import_lodash.forEach)(this.assignmentDataService.getSelectedEntities(), (selectedEntity) => {
					 if (!mapService.isReadOnly(selectedEntity)) {
						canDelete = true;
						if ((0, import_lodash.isFunction)(mapService.canDelete)) {
						  canDelete = mapService.canDelete(selectedEntity);
						}
					 }
				  });
				} else {
				  canDelete = true;
				}
				return canDelete && this.assignmentDataService.getSelectedEntities().length > 0;
			 };
			 this.setTimeAxis = (value) => {
				timeaxis = value;
			 };
			 this.getPlanningBoardSettingsList = () => {
				return options.planningBoardSettingsList;
			 };
			 this.getPlanningBoardConfigService = () => {
				return planningBoardConfigService;
			 };
			 this.getChartBase = () => {
				return chartBaseComponent;
			 };
			 this.getHelperServices = () => {
				return helperServices;
			 };
			 const _getSettingValue = (key) => {
				const list = this.getPlanningBoardSettingsList();
				let settingValue;
				let valueToCheck = list["planningBoard.chart.presentation.settings"][key];
				if (!(0, import_lodash.isUndefined)(valueToCheck)) {
				  settingValue = valueToCheck;
				} else if (list["planningBoard.chart.gridSettings"]) {
				  valueToCheck = list["planningBoard.chart.gridSettings"][key];
				  if (!(0, import_lodash.isUndefined)(valueToCheck)) {
					 settingValue = valueToCheck;
				  }
				}
				return (0, import_lodash.isUndefined)(settingValue) ? false : settingValue;
			 };
			 this.loadVirtualForSelected = (selectedAsssignment) => {
				const dateShiftConfig = this.getDateshiftConfig();
				if (!(0, import_lodash.isNil)(dateShiftConfig)) {
				  const entityName = dateShiftConfig.entityName;
				  const leadingRegistration = dateShiftConfig.dataService.getContainerData().registeredServices[entityName].find((rs) => rs.serviceContainer.service === this.getAssignmentConfig().dataService);
				  const selectedAssignments = [selectedAsssignment];
				  const foundVirtualIds = new Set(dateShiftConfig.dataService.findVirtualEntities(selectedAssignments, entityName).map((foundVirtualEntity) => foundVirtualEntity.Id));
				  const virtualToLoadIds = selectedAssignments.filter((assignment) => !foundVirtualIds.has(assignment.Id)).map((assignment) => assignment.Id);
				  if (virtualToLoadIds.length > 0) {
					 return dateShiftConfig.dataService.loadVirtualEntities({
						mainItemIds: virtualToLoadIds,
						entity: entityName,
						foreignKey: leadingRegistration.config.match ? leadingRegistration.config.match : "Id",
						triggerEntityName: leadingRegistration.serviceContainer.data.itemName
					 }).then(() => {
						dateShiftConfig.dateShiftHelperService.resetDateshift(dateShiftConfig.dataService.getServiceName());
					 });
				  }
				}
				return resolvePromise();
			 };
		  }
		};
		PlanningBoardDataService = __decorate([
		  __param(0, Inject(Object)),
		  __param(1, Inject(Object))
		], PlanningBoardDataService);
		var PlanningBoardDataServiceInterfaceService = class _PlanningBoardDataServiceInterfaceService {
		  static {
			 this.dataServiceMap = /* @__PURE__ */ new Map();
		  }
		  static {
			 this.demandDataServiceMap = /* @__PURE__ */ new Map();
		  }
		  static {
			 this.supplierDataServiceMap = /* @__PURE__ */ new Map();
		  }
		  static {
			 this.assignmentDataServiceMap = /* @__PURE__ */ new Map();
		  }
		  static setPlanningBoardConfiguration(options, externalServices, cultureOfUser) {
			 DateExtension.locale(cultureOfUser);
			 if ((0, import_lodash.isUndefined)(this.planningBoardExternalServicesService) && externalServices) {
				this.planningBoardExternalServicesService = new PlanningBoardExternalServices(externalServices);
			 }
			 if ((0, import_lodash.isUndefined)(this.dataServiceMap.get(options.uuid))) {
				if (options.demand && options.demand.dataService && options.demand.dataService.getServiceName) {
				  this.demandDataServiceMap.set(options.demand.dataService.getServiceName(), options.uuid);
				}
				if (options.supplier) {
				  if (options.supplier.dataService && options.supplier.dataService.getServiceName) {
					 this.supplierDataServiceMap.set(options.supplier.dataService.getServiceName(), options.uuid);
				  }
				  if (!options.supplier.mappingService) {
					 options.supplier.mappingService = {
						actualId: (dataObject) => dataObject.Id,
						id: (dataObject) => dataObject.Id
					 };
				  }
				}
				if (options.assignment && options.assignment.dataService && options.assignment.dataService.getServiceName) {
				  this.assignmentDataServiceMap.set(options.assignment.dataService.getServiceName(), options.uuid);
				}
				const containerLink = externalServices.containerLink;
				containerLink.supplierGridId = options.supplier.uuid;
				const planningBoardDataService = new PlanningBoardDataService(containerLink, externalServices);
				planningBoardDataService.setPlanningBoardConfiguration(options, containerLink);
				this.dataServiceMap.set(options.uuid, {
				  dataService: planningBoardDataService,
				  containerLink
				});
				return planningBoardDataService;
			 } else {
				const cachedData = this.dataServiceMap.get(options.uuid);
				const dataServiceToLoad = cachedData.dataService;
				dataServiceToLoad.setPlanningBoardScopeProperties(options, cachedData.containerLink);
				dataServiceToLoad.registerPlanningBoardEvents(options);
				dataServiceToLoad.reloadPlanningBoardCalendar();
				if (dataServiceToLoad) {
				  let mapServ = dataServiceToLoad.getAssignmentConfig().mappingService;
				  if (mapServ.updateMaintenanceList) {
					 mapServ.updateMaintenanceList();
				  }
				}
				return dataServiceToLoad;
			 }
		  }
		  static getPlanningBoardDataServiceByUUID(uuid) {
			 return this.dataServiceMap.get(uuid)?.dataService;
		  }
		  static getPlanningBoardDataServiceByDemandServiceName(name) {
			 const uuid = this.demandDataServiceMap.get(name);
			 return this.getPlanningBoardDataServiceByUUID(uuid);
		  }
		  static getPlanningBoardDataServiceBySupplierServiceName(name) {
			 const uuid = this.supplierDataServiceMap.get(name);
			 return this.getPlanningBoardDataServiceByUUID(uuid);
		  }
		  static getPlanningBoardDataServiceByAssignmentServiceName(name) {
			 const uuid = this.assignmentDataServiceMap.get(name);
			 return this.getPlanningBoardDataServiceByUUID(uuid);
		  }
		  constructor() {
		  }
		  static {
			 this.\u0275fac = function PlanningBoardDataServiceInterfaceService_Factory(t) {
				return new (t || _PlanningBoardDataServiceInterfaceService)();
			 };
		  }
		  static {
			 this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _PlanningBoardDataServiceInterfaceService, factory: _PlanningBoardDataServiceInterfaceService.\u0275fac, providedIn: "root" });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlanningBoardDataServiceInterfaceService, [{
			 type: Injectable,
			 args: [{
				providedIn: "root"
			 }]
		  }], () => [], null);
		})();
		var PlanningBoardSupplierGridComponent = class _PlanningBoardSupplierGridComponent {
		  constructor(element) {
			 this.element = element;
			 let legacyScopeVar = this.containerLink ? this.containerLink : document.getElementsByTagName("platform-planningboard-component")[0].scope;
			 this.containerLink = (0, import_lodash.cloneDeep)(legacyScopeVar);
			 const that = this;
			 const platformGridControllerService = PlanningBoardExternalServices.platformGridControllerService, platformGridAPI = PlanningBoardExternalServices.platformGridAPI;
			 let uuid = this.containerLink.uuid;
			 let planningBoardDataService = PlanningBoardDataServiceInterfaceService.getPlanningBoardDataServiceByUUID(uuid);
			 const conf = planningBoardDataService.getSupplierConfig();
			 this.containerLink.gridId = conf.uuid;
			 let demandConf, demandGrid, demandList;
			 this.gridConfigReady = false;
			 const config2 = {
				initCalled: false,
				columns: [],
				passThrough: {
				  rowHeight: planningBoardDataService.getRowHeightFromSettings()
				},
				gridDataAccess: "supplierGridData",
				toolbarItemsDisabled: conf.toolbarItemsDisabled || false,
				skipToolbarCreation: conf.skipToolbarCreation || false,
				dragDropService: void 0,
				type: ""
			 };
			 let suppControl = {};
			 function init2() {
				suppControl = platformGridControllerService.initListController(that.containerLink, conf.uiStandardService, conf.dataService, conf.validationService, config2);
				that.gridConfigReady = true;
				if (demandGrid) {
				  demandList = (0, import_lodash.cloneDeep)(demandConf.dataService.getUnfilteredList());
				  if (!demandGrid.dataView) {
					 demandGrid.dataView = {
						setItems: (data) => {
						  demandGrid.data = data;
						}
					 };
				  }
				  demandGrid.dataView.setItems(demandList);
				}
			 }
			 function onDestroy() {
				platformGridAPI.grids.unregister(conf.uuid);
			 }
			 function onStart() {
				that.gridConfigReady = false;
			 }
			 function listLoaded() {
				init2();
			 }
			 demandConf = planningBoardDataService.getDemandConfig();
			 if (demandConf) {
				demandGrid = platformGridAPI.grids.element("id", demandConf.uuid);
			 }
			 planningBoardDataService.registerOnSettingsChangedStarted(onStart);
			 conf.dataService.registerListLoaded(listLoaded);
			 that.containerLink?.registerFinalizer(function() {
				planningBoardDataService.unregisterOnSettingsChangedStarted(onStart);
				conf.dataService.unregisterListLoaded(listLoaded);
				onDestroy();
			 });
			 init2();
		  }
		  ngAfterViewInit() {
			 this.element.nativeElement.querySelectorAll("platform-grid").forEach((x) => PlanningBoardExternalServices.angularJScompile(this.containerLink, x));
		  }
		  static {
			 this.\u0275fac = function PlanningBoardSupplierGridComponent_Factory(t) {
				return new (t || _PlanningBoardSupplierGridComponent)(\u0275\u0275directiveInject(ElementRef));
			 };
		  }
		  static {
			 this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _PlanningBoardSupplierGridComponent, selectors: [["app-planning-board-supplier-grid"]], standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 1, vars: 0, consts: [["data-platform-dragdrop-component", "ddTarget", "data", "supplierGridData"]], template: function PlanningBoardSupplierGridComponent_Template(rf, ctx) {
				if (rf & 1) {
				  \u0275\u0275element(0, "platform-grid", 0);
				}
			 } });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlanningBoardSupplierGridComponent, [{
			 type: Component,
			 args: [{ standalone: true, imports: [], selector: "app-planning-board-supplier-grid", schemas: [CUSTOM_ELEMENTS_SCHEMA], template: '  <!-- agularJS component start -->\r\n  <!-- <platform-grid ng-if="gridConfigReady" data-platform-dragdrop-component="ddTarget" data="supplierGridData"></platform-grid> -->\r\n  <platform-grid data-platform-dragdrop-component="ddTarget" data="supplierGridData"></platform-grid>\r\n  <!-- agularJS component end -->\r\n' }]
		  }], () => [{ type: ElementRef }], null);
		})();
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(PlanningBoardSupplierGridComponent, { className: "PlanningBoardSupplierGridComponent", filePath: "lib\\components\\planning-board-supplier-grid\\planning-board-supplier-grid.component.ts", lineNumber: 21 });
		})();
		var SupplierData = class {
		  constructor(originalEntity) {
			 this.originalEntity = originalEntity;
			 this.validationData = {
				indicationAreaType: ""
			 };
		  }
		};
		var PlanningBoardDemandGridComponent = class _PlanningBoardDemandGridComponent {
		  constructor(element) {
			 this.element = element;
			 let containerLink = this.containerLink ? this.containerLink : document.getElementsByTagName("platform-planningboard-component")[0].scope;
			 this.containerLink = (0, import_lodash.cloneDeep)(containerLink);
			 const that = this;
			 const platformGridControllerService = PlanningBoardExternalServices.platformGridControllerService, platformGridAPI = PlanningBoardExternalServices.platformGridAPI;
			 let planningBoardDataService = PlanningBoardDataServiceInterfaceService.getPlanningBoardDataServiceByUUID(this.containerLink.uuid);
			 const conf = planningBoardDataService.getDemandConfig();
			 if (conf) {
				this.containerLink.gridId = conf.uuid;
			 }
			 let supplierConf, supplierGrid, supplierList;
			 let demandGrid, selectedDemand;
			 if (!(0, import_lodash.isNil)(conf)) {
				let gridConfig = {
				  initCalled: false,
				  columns: [],
				  gridDataAccess: "demandGridData",
				  dragDropService: conf.dragDropService,
				  type: conf.dragDropType,
				  toolbarItemsDisabled: conf.toolbarItemsDisabled,
				  skipToolbarCreation: conf.skipToolbarCreation
				};
				if (conf.treeViewConfig) {
				  gridConfig.parentProp = conf.treeViewConfig.parentProp;
				  gridConfig.childProp = conf.treeViewConfig.childProp;
				}
				platformGridControllerService.initListController(this.containerLink, conf.uiStandardService, conf.dataService, conf.validationService, gridConfig);
			 }
			 function onSettingsChanged() {
				init2();
				filterDemandList();
			 }
			 function filterDemandList() {
				if (conf && (0, import_lodash.isFunction)(conf.mappingService.filterDemands) && demandGrid) {
				  if (!demandGrid.dataView) {
					 demandGrid.dataView = {
						setItems: (data) => {
						  demandGrid.data = data;
						}
					 };
				  }
				  demandGrid.dataView.setItems(conf.mappingService.filterDemands(planningBoardDataService));
				}
			 }
			 function validateSelection() {
				const validAgainstSuppliers = planningBoardDataService.gridSettings.validateDemandAgainstSuppliers instanceof Function ? planningBoardDataService.gridSettings.validateDemandAgainstSuppliers() : planningBoardDataService.gridSettings.validateDemandAgainstSuppliers;
				if (validAgainstSuppliers && conf && conf.dataService.getSelected()) {
				  let selectedOriginalDemand = conf.dataService.getSelected();
				  selectedDemand = null;
				  if (selectedOriginalDemand) {
					 selectedDemand = new DemandData(selectedOriginalDemand);
				  }
				  supplierList = (0, import_lodash.cloneDeep)(supplierConf.dataService.getUnfilteredList());
				  const selectedOrgiginalSupplier = supplierConf.dataService.getSelected();
				  const selectedSupplierData = selectedOrgiginalSupplier ? new SupplierData(selectedOrgiginalSupplier) : null;
				  if (!(0, import_lodash.isNull)(selectedDemand)) {
					 let pbGridDefaultSettingForValidation = planningBoardDataService.gridSettings.validateDemandAgainstSuppliers instanceof Function ? planningBoardDataService.gridSettings.validateDemandAgainstSuppliers() : planningBoardDataService.gridSettings.validateDemandAgainstSuppliers;
					 const validSupplierList = planningBoardDataService.getHelperServices().validationService.validateSelectedAgainstList(selectedDemand.originalEntity, supplierList, "demand", "supplier", pbGridDefaultSettingForValidation);
					 supplierGrid.dataView.setItems(validSupplierList);
					 selectSupplier(selectedSupplierData);
					 selectDemand(selectedDemand);
				  } else {
					 supplierGrid.dataView.setItems(supplierList);
					 selectSupplier(selectedSupplierData);
				  }
				}
			 }
			 function selectDemand(demand) {
				if (!(0, import_lodash.isNull)(demand) && conf) {
				  platformGridAPI.rows.selection({
					 gridId: conf.uuid,
					 rows: [demand]
				  });
				  platformGridAPI.rows.scrollIntoViewByItem(conf.uuid, demand);
				}
			 }
			 function selectSupplier(supplier) {
				if (!(0, import_lodash.isNull)(supplier)) {
				  platformGridAPI.rows.selection({
					 gridId: supplierConf.uuid,
					 rows: [supplier]
				  });
				  platformGridAPI.rows.scrollIntoViewByItem(supplierConf.uuid, supplier);
				}
			 }
			 function listLoaded() {
				filterDemandList();
				validateSelection();
			 }
			 function init2() {
				supplierConf = planningBoardDataService.getSupplierConfig();
				supplierGrid = platformGridAPI.grids.element("id", supplierConf.uuid);
				if (!(0, import_lodash.isNil)(conf)) {
				  demandGrid = platformGridAPI.grids.element("id", conf.uuid);
				}
			 }
			 if (!(0, import_lodash.isNil)(conf)) {
				conf.dataService.registerSelectionChanged(validateSelection);
			 }
			 planningBoardDataService.registerOnSettingsChanged(onSettingsChanged);
			 if (!(0, import_lodash.isNil)(conf)) {
				conf.dataService.registerListLoaded(listLoaded);
				planningBoardDataService.getHelperServices().eventHandligSubjectService.onPlanningBoardRedraw$.subscribe([filterDemandList]);
			 }
			 that.containerLink?.registerFinalizer(function cleanupHandlers() {
				if (!(0, import_lodash.isNil)(conf)) {
				  conf.dataService.unregisterSelectionChanged(validateSelection);
				  conf.dataService.unregisterListLoaded(listLoaded);
				  planningBoardDataService.getHelperServices().eventHandligSubjectService.onPlanningBoardRedraw$.unsubscribe([filterDemandList]);
				  platformGridAPI.grids.unregister(conf.uuid);
				}
			 });
			 init2();
		  }
		  ngAfterViewInit() {
			 this.element.nativeElement.querySelectorAll("platform-grid").forEach((elem2) => PlanningBoardExternalServices.angularJScompile(this.containerLink, elem2));
		  }
		  static {
			 this.\u0275fac = function PlanningBoardDemandGridComponent_Factory(t) {
				return new (t || _PlanningBoardDemandGridComponent)(\u0275\u0275directiveInject(ElementRef));
			 };
		  }
		  static {
			 this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _PlanningBoardDemandGridComponent, selectors: [["app-planning-board-demand-grid"]], standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 1, vars: 0, consts: [["data-platform-dragdrop-component", "ddTarget", "data", "demandGridData"]], template: function PlanningBoardDemandGridComponent_Template(rf, ctx) {
				if (rf & 1) {
				  \u0275\u0275element(0, "platform-grid", 0);
				}
			 } });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlanningBoardDemandGridComponent, [{
			 type: Component,
			 args: [{ standalone: true, imports: [], selector: "app-planning-board-demand-grid", schemas: [CUSTOM_ELEMENTS_SCHEMA], template: '<!-- agularJS component start -->\r\n<!-- <platform-grid data-platform-dragdrop-component="ddTarget" ng-if="demandGridData" data="demandGridData"></platform-grid> -->\r\n<platform-grid data-platform-dragdrop-component="ddTarget" data="demandGridData"></platform-grid>\r\n<!-- agularJS component end -->\r\n' }]
		  }], () => [{ type: ElementRef }], null);
		})();
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(PlanningBoardDemandGridComponent, { className: "PlanningBoardDemandGridComponent", filePath: "lib\\components\\planning-board-demand-grid\\planning-board-demand-grid.component.ts", lineNumber: 23 });
		})();
		var PlanningBoardAggregateItemsComponentConstants;
		(function(PlanningBoardAggregateItemsComponentConstants2) {
		  PlanningBoardAggregateItemsComponentConstants2[PlanningBoardAggregateItemsComponentConstants2["xMargin"] = 3] = "xMargin";
		  PlanningBoardAggregateItemsComponentConstants2[PlanningBoardAggregateItemsComponentConstants2["trafficLightWidth"] = 10] = "trafficLightWidth";
		  PlanningBoardAggregateItemsComponentConstants2[PlanningBoardAggregateItemsComponentConstants2["aggregationHeight"] = 20] = "aggregationHeight";
		})(PlanningBoardAggregateItemsComponentConstants || (PlanningBoardAggregateItemsComponentConstants = {}));
		var _c0$g = ["scrollContent"];
		var PlanningBoardAggregateItemsComponent = class _PlanningBoardAggregateItemsComponent {
		  ngOnInit() {
			 if (!selection_default.prototype.parent) {
				selection_default.prototype.parent = function selectParent() {
				  return this.select(() => {
					 return this.parentNode;
				  });
				};
			 }
		  }
		  static {
			 this.aggregateItems = () => {
				let supplierScale, calendarScale, aggregates, mapService, clickHandler, aggregationTrafficLightsConfig, aggregationHeight = PlanningBoardAggregateItemsComponentConstants.aggregationHeight;
				function getAggregateYPos(aggregation) {
				  const supplierIdx = supplierScale.getVerticalIndex().get(aggregation.reference);
				  if ((0, import_lodash.isUndefined)(supplierIdx)) {
					 return 0;
				  } else {
					 return supplierScale.getHeaderLineHeight() + supplierIdx * supplierScale.getLineHeight() + (supplierScale.getLineHeight() - aggregationHeight);
				  }
				}
				function getAggregationXWidth(aggregation) {
				  return Math.max(15, calendarScale(aggregation.endDate) - calendarScale(aggregation.startDate));
				}
				function firstTextLineY() {
				  return Math.min(25, Math.max(10, aggregationHeight / 5 + 10));
				}
				const _aggregateItems = (selection2) => {
				  const aggregation = selection2.selectAll("g.aggregation").data(aggregates);
				  aggregation.exit().remove();
				  const newAggregations = aggregation.enter().append("g").classed("aggregation", true);
				  newAggregations.append("rect").classed("background", true);
				  newAggregations.append("rect").classed("traffic-light", true);
				  newAggregations.append("text").classed("aggregation", true).append("tspan").classed("aggregation-text", true);
				  const clip = newAggregations.append("clipPath").attr("id", function(d) {
					 return "aggregationClipPath" + d.id;
				  });
				  clip.append("rect").classed("aggregation-clip-path", true);
				  const combinedAggregations = newAggregations.merge(aggregation);
				  combinedAggregations.attr("x", function(d) {
					 return calendarScale(d.startDate);
				  }).attr("y", function(d) {
					 return getAggregateYPos(d);
				  });
				  combinedAggregations.select("rect.background").on("click", function(e, d) {
					 clickHandler(d, e, "enter");
				  }).attr("x", function(d) {
					 return calendarScale(d.startDate);
				  }).attr("y", function(d) {
					 return getAggregateYPos(d);
				  }).attr("height", function(d) {
					 return aggregationHeight;
				  }).attr("width", function(d) {
					 return getAggregationXWidth(d);
				  });
				  combinedAggregations.select("rect.aggregation-clip-path").attr("x", function(d) {
					 return calendarScale(d.startDate);
				  }).attr("y", function(d) {
					 return getAggregateYPos(d);
				  }).attr("height", function(d) {
					 return aggregationHeight;
				  }).attr("width", function(d) {
					 return getAggregationXWidth(d);
				  }).style("pointer-events", "none");
				  combinedAggregations.select("rect.traffic-light").attr("x", function(d) {
					 return calendarScale(d.startDate);
				  }).attr("y", function(d) {
					 return getAggregateYPos(d);
				  }).attr("height", function(d) {
					 return aggregationHeight;
				  }).attr("width", function(d) {
					 return PlanningBoardAggregateItemsComponentConstants.trafficLightWidth + "px";
				  }).style("pointer-events", "none").style("fill", function(d) {
					 return d.color;
				  });
				  combinedAggregations.select("text.aggregation").attr("x", function(d) {
					 return calendarScale(d.startDate) + PlanningBoardAggregateItemsComponentConstants.trafficLightWidth;
				  }).attr("y", function(d) {
					 return getAggregateYPos(d);
				  }).attr("width", function(d) {
					 return getAggregationXWidth(d) - PlanningBoardAggregateItemsComponentConstants.xMargin * 2;
				  }).attr("dy", function(d) {
					 return firstTextLineY() - 1;
				  }).attr("dx", function(d) {
					 return PlanningBoardAggregateItemsComponentConstants.xMargin;
				  }).style("pointer-events", "none");
				  combinedAggregations.select("tspan.aggregation-text").attr("x", function(d) {
					 return calendarScale(d.startDate) + PlanningBoardAggregateItemsComponentConstants.trafficLightWidth;
				  }).attr("y", function(d) {
					 return getAggregateYPos(d);
				  }).attr("dy", function(d) {
					 return firstTextLineY() - 1;
				  }).attr("dx", function(d) {
					 return PlanningBoardAggregateItemsComponentConstants.xMargin;
				  }).attr("clip-path", function(d) {
					 return "url(#aggregationClipPath" + d.id + ")";
				  }).attr("font-size", "10px").attr("font-weight", "bold").style("pointer-events", "none").text(function(d) {
					 return ((d.sum || 1) / d.displayFactor).toFixed(2) + " " + d.uomDescription;
				  });
				};
				_aggregateItems.setCalendarScale = (cs2) => {
				  calendarScale = cs2;
				  return _aggregateItems;
				};
				_aggregateItems.getCalendarScale = () => {
				  return calendarScale;
				};
				_aggregateItems.setSupplierScale = (ss) => {
				  supplierScale = ss;
				  return _aggregateItems;
				};
				_aggregateItems.getSupplierScale = () => {
				  return supplierScale;
				};
				_aggregateItems.setAggregates = (a) => {
				  aggregates = a;
				  return _aggregateItems;
				};
				_aggregateItems.getAggregates = () => {
				  return aggregates;
				};
				_aggregateItems.setMapService = (ms) => {
				  mapService = ms;
				  return _aggregateItems;
				};
				_aggregateItems.getMapService = () => {
				  return mapService;
				};
				_aggregateItems.setClickEvent = (ch) => {
				  clickHandler = ch;
				  return _aggregateItems;
				};
				_aggregateItems.getClickEvent = () => {
				  return clickHandler;
				};
				_aggregateItems.setAggregationHeight = (height) => {
				  aggregationHeight = height;
				  return _aggregateItems;
				};
				_aggregateItems.getAggregationHeight = () => {
				  return aggregationHeight;
				};
				_aggregateItems.setAggregationTrafficLightsConfig = (config2) => {
				  aggregationTrafficLightsConfig = config2;
				  return _aggregateItems;
				};
				_aggregateItems.getAggregationTrafficLightsConfig = () => {
				  return aggregationTrafficLightsConfig;
				};
				return _aggregateItems;
			 };
		  }
		  static {
			 this.\u0275fac = function PlanningBoardAggregateItemsComponent_Factory(t) {
				return new (t || _PlanningBoardAggregateItemsComponent)();
			 };
		  }
		  static {
			 this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _PlanningBoardAggregateItemsComponent, selectors: [["app-planning-board-aggregate-items"]], viewQuery: function PlanningBoardAggregateItemsComponent_Query(rf, ctx) {
				if (rf & 1) {
				  \u0275\u0275viewQuery(_c0$g, 7);
				}
				if (rf & 2) {
				  let _t;
				  \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.scrollContent = _t.first);
				}
			 }, standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 2, vars: 0, template: function PlanningBoardAggregateItemsComponent_Template(rf, ctx) {
				if (rf & 1) {
				  \u0275\u0275elementStart(0, "p");
				  \u0275\u0275text(1, "planning-board-aggregate-items works!");
				  \u0275\u0275elementEnd();
				}
			 } });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlanningBoardAggregateItemsComponent, [{
			 type: Component,
			 args: [{ standalone: true, selector: "app-planning-board-aggregate-items", template: "<p>planning-board-aggregate-items works!</p>\r\n" }]
		  }], null, { scrollContent: [{
			 type: ViewChild,
			 args: ["scrollContent", { static: true }]
		  }] });
		})();
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(PlanningBoardAggregateItemsComponent, { className: "PlanningBoardAggregateItemsComponent", filePath: "lib\\components\\planning-board-aggregate-items\\planning-board-aggregate-items.component.ts", lineNumber: 20 });
		})();
		var _c0$f = ["scrollContent"];
		var PlanningBoardAggregateSumItemsComponent = class _PlanningBoardAggregateSumItemsComponent {
		  ngOnInit() {
			 if (!selection_default.prototype.parent) {
				selection_default.prototype.parent = function selectParent() {
				  return this.select(() => {
					 return this.parentNode;
				  });
				};
			 }
		  }
		  static {
			 this.aggregateSumItems = () => {
				let calendarScale, mapService, sumAggregates, clickEventFn, sumHeight, textLines, aggregationTrafficLightsConfig, planningBoardDataService;
				let fontSize = 10, statusBarHeight = 17, xMargin = 5;
				function getAggregationXWidth(d) {
				  return Math.max(15, calendarScale(d.endDate) - calendarScale(d.startDate));
				}
				function getSumAggregationYPos() {
				  return sumHeight * -1 - statusBarHeight;
				}
				function getBaseTextLineYPosition() {
				  return sumHeight + statusBarHeight - fontSize / 2 - sumHeight / 2;
				}
				const _aggregateSumItems = (selection2) => {
				  var sumAggregations = selection2.selectAll("g.aggregation").data(sumAggregates);
				  sumAggregations.exit().remove();
				  var newSumAggregations = sumAggregations.enter().append("g").classed("aggregation", true);
				  newSumAggregations.append("rect").classed("background", true).attr("fill-opacity", "0.5");
				  newSumAggregations.append("rect").classed("traffic-light", true);
				  let sumAggregationText = newSumAggregations.append("text");
				  sumAggregationText.append("tspan").classed("aggregation aggregation-text line-1", true);
				  sumAggregationText.append("tspan").classed("aggregation aggregation-text line-2", true);
				  sumAggregationText.append("tspan").classed("aggregation aggregation-text line-3", true);
				  var clip = newSumAggregations.append("clipPath");
				  clip.append("rect").classed("aggregation-clip-path", true);
				  var combinedSumAggregations = newSumAggregations.merge(sumAggregations);
				  combinedSumAggregations.attr("x", function(d) {
					 return calendarScale(d.startDate);
				  }).attr("y", function(d) {
					 return 0;
				  });
				  combinedSumAggregations.select("rect.background").on("click", function(event, d) {
					 clickEventFn(d, event, "enter");
				  }).attr("x", function(d) {
					 return calendarScale(d.startDate);
				  }).attr("y", function(d) {
					 return getSumAggregationYPos();
				  }).attr("height", function(d) {
					 return sumHeight;
				  }).attr("width", function(d) {
					 return getAggregationXWidth(d);
				  });
				  combinedSumAggregations.select("rect.traffic-light").attr("x", function(d) {
					 return calendarScale(d.startDate);
				  }).attr("y", function(d) {
					 return getSumAggregationYPos();
				  }).attr("height", function(d) {
					 return 5;
				  }).attr("width", function(d) {
					 return getAggregationXWidth(d);
				  }).style("pointer-events", "none").style("fill", function(d) {
					 return d.color;
				  });
				  combinedSumAggregations.select("clipPath").attr("id", function(d) {
					 return "aggregationSumClipPath" + d.id;
				  });
				  combinedSumAggregations.select("rect.aggregation-clip-path").attr("x", function(d) {
					 return calendarScale(d.startDate);
				  }).attr("y", function(d) {
					 return getSumAggregationYPos();
				  }).attr("height", sumHeight).attr("width", function(d) {
					 return getAggregationXWidth(d);
				  }).style("pointer-events", "none");
				  combinedSumAggregations.select("tspan.aggregation-text.line-1").attr("x", function(d) {
					 return calendarScale(d.startDate) + xMargin;
				  }).attr("y", function(d) {
					 return getBaseTextLineYPosition() * -1 - 10;
				  }).attr("clip-path", function(d) {
					 return "url(#aggregationSumClipPath" + d.id + ")";
				  }).attr("font-size", fontSize + "px").attr("font-weight", "bold").style("pointer-events", "none").text(function(d) {
					 return planningBoardDataService.getHelperServices().aggregationService.getAggregationValue(d, textLines.line1.value);
				  });
				  combinedSumAggregations.select("tspan.aggregation-text.line-2").attr("x", function(d) {
					 return calendarScale(d.startDate) + xMargin;
				  }).attr("y", function(d) {
					 return getBaseTextLineYPosition() * -1;
				  }).attr("clip-path", function(d) {
					 return "url(#aggregationSumClipPath" + d.id + ")";
				  }).attr("font-size", fontSize + "px").attr("font-weight", "bold").style("pointer-events", "none").text(function(d) {
					 return planningBoardDataService.getHelperServices().aggregationService.getAggregationValue(d, textLines.line2.value);
				  });
				  combinedSumAggregations.select("tspan.aggregation-text.line-3").attr("x", function(d) {
					 return calendarScale(d.startDate) + xMargin;
				  }).attr("y", function(d) {
					 return getBaseTextLineYPosition() * -1 + 10;
				  }).attr("clip-path", function(d) {
					 return "url(#aggregationSumClipPath" + d.id + ")";
				  }).attr("font-size", fontSize + "px").attr("font-weight", "bold").style("pointer-events", "none").text(function(d) {
					 return planningBoardDataService.getHelperServices().aggregationService.getAggregationValue(d, textLines.line3.value);
				  });
				};
				_aggregateSumItems.setCalendarScale = (cs2) => {
				  calendarScale = cs2;
				  return _aggregateSumItems;
				}, _aggregateSumItems.getCalendarScale = () => {
				  return calendarScale;
				}, _aggregateSumItems.setMapService = (service) => {
				  mapService = service;
				  return _aggregateSumItems;
				}, _aggregateSumItems.getMapService = () => {
				  return mapService;
				}, _aggregateSumItems.setSumAggregates = (a) => {
				  sumAggregates = a;
				  return _aggregateSumItems;
				}, _aggregateSumItems.getSumAggregates = () => {
				  return sumAggregates;
				}, _aggregateSumItems.setClickEventHandler = (fn) => {
				  clickEventFn = fn;
				  return _aggregateSumItems;
				}, _aggregateSumItems.getClickEventHandler = () => {
				  return clickEventFn;
				}, _aggregateSumItems.setSumHeight = (height) => {
				  sumHeight = height;
				  return _aggregateSumItems;
				}, _aggregateSumItems.getSumHeight = () => {
				  return sumHeight;
				}, _aggregateSumItems.setTextLines = (l) => {
				  textLines = l;
				  return _aggregateSumItems;
				}, _aggregateSumItems.getTextLines = () => {
				  return textLines;
				}, _aggregateSumItems.setAggregationTrafficLightsConfig = (config2) => {
				  aggregationTrafficLightsConfig = config2;
				  return _aggregateSumItems;
				}, _aggregateSumItems.getaggregationTrafficLightsConfig = () => {
				  return aggregationTrafficLightsConfig;
				}, _aggregateSumItems.setPlanningBoardDataService = (pBD) => {
				  planningBoardDataService = pBD;
				  return _aggregateSumItems;
				}, _aggregateSumItems.getPlanningBoardDataService = () => {
				  return planningBoardDataService;
				};
				return _aggregateSumItems;
			 };
		  }
		  static {
			 this.\u0275fac = function PlanningBoardAggregateSumItemsComponent_Factory(t) {
				return new (t || _PlanningBoardAggregateSumItemsComponent)();
			 };
		  }
		  static {
			 this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _PlanningBoardAggregateSumItemsComponent, selectors: [["app-planning-board-aggregate-sum-items"]], viewQuery: function PlanningBoardAggregateSumItemsComponent_Query(rf, ctx) {
				if (rf & 1) {
				  \u0275\u0275viewQuery(_c0$f, 7);
				}
				if (rf & 2) {
				  let _t;
				  \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.scrollContent = _t.first);
				}
			 }, standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 2, vars: 0, template: function PlanningBoardAggregateSumItemsComponent_Template(rf, ctx) {
				if (rf & 1) {
				  \u0275\u0275elementStart(0, "p");
				  \u0275\u0275text(1, "planning-board-aggregate-sum-items works!");
				  \u0275\u0275elementEnd();
				}
			 } });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlanningBoardAggregateSumItemsComponent, [{
			 type: Component,
			 args: [{ standalone: true, selector: "app-planning-board-aggregate-sum-items", template: "<p>planning-board-aggregate-sum-items works!</p>\r\n" }]
		  }], null, { scrollContent: [{
			 type: ViewChild,
			 args: ["scrollContent", { static: true }]
		  }] });
		})();
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(PlanningBoardAggregateSumItemsComponent, { className: "PlanningBoardAggregateSumItemsComponent", filePath: "lib\\components\\planning-board-aggregate-sum-items\\planning-board-aggregate-sum-items.component.ts", lineNumber: 17 });
		})();
		var _c0$e = ["scrollContent"];
		var _c1$3 = ["class", "assignment-group-container"];
		var PlanningBoardAssignmentBaseGroupComponent = class _PlanningBoardAssignmentBaseGroupComponent {
		  ngOnInit() {
			 if (!selection_default.prototype.parent) {
				selection_default.prototype.parent = function selectParent() {
				  return this.select(() => {
					 return this.parentNode;
				  });
				};
			 }
		  }
		  static {
			 this.baseAssignment = () => {
				let supplierScale, calendarScale, timeScale, supplierScrollValue, mappingService, assignments, onClickFn, onDblClickFn, onHoverFn, onMouseOutFn, arePointerEventsDeactivated = false;
				const _baseAssignment = function(selection2, event) {
				  function getAssignmentPositionY(d) {
					 if (selection2 && event && event.offsetY && d.modificationData.isDragging) {
						let supplierId = supplierScale.supplierIdForYpx(event.offsetY + supplierScrollValue);
						return supplierScale.getHeaderLineHeight() + supplierScale.getVerticalIndex().get(supplierId) * supplierScale.getLineHeight();
					 }
					 if (!(0, import_lodash.isNull)(d.groupingData.positionY)) {
						return d.groupingData.positionY;
					 }
					 return supplierScale.getHeaderLineHeight() + supplierScale.getVerticalIndex().get(mappingService.supplier(d.originalEntity)) * supplierScale.getLineHeight();
				  }
				  function getAssignmentPositionX(d) {
					 if (selection2 && event && event.offsetX && d.modificationData.isDragging) {
						return event.offsetX;
					 }
					 if (!(0, import_lodash.isNull)(d.groupingData.positionX)) {
						return d.groupingData.positionX;
					 }
					 return calendarScale(new DateExtension(mappingService.from(d.originalEntity)));
				  }
				  function getAssignmentWidth(d) {
					 if (!(0, import_lodash.isNull)(d.groupingData.width)) {
						return d.groupingData.width;
					 } else if (mappingService.duration) {
						let productDuration = mappingService.duration(d.originalEntity);
						const finishDate = new DateExtension();
						const startDate = new DateExtension(finishDate).subtract(productDuration, "seconds");
						return Math.max(10, timeScale(DateExtension.utc(finishDate)) - timeScale(DateExtension.utc(startDate)));
					 }
					 const end = new DateExtension(mappingService.to(d.originalEntity));
					 const start2 = new DateExtension(mappingService.from(d.originalEntity));
					 return Math.max(10, timeScale(DateExtension.utc(end)) - timeScale(DateExtension.utc(start2)));
				  }
				  function getAssignmentHeight(d) {
					 if (!(0, import_lodash.isNull)(d.groupingData.height)) {
						return d.groupingData.height;
					 }
					 return supplierScale.get(d, "bottom") - supplierScale.get(d, "top");
				  }
				  function getFillColor(d) {
					 if (selection2 && event && event.offsetY && d.modificationData.isDragging) {
						return PlanningBoardAssignmentGroupingComponentConstants.defualtDraggingFillColor;
					 }
					 if (!(0, import_lodash.isNull)(d.groupingData.positionX)) {
						return d.groupingData.fillColor;
					 }
					 return PlanningBoardAssignmentGroupingComponentConstants.defualtFillColor;
				  }
				  let baseSelection = selection2.selectAll("rect.base-assignment").data(assignments);
				  baseSelection.exit().remove();
				  baseSelection.enter().append("rect").classed("base-assignment", true).merge(baseSelection).classed("assignment", true).attr("id", function(d) {
					 return mappingService.id(d.originalEntity);
				  }).attr("x", function(d) {
					 return getAssignmentPositionX(d);
				  }).attr("y", function(d) {
					 return getAssignmentPositionY(d);
				  }).attr("width", function(d) {
					 return getAssignmentWidth(d);
				  }).attr("height", function(d) {
					 return getAssignmentHeight(d);
				  }).attr("stroke", "black").attr("fill", function(d) {
					 return getFillColor(d);
				  });
				  if (arePointerEventsDeactivated) {
					 baseSelection.classed("assignment", true).attr("pointer-events", "none");
				  }
				  if ((0, import_lodash.isFunction)(onClickFn)) {
					 baseSelection.classed("assignment", true).on("click", function(d) {
						onClickFn(d);
					 });
				  }
				  if ((0, import_lodash.isFunction)(onDblClickFn)) {
					 baseSelection.classed("assignment", true).on("dblclick", function(d) {
						onDblClickFn(d);
					 });
				  }
				  if ((0, import_lodash.isFunction)(onHoverFn)) {
					 baseSelection.classed("assignment", true).on("mouseover", function(d) {
						onHoverFn(d);
					 });
				  }
				  if ((0, import_lodash.isFunction)(onMouseOutFn)) {
					 baseSelection.classed("assignment", true).on("mouseout", function(d) {
						onMouseOutFn(d);
					 });
				  }
				};
				_baseAssignment.setSupplierScale = (sc) => {
				  supplierScale = sc;
				  return _baseAssignment;
				};
				_baseAssignment.getSupplierScale = () => {
				  return supplierScale;
				};
				_baseAssignment.setCalendarScale = (value) => {
				  calendarScale = value;
				  return _baseAssignment;
				};
				_baseAssignment.getCalendarScale = () => {
				  return calendarScale;
				};
				_baseAssignment.setMapService = (newMappingService) => {
				  mappingService = newMappingService;
				  return _baseAssignment;
				};
				_baseAssignment.getMapService = () => {
				  return mappingService;
				};
				_baseAssignment.setTimeScale = (ts) => {
				  timeScale = ts;
				  return _baseAssignment;
				};
				_baseAssignment.getTimeScale = () => {
				  return timeScale;
				};
				_baseAssignment.setSupplierScrollValue = (sv2) => {
				  supplierScrollValue = sv2;
				  return _baseAssignment;
				};
				_baseAssignment.getSupplierScrollValue = () => {
				  return supplierScrollValue;
				};
				_baseAssignment.setAssignments = (data) => {
				  assignments = data;
				  return _baseAssignment;
				};
				_baseAssignment.getAssignments = () => {
				  return assignments;
				};
				_baseAssignment.setOnHover = (fn) => {
				  onHoverFn = fn;
				  return _baseAssignment;
				};
				_baseAssignment.getOnHover = () => {
				  return onHoverFn;
				};
				_baseAssignment.setOnClick = (fn) => {
				  onClickFn = fn;
				  return _baseAssignment;
				};
				_baseAssignment.getOnClick = () => {
				  return onClickFn;
				};
				_baseAssignment.setOnDblClick = (fn) => {
				  onDblClickFn = fn;
				  return _baseAssignment;
				};
				_baseAssignment.getOnDblClick = () => {
				  return onDblClickFn;
				};
				_baseAssignment.setOnMouseOut = (fn) => {
				  onMouseOutFn = fn;
				  return _baseAssignment;
				};
				_baseAssignment.getOnMouseOut = () => {
				  return onMouseOutFn;
				};
				_baseAssignment.setDeactivatePointerEvents = (value) => {
				  arePointerEventsDeactivated = value;
				  return _baseAssignment;
				};
				_baseAssignment.getDeactivatePointerEvents = () => {
				  return arePointerEventsDeactivated;
				};
				return _baseAssignment;
			 };
		  }
		  static {
			 this.\u0275fac = function PlanningBoardAssignmentBaseGroupComponent_Factory(t) {
				return new (t || _PlanningBoardAssignmentBaseGroupComponent)();
			 };
		  }
		  static {
			 this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _PlanningBoardAssignmentBaseGroupComponent, selectors: [["", 8, "assignment-group-container"]], viewQuery: function PlanningBoardAssignmentBaseGroupComponent_Query(rf, ctx) {
				if (rf & 1) {
				  \u0275\u0275viewQuery(_c0$e, 7);
				}
				if (rf & 2) {
				  let _t;
				  \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.scrollContent = _t.first);
				}
			 }, standalone: true, features: [\u0275\u0275StandaloneFeature], attrs: _c1$3, decls: 2, vars: 0, template: function PlanningBoardAssignmentBaseGroupComponent_Template(rf, ctx) {
				if (rf & 1) {
				  \u0275\u0275elementStart(0, "p");
				  \u0275\u0275text(1, "planning-board-assignment-base works!");
				  \u0275\u0275elementEnd();
				}
			 } });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlanningBoardAssignmentBaseGroupComponent, [{
			 type: Component,
			 args: [{ standalone: true, selector: ".assignment-group-container", template: "<p>planning-board-assignment-base works!</p>\r\n" }]
		  }], null, { scrollContent: [{
			 type: ViewChild,
			 args: ["scrollContent", { static: true }]
		  }] });
		})();
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(PlanningBoardAssignmentBaseGroupComponent, { className: "PlanningBoardAssignmentBaseGroupComponent", filePath: "lib\\components\\planning-board-assignment-base-group\\planning-board-assignment-base-group.component.ts", lineNumber: 20 });
		})();
		var PlanningBoardTooltipComponentConstants;
		(function(PlanningBoardTooltipComponentConstants2) {
		  PlanningBoardTooltipComponentConstants2[PlanningBoardTooltipComponentConstants2["tooltipContainerMargin"] = 7] = "tooltipContainerMargin";
		  PlanningBoardTooltipComponentConstants2[PlanningBoardTooltipComponentConstants2["tooltipTextMargin"] = 25] = "tooltipTextMargin";
		  PlanningBoardTooltipComponentConstants2[PlanningBoardTooltipComponentConstants2["fixedHeightOfSingleAssignment"] = 45.40000057220459] = "fixedHeightOfSingleAssignment";
		  PlanningBoardTooltipComponentConstants2[PlanningBoardTooltipComponentConstants2["xPositionMargin"] = 15] = "xPositionMargin";
		  PlanningBoardTooltipComponentConstants2[PlanningBoardTooltipComponentConstants2["widthMarginTooltipText"] = 30] = "widthMarginTooltipText";
		  PlanningBoardTooltipComponentConstants2[PlanningBoardTooltipComponentConstants2["rectHeight"] = 12] = "rectHeight";
		  PlanningBoardTooltipComponentConstants2[PlanningBoardTooltipComponentConstants2["textFontSize"] = 12] = "textFontSize";
		  PlanningBoardTooltipComponentConstants2[PlanningBoardTooltipComponentConstants2["dyTooltipText"] = 15] = "dyTooltipText";
		  PlanningBoardTooltipComponentConstants2[PlanningBoardTooltipComponentConstants2["paddingBetweenLines"] = 15] = "paddingBetweenLines";
		})(PlanningBoardTooltipComponentConstants || (PlanningBoardTooltipComponentConstants = {}));
		var _c0$d = ["scrollContent"];
		var _c1$2 = ["class", "assignment-tooltip-container"];
		var PlanningBoardTooltipComponent = class _PlanningBoardTooltipComponent {
		  ngOnInit() {
			 if (!selection_default.prototype.parent) {
				selection_default.prototype.parent = function selectParent() {
				  return this.select(() => {
					 return this.parentNode;
				  });
				};
			 }
		  }
		  static {
			 this.tooltip = () => {
				let supplierScale, calendarScale, supplierScrollValue, assignmentMappingService, assignments, onClickFn, onDblClickFn, onHoverFn, positionX;
				let _tooltip = function(selection2, event) {
				  function getCollectionYPos(assignment, event2) {
					 if (selection2 && event2 && event2.offsetY) {
						const offsetY = event2.offsetY;
						let supplierId = supplierScale.supplierIdForYpx(offsetY + supplierScrollValue);
						return supplierScale.getHeaderLineHeight() + supplierScale.getVerticalIndex().get(supplierId) * supplierScale.getLineHeight();
					 }
					 var supplierIdx = supplierScale.getVerticalIndex().get(assignmentMappingService.supplier(assignment.originalEntity));
					 if ((0, import_lodash.isUndefined)(supplierIdx)) {
						return 0;
					 } else {
						return supplierScale.getHeaderLineHeight() + supplierIdx * supplierScale.getLineHeight() + (supplierScale.getLineHeight() - PlanningBoardTooltipComponentConstants.rectHeight);
					 }
				  }
				  function getCorrectRectHeight() {
					 return selection2.selectAll("g.tooltip-container text")._groups[0][0].getBoundingClientRect().height + PlanningBoardTooltipComponentConstants.paddingBetweenLines;
				  }
				  let tooltipSelection = selection2.selectAll("g.tooltip-container").data(assignments);
				  tooltipSelection.exit().remove();
				  tooltipSelection.enter().append("g").classed("tooltip-container", true).merge(tooltipSelection);
				  tooltipSelection.raise();
				  let tooltipDiv = selection2.selectAll("g.tooltip-container").append("rect").style("background", "transparent").attr("stroke", "#6c848d").attr("fill", "#ADD8E6").attr("x", function() {
					 if (!(0, import_lodash.isUndefined)(positionX)) {
						return positionX;
					 }
					 return calendarScale(assignmentMappingService.from(assignments[0].originalEntity));
				  }).attr("y", function(d) {
					 return getCollectionYPos(assignments[0], event) + PlanningBoardTooltipComponentConstants.fixedHeightOfSingleAssignment * assignments.indexOf(d) + PlanningBoardTooltipComponentConstants.tooltipContainerMargin;
				  });
				  let tooltipText = selection2.selectAll("g.tooltip-container").append("text").attr("dx", "15px").style("pointer-events", "none").classed("assignmentdescription", true).attr("x", function(d) {
					 if (!(0, import_lodash.isUndefined)(positionX)) {
						return positionX;
					 }
					 return calendarScale(assignmentMappingService.from(assignments[0].originalEntity));
				  }).text(function(d) {
					 return assignmentMappingService.from(d.originalEntity).format("PPPP p") + " - " + assignmentMappingService.to(d.originalEntity).format("PPPP p");
				  }).attr("width", function(d) {
					 return 300;
				  }).attr("clip-path", function(d) {
					 return "url(#clip" + assignmentMappingService.id(d.originalEntity) + ")";
				  }).attr("dy", function(d) {
					 return getCollectionYPos(assignments[0], event) + PlanningBoardTooltipComponentConstants.fixedHeightOfSingleAssignment * assignments.indexOf(d) + PlanningBoardTooltipComponentConstants.tooltipTextMargin;
				  }).attr("font-size", function(d) {
					 return PlanningBoardTooltipComponentConstants.textFontSize + "px";
				  }).attr("display", function() {
					 return "block";
				  }).style("position", "absolute").append("tspan").classed("assignmentDescription", true).text(function(d) {
					 return assignmentMappingService.description(d.originalEntity) || "-";
				  }).attr("x", function(d) {
					 if (!(0, import_lodash.isUndefined)(positionX)) {
						return positionX + PlanningBoardTooltipComponentConstants.xPositionMargin;
					 }
					 return calendarScale(assignmentMappingService.from(assignments[0].originalEntity)) + PlanningBoardTooltipComponentConstants.xPositionMargin;
				  }).attr("dy", function() {
					 return PlanningBoardTooltipComponentConstants.dyTooltipText;
				  });
				  tooltipDiv.style("width", function(d) {
					 return selection2.selectAll("g.tooltip-container text")._parents[0].getBoundingClientRect().width + PlanningBoardTooltipComponentConstants.widthMarginTooltipText;
				  }).style("height", function(d) {
					 return getCorrectRectHeight();
				  });
				  if ((0, import_lodash.isFunction)(onClickFn)) {
					 tooltipSelection.classed("assignment", true).on("click", function(d) {
						onClickFn(d);
					 });
				  }
				  if ((0, import_lodash.isFunction)(onDblClickFn)) {
					 tooltipSelection.classed("assignment", true).on("dblclick", function(d) {
						onDblClickFn(d);
					 });
				  }
				  if ((0, import_lodash.isFunction)(onHoverFn)) {
					 tooltipSelection.classed("assignment", true).on("mouseover", function(d) {
						onHoverFn(d);
					 });
				  }
				};
				const component = {
				  selection: _tooltip,
				  setSupplierScale(newSupplierScale) {
					 supplierScale = newSupplierScale;
					 return this;
				  },
				  getSupplierScale() {
					 return supplierScale;
				  },
				  setCalendarScale(newCalendarScale) {
					 calendarScale = newCalendarScale;
					 return this;
				  },
				  getCalendarScale() {
					 return calendarScale;
				  },
				  setMapService(newMappingService) {
					 assignmentMappingService = newMappingService;
					 return this;
				  },
				  getMapService() {
					 return assignmentMappingService;
				  },
				  setSupplierScrollValue(newScrollValue) {
					 supplierScrollValue = newScrollValue;
					 return this;
				  },
				  getSupplierScrollValue() {
					 return supplierScrollValue;
				  },
				  setAssignments(newAssignmentsArray) {
					 assignments = newAssignmentsArray;
					 return this;
				  },
				  getAssignments() {
					 return assignments;
				  },
				  setOnHover(fn) {
					 onHoverFn = fn;
					 return this;
				  },
				  getOnHover() {
					 return onHoverFn;
				  },
				  setOnClick(fn) {
					 onClickFn = fn;
					 return this;
				  },
				  getOnClick() {
					 return onClickFn;
				  },
				  setOnDblClick(fn) {
					 onDblClickFn = fn;
					 return this;
				  },
				  getOnDblClick() {
					 return onDblClickFn;
				  },
				  setPositionX(newPositionX) {
					 positionX = newPositionX;
					 return this;
				  },
				  getPositionX() {
					 return positionX;
				  }
				};
				return component;
			 };
		  }
		  static {
			 this.\u0275fac = function PlanningBoardTooltipComponent_Factory(t) {
				return new (t || _PlanningBoardTooltipComponent)();
			 };
		  }
		  static {
			 this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _PlanningBoardTooltipComponent, selectors: [["", 8, "assignment-tooltip-container"]], viewQuery: function PlanningBoardTooltipComponent_Query(rf, ctx) {
				if (rf & 1) {
				  \u0275\u0275viewQuery(_c0$d, 7);
				}
				if (rf & 2) {
				  let _t;
				  \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.scrollContent = _t.first);
				}
			 }, standalone: true, features: [\u0275\u0275StandaloneFeature], attrs: _c1$2, decls: 2, vars: 0, template: function PlanningBoardTooltipComponent_Template(rf, ctx) {
				if (rf & 1) {
				  \u0275\u0275elementStart(0, "p");
				  \u0275\u0275text(1, "planning-board-tooltip works!");
				  \u0275\u0275elementEnd();
				}
			 } });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlanningBoardTooltipComponent, [{
			 type: Component,
			 args: [{ standalone: true, selector: ".assignment-tooltip-container", template: "<p>planning-board-tooltip works!</p>\r\n" }]
		  }], null, { scrollContent: [{
			 type: ViewChild,
			 args: ["scrollContent", { static: true }]
		  }] });
		})();
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(PlanningBoardTooltipComponent, { className: "PlanningBoardTooltipComponent", filePath: "lib\\components\\planning-board-tooltip\\planning-board-tooltip.component.ts", lineNumber: 15 });
		})();
		var _c0$c = ["scrollContent"];
		var PlanningBoardAssignmentCollectionComponent = class _PlanningBoardAssignmentCollectionComponent {
		  ngOnInit() {
			 if (!selection_default.prototype.parent) {
				selection_default.prototype.parent = function selectParent() {
				  return this.select(() => {
					 return this.parentNode;
				  });
				};
			 }
		  }
		  static {
			 this.assignmentCollection = () => {
				let basicsCommonDrawingUtilitiesService = PlanningBoardExternalServices.basicsCommonDrawingUtilitiesService;
				function getCollectionText(assignmentsData) {
				  let collectionString = "";
				  const assignments = [...new Set(assignmentsData)];
				  if (assignments[0].collectionData.collectionStart && assignments.some((assignment) => assignment.collectionData.isVerticallyCollected)) {
					 collectionString += "+";
				  }
				  return assignments.length > 9 ? collectionString + "*" : collectionString + assignments.length;
				}
				function getCollectionYPos(assignment) {
				  let supplierIdx = supplierScale.getVerticalIndex().get(mapService.supplier(assignment.originalEntity));
				  if ((0, import_lodash.isUndefined)(supplierIdx)) {
					 return 0;
				  } else if (assignment.collectionData.collectionStart && assignment.collectionData.isVerticallyCollected) {
					 return supplierScale.getHeaderLineHeight() + supplierIdx * supplierScale.getLineHeight() + (supplierScale.getLineHeight() - rectHeight);
				  } else {
					 return supplierScale.getHeaderLineHeight() + supplierIdx * supplierScale.getLineHeight() + 1;
				  }
				}
				function getCollectionWidth(assignment) {
				  if (assignment.collectionData.collectionStart && assignment.collectionData.isVerticallyCollected) {
					 return rectWidth;
				  }
				  return rectHeight;
				}
				let calendarScale, supplierScale, mapService, assignmentCollectionsObject, collectionConfig, supplierScrollValue, calendarDateEnd, calendarDateStart;
				let rectHeight = 12;
				let rectWidth = 15;
				const fontSizeMany = 17;
				const fontSizeSmall = 12;
				let previousMousePosition = {
				  x: 0,
				  y: 0
				};
				let assignmentGroupTooltipsLayer = selection_default().select("g.assignment-tooltip-container");
				const _assignmentCollection = (selectionRef) => {
				  const visibleSupplierIds = Array.from(supplierScale.getVerticalIndex().keys());
				  if (assignmentCollectionsObject) {
					 assignmentCollectionsObject = assignmentCollectionsObject.filter((assignmentCollection) => visibleSupplierIds.includes(mapService.supplier(assignmentCollection[0].originalEntity)));
					 assignmentCollectionsObject = assignmentCollectionsObject.filter((assignmentCollection) => {
						if (!mapService) {
						  return true;
						}
						const assignmentFromDates = assignmentCollection.map((assignment) => mapService.from(assignment.originalEntity));
						const assignmentToDates = assignmentCollection.map((assignment) => mapService.to(assignment.originalEntity));
						return DateExtension.min(assignmentFromDates).getTime() - calendarDateEnd.getTime() <= -36e5 && DateExtension.max(assignmentToDates).getTime() - calendarDateStart.getTime() >= 36e5;
					 });
					 assignmentCollectionsObject = assignmentCollectionsObject.map((x) => [...new Set(x).values()]);
				  }
				  function onMouseOut(event) {
					 if (previousMousePosition.x !== event.clientX && previousMousePosition.y !== event.clientY) {
						assignmentGroupTooltipsLayer.transition().duration(100).style("opacity", 0);
						const tooltipDiv = assignmentGroupTooltipsLayer.selectAll("rect");
						const tooltipDiv2 = assignmentGroupTooltipsLayer.selectAll("text");
						tooltipDiv.remove();
						tooltipDiv2.remove();
					 }
				  }
				  let collectionContainer = selectionRef.select("g.collection-container");
				  collectionContainer.raise();
				  let collections = collectionContainer.selectAll("g.collection").data(assignmentCollectionsObject);
				  let newCollections = collections.enter().append("g").classed("collection", true);
				  collections.exit().remove();
				  newCollections.append("rect").style("fill", !(0, import_lodash.isUndefined)(collectionConfig) && !(0, import_lodash.isUndefined)(collectionConfig.background) ? basicsCommonDrawingUtilitiesService.intToRgbColor(collectionConfig.background) : "rgba(255,255,255,1)").style("stroke", !(0, import_lodash.isUndefined)(collectionConfig) && !(0, import_lodash.isUndefined)(collectionConfig.border) ? basicsCommonDrawingUtilitiesService.decToHexColor(collectionConfig.border) : "#000000").style("stroke-width", "1px").on("mouseover", function(event, d) {
					 previousMousePosition.x = event.clientX;
					 previousMousePosition.y = event.clientY;
					 assignmentGroupTooltipsLayer = selection_default().select("g.assignment-tooltip-container");
					 const tooltipDiv = assignmentGroupTooltipsLayer.selectAll("rect");
					 const tooltipDiv2 = assignmentGroupTooltipsLayer.selectAll("text");
					 tooltipDiv.remove();
					 tooltipDiv2.remove();
					 const assignmentGroupTooltipComponent = PlanningBoardTooltipComponent.tooltip().setSupplierScale(supplierScale).setCalendarScale(calendarScale).setMapService(mapService).setSupplierScrollValue(supplierScrollValue).setAssignments(d).setPositionX(calendarScale(d[0].collectionData.collectionStart) + 7);
					 assignmentGroupTooltipsLayer.call(assignmentGroupTooltipComponent.selection, event);
					 assignmentGroupTooltipsLayer.on("mouseout", function(event2) {
						onMouseOut(event2);
					 });
					 assignmentGroupTooltipsLayer.transition().duration(100).style("opacity", 0.9);
				  }).on("mouseout", function(event) {
					 onMouseOut(event);
				  }).classed("collection-item", true);
				  newCollections.append("text").style("text-anchor", "middle").style("pointer-events", "none").classed("assignmentdescription", true);
				  let mergedCollections = newCollections.merge(collections);
				  mergedCollections.select("rect.collection-item").attr("height", function() {
					 return rectHeight;
				  }).attr("width", function(d) {
					 return getCollectionWidth(d[0]);
				  }).attr("x", function(d) {
					 return calendarScale(d[0].collectionData.collectionStart);
				  }).attr("y", function(d) {
					 return getCollectionYPos(d[0]);
				  });
				  mergedCollections.attr("x", function(d) {
					 return calendarScale(d[0].collectionData.collectionStart);
				  }).attr("y", function(d) {
					 return getCollectionYPos(d[0]);
				  });
				  mergedCollections.select("text.assignmentdescription").attr("height", function() {
					 return rectHeight;
				  }).attr("width", function(d) {
					 return getCollectionWidth(d[0]);
				  }).attr("x", function(d) {
					 return calendarScale(d[0].collectionData.collectionStart);
				  }).attr("y", function(d) {
					 return getCollectionYPos(d[0]) + (d.length > 9 ? 7 : 0);
				  }).attr("dx", function(d) {
					 return getCollectionWidth(d[0]) / 2;
				  }).attr("dy", function(d) {
					 return rectHeight / 2 + 4 - (d.length > 9 ? 1 : 0);
				  }).style("font-size", function(d) {
					 return d.length > 9 ? "17px" : "12px";
				  }).style("fill", !(0, import_lodash.isUndefined)(collectionConfig) && !(0, import_lodash.isUndefined)(collectionConfig.font) ? basicsCommonDrawingUtilitiesService.intToRgbColor(collectionConfig.font) : "rgba(0,0,0,1)").text(function(d) {
					 return getCollectionText(d);
				  });
				};
				_assignmentCollection.setCalendarScale = (s) => {
				  calendarScale = s;
				  return _assignmentCollection;
				};
				_assignmentCollection.getCalendarScale = () => {
				  return calendarScale;
				};
				_assignmentCollection.setSupplierScale = (s) => {
				  supplierScale = s;
				  return _assignmentCollection;
				};
				_assignmentCollection.getSupplierScale = () => {
				  return supplierScale;
				};
				_assignmentCollection.setAssignments = (a) => {
				  assignmentCollectionsObject = a;
				  return _assignmentCollection;
				};
				_assignmentCollection.getAssignments = () => {
				  return assignmentCollectionsObject;
				};
				_assignmentCollection.setMapService = (service) => {
				  mapService = service;
				  return _assignmentCollection;
				};
				_assignmentCollection.getMapService = () => {
				  return mapService;
				};
				_assignmentCollection.setCollectionConfig = (config2) => {
				  collectionConfig = config2;
				  return _assignmentCollection;
				};
				_assignmentCollection.getCollectionConfig = () => {
				  return collectionConfig;
				};
				_assignmentCollection.setSupplierScrollValue = (value) => {
				  supplierScrollValue = value;
				  return _assignmentCollection;
				};
				_assignmentCollection.getSupplierScrollValue = () => {
				  return supplierScrollValue;
				};
				_assignmentCollection.setCalendarDateStart = (cds) => {
				  calendarDateStart = cds;
				  return _assignmentCollection;
				};
				_assignmentCollection.getCalendarDateStart = () => {
				  return calendarDateStart;
				};
				_assignmentCollection.setCalendarDateEnd = (cde) => {
				  calendarDateEnd = cde;
				  return _assignmentCollection;
				};
				_assignmentCollection.getCalendarDateEnd = () => {
				  return calendarDateEnd;
				};
				return _assignmentCollection;
			 };
		  }
		  static {
			 this.\u0275fac = function PlanningBoardAssignmentCollectionComponent_Factory(t) {
				return new (t || _PlanningBoardAssignmentCollectionComponent)();
			 };
		  }
		  static {
			 this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _PlanningBoardAssignmentCollectionComponent, selectors: [["app-planning-board-assignment-collection"]], viewQuery: function PlanningBoardAssignmentCollectionComponent_Query(rf, ctx) {
				if (rf & 1) {
				  \u0275\u0275viewQuery(_c0$c, 7);
				}
				if (rf & 2) {
				  let _t;
				  \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.scrollContent = _t.first);
				}
			 }, standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 2, vars: 0, template: function PlanningBoardAssignmentCollectionComponent_Template(rf, ctx) {
				if (rf & 1) {
				  \u0275\u0275elementStart(0, "p");
				  \u0275\u0275text(1, "planning-board-assignment-collection works!");
				  \u0275\u0275elementEnd();
				}
			 } });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlanningBoardAssignmentCollectionComponent, [{
			 type: Component,
			 args: [{ standalone: true, selector: "app-planning-board-assignment-collection", template: "<p>planning-board-assignment-collection works!</p>\r\n" }]
		  }], null, { scrollContent: [{
			 type: ViewChild,
			 args: ["scrollContent", { static: true }]
		  }] });
		})();
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(PlanningBoardAssignmentCollectionComponent, { className: "PlanningBoardAssignmentCollectionComponent", filePath: "lib\\components\\planning-board-assignment-collection\\planning-board-assignment-collection.component.ts", lineNumber: 23 });
		})();
		var PlanningBoardAssignmentComponentConstants;
		(function(PlanningBoardAssignmentComponentConstants2) {
		  PlanningBoardAssignmentComponentConstants2[PlanningBoardAssignmentComponentConstants2["maxFontSizeInfoText"] = 13] = "maxFontSizeInfoText";
		  PlanningBoardAssignmentComponentConstants2[PlanningBoardAssignmentComponentConstants2["maxSpaceInfoTexts"] = 25] = "maxSpaceInfoTexts";
		  PlanningBoardAssignmentComponentConstants2[PlanningBoardAssignmentComponentConstants2["maxIconSize"] = 15] = "maxIconSize";
		  PlanningBoardAssignmentComponentConstants2[PlanningBoardAssignmentComponentConstants2["minAssignmentSize"] = 1] = "minAssignmentSize";
		})(PlanningBoardAssignmentComponentConstants || (PlanningBoardAssignmentComponentConstants = {}));
		var _c0$b = ["scrollContent"];
		var PlanningBoardAssignmentItemsComponent = class _PlanningBoardAssignmentItemsComponent {
		  ngOnInit() {
			 if (!selection_default.prototype.parent) {
				selection_default.prototype.parent = function selectParent() {
				  return this.select(() => {
					 return this.parentNode;
				  });
				};
			 }
			 drag_default().filter(function() {
				return true;
			 });
		  }
		  static {
			 this.assignmentItems = () => {
				let basicsCommonDrawingUtilitiesService = PlanningBoardExternalServices.basicsCommonDrawingUtilitiesService;
				let basicsCustomizeReservationTypeIconService = PlanningBoardExternalServices.basicsCustomizeReservationTypeIconService;
				let BasicsSharedStatusIconService = PlanningBoardExternalServices.BasicsSharedStatusIconService;
				let basicsUnitLookupDataService = PlanningBoardExternalServices.basicsUnitLookupDataService;
				let globals = PlanningBoardExternalServices.PlatformConfigurationService;
				const rgbaColorCache = {};
				let allStausIconItems = {};
				let allReservationStausIconItems = {};
				let calendarScale, supplierScale, dragHandler, clickEventHandler, doubleClickEventHandler, assignmentStartDragHandler, assignmentEndDragHandler, showHeaderColor, showSameAssignments, showStatusIcon, showInTransportIcon, showTypeIcon, showMainText, showInfo1Text, showInfo2Text, showInfo3Text, statusIconItems, backgroundColorConfig, mainInfoLabel, info1Label, info2Label, info3Label, typeIconItems, mapService, assignmentDataService, assignments, draggingAssignmentSupplier, lastDraggingAssignmentSupplier = -1, draggingAssignment, isMultiSelect = false, assignmentCollection, aggregationHeight = 20, useTaggingSystem = false, calendarDateStart, calendarDateEnd, containerDimensions, supplierScrollValue;
				const _assignmentItems = (selection2) => {
				  let assignmentData = [];
				  let maintainanceData = [];
				  let layerAssignmentData = {};
				  function getMin(data) {
					 let min3 = data.at(0) || 0;
					 data.forEach((num) => {
						if (num < min3) {
						  min3 = num;
						}
					 });
					 return min3;
				  }
				  function getMax(data) {
					 let max3 = data.at(0) || 0;
					 data.forEach((num) => {
						if (num > max3) {
						  max3 = num;
						}
					 });
					 return max3;
				  }
				  function getAssignmentYPos(d) {
					 let y = supplierScale.get(d, "top");
					 let top2 = d.collisionData.top || 0;
					 return y + top2;
				  }
				  function getAssignmentYHeight(d) {
					 let assignmentHeight = supplierScale.get(d, "bottom") - supplierScale.get(d, "top");
					 return (assignmentHeight - aggregationHeight) * d.collisionData.scale;
				  }
				  function getAssignmentYBottom(d) {
					 return getAssignmentYPos(d) + getAssignmentYHeight(d);
				  }
				  function getAssignmentYCenter(sel, d) {
					 return getAssignmentYPos(d) + getAssignmentYHeight(d) / 2;
				  }
				  function getAssignmentIconSize(d) {
					 return getMin([PlanningBoardAssignmentComponentConstants.maxIconSize, getAssignmentYHeight(d) / 4]);
				  }
				  function getAssignmentXWidth(d) {
					 return getMax([PlanningBoardAssignmentComponentConstants.minAssignmentSize, calendarScale(mapService.to(d.originalEntity)) - calendarScale(mapService.from(d.originalEntity))]);
				  }
				  function firstTextLineY(d) {
					 return getMin([PlanningBoardAssignmentComponentConstants.maxSpaceInfoTexts, getMax([10, getAssignmentYHeight(d) / 5 + 15])]);
				  }
				  function textLineHeight(d) {
					 return getMin([PlanningBoardAssignmentComponentConstants.maxFontSizeInfoText, getMax([9, Math.round(Number(getAssignmentYHeight(d) / 14)) + 9])]);
				  }
				  function assignmentInRange(assignment) {
					 return mapService.supplier(draggingAssignment.originalEntity) === mapService.supplier(assignment.originalEntity) || lastDraggingAssignmentSupplier === mapService.supplier(assignment.originalEntity);
				  }
				  function pushIntoDataArrays(d) {
					 if (supplierScale.getVerticalIndex().has(mapService.supplier(d.originalEntity))) {
						if ((0, import_lodash.isFunction)(mapService.layer) && mapService.layer(d.originalEntity).length > 0) {
						  if (!(0, import_lodash.isArray)(layerAssignmentData[mapService.layer(d.originalEntity)])) {
							 layerAssignmentData[mapService.layer(d.originalEntity)] = [];
						  }
						  d.modificationData.Disabled = mapService.isEditable && !mapService.isEditable(d.originalEntity) || true;
						  layerAssignmentData[mapService.layer(d.originalEntity)].push(d);
						} else {
						  if (mapService.forMaintenance && mapService.forMaintenance(d.originalEntity)) {
							 maintainanceData.push(d);
						  } else {
							 assignmentData.push(d);
						  }
						}
					 }
				  }
				  function getBackgroundColorByConfig(id3, items, decreaseFactor, bgcEntity) {
					 let color2 = "";
					 if (id3) {
						if (!bgcEntity) {
						  bgcEntity = items.find((sii) => sii.Id === id3 && sii.BackgroundColor);
						}
						if (bgcEntity) {
						  let dec = +bgcEntity.BackgroundColor;
						  color2 = rgbaColorCache[dec] && rgbaColorCache[dec][decreaseFactor];
						  if (!color2) {
							 let hexa = bgcEntity.BackgroundColor.toString(16);
							 hexa = hexa.padStart(6, "0").slice();
							 let r = parseInt(hexa[0] + hexa[1], 16) - decreaseFactor;
							 let g = parseInt(hexa[2] + hexa[3], 16) - decreaseFactor;
							 let b = parseInt(hexa[4] + hexa[5], 16) - decreaseFactor;
							 let a = parseInt(hexa[6] + hexa[7], 16) / 255 || 1;
							 color2 = "rgba(" + r + "," + g + "," + b + "," + a + ")";
							 !rgbaColorCache[dec] ? rgbaColorCache[dec] = {} : true;
							 rgbaColorCache[dec][decreaseFactor] = color2;
						  }
						}
					 }
					 return color2;
				  }
				  function decreaseValueByFactor(value, decreaseFactor) {
					 if (value >= decreaseFactor) {
						return value - decreaseFactor;
					 }
					 return 0;
				  }
				  function getBackgroundColor(assignment, decreaseFactor) {
					 let defaulColor = "rgb(128, 171, 202)";
					 let color2 = defaulColor;
					 switch (backgroundColorConfig.id) {
						case "statuscolor":
						  color2 = mapService.status ? getBackgroundColorByConfig(mapService.status(assignment.originalEntity), statusIconItems, decreaseFactor) : color2;
						  break;
						case "projectcolor":
						  if (mapService.project(assignment.originalEntity) > 0 && mapService.headerColor) {
							 let headerColor = mapService.headerColor(assignment.originalEntity);
							 if ((0, import_lodash.isNumber)(headerColor)) {
								let dec = +headerColor;
								color2 = rgbaColorCache[dec] && rgbaColorCache[dec][decreaseFactor];
								if (!color2) {
								  let d3interpolate = rainbow_default(headerColor);
								  let value = d3interpolate.substring(4, d3interpolate.length - 1).split(",");
								  color2 = `rgba(${decreaseValueByFactor(1 * +value[0], decreaseFactor)}, ${decreaseValueByFactor(1 * +value[1], decreaseFactor)}, ${decreaseValueByFactor(1 * +value[2], decreaseFactor)}, 1)`;
								  !rgbaColorCache[dec] ? rgbaColorCache[dec] = {} : true;
								  rgbaColorCache[dec][decreaseFactor] = color2;
								}
							 } else {
								color2 = headerColor;
							 }
						  }
						  break;
						case "ppsHeadercolor":
						  if (mapService.project(assignment.originalEntity) > 0 && mapService.ppsHeaderColor) {
							 let ppsHeaderColor = mapService.ppsHeaderColor(assignment.originalEntity);
							 if ((0, import_lodash.isNumber)(ppsHeaderColor)) {
								let dec = +ppsHeaderColor;
								color2 = rgbaColorCache[dec] && rgbaColorCache[dec][decreaseFactor];
								if (!color2) {
								  color2 = basicsCommonDrawingUtilitiesService.intToRgbColor(ppsHeaderColor).toString();
								  let rValue = +color2.toString().split(",")[0].substring(5);
								  let gValue = +color2.toString().split(",")[1];
								  let bValue = +color2.toString().split(",")[2];
								  color2 = `rgba(${decreaseValueByFactor(1 * rValue, decreaseFactor)}, ${decreaseValueByFactor(1 * gValue, decreaseFactor)}, ${decreaseValueByFactor(1 * bValue, decreaseFactor)}, 1)`;
								  !rgbaColorCache[dec] ? rgbaColorCache[dec] = {} : true;
								  rgbaColorCache[dec][decreaseFactor] = color2;
								}
							 }
						  } else {
							 color2 = defaulColor;
						  }
						  break;
						case "defaultcolor":
						  color2 = defaulColor;
						  break;
						default:
						  break;
					 }
					 return color2;
				  }
				  let xMargin = 3;
				  let draggerSize = 5;
				  let projSize = 5;
				  let redrawAll = true;
				  allReservationStausIconItems = Object.fromEntries(basicsCustomizeReservationTypeIconService.getItems().map((icon) => [icon.id, icon]));
				  const drawAssignment = (data, assignmentType) => {
					 let isMaintenance = assignmentType === "maintenance";
					 let layer = (0, import_lodash.includes)(assignmentType, "layer");
					 let assignmentGs;
					 let assignmentContainer = selection2.selectAll("g." + assignmentType + "-container").data([{ "type": assignmentType }]);
					 assignmentContainer.enter().append("g").classed(assignmentType + "-container", true);
					 assignmentContainer.exit().remove();
					 if (assignmentType.indexOf("layer") >= 0) {
						assignmentContainer.lower();
					 }
					 if (redrawAll) {
						const calendarDateEndTime = calendarDateEnd.getTime();
						const calendarDateStartTime = calendarDateStart.getTime();
						const filteredSelection = data.filter((assignment) => supplierScale.getVerticalIndexObj().hasOwnProperty(mapService.supplier(assignment.originalEntity)) && (assignment.timeData.startDateInMs - calendarDateEndTime <= -36e5 && assignment.timeData.endDateInMs - calendarDateStartTime >= 36e5));
						assignmentGs = assignmentContainer.selectAll("g." + assignmentType + ".assignment-item").data(filteredSelection, identify);
					 } else {
						assignmentGs = assignmentContainer.selectAll("g." + assignmentType + ".assignment-item").filter((assignment) => {
						  return mapService.supplier(assignment.originalEntity) === lastDraggingAssignmentSupplier || mapService.supplier(assignment.originalEntity) === draggingAssignmentSupplier;
						}).data(data, identify);
					 }
					 assignmentGs.exit().remove();
					 let newassignmentGs;
					 if (!isMaintenance && !layer) {
						newassignmentGs = assignmentGs.enter().append("g").classed("assignment assignment-item", true).attr("data-supplier", function(d) {
						  return mapService.supplier(d.originalEntity);
						}).on("mousedown", clickEventHandler);
					 } else {
						newassignmentGs = assignmentGs.enter().append("g").classed(assignmentType + " assignment-item", true).attr("data-supplier", function(d) {
						  return mapService.supplier(d.originalEntity);
						});
					 }
					 let clip = newassignmentGs.append("clipPath").attr("id", function(d) {
						return "clip" + mapService.id(d.originalEntity);
					 });
					 clip.append("rect").classed("assignmentClipPath", true);
					 newassignmentGs.append("rect").classed("assignment", true);
					 newassignmentGs.each((d, index, groups) => {
						let sel2 = select_default2(groups[index]);
						sel2.on("dblclick", (e, d2) => doubleClickEventHandler(d2.originalEntity));
						sel2.call((sel3) => dragHandler(sel3));
						if (mapService.isFromFixed && !mapService.isFromFixed(d.originalEntity) || (0, import_lodash.isUndefined)(mapService.isFromFixed)) {
						  sel2.append("circle").attr("data-special", (e) => {
							 return "startid-" + mapService.id(e.originalEntity);
						  }).classed("assignmentStartDragHandlerCircle assignmentDragSizeCircle assignmentSizeCircle assignmentActiveSizeCircle", true).attr("r", draggerSize).call((sel3) => assignmentStartDragHandler(sel3));
						}
						if (mapService.isToFixed && !mapService.isToFixed(d.originalEntity) || (0, import_lodash.isUndefined)(mapService.isToFixed)) {
						  sel2.append("circle").attr("data-special", (e) => {
							 return "startid-" + mapService.id(e.originalEntity);
						  }).classed("assignmentEndDragHandlerCircle assignmentDragSizeCircle assignmentSizeCircle assignmentActiveSizeCircle", true).attr("r", draggerSize).call((sel3) => assignmentEndDragHandler(sel3));
						}
					 });
					 newassignmentGs.append("text").attr("dx", xMargin).style("pointer-events", "none").classed("assignmentdescription", true);
					 newassignmentGs.append("text").attr("dx", xMargin).classed("assignmentinfotext1", true);
					 newassignmentGs.append("text").attr("dx", xMargin).classed("assignmentinfotext2", true);
					 newassignmentGs.append("text").attr("dx", xMargin).classed("assignmentinfotext3", true);
					 newassignmentGs.append("use").classed("typeIcon", true);
					 newassignmentGs.append("use").classed("statusIcon", true);
					 newassignmentGs.append("use").classed("inTransportIcon", true);
					 newassignmentGs.append("rect").attr("height", projSize).classed("assignmentHeaderColor", true);
					 newassignmentGs.append("text").classed("modifiedAssignment", true);
					 newassignmentGs.append("image").classed("validation", true);
					 if (mapService.isHighlightAssignments && mapService.isHighlightAssignments() && assignments.size > 0 && (0, import_lodash.isFunction)(mapService.filteredAssignmentsOnProductionSet)) {
						let highlightAssignmentKeys = mapService.filteredAssignmentsOnProductionSet(assignments);
						if (highlightAssignmentKeys.length > 0) {
						  highlightAssignmentKeys.forEach((key) => {
							 newassignmentGs.filter((assignment) => mapService.id(assignment.originalEntity) === key).style("filter", "url(#glow)");
						  });
						}
					 }
					 let combinedassignmentGs = newassignmentGs.merge(assignmentGs);
					 combinedassignmentGs.classed("disabled", (assignment) => {
						return assignment.modificationData.Disabled;
					 });
					 const sel = combinedassignmentGs.select("rect.assignment").classed("activeAssignmentItem", (assignment) => {
						return assignment.modificationData.selectedFlag;
					 }).classed("item", (assignment) => {
						return !assignment.modificationData.selectedFlag;
					 }).attr("height", (d) => {
						return getMax([0, getAssignmentYHeight(d)]);
					 }).attr("width", function(d) {
						return getAssignmentXWidth(d);
					 }).attr("x", function(d) {
						return calendarScale(d.timeData.startDateInMs);
					 }).attr("y", function(d) {
						return getAssignmentYPos(d);
					 }).style("fill", function(d) {
						if (d.modificationData.selectedFlag) {
						  return "rgb(196, 226, 248)";
						} else if (isMaintenance) {
						  return "url(#mainGradient)";
						} else {
						  return getBackgroundColor(d, 0);
						}
					 }).style("stroke", function(d) {
						let decreaseFactor = 50;
						let r = 0, g = 0, b = 0, a = 1;
						if (d.modificationData.selectedFlag) {
						  r = 196 - decreaseFactor;
						  g = 226 - decreaseFactor;
						  b = 248 - decreaseFactor;
						  return "rgba(" + r + ", " + g + ", " + b + ",1)";
						} else if (isMaintenance) {
						  return "rgba(0,0,0,0)";
						} else {
						  return getBackgroundColor(d, decreaseFactor);
						}
					 }).style("cursor", function() {
						return isMaintenance ? "not-allowed" : false;
					 }).style("pointer-events", function() {
						return isMaintenance ? "none" : false;
					 });
					 selectAll_default2(sel.nodes().map((x) => x.parentNode)).selectAll("circle.assignmentDragSizeCircle").classed("assignmentActiveSizeCircle", function(d) {
						return d.modificationData.activeFlag || !isReadOnly(d) || !d.modificationData.Disabled;
					 }).classed("assignmentSizeCircle", function(d) {
						return !d.modificationData.activeFlag || isReadOnly(d) || d.modificationData.Disabled;
					 });
					 combinedassignmentGs.select("circle.assignmentStartDragHandlerCircle").attr("cx", function(d) {
						return calendarScale(d.timeData.startDateInMs);
					 }).attr("cy", function(d) {
						return getAssignmentYCenter(selection2.datum(), d);
					 });
					 combinedassignmentGs.select("circle.assignmentEndDragHandlerCircle").attr("cx", function(d) {
						return calendarScale(d.timeData.endDateInMs);
					 }).attr("cy", function(d) {
						return getAssignmentYCenter(selection2.datum(), d);
					 });
					 combinedassignmentGs.select("use.typeIcon").attr("x", function(d) {
						return xMargin + calendarScale(mapService.from(d.originalEntity));
					 }).attr("y", function(d) {
						return getAssignmentYBottom(d) - getAssignmentIconSize(d) - 2;
					 }).attr("width", function(d) {
						return getAssignmentIconSize(d) + "px";
					 }).attr("height", function(d) {
						return getAssignmentIconSize(d) + "px";
					 }).attr("display", function() {
						return showTypeIcon && !useTaggingSystem ? "block" : "none";
					 }).attr("href", function(d) {
						let icon = "";
						let assignmentType2 = mapService.assignmentType(d.originalEntity);
						if (assignmentType2) {
						  let iconId = 0;
						  let typeIcon = typeIconItems.find((tii) => tii.Id === assignmentType2);
						  if (typeIcon) {
							 iconId = typeIcon.icon;
						  }
						  if (iconId) {
							 let resTypeIconPath = allStausIconItems[+iconId].icon;
							 icon = resTypeIconPath.substring(resTypeIconPath.indexOf("#"));
						  }
						}
						return icon;
					 });
					 combinedassignmentGs.select("use.statusIcon").attr("x", function(d) {
						const withoutIconSize = xMargin + calendarScale(mapService.from(d.originalEntity));
						let withIconSize = calendarScale(mapService.to(d.originalEntity).toDate()) - getAssignmentIconSize(d) - xMargin;
						if (getAssignmentXWidth(d) < 40 && mapService.getTransportInfo && mapService.getTransportInfo(d.originalEntity)) {
						  withIconSize = calendarScale(mapService.to(d.originalEntity).toDate()) - getAssignmentIconSize(d) + xMargin / 2;
						}
						return withIconSize > withoutIconSize ? withIconSize : withoutIconSize;
					 }).attr("y", function(d) {
						let yMargin = 2;
						if (getAssignmentXWidth(d) < 40 && mapService.getTransportInfo && mapService.getTransportInfo(d.originalEntity)) {
						  yMargin = 0;
						}
						return getAssignmentYBottom(d) - getAssignmentIconSize(d) - yMargin;
					 }).attr("width", function(d) {
						let computedAssignmentIconSize = getAssignmentIconSize(d);
						if (getAssignmentXWidth(d) < 40 && mapService.getTransportInfo && mapService.getTransportInfo(d.originalEntity)) {
						  computedAssignmentIconSize = getAssignmentIconSize(d) / 1.4;
						}
						return computedAssignmentIconSize + "px";
					 }).attr("height", function(d) {
						return getAssignmentIconSize(d) + "px";
					 }).attr("display", function() {
						return showStatusIcon && !useTaggingSystem ? "block" : "none";
					 }).attr("href", function(d) {
						let icon = "";
						let status = mapService.status ? mapService.status(d.originalEntity) : -1;
						if (status) {
						  let iconId = 0;
						  let statusIcon = statusIconItems.find((sii) => sii.Id === status);
						  if (statusIcon) {
							 iconId = +statusIcon.icon;
						  }
						  if (iconId) {
							 let resStatusIconPath = BasicsSharedStatusIconService.select({ Icon: iconId });
							 icon = "#" + resStatusIconPath.substring(resStatusIconPath.indexOf(" ") + 1);
						  }
						}
						return icon;
					 });
					 combinedassignmentGs.select("use.inTransportIcon").attr("x", function(d) {
						let xMarginTransport = getAssignmentIconSize(d) + xMargin * 2;
						if (getAssignmentXWidth(d) < 40) {
						  xMarginTransport = getAssignmentIconSize(d) - xMargin;
						}
						const withoutIconSize = xMargin + calendarScale(mapService.from(d.originalEntity).toDate());
						if (useTaggingSystem) {
						  xMarginTransport = xMargin;
						}
						let withIconSize = calendarScale(mapService.to(d.originalEntity).toDate()) - getAssignmentIconSize(d) - xMarginTransport;
						return withIconSize > withoutIconSize ? withIconSize : withoutIconSize;
					 }).attr("y", function(d) {
						let yMargin = 2;
						if (getAssignmentXWidth(d) < 40) {
						  yMargin = 0;
						}
						return getAssignmentYBottom(d) - getAssignmentIconSize(d) - yMargin;
					 }).attr("width", function(d) {
						let computedAssignmentIconSize = getAssignmentIconSize(d);
						if (getAssignmentXWidth(d) < 40) {
						  computedAssignmentIconSize = getAssignmentIconSize(d) / 1.4;
						}
						return computedAssignmentIconSize + "px";
					 }).attr("height", function(d) {
						return getAssignmentIconSize(d) + "px";
					 }).attr("display", function(d) {
						return showInTransportIcon && !isMaintenance ? "block" : "none";
					 }).attr("xlink:href", function(d) {
						let icon = "";
						if ((0, import_lodash.isFunction)(mapService.getTransportInfo) && mapService.getTransportInfo(d.originalEntity).isInTransport) {
						  icon = globals.appBaseUrl + "cloud.style/content/images/status-icons.svg#ico-status94";
						}
						return icon;
					 }).attr("style", function() {
						return "--icon-color-7: black; --icon-color-6: white";
					 });
					 combinedassignmentGs.attr("x", function(d) {
						return calendarScale(mapService.from(d.originalEntity));
					 }).attr("y", function(d) {
						return supplierScale.get(d, "top");
					 });
					 combinedassignmentGs.select("text.assignmentdescription").attr("x", function(d) {
						return calendarScale(mapService.from(d.originalEntity));
					 }).text(function(d) {
						const getTextLineOfTypeData = {
						  property: mainInfoLabel,
						  assignmentOriginal: d.originalEntity,
						  mapService,
						  basicsUnitLookupDataService,
						  isMainInfoLabel: true
						};
						return PlanningBoardLabelConfigService.getTextLineOfType(getTextLineOfTypeData);
					 }).attr("y", function(d) {
						return getAssignmentYPos(d);
					 }).attr("width", function(d) {
						return getAssignmentXWidth(d) - xMargin * 2;
					 }).attr("clip-path", function(d) {
						return "url(#clip" + mapService.id(d.originalEntity) + ")";
					 }).attr("dy", function(d) {
						return firstTextLineY(d);
					 }).attr("font-size", function(d) {
						return textLineHeight(d) + "px";
					 }).attr("display", function() {
						return showMainText ? "block" : "none";
					 }).style("fill", function() {
						return isMaintenance ? "rgb(0,0,0)" : false;
					 });
					 combinedassignmentGs.select("text.assignmentinfotext1").attr("x", function(d) {
						return calendarScale(mapService.from(d.originalEntity));
					 }).text(function(d) {
						const getTextLineOfTypeData = {
						  property: info1Label,
						  assignmentOriginal: d.originalEntity,
						  mapService,
						  basicsUnitLookupDataService,
						  isMainInfoLabel: false
						};
						return PlanningBoardLabelConfigService.getTextLineOfType(getTextLineOfTypeData);
					 }).attr("y", function(d) {
						return getAssignmentYPos(d);
					 }).attr("width", function(d) {
						return getAssignmentXWidth(d) - xMargin * 2;
					 }).attr("clip-path", function(d) {
						return "url(#clip" + mapService.id(d.originalEntity) + ")";
					 }).attr("dy", function(d) {
						return firstTextLineY(d) + (textLineHeight(d) + 3);
					 }).attr("font-size", function(d) {
						return textLineHeight(d) - 1 + "px";
					 }).attr("display", function() {
						return showInfo1Text ? "block" : "none";
					 }).style("fill", function() {
						return isMaintenance ? "rgb(0,0,0)" : false;
					 }).attr("cursor", function(d) {
						return d.modificationData.selectedFlag ? "move" : "pointer";
					 });
					 combinedassignmentGs.select("text.assignmentinfotext2").attr("x", function(d) {
						return calendarScale(mapService.from(d.originalEntity));
					 }).text(function(d) {
						const getTextLineOfTypeData = {
						  property: info2Label,
						  assignmentOriginal: d.originalEntity,
						  mapService,
						  basicsUnitLookupDataService,
						  isMainInfoLabel: false
						};
						return PlanningBoardLabelConfigService.getTextLineOfType(getTextLineOfTypeData);
					 }).attr("y", function(d) {
						return getAssignmentYPos(d);
					 }).attr("width", function(d) {
						return getAssignmentXWidth(d) - xMargin * 2;
					 }).attr("clip-path", function(d) {
						return "url(#clip" + mapService.id(d.originalEntity) + ")";
					 }).attr("dy", function(d) {
						return firstTextLineY(d) + 2 * (textLineHeight(d) + 3);
					 }).attr("font-size", function(d) {
						return textLineHeight(d) - 1 + "px";
					 }).attr("display", function() {
						return showInfo2Text ? "block" : "none";
					 }).style("fill", function() {
						return isMaintenance ? "rgb(0,0,0)" : false;
					 }).attr("cursor", function(d) {
						return d.modificationData.selectedFlag ? "move" : "pointer";
					 });
					 combinedassignmentGs.select("text.assignmentinfotext3").attr("x", function(d) {
						return calendarScale(mapService.from(d.originalEntity));
					 }).text(function(d) {
						const getTextLineOfTypeData = {
						  property: info3Label,
						  assignmentOriginal: d.originalEntity,
						  mapService,
						  basicsUnitLookupDataService,
						  isMainInfoLabel: false
						};
						return PlanningBoardLabelConfigService.getTextLineOfType(getTextLineOfTypeData);
					 }).attr("y", function(d) {
						return getAssignmentYPos(d);
					 }).attr("width", function(d) {
						return getAssignmentXWidth(d) - xMargin * 2;
					 }).attr("clip-path", function(d) {
						return "url(#clip" + mapService.id(d.originalEntity) + ")";
					 }).attr("dy", function(d) {
						return firstTextLineY(d) + 3 * (textLineHeight(d) + 3);
					 }).attr("font-size", function(d) {
						return textLineHeight(d) - 1 + "px";
					 }).attr("display", function() {
						return showInfo3Text ? "block" : "none";
					 }).style("fill", function() {
						return isMaintenance ? "rgb(0,0,0)" : false;
					 }).attr("cursor", function(d) {
						return d.modificationData.selectedFlag ? "move" : "pointer";
					 });
					 combinedassignmentGs.select("rect.assignmentClipPath").attr("x", function(d) {
						return calendarScale(mapService.from(d.originalEntity));
					 }).attr("y", function(d) {
						return getAssignmentYPos(d);
					 }).attr("width", function(d) {
						return getAssignmentXWidth(d);
					 }).attr("height", function(d) {
						return getAssignmentYHeight(d);
					 });
					 combinedassignmentGs.select("rect.assignmentHeaderColor").attr("x", function(d) {
						return calendarScale(mapService.from(d.originalEntity)) + 1;
					 }).attr("y", function(d) {
						return getAssignmentYPos(d);
					 }).attr("width", function(d) {
						let result = getAssignmentXWidth(d) - 2;
						if (result > 0) {
						  return result;
						} else {
						  return 0;
						}
					 }).style("fill", function(d) {
						if (isMaintenance) {
						  return "transparent";
						}
						if (showSameAssignments && d.modificationData.areRelated) {
						  return "rgb(0,0,0)";
						}
						if (showHeaderColor && mapService.project(d.originalEntity) > 0) {
						  let headerColor = mapService.headerColor(d.originalEntity);
						  if ((0, import_lodash.isNumber)(headerColor)) {
							 return rainbow_default(headerColor);
						  } else {
							 return headerColor;
						  }
						} else {
						  return "transparent";
						}
					 }).attr("display", function() {
						return !useTaggingSystem ? "block" : "none";
					 }).attr("height", 5);
					 combinedassignmentGs.select("text.modifiedAssignment").attr("x", function(d) {
						return calendarScale(mapService.from(d.originalEntity));
					 }).attr("dx", function(d) {
						return getAssignmentXWidth(d) - xMargin;
					 }).text((d) => {
						if (d.modificationData.pBoardModified) {
						  return "*";
						}
						return "";
					 }).attr("y", function(d) {
						return getAssignmentYPos(d);
					 }).attr("width", function(d) {
						return getAssignmentXWidth(d) - xMargin * 2;
					 }).attr("clip-path", function(d) {
						return "url(#clip" + mapService.id(d.originalEntity) + ")";
					 }).attr("dy", function(d) {
						return firstTextLineY(d) + textLineHeight(d);
					 }).attr("font-size", function(d) {
						return textLineHeight(d) * 2.5 + "px";
					 }).attr("display", function(d) {
						return d.modificationData.pBoardModified && !useTaggingSystem ? "block" : "none";
					 }).style("text-anchor", "end").style("fill", "red").style("stroke", "white").style("stroke-width", "2px").style("paint-order", "stroke");
					 combinedassignmentGs.select("image.validation").attr("x", function(d) {
						let marginRight = getAssignmentIconSize(d) + 5;
						if (d.modificationData.pBoardModified) {
						  marginRight = getAssignmentIconSize(d) + 15;
						}
						return calendarScale(mapService.from(d.originalEntity)) + getAssignmentXWidth(d) - marginRight;
					 }).attr("y", function(d) {
						return getAssignmentYPos(d) + 10;
					 }).attr("width", function(d) {
						return getAssignmentIconSize(d) + "px";
					 }).attr("height", function(d) {
						return getAssignmentIconSize(d) + "px";
					 }).attr("display", function(d) {
						return !d.validationData.isValid && !useTaggingSystem ? "block" : "none";
					 }).attr("xlink:href", globals.appBaseUrl + "cloud.style/content/images/tlb-icons.svg#ico-validation-error");
				  };
				  (0, import_lodash.forEach)(selection2.datum(), function(val) {
					 if (draggingAssignmentSupplier && !isMultiSelect) {
						if (assignmentInRange(val)) {
						  pushIntoDataArrays(val);
						}
						redrawAll = false;
					 } else {
						redrawAll = true;
						pushIntoDataArrays(val);
					 }
				  });
				  selection2.select("g.tooltip-container").remove();
				  let tooltipDiv = selection2.append("g").style("width", "100%").style("height", "100%").style("opacity", 0).style("background", "transparent").style("border-radius", "1px").style("pointer-events", "none").classed("tooltip-container", true);
				  tooltipDiv.exit().remove();
				  (0, import_lodash.forEachRight)(layerAssignmentData, (layer, idx) => {
					 drawAssignment(layer, "layer-" + idx);
				  });
				  drawAssignment(assignmentData, "assignment");
				  drawAssignment(maintainanceData, "maintenance");
				  selection2.select("#mainGradient").remove();
				  let mainHatch = selection2.append("pattern").attr("id", "mainGradient").attr("patternUnits", "userSpaceOnUse").attr("patternTransform", "rotate(45 0 0)").attr("width", "20").attr("height", "10");
				  mainHatch.append("line").attr("x1", "0").attr("y1", "0").attr("x2", "0").attr("y2", "10").style("stroke", "rgba(70,70,70,.35)").style("stroke-width", "20");
				  mainHatch.append("line").attr("x1", "20").attr("y1", "0").attr("x2", "20").attr("y2", "10").style("stroke", "rgba(0,0,0,.35)").style("stroke-width", "20");
				  function identify(assignment) {
					 return mapService.id(assignment.originalEntity);
				  }
				  function isReadOnly(assignment) {
					 return !(0, import_lodash.isUndefined)(mapService.isReadOnly) ? mapService.isReadOnly(assignment.originalEntity) : false;
				  }
				};
				_assignmentItems.setCalendarScale = (cs2) => {
				  calendarScale = cs2;
				  return _assignmentItems;
				};
				_assignmentItems.getCalendarScale = () => {
				  return calendarScale;
				};
				_assignmentItems.setSupplierScale = (sc) => {
				  supplierScale = sc;
				  return _assignmentItems;
				};
				_assignmentItems.getSupplierScale = () => {
				  return supplierScale;
				};
				_assignmentItems.setDragHandler = (dh) => {
				  dragHandler = dh;
				  return _assignmentItems;
				};
				_assignmentItems.getDragHandler = () => {
				  return dragHandler;
				};
				_assignmentItems.setClickHandler = (ch) => {
				  clickEventHandler = ch;
				  return _assignmentItems;
				};
				_assignmentItems.getClickHandler = () => {
				  return clickEventHandler;
				};
				_assignmentItems.setDoubleClickEvent = (dch) => {
				  doubleClickEventHandler = dch;
				  return _assignmentItems;
				};
				_assignmentItems.getDoubleClickEvent = () => {
				  return doubleClickEventHandler;
				};
				_assignmentItems.setAssignmentStartDragHandler = (asdh) => {
				  assignmentStartDragHandler = asdh;
				  return _assignmentItems;
				};
				_assignmentItems.getAssignmentStartDragHandler = () => {
				  return assignmentStartDragHandler;
				};
				_assignmentItems.setAssignmentEndDragHandler = (aedh) => {
				  assignmentEndDragHandler = aedh;
				  return _assignmentItems;
				};
				_assignmentItems.getAssignmentEndDragHandler = () => {
				  return assignmentEndDragHandler;
				};
				_assignmentItems.setShowHeaderColor = (bShow) => {
				  showHeaderColor = bShow;
				  return _assignmentItems;
				};
				_assignmentItems.getShowHeaderColor = () => {
				  return showHeaderColor;
				};
				_assignmentItems.setShowSameAssignments = (bShow) => {
				  showSameAssignments = bShow;
				  return _assignmentItems;
				};
				_assignmentItems.getShowSameAssignments = () => {
				  return showSameAssignments;
				};
				_assignmentItems.setShowStatusIcon = (bShow) => {
				  showStatusIcon = bShow;
				  return _assignmentItems;
				};
				_assignmentItems.getShowStatusIcon = () => {
				  return showStatusIcon;
				};
				_assignmentItems.setBackgroundColorConfig = (bShow) => {
				  backgroundColorConfig = bShow;
				  return _assignmentItems;
				};
				_assignmentItems.getBackgroundColorConfig = () => {
				  return backgroundColorConfig;
				};
				_assignmentItems.setStatusIconItems = (sii) => {
				  statusIconItems = sii;
				  allStausIconItems = Object.fromEntries(statusIconItems.map((icon) => [icon.Id, icon]));
				  return _assignmentItems;
				};
				_assignmentItems.getStatusIconItems = () => {
				  return statusIconItems;
				};
				_assignmentItems.setShowTypeIcon = (bShow) => {
				  showTypeIcon = bShow;
				  return _assignmentItems;
				};
				_assignmentItems.getShowTypeIcon = () => {
				  return showTypeIcon;
				};
				_assignmentItems.setShowMainText = (bShow) => {
				  showMainText = bShow;
				  return _assignmentItems;
				};
				_assignmentItems.getShowMainText = () => {
				  return showMainText;
				};
				_assignmentItems.setShowInfo1Text = (bShow) => {
				  showInfo1Text = bShow;
				  return _assignmentItems;
				};
				_assignmentItems.getshowInfo1Text = () => {
				  return showInfo1Text;
				};
				_assignmentItems.setShowInfo2Text = (bShow) => {
				  showInfo2Text = bShow;
				  return _assignmentItems;
				};
				_assignmentItems.getShowInfo2Text = () => {
				  return showInfo2Text;
				};
				_assignmentItems.setShowInfo3Text = (bShow) => {
				  showInfo3Text = bShow;
				  return _assignmentItems;
				};
				_assignmentItems.getShowInfo3Text = () => {
				  return showInfo3Text;
				};
				_assignmentItems.setMainInfoLabel = (text) => {
				  mainInfoLabel = text;
				  return _assignmentItems;
				};
				_assignmentItems.getMainInfoLabel = () => {
				  return mainInfoLabel;
				};
				_assignmentItems.setInfo1Label = (text) => {
				  info1Label = text;
				  return _assignmentItems;
				};
				_assignmentItems.getInfo1Label = () => {
				  return info1Label;
				};
				_assignmentItems.setInfo2Label = (text) => {
				  info2Label = text;
				  return _assignmentItems;
				};
				_assignmentItems.getInfo2Label = () => {
				  return info2Label;
				};
				_assignmentItems.setInfo3Label = (text) => {
				  info3Label = text;
				  return _assignmentItems;
				};
				_assignmentItems.getInfo3Label = () => {
				  return info3Label;
				};
				_assignmentItems.setTypeIconItems = (tii) => {
				  typeIconItems = tii;
				  return _assignmentItems;
				};
				_assignmentItems.getTypeIconItems = () => {
				  return typeIconItems;
				};
				_assignmentItems.setMapService = (service) => {
				  mapService = service;
				  return _assignmentItems;
				};
				_assignmentItems.getMapService = () => {
				  return mapService;
				};
				_assignmentItems.setAssignmentDataService = (service) => {
				  assignmentDataService = service;
				  return _assignmentItems;
				};
				_assignmentItems.getAssignmentDataService = () => {
				  return assignmentDataService;
				};
				_assignmentItems.setAssignments = (a) => {
				  assignments = a;
				  return _assignmentItems;
				};
				_assignmentItems.getAssignments = () => {
				  return assignments;
				};
				_assignmentItems.setDraggingAssignmentSupplier = (supplierId) => {
				  lastDraggingAssignmentSupplier = draggingAssignmentSupplier;
				  draggingAssignmentSupplier = supplierId;
				  return _assignmentItems;
				};
				_assignmentItems.getDraggingAssignmentSupplier = () => {
				  return draggingAssignmentSupplier;
				};
				_assignmentItems.setDraggingAssignment = (assignment) => {
				  draggingAssignment = assignment;
				  return _assignmentItems;
				};
				_assignmentItems.getDraggingAssignment = () => {
				  return draggingAssignment;
				};
				_assignmentItems.setIsMultiSelect = (ims) => {
				  isMultiSelect = ims;
				  return _assignmentItems;
				};
				_assignmentItems.getIsMultiSelect = () => {
				  return isMultiSelect;
				};
				_assignmentItems.setAssignmentCollection = (ac) => {
				  assignmentCollection = ac;
				  return _assignmentItems;
				};
				_assignmentItems.getAssignmentCollection = () => {
				  return assignmentCollection;
				};
				_assignmentItems.setAggregationHeight = (height) => {
				  aggregationHeight = height;
				  return _assignmentItems;
				};
				_assignmentItems.getAggregationHeight = () => {
				  return aggregationHeight;
				};
				_assignmentItems.setUseTaggingSystem = (ts) => {
				  useTaggingSystem = ts;
				  return _assignmentItems;
				};
				_assignmentItems.getUseTaggingSystem = () => {
				  return useTaggingSystem;
				};
				_assignmentItems.setCalendarDateStart = (cds) => {
				  calendarDateStart = cds;
				  return _assignmentItems;
				};
				_assignmentItems.getCalendarDateStart = () => {
				  return calendarDateStart;
				};
				_assignmentItems.setCalendarDateEnd = (cde) => {
				  calendarDateEnd = cde;
				  return _assignmentItems;
				};
				_assignmentItems.getCalendarDateEnd = () => {
				  return calendarDateEnd;
				};
				_assignmentItems.setContainerDimensions = (containerDimensionsFn) => {
				  if (containerDimensionsFn) {
					 containerDimensions = containerDimensionsFn;
				  }
				  return _assignmentItems;
				};
				_assignmentItems.getContainerDimensions = () => {
				  return containerDimensions;
				};
				_assignmentItems.setSupplierScrollValue = (supplierScroll) => {
				  supplierScrollValue = supplierScroll;
				  return _assignmentItems;
				};
				_assignmentItems.getSupplierScrollValue = () => {
				  return supplierScrollValue;
				};
				_assignmentItems.setShowInTransportIcon = (showInTransportIndicator) => {
				  showInTransportIcon = showInTransportIndicator;
				  return _assignmentItems;
				};
				_assignmentItems.getShowInTransportIcon = () => {
				  return showInTransportIcon;
				};
				return _assignmentItems;
			 };
		  }
		  static {
			 this.\u0275fac = function PlanningBoardAssignmentItemsComponent_Factory(t) {
				return new (t || _PlanningBoardAssignmentItemsComponent)();
			 };
		  }
		  static {
			 this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _PlanningBoardAssignmentItemsComponent, selectors: [["app-planning-board-assignment-items"]], viewQuery: function PlanningBoardAssignmentItemsComponent_Query(rf, ctx) {
				if (rf & 1) {
				  \u0275\u0275viewQuery(_c0$b, 7);
				}
				if (rf & 2) {
				  let _t;
				  \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.scrollContent = _t.first);
				}
			 }, standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 2, vars: 0, template: function PlanningBoardAssignmentItemsComponent_Template(rf, ctx) {
				if (rf & 1) {
				  \u0275\u0275elementStart(0, "p");
				  \u0275\u0275text(1, "planning-board-assignment-items works!");
				  \u0275\u0275elementEnd();
				}
			 } });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlanningBoardAssignmentItemsComponent, [{
			 type: Component,
			 args: [{ standalone: true, selector: "app-planning-board-assignment-items", template: "<p>planning-board-assignment-items works!</p>\r\n" }]
		  }], null, { scrollContent: [{
			 type: ViewChild,
			 args: ["scrollContent", { static: true }]
		  }] });
		})();
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(PlanningBoardAssignmentItemsComponent, { className: "PlanningBoardAssignmentItemsComponent", filePath: "lib\\components\\planning-board-assignment-items\\planning-board-assignment-items.component.ts", lineNumber: 29 });
		})();
		var _c0$a = ["scrollContent"];
		var PlanningBoardAssignmentTagComponent = class _PlanningBoardAssignmentTagComponent {
		  ngOnInit() {
			 if (!selection_default.prototype.parent) {
				selection_default.prototype.parent = function selectParent() {
				  return this.select(() => {
					 return this.parentNode;
				  });
				  {
				  }
				  ;
				};
			 }
		  }
		  static {
			 this.assignmentTags = () => {
				let globals = PlanningBoardExternalServices.PlatformConfigurationService, basicsCommonDrawingUtilitiesService = PlanningBoardExternalServices.basicsCommonDrawingUtilitiesService, BasicsSharedStatusIconService = PlanningBoardExternalServices.BasicsSharedStatusIconService, basicsCustomizeReservationTypeIconService = PlanningBoardExternalServices.basicsCustomizeReservationTypeIconService;
				const hexColorCache = {};
				let calendarScale, supplierScale, tagConfig, mapService, statusIconItems, typeIconItems, showSameAssignments, useFilter, calendarDateStart, calendarDateEnd, calendarFrom, calendarTo, clickEventHandler, dragHandler, containerDimensions, supplierScrollValue, getCurrentZoomUnit;
				let allStatusIconItems = {};
				const _assignmentTags = (selection2) => {
				  function identify(assignment) {
					 return mapService.id(assignment.originalEntity);
				  }
				  function getYPos(d) {
					 let y = supplierScale.get(d, "top");
					 let top2 = d.collisionData.top || 0;
					 return y + top2;
				  }
				  function parseDecToRgba(dec) {
					 if ((0, import_lodash.isString)(dec) && dec.charAt(0) === "#") {
						dec = dec.substring(1);
					 }
					 let color2 = hexColorCache[+dec];
					 if (!color2) {
						const hexaString = dec.toString(16);
						const hexaCharArray = hexaString.split("");
						let r = parseInt(hexaCharArray[0] + hexaCharArray[1], 16);
						let g = parseInt(hexaCharArray[2] + hexaCharArray[3], 16);
						let b = parseInt(hexaCharArray[4] + hexaCharArray[5], 16);
						let a = parseInt(hexaCharArray[6] + hexaCharArray[7], 16) / 255 || 1;
						color2 = "rgba(" + r + "," + g + "," + b + "," + a + ")";
						hexColorCache[dec] = color2;
					 }
					 return color2;
				  }
				  function getBackgroundColorByConfig(id3, items, decreaseFactor, bgcEntity) {
					 let color2;
					 if (id3) {
						if (!bgcEntity) {
						  bgcEntity = items.find((sii) => sii.Id === +id3 && sii.BackgroundColor);
						}
						if (bgcEntity && bgcEntity.BackgroundColor) {
						  let dec = +bgcEntity.BackgroundColor;
						  color2 = hexColorCache[dec];
						  if (!color2) {
							 const hexaString = dec.toString(16);
							 const hexaCharArray = hexaString.padStart(6, "0").slice();
							 let r = parseInt(hexaCharArray[0] + hexaCharArray[1], 16) - decreaseFactor;
							 let g = parseInt(hexaCharArray[2] + hexaCharArray[3], 16) - decreaseFactor;
							 let b = parseInt(hexaCharArray[4] + hexaCharArray[5], 16) - decreaseFactor;
							 let a = parseInt(hexaCharArray[6] + hexaCharArray[7], 16) / 255 || 1;
							 color2 = "rgba(" + r + "," + g + "," + b + "," + a + ")";
							 hexColorCache[dec] = color2;
						  }
						}
					 }
					 return color2;
				  }
				  function getTagBackgroundColor(assignment, config2) {
					 let color2 = "";
					 if (mapService.status) {
						switch (config2.id) {
						  case "status":
							 let status = mapService.status(assignment.originalEntity);
							 if (status) {
								let statusIcon = allStatusIconItems[+status];
								if (statusIcon && statusIcon.BackgroundColor) {
								  color2 = getBackgroundColorByConfig(statusIcon.icon, statusIconItems, 0) || parseDecToRgba(config2.color);
								}
							 }
							 break;
						  case "type":
							 let assignmentType = mapService.assignmentType(assignment.originalEntity);
							 if (assignmentType) {
								color2 = parseDecToRgba(config2.color) || getEmptyColor();
							 } else {
								color2 = getEmptyColor();
							 }
							 break;
						  case "project":
							 if (showSameAssignments && assignment.modificationData.areRelated) {
								color2 = "rgb(0,0,0)";
							 } else {
								let headerColor = mapService.headerColor(assignment.originalEntity);
								color2 = rainbow_default(headerColor);
							 }
							 break;
						  case "validation":
							 if (assignment.validationData.isValid && assignment.validationData.invalidItems.length > 0) {
								color2 = "rgb(205,133,25)";
							 } else if (assignment.validationData.isValid) {
								color2 = "rgb(66,205,25)";
							 } else {
								color2 = "rgb(201,34,34)";
							 }
							 break;
						  case "ppsHeader":
							 if (mapService.ppsHeaderColor) {
								let ppsHeaderColor = mapService.ppsHeaderColor(assignment.originalEntity);
								if (ppsHeaderColor) {
								  const rgbaColor = basicsCommonDrawingUtilitiesService.intToRgbColor(ppsHeaderColor);
								  color2 = "rgba(" + rgbaColor.r + "," + rgbaColor.g + "," + rgbaColor.b + "," + rgbaColor.opacity + ")";
								} else {
								  color2 = PlanningBoardAssignmentTagComponentConstants.defaultTagColor;
								}
							 }
							 break;
						  default:
							 color2 = parseDecToRgba(config2.color) || "rgba(100,100,100)";
							 break;
						}
					 }
					 return color2;
				  }
				  function getTagIcon(assignment, config2) {
					 let icon = "", iconId = 0;
					 if (mapService.status) {
						switch (config2.id) {
						  case "status":
							 let status = mapService.status(assignment.originalEntity);
							 if (status) {
								let statusIcon = allStatusIconItems[+status];
								if (statusIcon && statusIcon.BackgroundColor) {
								  iconId = +statusIcon.icon;
								}
								if (iconId) {
								  let resStatusIconPath = BasicsSharedStatusIconService.select({ Icon: iconId });
								  icon = globals.appBaseUrl + "cloud.style/content/images/status-icons.svg#" + resStatusIconPath.substring(resStatusIconPath.indexOf(" ") + 1);
								}
							 }
							 break;
						  case "type":
							 let assignmentType = mapService.assignmentType(assignment.originalEntity);
							 if (assignmentType) {
								typeIconItems.forEach(function(tii) {
								  if (tii.Id === assignmentType) {
									 iconId = tii.icon;
								  }
								});
								if (iconId) {
								  let resTypeIconPath = basicsCustomizeReservationTypeIconService.getImageResById(iconId);
								  icon = globals.appBaseUrl + "cloud.style/content/images/type-icons.svg#" + resTypeIconPath.substring(resTypeIconPath.indexOf("#"));
								}
							 }
							 break;
						  case "validation":
							 if (assignment.validationData.isValid && assignment.validationData.invalidItems.length > 0) {
								icon = globals.appBaseUrl + "cloud.style/content/images/tlb-icons.svg#ico-warning";
							 } else if (!assignment.validationData.isValid) {
								icon = globals.appBaseUrl + "cloud.style/content/images/tlb-icons.svg#ico-validation-error";
							 }
							 break;
						  case "project":
							 break;
						  case "ppsHeader":
							 break;
						  default:
							 console.warn("No icon defined for: " + config2.id);
							 break;
						}
					 }
					 return icon;
				  }
				  function getEdgeTagIcon(item, type2) {
					 let icon = "";
					 if ((0, import_lodash.isFunction)(mapService.isLocked) && mapService.isLocked(item.originalEntity, type2)) {
						icon = globals.appBaseUrl + "cloud.style/content/images/type-icons.svg#ico-event41";
					 } else if (type2 === "start") {
						icon = globals.appBaseUrl + "cloud.style/content/images/tlb-icons.svg#ico-rec-previous";
					 } else if (type2 === "end") {
						icon = globals.appBaseUrl + "cloud.style/content/images/tlb-icons.svg#ico-rec-next";
					 }
					 return icon;
				  }
				  function getEmptyIcon() {
					 return globals.appBaseUrl + "cloud.style/content/images/tlb-icons.svg#ico-warning";
				  }
				  function getEmptyColor() {
					 return PlanningBoardAssignmentTagComponentConstants.defaultEmptyColor.toString();
				  }
				  function getAssignmentXWidth(assignment, calendarToFromDiff) {
					 if (!calendarToFromDiff) {
						calendarToFromDiff = calendarScale(assignment.timeData.startDateInMs) - calendarScale(assignment.timeData.endDateInMs);
					 }
					 return 1 > calendarToFromDiff ? 1 : calendarToFromDiff;
				  }
				  function getTagWidth(d, tagCount) {
					 return PlanningBoardAssignmentTagComponentConstants.tagWidthBig;
				  }
				  function getTagCount(assignmentComponentWidth, d) {
					 let reservedTagCounter = d.modificationData.pBoardModified ? 4 : 3;
					 const calculatedRestWidth = assignmentComponentWidth - PlanningBoardAssignmentTagComponentConstants.tagWidth * reservedTagCounter;
					 return Math.floor(calculatedRestWidth / PlanningBoardAssignmentTagComponentConstants.tagWidthBig);
				  }
				  selection2.raise();
				  const calendarDateEndTime = calendarDateEnd.getTime();
				  const calendarDateStartTime = calendarDateStart.getTime();
				  const filteredSelection = selection2.datum().filter((assignment) => supplierScale.getVerticalIndexObj().hasOwnProperty(mapService.supplier(assignment.originalEntity)) && (assignment.timeData.startDateInMs - calendarDateEndTime <= -36e5 && assignment.timeData.endDateInMs - calendarDateStartTime >= 36e5));
				  let tags = selection2.selectAll("g.tag-items").data(filteredSelection, identify);
				  let newTags = tags.enter().append("g").classed("tag-items", true).on("mousedown", clickEventHandler);
				  let tagClip = newTags.append("clip").attr("id", function(d) {
					 return "clip" + mapService.id(d.originalEntity);
				  });
				  tagClip.append("rect").attr("width", function(d) {
					 return getAssignmentXWidth(d);
				  }).attr("height", PlanningBoardAssignmentTagComponentConstants.tagHeight).classed("tag-clip", true);
				  let changedTags;
				  if (useFilter) {
					 const tagsPreviousMetaData = new Map([...tags].map((d, index3, group2) => {
						const previousState = group2[index3];
						const previousFrom = new DateExtension(previousState.getAttribute("data-from"));
						const previousTo = new DateExtension(previousState.getAttribute("data-to"));
						const supplier = parseInt(previousState.getAttribute("data-supplier"));
						return [previousState, { from: previousFrom, to: previousTo, supplier }];
					 }));
					 changedTags = tags.filter((d, index, group) => {
						let previousState = tagsPreviousMetaData.get(group[index]);
						return mapService.supplier(d.originalEntity) !== parseInt(previousState.supplier) || !mapService.from(d.originalEntity).isSame(previousState.from) || !mapService.to(d.originalEntity).isSame(previousState.to);
					 });
					 if (changedTags.data().length > 0) {
						const collisionsOfChanged = new Set(changedTags.data().flatMap((collidingWithChanged) => collidingWithChanged.collisionData._collisionsArray.flatMap((x) => x)));
						let collidingWithChangedTags = tags.filter((tagData) => collisionsOfChanged.has(tagData));
						changedTags = collidingWithChangedTags;
					 }
				  } else {
					 changedTags = tags;
				  }
				  tags.exit().remove();
				  let mergedTags = newTags.merge(changedTags);
				  let clips = mergedTags.selectAll("rect.tag-clip");
				  clips.attr("x", function(d) {
					 return calendarScale(d.timeData.startDateInMs);
				  }).attr("y", function(d) {
					 return getYPos(d);
				  });
				  mergedTags.attr("data-supplier", function(d) {
					 return mapService.supplier(d.originalEntity);
				  }).attr("data-from", function(d) {
					 return d.timeData.startDateInMs;
				  }).attr("data-to", function(d) {
					 return d.timeData.endDateInMs;
				  }).attr("data-collision-id", function(d) {
					 return d.collisionData.collisionId;
				  }).attr("display", function(d) {
					 return (0, import_lodash.isFunction)(mapService.forMaintenance) && !mapService.forMaintenance(d.originalEntity) ? "block" : "none";
				  }).attr("cursor", function(d) {
					 return d.modificationData.selectedFlag ? "move" : "pointer";
				  }).classed("disabled", (assignment) => {
					 return assignment.modificationData.Disabled;
				  });
				  mergedTags.each((d, index, groups) => {
					 const tagItems = select_default2(groups[index]);
					 calendarFrom = calendarScale(d.timeData.startDateInMs);
					 calendarTo = calendarScale(d.timeData.endDateInMs);
					 const tagCount = getTagCount(getAssignmentXWidth(d, calendarTo - calendarFrom), d);
					 const tagYPos = getYPos(d);
					 select_default2(tagItems.node()).call((sel) => dragHandler(sel));
					 if (tagConfig) {
						let tagBackgrounds = select_default2(tagItems.node()).selectAll("rect.tag-item-background").data(tagConfig);
						let newTagBackgrounds = tagBackgrounds.enter().append("rect").attr("height", PlanningBoardAssignmentTagComponentConstants.tagHeight).attr("width", function() {
						  return PlanningBoardAssignmentTagComponentConstants.tagWidthBig;
						}).classed("tag-item tag-item-background", true);
						tagBackgrounds.exit().remove();
						let mergedTagBackgrounds = newTagBackgrounds.merge(tagBackgrounds);
						mergedTagBackgrounds.attr("y", tagYPos).attr("x", function(config2) {
						  return calendarFrom + PlanningBoardAssignmentTagComponentConstants.tagWidthBig * config2.sort + PlanningBoardAssignmentTagComponentConstants.marginLeft;
						}).attr("display", function(config2) {
						  return config2.sort <= tagCount - 1 && config2.visible ? "block" : "none";
						}).style("fill", function(config2) {
						  return getTagBackgroundColor(d, config2);
						});
					 }
					 if (tagConfig) {
						let filteredConfig = tagConfig.filter((conf) => !!conf.icon);
						let tagIcons = select_default2(tagItems.node()).selectAll("image.tag-item-icon").data(filteredConfig);
						let newTagIcons = tagIcons.enter().append("image").attr("height", PlanningBoardAssignmentTagComponentConstants.tagHeight - 2).attr("width", function() {
						  return PlanningBoardAssignmentTagComponentConstants.tagWidthBig - 2;
						}).classed("tag-item tag-item-icon", true);
						tagIcons.exit().remove();
						let mergedTagIcons = newTagIcons.merge(tagIcons);
						mergedTagIcons.attr("y", tagYPos + 1).attr("x", function(config2) {
						  return calendarFrom + PlanningBoardAssignmentTagComponentConstants.tagWidthBig * config2.sort + PlanningBoardAssignmentTagComponentConstants.marginLeft;
						}).attr("display", function(config2) {
						  return config2.sort <= tagCount - 1 && config2.visible ? "block" : "none";
						}).attr("xlink:href", function(config2) {
						  let tagIcon = getTagIcon(d, config2);
						  return tagIcon.length === 0 ? tagIcon : "";
						});
					 }
					 let collectionTags = select_default2(tagItems.node()).selectAll("rect.collection-tag").data([d], identify);
					 let newCollectionTags = collectionTags.enter().append("rect").attr("height", PlanningBoardAssignmentTagComponentConstants.tagHeight).attr("width", PlanningBoardAssignmentTagComponentConstants.tagWidth).style("fill", function(d2) {
						return "rgba(210,210,210)";
					 }).classed("tag-item collection-tag", true);
					 collectionTags.exit().remove();
					 let mergedCollectionTags = newCollectionTags.merge(collectionTags);
					 mergedCollectionTags.attr("y", tagYPos).attr("x", function(d2) {
						let reservedTagCounter = d2.modificationData.pBoardModified ? 3 : 2;
						return calendarTo - PlanningBoardAssignmentTagComponentConstants.tagWidth * reservedTagCounter;
					 }).attr("display", function(d2) {
						return tagConfig.length > tagCount ? "block" : "none";
					 });
					 let collectionTagImages = select_default2(tagItems.node()).selectAll("image.collection-image").data([d], identify);
					 let newCollectionTagImages = collectionTagImages.enter().append("image").attr("width", function(d2) {
						return "12px";
					 }).attr("height", function(d2) {
						return "12px";
					 }).attr("xlink:href", globals.appBaseUrl + "cloud.style/content/images/tlb-icons.svg#ico-menu").classed("tag-image collection-image", true);
					 collectionTagImages.exit().remove();
					 let mergedCollectionTagImages = newCollectionTagImages.merge(collectionTagImages);
					 mergedCollectionTagImages.attr("y", tagYPos).attr("x", function(d2) {
						let reservedTagCounter = d2.modificationData.pBoardModified ? 3 : 2;
						return calendarTo - PlanningBoardAssignmentTagComponentConstants.tagWidth * reservedTagCounter;
					 }).attr("display", function(d2) {
						return tagConfig.length > tagCount ? "block" : "none";
					 });
					 let modifiedTags = select_default2(tagItems.node()).selectAll("rect.modified-tag").data([d], identify);
					 let newModifiedTags = modifiedTags.enter().append("rect").attr("height", PlanningBoardAssignmentTagComponentConstants.tagHeight).attr("width", PlanningBoardAssignmentTagComponentConstants.tagWidth).style("fill", function(d2) {
						return "rgb(197, 197, 197)";
					 }).classed("tag-item modified-tag", true);
					 modifiedTags.exit().remove();
					 let mergedModifiedTags = newModifiedTags.merge(modifiedTags);
					 mergedModifiedTags.attr("y", tagYPos).attr("x", function() {
						return calendarTo - PlanningBoardAssignmentTagComponentConstants.tagWidth * 2;
					 }).attr("display", function(d2) {
						return d2.modificationData.pBoardModified ? "block" : "none";
					 });
					 let modifiedTagTexts = select_default2(tagItems.node()).selectAll("text.modified-tag-text").data([d], identify);
					 let newMergedModifiedTagTexts = modifiedTagTexts.enter().append("text").text("*").attr("dx", 1).attr("dy", 20).attr("height", PlanningBoardAssignmentTagComponentConstants.tagHeight).attr("width", PlanningBoardAssignmentTagComponentConstants.tagWidth).attr("font-size", "25px").style("fill", "red").classed("tag-item tag-text modified-tag-text", true);
					 modifiedTagTexts.exit().remove();
					 let mergedModifiedTagTexts = newMergedModifiedTagTexts.merge(modifiedTagTexts);
					 mergedModifiedTagTexts.attr("y", tagYPos).attr("x", function() {
						return calendarTo - PlanningBoardAssignmentTagComponentConstants.tagWidth * 2;
					 }).attr("display", function(d2) {
						return d2.modificationData.pBoardModified ? "block" : "none";
					 });
					 let startTags = select_default2(tagItems.node()).selectAll("rect.start-tag").data([d], identify);
					 let newStartTags = startTags.enter().append("rect").attr("height", PlanningBoardAssignmentTagComponentConstants.tagHeight).attr("width", PlanningBoardAssignmentTagComponentConstants.tagWidth).style("fill", function(d2) {
						return PlanningBoardAssignmentTagComponentConstants.defaultTagColor;
					 }).classed("tag-item start-tag", true);
					 startTags.exit().remove();
					 let mergedStartTags = newStartTags.merge(startTags);
					 mergedStartTags.attr("y", tagYPos).attr("x", function(d2) {
						return calendarFrom;
					 });
					 let startTagImages = select_default2(tagItems.node()).selectAll("image.start-tag-image").data([d], identify);
					 let newStartTagImages = startTagImages.enter().append("image").attr("width", function(d2) {
						return "10px";
					 }).attr("height", function(d2) {
						return "10px";
					 }).attr("xlink:href", function(d2) {
						return getEdgeTagIcon(d2, "start");
					 }).classed("tag-image start-tag-image", true);
					 startTagImages.exit().remove();
					 let mergedStartTagImages = newStartTagImages.merge(startTagImages);
					 mergedStartTagImages.attr("x", function(d2) {
						return calendarFrom + 1;
					 }).attr("y", function(d2) {
						return getYPos(d2) + 1;
					 }).attr("xlink:href", function(d2) {
						return getEdgeTagIcon(d2, "start");
					 });
					 let endTags = select_default2(tagItems.node()).selectAll("rect.end-tag").data([d]);
					 let newEndTags = endTags.enter().append("rect").attr("height", PlanningBoardAssignmentTagComponentConstants.tagHeight).attr("width", PlanningBoardAssignmentTagComponentConstants.tagWidth).style("fill", PlanningBoardAssignmentTagComponentConstants.defaultTagColor).classed("tag-item end-tag", true);
					 endTags.exit().remove();
					 let mergedEndTags = newEndTags.merge(endTags);
					 mergedEndTags.attr("y", tagYPos).attr("x", function(d2) {
						return calendarTo - PlanningBoardAssignmentTagComponentConstants.tagWidth;
					 });
					 let endTagImages = select_default2(tagItems.node()).selectAll("image.end-tag-image").data([d]);
					 let newEndTagImages = endTagImages.enter().append("image").attr("width", function(d2) {
						return "10px";
					 }).attr("height", function(d2) {
						return "10px";
					 }).attr("xlink:href", function(d2) {
						return getEdgeTagIcon(d2, "end");
					 }).classed("tag-image end-tag-image", true);
					 endTagImages.exit().remove();
					 let mergedEndTagImages = newEndTagImages.merge(endTagImages);
					 mergedEndTagImages.attr("x", function(d2) {
						return calendarTo - PlanningBoardAssignmentTagComponentConstants.tagWidth + 1;
					 }).attr("y", function(d2) {
						return tagYPos + 1;
					 }).attr("xlink:href", function(d2) {
						return getEdgeTagIcon(d2, "end");
					 });
					 select_default2(tagItems.node()).selectAll("rect").attr("clip-path", (d2) => {
						let url = "";
						if (d2 instanceof AssignmentData) {
						  url = "url(#clip" + mapService.id(d2.originalEntity) + ")";
						}
						return url;
					 });
					 select_default2(tagItems.node()).selectAll("image").attr("clip-path", (d2) => {
						let url = "";
						if (d2 instanceof AssignmentData) {
						  url = "url(#clip" + mapService.id(d2.originalEntity) + ")";
						}
						return url;
					 });
					 select_default2(tagItems.node()).selectAll("text").attr("clip-path", (d2) => {
						let url = "";
						if (d2 instanceof AssignmentData) {
						  url = "url(#clip" + mapService.id(d2.originalEntity) + ")";
						}
						return url;
					 });
				  });
				};
				_assignmentTags.setCalendarScale = (newCalendarScale) => {
				  calendarScale = newCalendarScale;
				  return _assignmentTags;
				};
				_assignmentTags.getCalendarScale = () => {
				  return calendarScale;
				};
				_assignmentTags.setSupplierScale = (newSupplierScale) => {
				  supplierScale = newSupplierScale;
				  return _assignmentTags;
				};
				_assignmentTags.getSupplierScale = () => {
				  return supplierScale;
				};
				_assignmentTags.setMapService = (newMappingService) => {
				  mapService = newMappingService;
				  return _assignmentTags;
				};
				_assignmentTags.getMapService = () => {
				  return mapService;
				};
				_assignmentTags.setTagConfig = (newTagConfig) => {
				  tagConfig = newTagConfig;
				  return _assignmentTags;
				};
				_assignmentTags.getTagConfig = () => {
				  return tagConfig;
				};
				_assignmentTags.setStatusIconItems = (sii) => {
				  statusIconItems = sii;
				  allStatusIconItems = Object.fromEntries(statusIconItems.map((icon) => [icon.Id, icon]));
				  return _assignmentTags;
				};
				_assignmentTags.getStatusIconItems = () => {
				  return statusIconItems;
				};
				_assignmentTags.setTypeIconItems = (tii) => {
				  typeIconItems = tii;
				  return _assignmentTags;
				};
				_assignmentTags.getTypeIconItems = () => {
				  return typeIconItems;
				};
				_assignmentTags.setShowSameAssignments = (bShow) => {
				  showSameAssignments = bShow;
				  return _assignmentTags;
				};
				_assignmentTags.getShowSameAssignments = () => {
				  return showSameAssignments;
				};
				_assignmentTags.setUseFilter = (usefilter) => {
				  useFilter = usefilter;
				  return _assignmentTags;
				};
				_assignmentTags.getUseFilter = () => {
				  return useFilter;
				};
				_assignmentTags.setCalendarDateStart = (cds) => {
				  calendarDateStart = cds;
				  return _assignmentTags;
				};
				_assignmentTags.getCalendarDateStart = () => {
				  return calendarDateStart;
				};
				_assignmentTags.setCalendarDateEnd = (cde) => {
				  calendarDateEnd = cde;
				  return _assignmentTags;
				};
				_assignmentTags.getCalendarDateEnd = () => {
				  return calendarDateEnd;
				};
				_assignmentTags.setClickEventHandler = (ch) => {
				  clickEventHandler = ch;
				  return _assignmentTags;
				};
				_assignmentTags.getClickEventHandler = () => {
				  return clickEventHandler;
				};
				_assignmentTags.setDragHandler = (dragHandlerFn) => {
				  dragHandler = dragHandlerFn;
				  return _assignmentTags;
				};
				_assignmentTags.getDragHandler = () => {
				  return dragHandler;
				};
				_assignmentTags.setContainerDimensions = (containerDimensionsFn) => {
				  containerDimensions = containerDimensionsFn;
				  return _assignmentTags;
				};
				_assignmentTags.getContainerDimensions = () => {
				  return containerDimensions;
				};
				_assignmentTags.setSupplierScrollValue = (supplierScroll) => {
				  supplierScrollValue = supplierScroll;
				  return _assignmentTags;
				};
				_assignmentTags.getSupplierScrollValue = () => {
				  return supplierScrollValue;
				};
				_assignmentTags.setGetCurrentZoomUnit = (unitFn) => {
				  getCurrentZoomUnit = unitFn;
				  return _assignmentTags;
				};
				_assignmentTags.getGetCurrentZoomUnit = () => {
				  return getCurrentZoomUnit;
				};
				return _assignmentTags;
			 };
		  }
		  static {
			 this.\u0275fac = function PlanningBoardAssignmentTagComponent_Factory(t) {
				return new (t || _PlanningBoardAssignmentTagComponent)();
			 };
		  }
		  static {
			 this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _PlanningBoardAssignmentTagComponent, selectors: [["app-planning-board-assignment-tag"]], viewQuery: function PlanningBoardAssignmentTagComponent_Query(rf, ctx) {
				if (rf & 1) {
				  \u0275\u0275viewQuery(_c0$a, 7);
				}
				if (rf & 2) {
				  let _t;
				  \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.scrollContent = _t.first);
				}
			 }, standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 2, vars: 0, template: function PlanningBoardAssignmentTagComponent_Template(rf, ctx) {
				if (rf & 1) {
				  \u0275\u0275elementStart(0, "p");
				  \u0275\u0275text(1, "planning-board-assignment-tag works!");
				  \u0275\u0275elementEnd();
				}
			 } });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlanningBoardAssignmentTagComponent, [{
			 type: Component,
			 args: [{ standalone: true, selector: "app-planning-board-assignment-tag", template: "<p>planning-board-assignment-tag works!</p>\r\n" }]
		  }], null, { scrollContent: [{
			 type: ViewChild,
			 args: ["scrollContent", { static: true }]
		  }] });
		})();
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(PlanningBoardAssignmentTagComponent, { className: "PlanningBoardAssignmentTagComponent", filePath: "lib\\components\\planning-board-assignment-tag\\planning-board-assignment-tag.component.ts", lineNumber: 26 });
		})();
		var _c0$9 = ["scrollContent"];
		var PlanningBoardBackgroundsComponent = class _PlanningBoardBackgroundsComponent {
		  ngOnInit() {
			 if (!selection_default.prototype.parent) {
				selection_default.prototype.parent = function selectParent() {
				  return this.select(() => {
					 return this.parentNode;
				  });
				};
			 }
		  }
		  static {
			 this.backgrounds = () => {
				let supplierScale, bgExceptionDayClickHandler, calendarScale, startDate, endDate, verticalIndexSize, containerDimensions, supplierScrollValue, supplierBackgrounds;
				function filterSupplierInYAxis() {
				  let visibleSuppIds = supplierScale.getVerticalIndex();
				  let filteredSuppliersInY = /* @__PURE__ */ new Map();
				  [...visibleSuppIds.keys()].map((supplierId) => filteredSuppliersInY.set(supplierId, supplierBackgrounds.get(supplierId)));
				  return filteredSuppliersInY;
				}
				const _backgrounds = function(selection2) {
				  const startDateMs = new DateExtension(startDate).getTime();
				  const filteredSuppliersAllAxis = filterSupplierInYAxis();
				  selection2 = selection2.selectAll("g.backgrounds").data([...filteredSuppliersAllAxis.keys()], function identify(supplierId) {
					 return supplierId;
				  });
				  const newBackgrounds = selection2.enter().append("g").classed("backgrounds", true);
				  selection2.exit().remove();
				  selection2 = newBackgrounds.merge(selection2);
				  selection2.attr("height", () => {
					 return supplierScale.getLineHeight();
				  }).attr("width", containerDimensions().width).attr("transform", function(supplierId) {
					 return "translate(0," + (supplierScale.getHeaderLineHeight() + supplierScale.getVerticalIndex().get(supplierId) * supplierScale.getLineHeight()) + ")";
				  });
				  let supplierLineHeight = supplierScale.getLineHeight();
				  selection2.each(function setDayBackground(supplierId, index, nodes) {
					 const supplierBackgroundData = filteredSuppliersAllAxis.get(supplierId);
					 if (supplierBackgroundData && supplierBackgroundData.length > 0) {
						let subBackgrounds = select_default2(nodes[index]).selectAll("rect.sub-background").data(supplierBackgroundData);
						let newSubBackgrounds = subBackgrounds.enter().append("rect").on("click", (event, d) => {
						  bgExceptionDayClickHandler(event, d);
						}).classed("sub-background", true);
						subBackgrounds.exit().remove();
						const mergedSubBackgrounds = newSubBackgrounds.merge(subBackgrounds);
						mergedSubBackgrounds.attr("width", calendarScale(startDateMs + 864e5)).attr("x", function(day) {
						  return calendarScale(day.dayMs);
						}).attr("height", () => {
						  return supplierLineHeight;
						}).style("fill", function(day) {
						  return day.bgColor;
						});
					 }
				  });
				};
				_backgrounds.setSupplierScale = (sc) => {
				  supplierScale = sc;
				  return _backgrounds;
				}, _backgrounds.getSupplierScale = () => {
				  return supplierScale;
				}, _backgrounds.setBgExceptionDayClckHandler = (fn) => {
				  bgExceptionDayClickHandler = fn;
				  return _backgrounds;
				}, _backgrounds.getBgExceptionDayClickHandler = () => {
				  return bgExceptionDayClickHandler;
				}, _backgrounds.setStartDate = (sd) => {
				  startDate = sd;
				  return _backgrounds;
				}, _backgrounds.getStartDate = () => {
				  return startDate;
				}, _backgrounds.setEndDate = (ed) => {
				  endDate = ed;
				  return _backgrounds;
				}, _backgrounds.getEndDate = () => {
				  return endDate;
				}, _backgrounds.setVerticalIndexSize = (vis) => {
				  verticalIndexSize = vis;
				  return _backgrounds;
				}, _backgrounds.getVerticalIndexSize = () => {
				  return verticalIndexSize;
				}, _backgrounds.setTimeScale = (cs2) => {
				  calendarScale = cs2;
				  return _backgrounds;
				}, _backgrounds.getTimeScale = () => {
				  return calendarScale;
				}, _backgrounds.setContainerDimensins = (containerDimensionsFn) => {
				  containerDimensions = containerDimensionsFn;
				  return _backgrounds;
				}, _backgrounds.getContainerDimensions = () => {
				  return containerDimensions;
				}, _backgrounds.setSupplierScrollVaue = (scv) => {
				  supplierScrollValue = scv;
				  return _backgrounds;
				}, _backgrounds.getSupplierScrollValue = () => {
				  return supplierScrollValue;
				}, _backgrounds.setSupplierBackgrounds = (sB) => {
				  supplierBackgrounds = sB;
				  return _backgrounds;
				}, _backgrounds.getSupplierBackgrounds = () => {
				  return supplierBackgrounds;
				};
				return _backgrounds;
			 };
		  }
		  static {
			 this.\u0275fac = function PlanningBoardBackgroundsComponent_Factory(t) {
				return new (t || _PlanningBoardBackgroundsComponent)();
			 };
		  }
		  static {
			 this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _PlanningBoardBackgroundsComponent, selectors: [["app-planning-board-backgrounds"]], viewQuery: function PlanningBoardBackgroundsComponent_Query(rf, ctx) {
				if (rf & 1) {
				  \u0275\u0275viewQuery(_c0$9, 7);
				}
				if (rf & 2) {
				  let _t;
				  \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.scrollContent = _t.first);
				}
			 }, standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 2, vars: 0, template: function PlanningBoardBackgroundsComponent_Template(rf, ctx) {
				if (rf & 1) {
				  \u0275\u0275elementStart(0, "p");
				  \u0275\u0275text(1, "planning-board-backgrounds works!");
				  \u0275\u0275elementEnd();
				}
			 } });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlanningBoardBackgroundsComponent, [{
			 type: Component,
			 args: [{ standalone: true, selector: "app-planning-board-backgrounds", template: "<p>planning-board-backgrounds works!</p>\r\n" }]
		  }], null, { scrollContent: [{
			 type: ViewChild,
			 args: ["scrollContent", { static: true }]
		  }] });
		})();
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(PlanningBoardBackgroundsComponent, { className: "PlanningBoardBackgroundsComponent", filePath: "lib\\components\\planning-board-backgrounds\\planning-board-backgrounds.component.ts", lineNumber: 14 });
		})();
		var _c0$8 = ["scrollContent"];
		var PlanningBoardIndicatorAreasComponent = class _PlanningBoardIndicatorAreasComponent {
		  ngOnInit() {
			 if (!selection_default.prototype.parent) {
				selection_default.prototype.parent = function selectParent() {
				  return this.select(() => {
					 return this.parentNode;
				  });
				};
			 }
		  }
		  static {
			 this.indicatorAreas = () => {
				function getAreaXWidth() {
				  return Math.max(15, calendarScale(endDate) - calendarScale(startDate));
				}
				function getAreaYPosition(d) {
				  const idMapFn = mapService.actualId || mapService.id;
				  let supplierIdx = supplierScale.getVerticalIndex().get(idMapFn(d));
				  if ((0, import_lodash.isUndefined)(supplierIdx)) {
					 return 0;
				  } else {
					 return supplierScale.getHeaderLineHeight() + supplierIdx * supplierScale.getLineHeight() + 1;
				  }
				}
				let supplierScale, calendarScale, startDate, endDate, indicatorY, mapService;
				const indicationTypes = ["warning", "error"];
				const _indicatorAreas = function(selection2) {
				  let newIndicatorAreas = selection2.enter().append("rect").attr("height", function(d) {
					 return supplierScale.getLineHeight();
				  }).attr("width", function(d) {
					 return getAreaXWidth();
				  }).attr("x", function(d) {
					 return calendarScale(startDate);
				  }).attr("y", function(d) {
					 return indicatorY ? indicatorY : getAreaYPosition(d);
				  }).attr("class", function(d) {
					 const indicationType = mapService.indicationAreaType ? mapService.indicationAreaType(d) : "";
					 return indicationTypes.includes(indicationType) ? indicationType : "disabled";
				  }).classed("assignment indicator-area", true);
				  selection2.exit().remove();
				};
				_indicatorAreas.setCalendarScale = (s) => {
				  calendarScale = s;
				  return _indicatorAreas;
				};
				_indicatorAreas.getCalendarScale = () => {
				  return calendarScale;
				};
				_indicatorAreas.setSupplierScale = (sc) => {
				  supplierScale = sc;
				  return _indicatorAreas;
				};
				_indicatorAreas.getSupplierScale = () => {
				  return supplierScale;
				};
				_indicatorAreas.setStartDate = (sd) => {
				  startDate = sd;
				  return _indicatorAreas;
				};
				_indicatorAreas.getStartDate = () => {
				  return startDate;
				};
				_indicatorAreas.setEndDate = (ed) => {
				  endDate = ed;
				  return _indicatorAreas;
				};
				_indicatorAreas.getEndDate = () => {
				  return endDate;
				};
				_indicatorAreas.setIndicatorY = (indY) => {
				  indicatorY = indY;
				  return _indicatorAreas;
				};
				_indicatorAreas.getIndicatorY = () => {
				  return indicatorY;
				};
				_indicatorAreas.setMapService = (supplierMappingService) => {
				  mapService = supplierMappingService;
				  return _indicatorAreas;
				};
				_indicatorAreas.getMapService = () => {
				  return mapService;
				};
				return _indicatorAreas;
			 };
		  }
		  static {
			 this.\u0275fac = function PlanningBoardIndicatorAreasComponent_Factory(t) {
				return new (t || _PlanningBoardIndicatorAreasComponent)();
			 };
		  }
		  static {
			 this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _PlanningBoardIndicatorAreasComponent, selectors: [["app-planning-board-indicator-areas"]], viewQuery: function PlanningBoardIndicatorAreasComponent_Query(rf, ctx) {
				if (rf & 1) {
				  \u0275\u0275viewQuery(_c0$8, 7);
				}
				if (rf & 2) {
				  let _t;
				  \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.scrollContent = _t.first);
				}
			 }, standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 2, vars: 0, template: function PlanningBoardIndicatorAreasComponent_Template(rf, ctx) {
				if (rf & 1) {
				  \u0275\u0275elementStart(0, "p");
				  \u0275\u0275text(1, "planning-board-indicator-areas works!");
				  \u0275\u0275elementEnd();
				}
			 } });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlanningBoardIndicatorAreasComponent, [{
			 type: Component,
			 args: [{ standalone: true, selector: "app-planning-board-indicator-areas", template: "<p>planning-board-indicator-areas works!</p>\r\n" }]
		  }], null, { scrollContent: [{
			 type: ViewChild,
			 args: ["scrollContent", { static: true }]
		  }] });
		})();
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(PlanningBoardIndicatorAreasComponent, { className: "PlanningBoardIndicatorAreasComponent", filePath: "lib\\components\\planning-board-indicator-areas\\planning-board-indicator-areas.component.ts", lineNumber: 19 });
		})();
		var _c0$7 = ["scrollContent"];
		var PlanningBoardLanesComponent = class _PlanningBoardLanesComponent {
		  ngOnInit() {
			 if (!selection_default.prototype.parent) {
				selection_default.prototype.parent = function selectParent() {
				  return this.select(() => {
					 return this.parentNode;
				  });
				};
			 }
		  }
		  static {
			 this.lanes = () => {
				let panelWidth, supplierScale;
				const _lanes = function(selection2) {
				  let newLanes = selection2.enter().append("rect").attr("width", panelWidth).attr("height", 1).classed("lanes", true).classed("lanesLine", true);
				  selection2.exit().remove();
				  selection2 = newLanes.merge(selection2);
				  selection2.attr("width", panelWidth).attr("transform", function(d) {
					 return "translate(0," + (supplierScale.getHeaderLineHeight() + (d + 1) * supplierScale.getLineHeight()) + ")";
				  });
				};
				_lanes.setPanelWidth = (pw) => {
				  panelWidth = pw;
				  return _lanes;
				};
				_lanes.getPanelWidth = () => {
				  return panelWidth;
				};
				_lanes.setSupplierScale = (s) => {
				  supplierScale = s;
				  return _lanes;
				};
				_lanes.getSupplierScale = () => {
				  return supplierScale;
				};
				return _lanes;
			 };
		  }
		  static {
			 this.\u0275fac = function PlanningBoardLanesComponent_Factory(t) {
				return new (t || _PlanningBoardLanesComponent)();
			 };
		  }
		  static {
			 this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _PlanningBoardLanesComponent, selectors: [["app-planning-board-lanes"]], viewQuery: function PlanningBoardLanesComponent_Query(rf, ctx) {
				if (rf & 1) {
				  \u0275\u0275viewQuery(_c0$7, 7);
				}
				if (rf & 2) {
				  let _t;
				  \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.scrollContent = _t.first);
				}
			 }, standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 2, vars: 0, template: function PlanningBoardLanesComponent_Template(rf, ctx) {
				if (rf & 1) {
				  \u0275\u0275elementStart(0, "p");
				  \u0275\u0275text(1, "planning-board-lanes works!");
				  \u0275\u0275elementEnd();
				}
			 } });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlanningBoardLanesComponent, [{
			 type: Component,
			 args: [{ standalone: true, selector: "app-planning-board-lanes", template: "<p>planning-board-lanes works!</p>\r\n" }]
		  }], null, { scrollContent: [{
			 type: ViewChild,
			 args: ["scrollContent", { static: true }]
		  }] });
		})();
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(PlanningBoardLanesComponent, { className: "PlanningBoardLanesComponent", filePath: "lib\\components\\planning-board-lanes\\planning-board-lanes.component.ts", lineNumber: 11 });
		})();
		var _c0$6 = ["scrollContent"];
		var PlanningBoardLineComponent = class _PlanningBoardLineComponent {
		  ngOnInit() {
			 if (!selection_default.prototype.parent) {
				selection_default.prototype.parent = function selectParent() {
				  return this.select(() => {
					 return this.parentNode;
				  });
				};
			 }
		  }
		  static line() {
			 let supplierScale, calendarScale, timeScale, mappingService, assignments, lineColor;
			 const _line = function(selection2) {
				function getPositionY1(d) {
				  if (!(0, import_lodash.isUndefined)(d.groupingData.linePositionY1)) {
					 return d.groupingData.linePositionY1;
				  }
				  return supplierScale.get(d, "bottom");
				}
				function getPositionY2(d) {
				  if (!(0, import_lodash.isUndefined)(d.groupingData.linePositionY2)) {
					 return d.groupingData.linePositionY2;
				  }
				  return supplierScale.get(d, "bottom");
				}
				function getPositionX1(d) {
				  if (!(0, import_lodash.isUndefined)(d.groupingData.linePositionX1)) {
					 return d.groupingData.linePositionX1;
				  }
				  return calendarScale(mappingService.from(d.originalEntity));
				}
				function getPositionX2(d) {
				  if (!(0, import_lodash.isUndefined)(d.groupingData.linePositionX2)) {
					 return d.groupingData.linePositionX2;
				  }
				  return calendarScale(mappingService.from(d.originalEntity));
				}
				let lineSelection = selection2.selectAll("line.base-assignment-line").data(assignments);
				lineSelection.exit().remove();
				lineSelection.enter().append("line").classed("base-assignment-line", true).merge(lineSelection).classed("assignment", true).attr("id", function(d) {
				  return mappingService.id(d.originalEntity);
				}).style("stroke", lineColor).style("stroke-width", 2).style("stroke-dasharray", 2).style("stroke-opacity", 0.8).attr("x1", function(d) {
				  return getPositionX1(d);
				}).attr("x2", function(d) {
				  return getPositionX2(d);
				}).attr("y1", function(d) {
				  return getPositionY1(d);
				}).attr("y2", function(d) {
				  return getPositionY2(d);
				});
			 };
			 _line.setSupplierScale = (newSupplierScale) => {
				supplierScale = newSupplierScale;
				return _line;
			 };
			 _line.getSupplierScale = () => {
				return supplierScale;
			 };
			 _line.setCalendarScale = (newCalendarScale) => {
				calendarScale = newCalendarScale;
				return _line;
			 };
			 _line.getCalendarScale = () => {
				return calendarScale;
			 };
			 _line.setMapService = (newMappingService) => {
				mappingService = newMappingService;
				return _line;
			 };
			 _line.getMapService = () => {
				return mappingService;
			 };
			 _line.setTimeScale = (newTimeScale) => {
				timeScale = newTimeScale;
				return _line;
			 };
			 _line.getTimeScale = () => {
				return timeScale;
			 };
			 _line.setAssignments = (newAssignmentsArray) => {
				assignments = newAssignmentsArray;
				return _line;
			 };
			 _line.getAssignments = () => {
				return assignments;
			 };
			 _line.setLineColor = (newLineColor) => {
				lineColor = newLineColor;
				return _line;
			 };
			 _line.getLineColor = () => {
				return lineColor;
			 };
			 return _line;
		  }
		  static {
			 this.\u0275fac = function PlanningBoardLineComponent_Factory(t) {
				return new (t || _PlanningBoardLineComponent)();
			 };
		  }
		  static {
			 this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _PlanningBoardLineComponent, selectors: [["app-planning-board-line"]], viewQuery: function PlanningBoardLineComponent_Query(rf, ctx) {
				if (rf & 1) {
				  \u0275\u0275viewQuery(_c0$6, 7);
				}
				if (rf & 2) {
				  let _t;
				  \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.scrollContent = _t.first);
				}
			 }, standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 2, vars: 0, template: function PlanningBoardLineComponent_Template(rf, ctx) {
				if (rf & 1) {
				  \u0275\u0275elementStart(0, "p");
				  \u0275\u0275text(1, "planning-board-line works!");
				  \u0275\u0275elementEnd();
				}
			 } });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlanningBoardLineComponent, [{
			 type: Component,
			 args: [{ standalone: true, selector: "app-planning-board-line", template: "<p>planning-board-line works!</p>\r\n" }]
		  }], null, { scrollContent: [{
			 type: ViewChild,
			 args: ["scrollContent", { static: true }]
		  }] });
		})();
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(PlanningBoardLineComponent, { className: "PlanningBoardLineComponent", filePath: "lib\\components\\planning-board-line\\planning-board-line.component.ts", lineNumber: 15 });
		})();
		var _c0$5 = ["scrollContent"];
		var PlanningBoardSupplierScaleComponent = class _PlanningBoardSupplierScaleComponent {
		  ngOnInit() {
			 if (!selection_default.prototype.parent) {
				selection_default.prototype.parent = function selectParent() {
				  return this.select(() => {
					 return this.parentNode;
				  });
				};
			 }
		  }
		  static {
			 this.supplierScale = () => {
				let verticalIndex, lineHeight = 0, headerLineHeight = 0, mapService, verticalIndexObj;
				const _supplierScale = {
				  get(assignment, origin) {
					 let result = -100;
					 const idx = verticalIndex.get(mapService.supplier(assignment.originalEntity));
					 if ((0, import_lodash.isNumber)(idx)) {
						result = headerLineHeight + idx * lineHeight;
						if (origin === "bottom") {
						  result += lineHeight;
						}
					 }
					 return result;
				  },
				  supplierIdForYpx(yPx) {
					 let assignmentId = 0;
					 verticalIndex.forEach((value, key) => {
						const top2 = headerLineHeight + value * lineHeight;
						if (top2 <= yPx && yPx <= top2 + lineHeight) {
						  assignmentId = key;
						}
					 });
					 return assignmentId;
				  },
				  setVerticalIndex(vi2) {
					 verticalIndex = vi2;
					 verticalIndexObj = Object.fromEntries(verticalIndex.entries());
					 return this;
				  },
				  setLineHeight(lh) {
					 lineHeight = lh;
					 return this;
				  },
				  setHeaderLineHeight(hlh) {
					 headerLineHeight = hlh;
					 return this;
				  },
				  setMapService(service) {
					 mapService = service;
					 return this;
				  },
				  getVerticalIndex() {
					 return verticalIndex;
				  },
				  getLineHeight() {
					 return lineHeight;
				  },
				  getHeaderLineHeight() {
					 return headerLineHeight;
				  },
				  getMapService() {
					 return mapService;
				  },
				  getVerticalIndexObj() {
					 return verticalIndexObj;
				  }
				};
				return _supplierScale;
			 };
		  }
		  static {
			 this.\u0275fac = function PlanningBoardSupplierScaleComponent_Factory(t) {
				return new (t || _PlanningBoardSupplierScaleComponent)();
			 };
		  }
		  static {
			 this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _PlanningBoardSupplierScaleComponent, selectors: [["app-planning-board-supplier-scale"]], viewQuery: function PlanningBoardSupplierScaleComponent_Query(rf, ctx) {
				if (rf & 1) {
				  \u0275\u0275viewQuery(_c0$5, 7);
				}
				if (rf & 2) {
				  let _t;
				  \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.scrollContent = _t.first);
				}
			 }, standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 2, vars: 0, template: function PlanningBoardSupplierScaleComponent_Template(rf, ctx) {
				if (rf & 1) {
				  \u0275\u0275elementStart(0, "p");
				  \u0275\u0275text(1, "planning-board-supplier-scale works!");
				  \u0275\u0275elementEnd();
				}
			 } });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlanningBoardSupplierScaleComponent, [{
			 type: Component,
			 args: [{ standalone: true, selector: "app-planning-board-supplier-scale", template: "<p>planning-board-supplier-scale works!</p>\r\n" }]
		  }], null, { scrollContent: [{
			 type: ViewChild,
			 args: ["scrollContent", { static: true }]
		  }] });
		})();
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(PlanningBoardSupplierScaleComponent, { className: "PlanningBoardSupplierScaleComponent", filePath: "lib\\components\\planning-board-supplier-scale\\planning-board-supplier-scale.component.ts", lineNumber: 13 });
		})();
		var _c0$4 = ["scrollContent"];
		var PlanningBoardTextLineComponent = class _PlanningBoardTextLineComponent {
		  ngOnInit() {
			 if (!selection_default.prototype.parent) {
				selection_default.prototype.parent = function selectParent() {
				  return this.select(() => {
					 return this.parentNode;
				  });
				};
			 }
		  }
		  static {
			 this.textLine = (getTextLineOfTypeData) => {
				return PlanningBoardLabelConfigService.getTextLineOfType(getTextLineOfTypeData);
			 };
		  }
		  static {
			 this.\u0275fac = function PlanningBoardTextLineComponent_Factory(t) {
				return new (t || _PlanningBoardTextLineComponent)();
			 };
		  }
		  static {
			 this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _PlanningBoardTextLineComponent, selectors: [["app-planning-board-text-line"]], viewQuery: function PlanningBoardTextLineComponent_Query(rf, ctx) {
				if (rf & 1) {
				  \u0275\u0275viewQuery(_c0$4, 7);
				}
				if (rf & 2) {
				  let _t;
				  \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.scrollContent = _t.first);
				}
			 }, standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 2, vars: 0, template: function PlanningBoardTextLineComponent_Template(rf, ctx) {
				if (rf & 1) {
				  \u0275\u0275elementStart(0, "p");
				  \u0275\u0275text(1, "planning-board-text-line works!");
				  \u0275\u0275elementEnd();
				}
			 } });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlanningBoardTextLineComponent, [{
			 type: Component,
			 args: [{ standalone: true, selector: "app-planning-board-text-line", template: "<p>planning-board-text-line works!</p>\r\n" }]
		  }], null, { scrollContent: [{
			 type: ViewChild,
			 args: ["scrollContent", { static: true }]
		  }] });
		})();
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(PlanningBoardTextLineComponent, { className: "PlanningBoardTextLineComponent", filePath: "lib\\components\\planning-board-text-line\\planning-board-text-line.component.ts", lineNumber: 13 });
		})();
		var _c0$3 = ["scrollContent"];
		var PlanningBoardTooltipBackgroundComponent = class _PlanningBoardTooltipBackgroundComponent {
		  ngOnInit() {
			 if (!selection_default.prototype.parent) {
				selection_default.prototype.parent = function selectParent() {
				  return this.select(() => {
					 return this.parentNode;
				  });
				};
			 }
		  }
		  static {
			 this.toolTipBackground = () => {
				let infoMsg, timeScale, offset, date2, onDblClickFn;
				const _toolTipBackground = function(selection2, event) {
				  selection2.append("g").classed("toolTipBackground", true).append("rect").attr("transform", "translate(" + (timeScale(date2.day) + 15) + "," + ((event && event.offsetY || 0) - 22 - offset) + ")").attr("width", infoMsg.length * 6.5 + 20).attr("height", 30);
				  selection2.append("text").classed("toolTipLabel", true).attr("transform", "translate(" + (timeScale(date2.day) + 27) + "," + ((event && event.offsetY || 0) - 2 - offset) + ")").text(() => {
					 return infoMsg;
				  });
				  if ((0, import_lodash.isFunction)(onDblClickFn)) {
					 selection2.on("dblclick", onDblClickFn);
				  }
				};
				_toolTipBackground.setInfoMsg = (msg) => {
				  infoMsg = msg;
				  return _toolTipBackground;
				};
				_toolTipBackground.getInfoMsg = () => {
				  return infoMsg;
				};
				_toolTipBackground.setTimeScale = (ts) => {
				  timeScale = ts;
				  return _toolTipBackground;
				};
				_toolTipBackground.getTimeScale = () => {
				  return timeScale;
				};
				_toolTipBackground.setOffset = (newOffset) => {
				  offset = newOffset;
				  return _toolTipBackground;
				};
				_toolTipBackground.getOffset = () => {
				  return offset;
				};
				_toolTipBackground.setDay = (newDate2) => {
				  date2 = newDate2;
				  return _toolTipBackground;
				};
				_toolTipBackground.getDay = () => {
				  return date2;
				};
				_toolTipBackground.setOnDblClickFn = (fn) => {
				  onDblClickFn = fn;
				  return _toolTipBackground;
				};
				_toolTipBackground.getOnDblClickFn = () => {
				  return onDblClickFn;
				};
				return _toolTipBackground;
			 };
		  }
		  static {
			 this.\u0275fac = function PlanningBoardTooltipBackgroundComponent_Factory(t) {
				return new (t || _PlanningBoardTooltipBackgroundComponent)();
			 };
		  }
		  static {
			 this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _PlanningBoardTooltipBackgroundComponent, selectors: [["app-planning-board-tooltip-background"]], viewQuery: function PlanningBoardTooltipBackgroundComponent_Query(rf, ctx) {
				if (rf & 1) {
				  \u0275\u0275viewQuery(_c0$3, 7);
				}
				if (rf & 2) {
				  let _t;
				  \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.scrollContent = _t.first);
				}
			 }, standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 2, vars: 0, template: function PlanningBoardTooltipBackgroundComponent_Template(rf, ctx) {
				if (rf & 1) {
				  \u0275\u0275elementStart(0, "p");
				  \u0275\u0275text(1, "planning-board-tooltip-background works!");
				  \u0275\u0275elementEnd();
				}
			 } });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlanningBoardTooltipBackgroundComponent, [{
			 type: Component,
			 args: [{ standalone: true, selector: "app-planning-board-tooltip-background", template: "<p>planning-board-tooltip-background works!</p>\r\n" }]
		  }], null, { scrollContent: [{
			 type: ViewChild,
			 args: ["scrollContent", { static: true }]
		  }] });
		})();
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(PlanningBoardTooltipBackgroundComponent, { className: "PlanningBoardTooltipBackgroundComponent", filePath: "lib\\components\\planning-board-tooltip-background\\planning-board-tooltip-background.component.ts", lineNumber: 11 });
		})();
		var PlanningBoardDrawingUtilitiesService = class _PlanningBoardDrawingUtilitiesService {
		  static {
			 this.intToRgbColor = (color2) => {
				const rgbaObj = _PlanningBoardDrawingUtilitiesService.rgbaColor(color2 >> 16 & 255, color2 >> 8 & 255, color2 & 255);
				return rgbaObj;
			 };
		  }
		  static {
			 this.rgbaColor = (r, g, b, opacity) => {
				const rgba2 = !(0, import_lodash.isUndefined)(g) && !(0, import_lodash.isUndefined)(b) ? rgb(r, g, b, opacity) : rgb(r.toString());
				return new RgbaColor(rgba2.r, rgba2.g, rgba2.b, rgba2.opacity);
			 };
		  }
		  static {
			 this.decToHexColor = (c2) => {
				return (0, import_lodash.padStart)(c2.toString(16), 7, "#000000");
			 };
		  }
		  constructor() {
		  }
		  static {
			 this.\u0275fac = function PlanningBoardDrawingUtilitiesService_Factory(t) {
				return new (t || _PlanningBoardDrawingUtilitiesService)();
			 };
		  }
		  static {
			 this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _PlanningBoardDrawingUtilitiesService, factory: _PlanningBoardDrawingUtilitiesService.\u0275fac, providedIn: "root" });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlanningBoardDrawingUtilitiesService, [{
			 type: Injectable,
			 args: [{
				providedIn: "root"
			 }]
		  }], () => [], null);
		})();
		var RgbaColor = class {
		  constructor(r, g, b, opacity) {
			 this.toString = () => {
				return `rgba(${this.r}, ${this.g}, ${this.b}, ${this.opacity})`;
			 };
			 this.r = r;
			 this.g = g ? g : 0;
			 this.b = b ? b : 0;
			 this.opacity = opacity ? opacity : 0;
		  }
		};
		var PlanningBoardAssignmentGroupingService = class _PlanningBoardAssignmentGroupingService {
		  static updateAssignmentGrouping(updateAssignmentGroupingData) {
			 const groupViews = [];
			 const maxCapacityLineViews = [];
			 const intervals = this.calculateGroupIntervals(updateAssignmentGroupingData.dataService, updateAssignmentGroupingData.timeaxis, updateAssignmentGroupingData.timeScale, updateAssignmentGroupingData.chartBase);
			 const defaultMarginForLines = 2;
			 const lineHeightForMaxLoad = updateAssignmentGroupingData.supplierScale.getLineHeight() / (updateAssignmentGroupingData.dataService.aggregationTrafficLightsValuesConfig().overload / 100) - 2 * defaultMarginForLines;
			 const createGroupsObjectData = {
				assignments: updateAssignmentGroupingData.dataService.assignments,
				assignmentConfig: updateAssignmentGroupingData.dataService.getAssignmentConfig(),
				intervals,
				planningBoardDataService: updateAssignmentGroupingData.dataService
			 };
			 const groupedBySupplier = this.createAssignmentGroupsObject(createGroupsObjectData);
			 for (const supplierId in groupedBySupplier) {
				const groupedByStartDate = groupedBySupplier[supplierId];
				const heightPerAssignment = _PlanningBoardAssignmentGroupingService.calculateGroupHeightPerAssignment(groupedByStartDate, lineHeightForMaxLoad);
				for (const groupStartDate in groupedByStartDate) {
				  const groupedByMappedProperty = groupedByStartDate[groupStartDate];
				  let heightOfLastGroups = updateAssignmentGroupingData.supplierScale.getLineHeight();
				  let startOfGroup = new DateExtension();
				  let endOfGroup = new DateExtension();
				  let intervalCapacity = 0;
				  for (const groupProp in groupedByMappedProperty.groups) {
					 startOfGroup = groupedByMappedProperty.startDate;
					 endOfGroup = groupedByMappedProperty.endDate;
					 intervalCapacity = groupedByMappedProperty.capacity;
					 const groupByProperty = groupedByMappedProperty.groups;
					 const generateGroupObjectData = {
						baseObject: groupByProperty[groupProp][0],
						id: groupProp,
						startOfGroup,
						endOfGroup,
						heightOfLastGroups,
						heightPerAssignment,
						supplierId,
						reservations: groupByProperty[groupProp],
						planningBoardDataService: updateAssignmentGroupingData.dataService,
						supplierScale: updateAssignmentGroupingData.supplierScale,
						timeScale: updateAssignmentGroupingData.timeScale
					 };
					 const groupView = generateGroupObject(generateGroupObjectData);
					 groupViews.push(groupView);
					 heightOfLastGroups -= groupView.height;
				  }
				  const generateBaseLineObjectData = {
					 baseObject: groupViews.at(-1),
					 positionX1: updateAssignmentGroupingData.timeScale(startOfGroup),
					 positionX2: updateAssignmentGroupingData.timeScale(startOfGroup),
					 positionY1: updateAssignmentGroupingData.supplierScale.get(groupViews.at(-1), "bottom"),
					 positionY2: updateAssignmentGroupingData.supplierScale.get(groupViews.at(-1), "bottom")
				  };
				  const leftVerticalLineView = generateBaseLineObject(generateBaseLineObjectData);
				  const setLineObjectYPositionsData = {
					 horizontal: false,
					 intervalCapacity,
					 objToUpdate: leftVerticalLineView,
					 supplierId,
					 heightPerAssignment,
					 maxCapacityLineViews,
					 planningBoardDataService: updateAssignmentGroupingData.dataService,
					 supplierScale: updateAssignmentGroupingData.supplierScale
				  };
				  setLineObjectYPositions(setLineObjectYPositionsData);
				  maxCapacityLineViews.push(leftVerticalLineView);
				  generateBaseLineObjectData.positionX2 = updateAssignmentGroupingData.timeScale(endOfGroup);
				  const horizontalLineView = generateBaseLineObject(generateBaseLineObjectData);
				  setLineObjectYPositionsData.horizontal = true;
				  setLineObjectYPositions(setLineObjectYPositionsData);
				  maxCapacityLineViews.push(horizontalLineView);
				}
			 }
			 return {
				groupViews,
				maxCapacityLineViews
			 };
			 function generateGroupObject(generateGroupObjectData) {
				const groupObject = Object.assign({
				  Id: "",
				  width: 0,
				  height: 0,
				  positionX: 0,
				  positionY: 0,
				  fillColor: "",
				  reservations: [],
				  positionX1: 0,
				  positionX2: 0,
				  positionY1: 0,
				  positionY2: 0
				}, generateGroupObjectData.baseObject);
				groupObject.Id = generateGroupObjectData.id;
				groupObject.width = Math.max(10, generateGroupObjectData.timeScale(generateGroupObjectData.endOfGroup) - generateGroupObjectData.timeScale(generateGroupObjectData.startOfGroup));
				groupObject.positionX = generateGroupObjectData.timeScale(generateGroupObjectData.startOfGroup);
				groupObject.reservations = generateGroupObjectData.reservations;
				groupObject.height = generateGroupObjectData.heightPerAssignment * generateGroupObjectData.reservations.length;
				if (generateGroupObjectData.heightOfLastGroups - groupObject.height < 0) {
				  groupObject.height = generateGroupObjectData.heightOfLastGroups;
				}
				groupObject.positionY = generateGroupObjectData.supplierScale.getHeaderLineHeight() + generateGroupObjectData.supplierScale.getVerticalIndex().get(parseInt(generateGroupObjectData.supplierId)) * generateGroupObjectData.supplierScale.getLineHeight() + generateGroupObjectData.heightOfLastGroups - groupObject.height;
				const fillColor = _PlanningBoardAssignmentGroupingService.getComponentFillColor(generateGroupObjectData.planningBoardDataService.getAssignmentConfig().mappingService, generateGroupObjectData.planningBoardDataService.assignmentStatusItems, groupObject);
				if (fillColor) {
				  groupObject.fillColor = fillColor;
				}
				return groupObject;
			 }
			 function generateBaseLineObject(generateGroupObjectData) {
				const baseLineObject = Object.assign({}, generateGroupObjectData.baseObject);
				baseLineObject.positionX1 = generateGroupObjectData.positionX1 + defaultMarginForLines;
				baseLineObject.positionX2 = generateGroupObjectData.positionX2 + defaultMarginForLines;
				baseLineObject.positionY1 = generateGroupObjectData.positionY1 - defaultMarginForLines;
				baseLineObject.positionY2 = generateGroupObjectData.positionY2 - defaultMarginForLines;
				return baseLineObject;
			 }
			 function setLineObjectYPositions(setLineObjectYPositionsData) {
				if (!setLineObjectYPositionsData.horizontal && setLineObjectYPositionsData.intervalCapacity > 0) {
				  setLineObjectYPositionsData.objToUpdate.positionY2 = setLineObjectYPositionsData.supplierScale.getHeaderLineHeight() + setLineObjectYPositionsData.supplierScale.getVerticalIndex().get(parseInt("" + setLineObjectYPositionsData.supplierId)) * setLineObjectYPositionsData.supplierScale.getLineHeight() + (setLineObjectYPositionsData.supplierScale.getLineHeight() - setLineObjectYPositionsData.heightPerAssignment * setLineObjectYPositionsData.intervalCapacity);
				}
				if (setLineObjectYPositionsData.maxCapacityLineViews.length > 0 && setLineObjectYPositionsData.planningBoardDataService.getAssignmentConfig().mappingService.supplier(setLineObjectYPositionsData.maxCapacityLineViews.at(-1)) === setLineObjectYPositionsData.planningBoardDataService.getAssignmentConfig().mappingService.supplier(setLineObjectYPositionsData.objToUpdate)) {
				  setLineObjectYPositionsData.objToUpdate.positionY1 = setLineObjectYPositionsData.maxCapacityLineViews.at(-1).positionY2;
				} else if (!setLineObjectYPositionsData.horizontal) {
				  setLineObjectYPositionsData.objToUpdate.positionY1 = setLineObjectYPositionsData.objToUpdate.positionY2;
				}
				if (setLineObjectYPositionsData.horizontal) {
				  setLineObjectYPositionsData.objToUpdate.positionY2 = setLineObjectYPositionsData.objToUpdate.positionY1;
				}
			 }
		  }
		  /**
			* @ngdoc function
			* @name createAssignmentGroupsObject
			* @description Creates an assignment grouping object depending on the grouping property in mapping service
			*
			* @param {Object} createAssignmentGroupsObjectData
			* @return {Object} Object: {
			* 			grouped by supplier ID: {
			* 			     grouped by start date of interval: {
			* 			           grouped by grouping property from assignment mapping service
			* 			     }
			* 			}
			* }
			*/
		  static createAssignmentGroupsObject(createAssignmentGroupsObjectData) {
			 const assignmentsGroupsBySupplier = {};
			 const assignmentMappingServ = createAssignmentGroupsObjectData.assignmentConfig.mappingService;
			 const validConfigSupplier = Object.keys(createAssignmentGroupsObjectData.planningBoardDataService.supplierCapacityPerBaseUnit).map((x) => parseInt(x));
			 const uniqIntervals = (0, import_lodash.orderBy)((0, import_lodash.uniqBy)(createAssignmentGroupsObjectData.intervals, function(interval2) {
				return interval2.startDate.toISOString();
			 }), ["startDate"], ["asc"]);
			 const getValidAssignmentsForGroupingData = {
				assignments: Array.from(createAssignmentGroupsObjectData.assignments.values()),
				assignmentMappingServ,
				uniqIntervals,
				validConfigSupplier
			 };
			 const assignmentArray = this.getValidAssignmentsForGrouping(getValidAssignmentsForGroupingData);
			 if (assignmentArray && assignmentArray.length > 0 && validConfigSupplier.length > 0) {
				const assignmentsGroupsBySupplierTemp = (0, import_lodash.groupBy)(assignmentArray, function(assignment) {
				  return assignmentMappingServ.supplier(assignment.originalEntity);
				});
				let assignmentsGroupBySupplier = {}, tempGroupObj = {};
				for (const supplierId in assignmentsGroupsBySupplierTemp) {
				  let groupedAssignments = assignmentsGroupsBySupplierTemp[supplierId];
				  const capacityPerDay = createAssignmentGroupsObjectData.planningBoardDataService.supplierCapacityPerBaseUnit[supplierId];
				  uniqIntervals.forEach((interval2) => {
					 const intervalCapacity = _PlanningBoardAssignmentGroupingService.calculateCapacityInInterval(interval2, capacityPerDay);
					 let createGroupObjData;
					 (0, import_lodash.forEach)(groupedAssignments, function(assignment) {
						createGroupObjData = { tempGroupObj, interval: interval2, intervalCapacity, assignment, assignmentMappingServ };
						_PlanningBoardAssignmentGroupingService.createGroupObjectObject(createGroupObjData);
					 });
				  });
				  assignmentsGroupBySupplier = tempGroupObj;
				  assignmentsGroupsBySupplier[supplierId] = tempGroupObj;
				  for (const groupProp in assignmentsGroupBySupplier) {
					 const typedGroupProp = groupProp;
					 const groupArray = assignmentsGroupBySupplier[typedGroupProp].groups;
					 const assignmentCount = groupArray.length;
					 assignmentsGroupBySupplier[typedGroupProp].groups = assignmentMappingServ.grouping ? assignmentMappingServ.grouping(groupArray.map((assignmentData) => assignmentData.originalEntity)) : {};
					 assignmentsGroupBySupplier[typedGroupProp].assignmentCount = assignmentCount;
				  }
				}
				return assignmentsGroupsBySupplier;
			 }
			 return assignmentsGroupsBySupplier;
		  }
		  /**
			* @description Calculates the intervals according to minimal aggregation setting in planning board. ATTENTION! The minimal interval is 1 day!
			* @param planningBoardDataService
			* @param timeAxis
			* @param timeScale
			* @return {*}
			*/
		  static calculateGroupIntervals(planningBoardDataService, timeAxis, timeScale, chartBase) {
			 let levelOfIntervals = { type: "day", value: 1 };
			 if (planningBoardDataService.useMinAggregation() && !(0, import_lodash.isEqual)(planningBoardDataService.minAggregationLevel().type, "hour")) {
				levelOfIntervals = planningBoardDataService.minAggregationLevel();
			 }
			 const tickValues = timeAxis.getTickValues().length > 0 ? timeAxis.getTickValues() : timeScale.ticks();
			 return chartBase.calculateIntervals(tickValues, levelOfIntervals);
		  }
		  /**
			* @description Retrieves background color for the component
			* @param mappingService
			* @param assignmentStatusItems
			* @param assignment
			* @return {*} color in hex format || undefined
			*/
		  static getComponentFillColor(mappingService, assignmentStatusItems, assignment) {
			 let fillColor;
			 if ((0, import_lodash.isFunction)(mappingService.grouping) && mappingService.grouping() === "status") {
				const status = (0, import_lodash.find)(assignmentStatusItems, { Id: mappingService.status(assignment) });
				if (status && status.BackgroundColor) {
				  fillColor = (0, import_lodash.padStart)(status.BackgroundColor.toString(16), 7, "#000000");
				}
			 }
			 return fillColor;
		  }
		  /**
			* @description Calculate capacity of resource for given interval
			* @param interval
			* @param capacityPerDay
			* @return {number}
			*/
		  static calculateCapacityInInterval(interval2, capacityPerDay) {
			 let intervalCapacity = 0;
			 let daysInInterval = interval2.endDate.diff(interval2.startDate, "days");
			 const tempStartDate = new DateExtension(interval2.startDate);
			 if (daysInInterval) {
				while (daysInInterval > 0) {
				  if (!(0, import_lodash.isUndefined)(capacityPerDay)) {
					 const tempStartDateFormated = capacityPerDay.get(tempStartDate.format("YYYY-MM-DD")) || 0;
					 if (tempStartDateFormated) {
						intervalCapacity += tempStartDateFormated;
					 }
				  }
				  tempStartDate.add(1, "day");
				  --daysInInterval;
				}
			 } else {
				if (!(0, import_lodash.isUndefined)(capacityPerDay)) {
				  const tempStartDateFormated = capacityPerDay.get(tempStartDate.format("YYYY-MM-DD")) || 0;
				  if (tempStartDateFormated) {
					 intervalCapacity += tempStartDateFormated;
				  }
				}
			 }
			 return intervalCapacity;
		  }
		  static createGroupObjectObject(createGroupObjectObjectData) {
			 const reservationStart = createGroupObjectObjectData.assignmentMappingServ.from(createGroupObjectObjectData.assignment.originalEntity).utc();
			 const reservationEnd = createGroupObjectObjectData.assignmentMappingServ.to(createGroupObjectObjectData.assignment.originalEntity).utc();
			 if (reservationStart.isSameOrAfter(createGroupObjectObjectData.interval.startDate) && reservationStart.isBefore(createGroupObjectObjectData.interval.endDate) || reservationEnd.isSameOrBefore(createGroupObjectObjectData.interval.endDate) && reservationEnd.isAfter(createGroupObjectObjectData.interval.startDate) || reservationStart.isBefore(createGroupObjectObjectData.interval.startDate) && reservationEnd.isAfter(createGroupObjectObjectData.interval.endDate)) {
				const timeRangeProp = createGroupObjectObjectData.interval.startDate.toISOString();
				const groupingForTimeRange = createGroupObjectObjectData.tempGroupObj[timeRangeProp];
				if (groupingForTimeRange && groupingForTimeRange.groups.length) {
				  groupingForTimeRange.groups.push(createGroupObjectObjectData.assignment);
				} else {
				  createGroupObjectObjectData.tempGroupObj[timeRangeProp] = {
					 startDate: createGroupObjectObjectData.interval.startDate,
					 endDate: createGroupObjectObjectData.interval.endDate,
					 groups: [createGroupObjectObjectData.assignment],
					 capacity: createGroupObjectObjectData.intervalCapacity || 0,
					 assignmentCount: 0
				  };
				}
			 }
		  }
		  /**
			* @description Filters assignments between start of first and end of last interval and checks if there is valid capacity config for supplier of assignment
			* @param assignments
			* @param uniqIntervals
			* @param assignmentMappingServ
			* @param validConfigSupplier
			* @return {*}
			*/
		  static getValidAssignmentsForGrouping(getValidAssignmentsForGroupingData) {
			 const firstInterval = getValidAssignmentsForGroupingData.uniqIntervals[0];
			 const lastInterval = getValidAssignmentsForGroupingData.uniqIntervals.at(-1) || getValidAssignmentsForGroupingData.uniqIntervals[0];
			 const assignmentMapService = getValidAssignmentsForGroupingData.assignmentMappingServ;
			 const validConfigSupplier = getValidAssignmentsForGroupingData.validConfigSupplier;
			 return getValidAssignmentsForGroupingData.assignments.filter((assignment) => (assignmentMapService.from(assignment.originalEntity).isSameOrAfter(firstInterval.startDate) && assignmentMapService.from(assignment.originalEntity).isBefore(lastInterval.endDate) || assignmentMapService.to(assignment.originalEntity).isSameOrBefore(lastInterval.endDate) && assignmentMapService.to(assignment.originalEntity).isAfter(firstInterval.startDate) || assignmentMapService.from(assignment.originalEntity).isBefore(firstInterval.startDate) && assignmentMapService.to(assignment.originalEntity).isAfter(lastInterval.endDate)) && validConfigSupplier.includes(assignmentMapService.supplier(assignment.originalEntity)));
		  }
		  /**
			*
			* @param groupedByStartDate
			* @param lineHeightForMaxLoad
			* @return {number|number}
			*/
		  static calculateGroupHeightPerAssignment(groupedByStartDate, lineHeightForMaxLoad) {
			 const capacities = (0, import_lodash.flatMap)(groupedByStartDate).map((group) => group.capacity);
			 const nonExceptionDayCapacity = Math.max(...capacities);
			 return nonExceptionDayCapacity > 0 ? lineHeightForMaxLoad / nonExceptionDayCapacity : 0;
		  }
		  constructor() {
		  }
		  static {
			 this.\u0275fac = function PlanningBoardAssignmentGroupingService_Factory(t) {
				return new (t || _PlanningBoardAssignmentGroupingService)();
			 };
		  }
		  static {
			 this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _PlanningBoardAssignmentGroupingService, factory: _PlanningBoardAssignmentGroupingService.\u0275fac, providedIn: "root" });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlanningBoardAssignmentGroupingService, [{
			 type: Injectable,
			 args: [{
				providedIn: "root"
			 }]
		  }], () => [], null);
		})();
		var PlanningBoardFooterComponentConstants;
		(function(PlanningBoardFooterComponentConstants2) {
		  PlanningBoardFooterComponentConstants2[PlanningBoardFooterComponentConstants2["statusBarHeight"] = 17] = "statusBarHeight";
		})(PlanningBoardFooterComponentConstants || (PlanningBoardFooterComponentConstants = {}));
		var _c0$2 = ["scrollContent"];
		var _c1$1 = ["class", "footer-content"];
		var PlanningBoardFooterComponent = class _PlanningBoardFooterComponent {
		  ngOnInit() {
			 if (!selection_default.prototype.parent) {
				selection_default.prototype.parent = function selectParent() {
				  return this.select(() => {
					 return this.parentNode;
				  });
				};
			 }
		  }
		  static {
			 this.footerBackground = () => {
				let panelWidth, footerHeight;
				const _footerBackground = function(selection2) {
				  const background = selection2.select("rect.footer-background").attr("width", panelWidth).attr("height", footerHeight).attr("transform", "translate(0, -" + (footerHeight + PlanningBoardFooterComponentConstants.statusBarHeight) + ")").attr("fill", "rgba(233, 233, 233, 0.7)");
				};
				_footerBackground.setpanelWidth = (newPanelWidth) => {
				  panelWidth = newPanelWidth;
				  return _footerBackground;
				};
				_footerBackground.getpanelWidth = () => {
				  return panelWidth;
				};
				_footerBackground.setfooterHeight = (height) => {
				  footerHeight = height;
				  return _footerBackground;
				};
				_footerBackground.getfooterHeight = () => {
				  return footerHeight;
				};
				return _footerBackground;
			 };
		  }
		  static {
			 this.\u0275fac = function PlanningBoardFooterComponent_Factory(t) {
				return new (t || _PlanningBoardFooterComponent)();
			 };
		  }
		  static {
			 this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _PlanningBoardFooterComponent, selectors: [["", 8, "footer-content"]], viewQuery: function PlanningBoardFooterComponent_Query(rf, ctx) {
				if (rf & 1) {
				  \u0275\u0275viewQuery(_c0$2, 7);
				}
				if (rf & 2) {
				  let _t;
				  \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.scrollContent = _t.first);
				}
			 }, standalone: true, features: [\u0275\u0275StandaloneFeature], attrs: _c1$1, decls: 2, vars: 0, template: function PlanningBoardFooterComponent_Template(rf, ctx) {
				if (rf & 1) {
				  \u0275\u0275elementStart(0, "p");
				  \u0275\u0275text(1, "planning-board-footer works!");
				  \u0275\u0275elementEnd();
				}
			 } });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlanningBoardFooterComponent, [{
			 type: Component,
			 args: [{ standalone: true, selector: ".footer-content", template: "<p>planning-board-footer works!</p>\r\n" }]
		  }], null, { scrollContent: [{
			 type: ViewChild,
			 args: ["scrollContent", { static: true }]
		  }] });
		})();
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(PlanningBoardFooterComponent, { className: "PlanningBoardFooterComponent", filePath: "lib\\components\\planning-board-footer\\planning-board-footer.component.ts", lineNumber: 12 });
		})();
		var PlanningBoardUpdateService = class _PlanningBoardUpdateService {
		  // region Public methods
		  /**
			* @ngdoc function
			* @name resize
			* @description Resize planningboard components.
			*
			* @param {Object} resizeData
			*/
		  static resize(resizeData) {
			 resizeData.calendarlineobject.setHeight(resizeData.transY);
			 resizeData.timeScale.range([0, resizeData.panelWidth]);
			 resizeData.assignmentItems.setCalendarScale(resizeData.timeScale);
			 resizeData.assignmentCollections.setCalendarScale(resizeData.timeScale);
			 resizeData.assignmentGroups.setCalendarScale(resizeData.timeScale);
			 resizeData.aggregateItems.setCalendarScale(resizeData.timeScale);
			 resizeData.timeaxis.setScale(resizeData.timeScale);
		  }
		  /**
			* @ngdoc function
			* @name updateLanes
			* @description Update planningboard calendar lanes.
			*
			* @param {Object} updateLanesData
			*/
		  static updateLanes(updateLanesData) {
			 if (updateLanesData.laneLayer) {
				const lanes = updateLanesData.laneLayer.selectAll(".lanes").data([...updateLanesData.verticalIndex.values()]);
				updateLanesData.lanesComponent.setPanelWidth(updateLanesData.panelWidth);
				lanes.call(updateLanesData.lanesComponent);
			 }
		  }
		  /**
			* @ngdoc function
			* @name updateScale
			* @description
			*
			* @param {Object} scope
			* @param {Object} updateScaleData
			*/
		  static updateScale(updateScaleData) {
			 if (updateScaleData.timeScale) {
				updateScaleData.timeScale.domain([updateScaleData.dataService.getDateStart(), updateScaleData.dataService.getDateEnd()]).range([0, updateScaleData.panelWidth]);
			 }
			 if (updateScaleData.supplierScale) {
				updateScaleData.supplierScale.setLineHeight(updateScaleData.dataService.rowHeight());
			 }
			 if (updateScaleData.assignmentCollections) {
				updateScaleData.assignmentCollections.setCalendarScale(updateScaleData.timeScale);
				updateScaleData.assignmentCollections.setSupplierScale(updateScaleData.supplierScale);
				updateScaleData.assignmentCollections.setCalendarDateEnd(updateScaleData.dataService.getDateEnd());
				updateScaleData.assignmentCollections.setCalendarDateStart(updateScaleData.dataService.getDateStart());
				updateScaleData.aggregateItems.setCalendarScale(updateScaleData.timeScale);
				updateScaleData.aggregateItems.setSupplierScale(updateScaleData.supplierScale);
			 }
			 if (updateScaleData.assignmentItems) {
				updateScaleData.assignmentItems.setCalendarScale(updateScaleData.timeScale);
				updateScaleData.assignmentItems.setSupplierScale(updateScaleData.supplierScale);
				updateScaleData.assignmentItems.setCalendarDateEnd(updateScaleData.dataService.getDateEnd());
				updateScaleData.assignmentItems.setCalendarDateStart(updateScaleData.dataService.getDateStart());
			 }
			 if (updateScaleData.tagItems) {
				updateScaleData.tagItems.setCalendarDateEnd(updateScaleData.dataService.getDateEnd());
				updateScaleData.tagItems.setCalendarDateStart(updateScaleData.dataService.getDateStart());
			 }
		  }
		  /**
			* @ngdoc function
			* @name updateBackgrounds
			* @description
			*
			* @param {Object} scope
			* @param {Object} updateBackgroundsData
			*/
		  static updateBackgrounds(updateBackgroundsData) {
			 const backgroundsArrByCalendar = /* @__PURE__ */ new Map();
			 const startDateMs = updateBackgroundsData.dataService.getDateStart().toDate().getTime();
			 const endDateMs = updateBackgroundsData.dataService.getDateEnd().toDate().getTime();
			 updateBackgroundsData.supplierCalendars.forEach((calendar2) => {
				const backgroundsArr = [];
				calendar2.WeekDays.forEach(function f(weekday) {
				  let days = [];
				  switch (weekday.WeekdayIndex) {
					 case 1:
						days = utcSundays(updateBackgroundsData.dataService.getDateStart().add(-1, "day"), updateBackgroundsData.dataService.getDateEnd(), 1);
						break;
					 case 2:
						days = utcMondays(updateBackgroundsData.dataService.getDateStart().add(-1, "day"), updateBackgroundsData.dataService.getDateEnd(), 1);
						break;
					 case 3:
						days = utcTuesdays(updateBackgroundsData.dataService.getDateStart().add(-1, "day"), updateBackgroundsData.dataService.getDateEnd(), 1);
						break;
					 case 4:
						days = utcWednesdays(updateBackgroundsData.dataService.getDateStart().add(-1, "day"), updateBackgroundsData.dataService.getDateEnd(), 1);
						break;
					 case 5:
						days = utcThursdays(updateBackgroundsData.dataService.getDateStart().add(-1, "day"), updateBackgroundsData.dataService.getDateEnd(), 1);
						break;
					 case 6:
						days = utcFridays(updateBackgroundsData.dataService.getDateStart().add(-1, "day"), updateBackgroundsData.dataService.getDateEnd(), 1);
						break;
					 case 7:
						days = utcSaturdays(updateBackgroundsData.dataService.getDateStart().add(-1, "day"), updateBackgroundsData.dataService.getDateEnd(), 1);
						break;
				  }
				  days.forEach(function f2(day) {
					 let dayInMs = day.getTime();
					 if (dayInMs > startDateMs && dayInMs < endDateMs) {
						backgroundsArr.push({
						  type: weekday.IsWeekend ? "weekend" : "weekday",
						  day: new DateExtension(day),
						  dayMs: dayInMs,
						  bgColor: updateBackgroundsData.parseDecToRgba(weekday.BackgroundColor),
						  calendarId: calendar2.CalendarId
						});
					 }
				  });
				});
				const today = new DateExtension().startOf("day");
				const todayInMs = today.getTime();
				if (todayInMs > startDateMs && todayInMs < endDateMs) {
				  backgroundsArr.push({
					 type: "today",
					 day: today,
					 dayMs: todayInMs,
					 bgColor: "rgb(99,99,221)",
					 calendarId: calendar2.CalendarId
				  });
				}
				calendar2.ExceptionDays.forEach(function f(day) {
				  let dayInMs = day.ExceptDate.toDate().getTime();
				  if (dayInMs > startDateMs && dayInMs < endDateMs) {
					 backgroundsArr.push({
						type: "exday",
						day: day.ExceptDate,
						dayMs: dayInMs,
						info: day.DescriptionInfo.Translated,
						bgColor: updateBackgroundsData.parseDecToRgba(day.BackgroundColor),
						calendarId: calendar2.CalendarId
					 });
				  }
				});
				backgroundsArrByCalendar.set(calendar2.CalendarId, backgroundsArr);
			 });
			 if (updateBackgroundsData.backgroundLayer && updateBackgroundsData.backgroundComponent) {
				const supplierBackgrounds = /* @__PURE__ */ new Map();
				const supplierMappingService = updateBackgroundsData.dataService.getSupplierConfig().mappingService;
				const idMapFn = supplierMappingService.actualId || supplierMappingService.id;
				if (supplierMappingService && supplierMappingService.calendar && (0, import_lodash.isFunction)(supplierMappingService.calendar)) {
				  updateBackgroundsData.dataService.supplierDataService.getList().map((supplier) => supplierBackgrounds.set(idMapFn(supplier), backgroundsArrByCalendar.get(supplierMappingService.calendar(supplier))));
				} else {
				  const backgroundsArrByCalendarValues = [...backgroundsArrByCalendar.values()][0];
				  updateBackgroundsData.dataService.supplierDataService.getList().map((supplier) => supplierBackgrounds.set(idMapFn(supplier), backgroundsArrByCalendarValues));
				}
				updateBackgroundsData.backgroundComponent.setSupplierScale(updateBackgroundsData.supplierScale).setBgExceptionDayClckHandler(updateBackgroundsData.bgExceptionDayClickHandler).setTimeScale(updateBackgroundsData.timeScale).setStartDate(updateBackgroundsData.dataService.getDateStart()).setEndDate(updateBackgroundsData.dataService.getDateEnd()).setSupplierBackgrounds(supplierBackgrounds).setVerticalIndexSize(updateBackgroundsData.dataService.sharedData.verticalIndex.size).setSupplierScrollVaue(updateBackgroundsData.supplierScrollValue);
				updateBackgroundsData.backgroundLayer.call(updateBackgroundsData.backgroundComponent);
			 }
		  }
		  /**
			* @ngdoc function
			* @name updateFooterBackground
			* @description
			*
			* @param {object} footerContentLayer
			* @param {int} panelWidth
			* @param {int} footerHeight
			*/
		  static updateFooterBackground(footerContentLayer, panelWidth, footerHeight) {
			 const footerBackground = PlanningBoardFooterComponent.footerBackground();
			 footerBackground.setpanelWidth(panelWidth);
			 footerBackground.setfooterHeight(footerHeight);
			 if (footerContentLayer) {
				footerContentLayer.call(footerBackground);
			 }
		  }
		  /**
			* @ngdoc function
			* @name updateStatusPanel
			* @description
			*
			* @param {int} panelWidth
			*/
		  static updateStatusPanel(panelWidth) {
			 const foundElem = document.getElementById("statusPanel");
			 if (foundElem) {
				foundElem.style.width = "" + panelWidth;
			 }
		  }
		  /**
			* @ngdoc function
			* @name updateTimeScaleTicks
			* @description
			*
			* @param {int} sizeY
			* @param {Object} supplierScale
			* @param {Object} timeScale
			* @param {Object} timeaxis
			* @returns {Object} dayLinesAxis
			*/
		  static updateTimeScaleTicks(updateTimeScaleTicks) {
			 const dayLineTickValues = updateTimeScaleTicks.timeaxis.getTickValues();
			 return axisTop(updateTimeScaleTicks.timeScale).tickValues(dayLineTickValues).tickFormat(() => {
				return "";
			 }).tickSize(updateTimeScaleTicks.sizeY);
		  }
		  /**
			* @ngdoc function
			* @name updatePanelWidthDependencies
			* @description
			*
			* @param {Object} layers
			* @param {int} panelWidth
			*/
		  static updatePanelWidthDependencies(layers, panelWidth) {
			 if (layers.headerContent) {
				layers.headerContent.selectAll("rect").style("width", panelWidth);
			 }
		  }
		  /**
			* @ngdoc function
			* @name updatePlanningBoardCanvasSize
			* @description
			*
			* @param {int} curDimensionHeight
			* @param {Object} viewPort
			* @param {Object} pBoardCanvas
			* @param {Object} dragSel
			*/
		  static updatePlanningBoardCanvasSize(updatePlanningBoardCanvasSizeData) {
			 updatePlanningBoardCanvasSizeData.viewPort.style("height", updatePlanningBoardCanvasSizeData.curDimensionHeight);
			 updatePlanningBoardCanvasSizeData.pBoardCanvas.style("height", updatePlanningBoardCanvasSizeData.curDimensionHeight);
			 updatePlanningBoardCanvasSizeData.dragSel.style("height", updatePlanningBoardCanvasSizeData.curDimensionHeight);
			 updatePlanningBoardCanvasSizeData.footerContent.attr("transform", "translate(0," + updatePlanningBoardCanvasSizeData.curDimensionHeight + ")");
		  }
		  /**
			* @ngdoc function
			* @name updateAggregations
			* @description
			* Update aggregations in planningboard.
			* @param {Object} scope
			* @param {Object} aggregationData
			*/
		  static updateAggregations(aggregationData) {
			 if (aggregationData.dataService.showAggregations() || aggregationData.dataService.showSumAggregations()) {
				const supplierMappingService = aggregationData.dataService.getSupplierConfig().mappingService;
				const idMapFn = supplierMappingService.actualId || supplierMappingService.id;
				const supplierIds = new Set(aggregationData.dataService.getSupplierConfig().dataService.getList().map((supplier) => idMapFn(supplier)));
				const assignmentMappingService = aggregationData.dataService.getAssignmentConfig().mappingService;
				const assignmentsArray = [...aggregationData.dataService.assignments.values()].filter((assigment) => supplierIds.has(assignmentMappingService.supplier(assigment.originalEntity)));
				const assignments = new Map(assignmentsArray.map((a) => [assignmentMappingService.id(a.originalEntity), a]));
				const updateAssignmentAggregationData = {
				  service: aggregationData.dataService.getAssignmentConfig().mappingService,
				  useMinAggregation: aggregationData.dataService.useMinAggregation(),
				  minAggregationLevel: aggregationData.dataService.minAggregationLevel(),
				  tickValues: aggregationData.timeaxis.getTickValues(),
				  assignments,
				  doUpdateSumAggregations: aggregationData.dataService.showSumAggregations()
				};
				aggregationData.dataService.getHelperServices().aggregationService.updateAssignmentAggregations(updateAssignmentAggregationData);
			 }
			 if (aggregationData.dataService.showAggregations()) {
				const aggregates = aggregationData.dataService.getHelperServices().aggregationService.getAssignmentAggregations();
				aggregationData.aggregateItems.setAggregates(aggregates);
			 }
			 if (aggregationData.dataService.showSumAggregations()) {
				const sumAggregates = aggregationData.dataService.getHelperServices().aggregationService.getSumAggregations();
				aggregationData.aggregateSumItems.setSumAggregates(sumAggregates);
			 }
		  }
		  /**
			* @ngdoc function
			* @name updateData
			* @description
			*
			* @param {Object} scope
			* @param {Object} updateDataData
			*/
		  static updateData(searchString, updateDataData) {
			 updateDataData.calendarlineobject.setTickvalues(updateDataData.timeaxis.getTickValues()).setMaintickvalues(updateDataData.timeaxis.getMainTickValues());
			 if (updateDataData.layers && updateDataData.layers.assignments) {
				const assignmentMappingService = updateDataData.dataService.getAssignmentConfig().mappingService;
				const assignmentDataService = updateDataData.dataService.assignmentDataService;
				let updateAssignmentArray = [];
				let updateAssignmentArrayWithCollected = [];
				let assignmentIsDragging = !![...updateDataData.dataService.assignments.values()].find((assigment) => assigment.modificationData.isDragging);
				const needsCollisionsUpdate = !updateDataData.isCalendarDragging || updateDataData.settingsChanged || assignmentIsDragging;
				updateDataData.dataService.getHelperServices().levelOfDetailService.clearAssignmentCollections();
				updateDataData.dataService.getHelperServices().validationService.setSuppliers(updateDataData.dataService.suppliers);
				const previouslySelectedAssingments = new Set(assignmentDataService.getSelectedEntities().map((selectedAssignment) => assignmentMappingService.id(selectedAssignment)));
				const calendarSecondsDiff = updateDataData.dataService.getDateEnd().diff(updateDataData.dataService.getDateStart(), "seconds");
				updateDataData.dataService.assignments.forEach((assignment) => {
				  if (assignment.modificationData.isDragging || (0, import_lodash.isUndefined)(assignment.validationData.invalidItems)) {
					 if (updateDataData.dataService.getSupplierConfig().mappingService && updateDataData.dataService.validateAssignments()) {
						let supplierId = assignmentMappingService.supplier(assignment.originalEntity);
						let validationResult = updateDataData.dataService.getHelperServices().validationService.validateEntityAgainstSupplier(assignment.originalEntity, "assignment", supplierId);
						assignment.validationData.isValid = validationResult.isValid;
						assignment.validationData.invalidItems = validationResult.invalidItems;
					 } else {
						assignment.validationData.isValid = true;
						assignment.validationData.invalidItems = [];
					 }
				  }
				  assignment.modificationData.Disabled = updateDataData.dataService.sharedData.planningBoardMode.actionType === "createAssignment";
				  if (previouslySelectedAssingments.size > 0) {
					 assignment.modificationData.selectedFlag = previouslySelectedAssingments.has(assignmentMappingService.id(assignment.originalEntity));
				  }
				  let assignmentFromDate = assignmentMappingService.from(assignment.originalEntity);
				  if (assignmentFromDate.toDate) {
					 assignmentMappingService.from(assignment.originalEntity, new DateExtension(assignmentFromDate.toDate()));
					 assignmentFromDate = assignmentMappingService.from(assignment.originalEntity);
				  }
				  assignment.timeData.startDateInMs = assignmentFromDate.getTime();
				  let assignmentToDate = assignmentMappingService.to(assignment.originalEntity);
				  if (assignmentToDate.toDate) {
					 assignmentMappingService.to(assignment.originalEntity, new DateExtension(assignmentToDate.toDate()));
				  }
				  assignment.timeData.endDateInMs = assignmentMappingService.to(assignment.originalEntity).getTime();
				  let assignmentTickStart;
				  const tickValuesArray = updateDataData.timeaxis.getTickValues();
				  if (tickValuesArray.length > 0) {
					 const startOnTick = updateDataData.timeaxis.getTickValues().find((x) => x.getTime() === assignmentFromDate.getTime());
					 if (startOnTick) {
						assignmentTickStart = assignmentFromDate;
					 } else {
						const firstAfterFromDate = tickValuesArray.find((x) => x.getTime() > assignmentFromDate.getTime());
						let value = new DateExtension();
						if (firstAfterFromDate) {
						  if (tickValuesArray.indexOf(firstAfterFromDate) === tickValuesArray.length - 1) {
							 value = tickValuesArray[tickValuesArray.indexOf(firstAfterFromDate)];
						  } else if (tickValuesArray.indexOf(firstAfterFromDate) > 0) {
							 value = tickValuesArray[tickValuesArray.indexOf(firstAfterFromDate) - 1];
						  } else {
							 value = assignmentFromDate;
						  }
						}
						assignmentTickStart = value;
					 }
					 if (updateDataData.settingsChanged) {
						assignment.collectionData.isVerticallyCollected = false;
					 }
					 const isCollectedData = {
						assignmentMappingService,
						assignment,
						calendarDiffSeconds: calendarSecondsDiff,
						assignmentTickStart,
						panelWidth: updateDataData.panelWidth
					 };
					 if (!updateDataData.dataService.getHelperServices().levelOfDetailService.isCollected(isCollectedData)) {
						updateAssignmentArray.push(assignment);
					 }
					 updateAssignmentArrayWithCollected.push(assignment);
				  } else {
					 updateAssignmentArray.push(assignment);
					 updateAssignmentArrayWithCollected.push(assignment);
				  }
				});
				const assignmentDiff = (0, import_lodash.difference)(updateAssignmentArrayWithCollected, updateDataData.oldAssignmentArray);
				if (updateDataData.dataService.sharedData.planningBoardMode.actionType !== "grouping") {
				  if (needsCollisionsUpdate || assignmentDiff.length > 0) {
					 updateDataData.settingsChanged = false;
					 const updateCollisionsDataObj = {
						assignmentMappingService,
						assignmentArray: updateAssignmentArray,
						arrWithCollected: updateAssignmentArrayWithCollected,
						calendarSecondsDiff,
						panelWidth: updateDataData.panelWidth,
						dataService: updateDataData.dataService,
						tickvalues: updateDataData.timeaxis.getTickValues(),
						visibleSupplierIds: updateDataData.visibleSupplierIds
					 };
					 this.updateAssignmentCollisions(updateCollisionsDataObj);
				  }
				  updateAssignmentArray = updateAssignmentArray.filter((assigment) => !assigment.collectionData.isVerticallyCollected);
				  updateDataData.assignmentCollections.setAssignments(updateDataData.dataService.getHelperServices().levelOfDetailService.getAssignmentCollections());
				}
				this.updateAssignmentsFilter(searchString, updateAssignmentArrayWithCollected, updateDataData.dataService);
				this.updateAssignmentStatus({
				  assignmentAvailableStatusMatrix: updateDataData.assignmentAvailableStatusMatrix,
				  assignmentArray: updateAssignmentArray,
				  layers: updateDataData.layers,
				  draw: updateDataData.draw,
				  dataService: updateDataData.dataService
				});
				updateDataData.oldAssignmentArray = updateAssignmentArrayWithCollected;
			 }
		  }
		  static updateHighlightAssignments(updateHighlightAssignmentsData) {
			 if (updateHighlightAssignmentsData.dataService.getAssignmentConfig().dataService.isHighlightAssignments) {
				const assigments = updateHighlightAssignmentsData.dataService.assignments;
				if (assigments.size > 0) {
				  const assignmentMappingServ = updateHighlightAssignmentsData.dataService.getAssignmentConfig().mappingService;
				  if ((0, import_lodash.isFunction)(assignmentMappingServ.filteredAssignmentsOnProductionSet)) {
					 const highlightAssignmentKeys = assignmentMappingServ.filteredAssignmentsOnProductionSet(assigments);
					 if (highlightAssignmentKeys.length > 0) {
						highlightAssignmentKeys.forEach((key) => {
						  const defs = select_default2(".planningboard svg").append("defs");
						  const filter2 = defs.append("filter").attr("id", "glow");
						  filter2.append("feGaussianBlur").attr("stdDeviation", "10").attr("result", "coloredBlur");
						  const feMerge = filter2.append("feMerge");
						  feMerge.append("feMergeNode").attr("in", "coloredBlur");
						  feMerge.append("feMergeNode").attr("in", "SourceGraphic");
						  let iterations = 0;
						  const highlightAssignmentItems = updateHighlightAssignmentsData.layers.assignments.selectAll("g.assignment-item").filter((assignment) => assignmentMappingServ.id(assignment.originalEntity) === key);
						  function highlight() {
							 highlightAssignmentItems.transition().duration(1e3).attr("stroke-width", "5px").style("filter", "url(#glow)").ease(linear2).transition().duration(1e3).attr("stroke-width", "1px").on("end", function() {
								iterations++;
								if (iterations < 2) {
								  highlight();
								}
							 });
						  }
						  highlight();
						});
					 }
				  }
				}
			 } else {
				updateHighlightAssignmentsData.layers.assignments.selectAll("g.assignment-item").attr("stroke-width", "1px").attr("stroke-opacity", 1).style("filter", "");
			 }
		  }
		  static getAssignmentsNumberInRow(dataService) {
			 let assignmentsNumberInRow = 1;
			 const maxFontHeight = PlanningBoardAssignmentComponentConstants.maxFontSizeInfoText;
			 const spaceBetweenTextLines = PlanningBoardAssignmentComponentConstants.maxSpaceInfoTexts;
			 const textLinesHeight = maxFontHeight + spaceBetweenTextLines;
			 if (dataService.useFixedAssignmentHeight()) {
				let multipleLine = 1;
				switch (dataService.useFixedAssignmentHeight()) {
				  case dataService.showInfo3Text():
					 multipleLine = 4;
					 break;
				  case dataService.showInfo2Text():
					 multipleLine = 3;
					 break;
				  case dataService.showInfo1Text():
					 multipleLine = 2;
					 break;
				  default:
					 break;
				}
				assignmentsNumberInRow = Math.ceil(dataService.rowHeightAssignments() / (textLinesHeight * multipleLine));
			 }
			 return assignmentsNumberInRow;
		  }
		  static isJson(stringToParse) {
			 stringToParse = typeof stringToParse !== "string" ? JSON.stringify(stringToParse) : stringToParse;
			 if (stringToParse.startsWith("{")) {
				try {
				  stringToParse = JSON.parse(stringToParse);
				} catch (e) {
				  return false;
				}
				if (typeof stringToParse === "object" && stringToParse !== null && Object.keys(stringToParse).length > 0) {
				  return true;
				}
			 }
			 return false;
		  }
		  /**
			* !! ATTENTION !! refactor the code. too many copy-paste!
			*
			* @ngdoc function
			* @name updateAssignmentsFilter
			* @description Updates the assignments according to a searchString
			*
			* @param scope
			* @param assigmentsArray
			* @return {*[]}
			*/
		  static updateAssignmentsFilter(searchString, assigmentsArray, dataService) {
			 const filteredAssignments = [];
			 if (dataService.sharedData.planningBoardMode.actionType !== "createAssignment" && assigmentsArray.length > 0) {
				let filterFields = [];
				_PlanningBoardUpdateService.getFieldSearchString(dataService.showMainText(), dataService.mainInfoLabel(), filterFields);
				_PlanningBoardUpdateService.getFieldSearchString(dataService.showInfo1Text(), dataService.info1Label(), filterFields);
				_PlanningBoardUpdateService.getFieldSearchString(dataService.showInfo2Text(), dataService.info2Label(), filterFields);
				_PlanningBoardUpdateService.getFieldSearchString(dataService.showInfo3Text(), dataService.info3Label(), filterFields);
				const getFilterFieldsFn = dataService.getAssignmentConfig().mappingService.getFilterFields;
				if (getFilterFieldsFn && (0, import_lodash.isFunction)(getFilterFieldsFn)) {
				  filterFields = (0, import_lodash.uniq)([...filterFields, ...getFilterFieldsFn()]);
				}
				if (filterFields.length === 0) {
				  filterFields = ["Code", "Description"];
				}
				const supplierMappingService = dataService.getSupplierConfig().mappingService;
				const idMapFn = supplierMappingService.actualId || supplierMappingService.id;
				const idToSupplierMap = new Map(dataService.getSupplierConfig().dataService.getList().map((supplier) => [idMapFn(supplier), supplier]));
				const shownSupplierIds = idToSupplierMap.size ? idToSupplierMap : /* @__PURE__ */ new Map();
				const assigmentsArrayForShownSuppliers = assigmentsArray.filter((assignment) => !(0, import_lodash.isUndefined)(shownSupplierIds.get(dataService.getAssignmentConfig().mappingService.supplier(assignment.originalEntity))));
				if ((0, import_lodash.isObject)(assigmentsArrayForShownSuppliers) && !(0, import_lodash.isUndefined)(searchString) && (0, import_lodash.isString)(searchString)) {
				  assigmentsArrayForShownSuppliers.forEach((assigment) => assigment.modificationData.Disabled = searchString.length > 0);
				  if (searchString.length > 0) {
					 filterFields.forEach((filterField) => {
						assigmentsArrayForShownSuppliers.forEach((assigment) => {
						  const assignmentKeyValueMap = PlanningBoardCalculationUtilitiesService.objectToKeyValueMap(assigment.originalEntity);
						  if (assignmentKeyValueMap.get(filterField) && assignmentKeyValueMap.get(filterField).toString().toUpperCase().includes(searchString.toUpperCase())) {
							 assigment.modificationData.Disabled = false;
							 if (filteredAssignments.indexOf(assigment) === -1) {
								filteredAssignments.push(assigment);
							 }
						  }
						});
					 });
				  }
				}
			 }
			 return filteredAssignments;
		  }
		  /**
			* @description private helper function for parsing the filter strings
			* @param isShowInfoText
			* @param infoTextLabel
			* @param filterFieldsArr
			* @returns
			*/
		  static getFieldSearchString(isShowInfoText, infoTextLabel, filterFieldsArr) {
			 if (!(isShowInfoText && infoTextLabel !== "" && filterFieldsArr.indexOf(infoTextLabel) === -1)) {
				return;
			 }
			 if (_PlanningBoardUpdateService.isJson(infoTextLabel)) {
				let infoObject = JSON.parse(infoTextLabel);
				for (let key in infoObject) {
				  if (Array.isArray(infoObject[key])) {
					 infoObject[key].forEach(function(element) {
						if (element.match(/\{|\}/gi)) {
						  element = element.replace(/\{|\}/gi, "");
						  filterFieldsArr.push(element);
						}
					 });
				  }
				}
			 } else {
				filterFieldsArr.push(infoTextLabel);
			 }
		  }
		  /**
			* @ngdoc function
			* @name updateAssignmentStatus
			* @description Updates assignments component according to its status and the active planning board mode
			*
			* @param updateDataData
			*/
		  static updateAssignmentStatus(updateAssignmentStatusData) {
			 if (updateAssignmentStatusData.dataService.sharedData.planningBoardMode) {
				switch (updateAssignmentStatusData.dataService.sharedData.planningBoardMode.actionType) {
				  case "setStatus":
					 var pbModeId = parseInt((0, import_lodash.split)(updateAssignmentStatusData.dataService.sharedData.planningBoardMode.id, "_")[1]);
					 if (!(0, import_lodash.isUndefined)(pbModeId)) {
						updateAssignmentStatusData.assignmentArray.forEach((assignment) => {
						  if (updateAssignmentStatusData.assignmentAvailableStatusMatrix.has(assignment.statusData.StatusFrom)) {
							 let foundAvailableStati = updateAssignmentStatusData.assignmentAvailableStatusMatrix.get(assignment.statusData.StatusFrom);
							 if (foundAvailableStati && !foundAvailableStati.includes(pbModeId)) {
								assignment.modificationData.Disabled = true;
							 }
						  }
						});
					 }
					 updateAssignmentStatusData.layers.assignmentTags.datum(updateAssignmentStatusData.assignmentArray);
					 updateAssignmentStatusData.layers.assignments.datum(updateAssignmentStatusData.assignmentArray);
					 updateAssignmentStatusData.draw();
					 break;
				  case "createAssignment":
					 updateAssignmentStatusData.layers.assignmentTags.datum(updateAssignmentStatusData.assignmentArray);
					 updateAssignmentStatusData.layers.assignments.datum(updateAssignmentStatusData.assignmentArray);
					 updateAssignmentStatusData.draw();
					 break;
				  default:
					 updateAssignmentStatusData.layers.assignmentTags.datum(updateAssignmentStatusData.assignmentArray);
					 updateAssignmentStatusData.layers.assignments.datum(updateAssignmentStatusData.assignmentArray);
					 break;
				}
			 }
		  }
		  static updateAssignmentGrouping(updateAssignmentGroupingData) {
			 if (updateAssignmentGroupingData.planningBoardMode.actionType === "grouping") {
				return PlanningBoardAssignmentGroupingService.updateAssignmentGrouping(updateAssignmentGroupingData);
			 }
			 return {
				groupViews: [],
				maxCapacityLineViews: []
			 };
		  }
		  /**
			* @ngdoc function
			* @name updateAssignmentCollisions
			* @description Updates the assignment collisions depending on the 'minimal assignment height' setting
			*
			* @param {Object} scope
			* @param {Object} updateAssignmentCollisionsData
			* @example updateAssignmentCollisions(scope, {mapServ: mappingService, arr: assignmentsArray, calendarSecondsDiff: calendarSecondsDiff, panelWidth: panelWidth});
			*/
		  static updateAssignmentCollisions(updateAssignmentCollisionsData) {
			 const assignmentMappingService = updateAssignmentCollisionsData.assignmentMappingService;
			 const supplierMappingService = updateAssignmentCollisionsData.dataService.getSupplierConfig().mappingService;
			 const idMapFn = supplierMappingService.actualId || supplierMappingService.id;
			 let visibleSupplierList = updateAssignmentCollisionsData.dataService.getSupplierConfig().dataService.getList();
			 visibleSupplierList = visibleSupplierList.filter((x) => updateAssignmentCollisionsData.visibleSupplierIds.includes(idMapFn(x)));
			 const visibleSupplierIds = visibleSupplierList.map((supplier) => idMapFn(supplier));
			 let toUpdate = updateAssignmentCollisionsData.arrWithCollected.filter((x) => visibleSupplierIds.includes(assignmentMappingService.supplier(x.originalEntity)));
			 let draggedAssignment = toUpdate.find((assigment) => assigment.modificationData.isDragging);
			 toUpdate.forEach((assignment) => assignment.collectionData.isVerticallyCollected = false);
			 const groupedItems = (0, import_lodash.groupBy)(toUpdate, function(assignment) {
				if ((0, import_lodash.isFunction)(assignmentMappingService.layer) && assignmentMappingService.layer(assignment.originalEntity).length > 0) {
				  return "layer-" + assignmentMappingService.layer(assignment.originalEntity) + assignmentMappingService.supplier(assignment.originalEntity);
				}
				const isForMaintenance = assignmentMappingService.forMaintenance ? assignmentMappingService.forMaintenance(assignment.originalEntity) : false;
				return isForMaintenance ? "maintenance" + assignmentMappingService.supplier(assignment.originalEntity) : assignmentMappingService.supplier(assignment.originalEntity);
			 });
			 const assignmentsNumberInRow = this.getAssignmentsNumberInRow(updateAssignmentCollisionsData.dataService);
			 let indexOfDraggedAssignment = -1;
			 let draggedGroupAssignment;
			 let assignmentToMove;
			 if (groupedItems) {
				(0, import_lodash.forEach)(groupedItems, function(group) {
				  draggedGroupAssignment = group.filter((elem2) => elem2.modificationData.isDragging).at(0);
				  if (draggedGroupAssignment && updateAssignmentCollisionsData.dataService.useFixedAssignmentHeight()) {
					 indexOfDraggedAssignment = group.indexOf(draggedGroupAssignment);
					 if (indexOfDraggedAssignment !== -1 && indexOfDraggedAssignment + 1 > assignmentsNumberInRow) {
						assignmentToMove = group.splice(indexOfDraggedAssignment, 1).at(0);
						if (assignmentToMove) {
						  group.splice(assignmentsNumberInRow - 1, 0, assignmentToMove);
						}
					 }
				  }
				  updateAssignmentCollisionsData.dataService.getHelperServices().assignmentCollisionService.clearAll();
				  updateAssignmentCollisionsData.dataService.getHelperServices().assignmentCollisionService.setMaxHeight(updateAssignmentCollisionsData.dataService.rowHeightAssignments());
				  updateAssignmentCollisionsData.dataService.getHelperServices().assignmentCollisionService.setUseFixedAssignmentHeight(updateAssignmentCollisionsData.dataService.useFixedAssignmentHeight());
				  updateAssignmentCollisionsData.dataService.getHelperServices().assignmentCollisionService.setAssignmentsNumberInRow(assignmentsNumberInRow);
				  updateAssignmentCollisionsData.dataService.getHelperServices().assignmentCollisionService.setDefaultItemValues(group);
				  updateAssignmentCollisionsData.dataService.getHelperServices().assignmentCollisionService.addItems(group);
				  group.forEach((assignment) => {
					 const assignmentTickStart = assignmentMappingService.from(assignment.originalEntity);
					 const isCollectedData = {
						assignmentMappingService,
						assignment,
						calendarDiffSeconds: updateAssignmentCollisionsData.calendarSecondsDiff,
						assignmentTickStart,
						panelWidth: updateAssignmentCollisionsData.panelWidth
					 };
					 updateAssignmentCollisionsData.dataService.getHelperServices().levelOfDetailService.isCollected(isCollectedData);
				  });
				});
			 }
		  }
		  // endregion
		  constructor() {
		  }
		  static {
			 this.\u0275fac = function PlanningBoardUpdateService_Factory(t) {
				return new (t || _PlanningBoardUpdateService)();
			 };
		  }
		  static {
			 this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _PlanningBoardUpdateService, factory: _PlanningBoardUpdateService.\u0275fac, providedIn: "root" });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlanningBoardUpdateService, [{
			 type: Injectable,
			 args: [{
				providedIn: "root"
			 }]
		  }], () => [], null);
		})();
		var PlanningBoardStatusService = class _PlanningBoardStatusService {
		  static {
			 this.changedStatusAssignments = [];
		  }
		  static setAssignmentStatusChanged(assignment, toStatusId, assignmentMappingService) {
			 const useStatusProperties = (0, import_lodash.isFunction)(assignmentMappingService.useStatusProperties) && assignmentMappingService.useStatusProperties();
			 const entityId = useStatusProperties && assignmentMappingService.statusEntityId ? assignmentMappingService.statusEntityId(assignment.originalEntity) : assignmentMappingService.id(assignment.originalEntity);
			 const statusFieldKey = useStatusProperties && assignmentMappingService.statusEntityKey ? assignmentMappingService.statusEntityKey() : assignmentMappingService.statusKey();
			 const statusChangedIndex = (0, import_lodash.findIndex)(_PlanningBoardStatusService.changedStatusAssignments, ["EntityId", entityId]);
			 if (statusChangedIndex < 0 && toStatusId !== assignment.statusData.StatusFrom) {
				const changedAssignment = {
				  EntityId: entityId,
				  EntityTypeName: assignmentMappingService.entityTypeName(),
				  ToStatusId: toStatusId,
				  FromStatusId: assignment.statusData.StatusFrom,
				  StatusField: statusFieldKey,
				  Remark: ""
				};
				this.changedStatusAssignments.push(changedAssignment);
			 } else {
				this.changedStatusAssignments = (0, import_lodash.remove)(this.changedStatusAssignments, function(a) {
				  return a.EntityId !== entityId;
				});
			 }
		  }
		  static getAssignmentStatusChanged() {
			 return this.changedStatusAssignments;
		  }
		  static clearAssignmentStatusChanged() {
			 this.changedStatusAssignments = [];
		  }
		  constructor() {
		  }
		  static {
			 this.\u0275fac = function PlanningBoardStatusService_Factory(t) {
				return new (t || _PlanningBoardStatusService)();
			 };
		  }
		  static {
			 this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _PlanningBoardStatusService, factory: _PlanningBoardStatusService.\u0275fac, providedIn: "root" });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlanningBoardStatusService, [{
			 type: Injectable,
			 args: [{
				providedIn: "root"
			 }]
		  }], () => [], null);
		})();
		var _c0$1 = ["app-planning-board-edit-assignment-dialog", ""];
		var PlanningBoardEditAssignmentDialogComponent = class _PlanningBoardEditAssignmentDialogComponent {
		  constructor() {
			 let scope = this.containerLink;
			 let platformDetailControllerService = PlanningBoardExternalServices.platformDetailControllerService, platformToolbarService = PlanningBoardExternalServices.platformToolbarService, platformDateshiftHelperService = PlanningBoardExternalServices.platformDateshiftHelperService;
			 scope.getContainerUUID = function getContainerUUID() {
				return "2860df783e894efcbfd0fa5c8cbef024";
			 };
			 scope.assignmentItem = scope.$parent.$parent.entity;
			 let uiStandardService = scope.$parent.groups[0].rows[0].options.uiStandardService;
			 let dataServiceForDetail = scope.$parent.groups[0].rows[0].options.dataServiceForDetail;
			 let dataService = scope.$parent.groups[0].rows[0].options.dataService;
			 let gridToolConfig = [
				{
				  id: "dateshiftModes",
				  excluded: true
				},
				{
				  id: "fullshift",
				  value: true
				}
			 ];
			 const dateShiftModeTools = platformDateshiftHelperService.getDateshiftTools(dataService.getDateshiftConfig().dataService.getServiceName(), gridToolConfig, dataService.getDateshiftConfig().dateshiftId, scope);
			 scope.setTools = (tools) => {
				tools.items = platformToolbarService.getTools(scope.getContainerUUID(), tools.items);
				scope.tools = tools || [];
				if (scope.tools.items && scope.tools.items.length > 0) {
				  let itemsToDelete = ["create", "delete", "first", "previous", "next", "last", "print"];
				  scope.tools.items = scope.tools.items.filter((item) => !itemsToDelete.includes(item.id));
				  if (!(0, import_lodash.isUndefined)(dateShiftModeTools)) {
					 dateShiftModeTools.forEach(function f(tool) {
						scope.tools.items.unshift(tool);
					 });
				  }
				}
				scope.tools.update = () => {
				  return true;
				};
			 };
			 platformDetailControllerService.initDetailController(scope, dataServiceForDetail, dataServiceForDetail.getValidationService(), uiStandardService);
			 if (dataService.getDateshiftConfig()) {
				let cancelButton = document.querySelector(".modal-footer .cancel");
				if (cancelButton) {
				  cancelButton.disabled = true;
				}
			 }
		  }
		  static {
			 this.\u0275fac = function PlanningBoardEditAssignmentDialogComponent_Factory(t) {
				return new (t || _PlanningBoardEditAssignmentDialogComponent)();
			 };
		  }
		  static {
			 this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _PlanningBoardEditAssignmentDialogComponent, selectors: [["", "app-planning-board-edit-assignment-dialog", ""]], inputs: { containerLink: "containerLink" }, standalone: true, features: [\u0275\u0275StandaloneFeature], attrs: _c0$1, decls: 4, vars: 0, consts: [[1, "flex-box", "flex-column", 2, "min-width", "90%"], [1, "subview-header", "toolbar", "flex-box", "flex-row"], ["data-platform-menu-list", "", "data-list", "tools"], ["data-platform-form-container", "", "data-form-container-options", "formContainerOptions", "data-entity", "assignmentItem", 1, "flex-element", "ng-scope", "ng-isolate-scope"]], template: function PlanningBoardEditAssignmentDialogComponent_Template(rf, ctx) {
				if (rf & 1) {
				  \u0275\u0275elementStart(0, "div", 0)(1, "div", 1);
				  \u0275\u0275element(2, "div", 2);
				  \u0275\u0275elementEnd();
				  \u0275\u0275element(3, "div", 3);
				  \u0275\u0275elementEnd();
				}
			 } });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlanningBoardEditAssignmentDialogComponent, [{
			 type: Component,
			 args: [{ standalone: true, selector: "[app-planning-board-edit-assignment-dialog]", schemas: [CUSTOM_ELEMENTS_SCHEMA], template: '<div class=" flex-box flex-column" style="min-width: 90%;">\r\n	<div class="subview-header toolbar flex-box flex-row">\r\n		<div data-platform-menu-list data-list="tools"></div>\r\n	</div>\r\n	<div data-platform-form-container data-form-container-options="formContainerOptions" data-entity="assignmentItem" class="flex-element ng-scope ng-isolate-scope"></div>\r\n</div>\r\n\r\n' }]
		  }], () => [], { containerLink: [{
			 type: Input
		  }] });
		})();
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(PlanningBoardEditAssignmentDialogComponent, { className: "PlanningBoardEditAssignmentDialogComponent", filePath: "lib\\components\\planning-board-edit-assignment-dialog\\planning-board-edit-assignment-dialog.component.ts", lineNumber: 15 });
		})();
		var PlanningBoardMainComponent = class _PlanningBoardMainComponent {
		  constructor(elementRef, zone) {
			 this.elementRef = elementRef;
			 const zoneRef = zone;
			 const element = this.elementRef;
			 let containerLink = this.containerLink = this.containerLink ? this.containerLink : document.getElementsByTagName("platform-planningboard-component")[0].scope;
			 let $timeout = PlanningBoardExternalServices.angularJSTimeout, translate2 = PlanningBoardExternalServices.PlatformTranslateService, platformMasterDetailDialogService = PlanningBoardExternalServices.UiCommonDialogService, platformGridAPI = PlanningBoardExternalServices.platformGridAPI, platformDragdropService = PlanningBoardExternalServices.PlatformDragDropService, cloudDesktopSvgIconService = PlanningBoardExternalServices.CloudDesktopSvgIconService, basicsLookupdataPopupService = PlanningBoardExternalServices.UiCommonLookupViewService, platformDateshiftPlanningboardHelperService = PlanningBoardExternalServices.platformDateshiftPlanningboardHelperService, basicsUnitLookupDataService = PlanningBoardExternalServices.basicsUnitLookupDataService, PlatformConfigurationService = PlanningBoardExternalServices.PlatformConfigurationService;
			 const planningBoardDataService = PlanningBoardDataServiceInterfaceService.getPlanningBoardDataServiceByUUID(containerLink.uuid);
			 let root2, viewPort, layers, unregister = [], dragSel, dragSVG, pBoardCanvas, calendarlineobject, dayLinesAxis, footerDayLinesAxis, timeScale, supplierScale, backgroundLayer, bgPreviewLayer, hePreviewLayer, lanesComponent, toolTipBackgroundComponent, aggregateItems, aggregateSumItems, laneLayer, backgroundComponent, assignmentComponentItems, selectedAssignments = [], assignmentGroups, assignmentGroupTooltips, assignmentDragStartX, assignmentDragStartY, assignmentCollection, assignmentCollections, assignmentMaxLoadLines, calendarDrag, assignmentStartDrag, assignmentEndDrag, zoom$1, tagItems, oldAssignmentArr = [], demandInfo, demandDragView, lastClickedDay, canOpen = true, timerRunning = false, isDoubleClick = false, indicatorAreas, indicatorAreaComponent, firstMouseEnter = false, settingsChanged = false, panelWidth = getParentPanelWidth(), isCalendarDragging = false, supplierChanged = false, isCalendarClicked = false, timeaxis, CalDragTimeOut, OnScrollDrawTimeOut, lastAmountOfStepsX = 0, defaultHeaderlineHeight = 63, footerHeight = planningBoardDataService.sharedData.defaultFooterHeight, parentContainerLink, startDragX = 0, startDragY = 0, calculatedCurrentSizeY = 100, canOpenTimeout = $timeout(), backgroundHeaderComponent, assignmentFullDrag, oldDeltaY = 0, conflictAssignments = [], panelHeight = getParentPanelHeight(), oldD3ZoomVal = 0, selectedDemandIndex = 0, grid;
			 setupTools();
			 const radius = 5;
			 let oldXMoment, dragStartBarValues, moveMode = "day";
			 let popupInstance;
			 let aggregationHeight = planningBoardDataService.showAggregations() ? planningBoardDataService.defaultAggregationHeight() : 0;
			 const adjustCircleObj = {
				zoomLevel: "day",
				zoomLevelSeconds: 86400,
				movedUnits: 0,
				move: function move(assignment, movedX, circle, zl) {
				  if (zl === "auto" || (0, import_lodash.isUndefined)(zl)) {
					 this.zoomLevel = planningBoardDataService.getChartBase().getZoomLevel(timeaxis);
				  } else {
					 this.zoomLevel = zl;
				  }
				  let movedXMoment = new DateExtension();
				  let invertedMovedX = DateExtension.utc(timeScale.invert(movedX));
				  switch (this.zoomLevel) {
					 case "hour":
						movedXMoment = invertedMovedX.set({
						  minute: 0,
						  second: 0,
						  millisecond: 0
						});
						this.zoomLevelSeconds = 3600;
						break;
					 case "day":
						movedXMoment = invertedMovedX.set({
						  hour: 0,
						  minute: 0,
						  second: 0,
						  millisecond: 0
						});
						this.zoomLevelSeconds = 86400;
						break;
					 case "week":
						movedXMoment = invertedMovedX.set({
						  hour: 0,
						  minute: 0,
						  second: 0,
						  millisecond: 0
						});
						break;
					 default:
						console.warn("No definitions for [" + this.zoomLevel + "] this zoom level.");
						break;
				  }
				  if (((0, import_lodash.isUndefined)(oldXMoment) || !(0, import_lodash.isUndefined)(oldXMoment) && !movedXMoment.isSame(oldXMoment, this.zoomLevel)) && (circle === "min" && new DateExtension(movedXMoment).diff(dragStartBarValues.barEnd, "s") < 0 || circle === "max" && new DateExtension(movedXMoment).diff(dragStartBarValues.barStart, "s") >= 0 || circle === "mid")) {
					 if ((0, import_lodash.isUndefined)(oldXMoment)) {
						oldXMoment = new DateExtension(movedXMoment);
					 }
					 const movedDiff = movedXMoment.diff(oldXMoment, "seconds");
					 oldXMoment = new DateExtension(movedXMoment);
					 if (movedDiff > 0) {
						if (this.zoomLevel === "week") {
						  this.movedUnits++;
						} else {
						  this.movedUnits += Math.ceil(movedDiff / this.zoomLevelSeconds);
						}
					 } else {
						if (this.zoomLevel === "week") {
						  this.movedUnits--;
						} else {
						  this.movedUnits += Math.floor(movedDiff / this.zoomLevelSeconds);
						}
					 }
					 switch (this.zoomLevel) {
						case "hour":
						  if (circle === "max") {
							 movedXMoment = movedXMoment.set({
								minutes: +dragStartBarValues.barEnd.format("mm"),
								seconds: +dragStartBarValues.barEnd.format("ss")
							 });
						  } else if (circle === "min") {
							 movedXMoment = movedXMoment.set({
								minutes: +dragStartBarValues.barStart.format("mm"),
								seconds: +dragStartBarValues.barStart.format("ss")
							 });
						  }
						  break;
						case "day":
						  movedXMoment = this.setStartBarValues(movedXMoment, circle);
						  break;
						case "week":
						  movedXMoment = this.setStartBarValues(movedXMoment, circle);
						  movedXMoment = movedXMoment.days(new DateExtension(dragStartBarValues.barStart).days());
						  break;
					 }
					 this.setBarDates(assignment, movedXMoment, movedDiff, circle);
				  }
				},
				setBarDates: function(element2, movedXMoment, movedDiff, circle) {
				  if (movedDiff !== 0) {
					 const assignmentMapServ = planningBoardDataService.getAssignmentConfig().mappingService;
					 switch (circle) {
						case "min":
						  if (!(0, import_lodash.isNil)(planningBoardDataService.getDateshiftConfig()) && assignmentMapServ.dateShift) {
							 assignmentMapServ.dateShift({
								startMoment: movedXMoment,
								endMoment: dragStartBarValues.barEnd,
								el: element2,
								dateShiftConfig: planningBoardDataService.getDateshiftConfig(),
								dataService: planningBoardDataService,
								type: circle
							 });
						  } else {
							 assignmentMapServ.from(element2, new DateExtension(movedXMoment));
							 assignmentMapServ.to(element2, new DateExtension(dragStartBarValues.barEnd));
						  }
						  break;
						case "max":
						  if (!(0, import_lodash.isNil)(planningBoardDataService.getDateshiftConfig()) && assignmentMapServ.dateShift) {
							 assignmentMapServ.dateShift({
								startMoment: dragStartBarValues.barStart,
								endMoment: movedXMoment,
								el: element2,
								dateShiftConfig: planningBoardDataService.getDateshiftConfig(),
								dataService: planningBoardDataService,
								type: circle
							 });
						  } else {
							 assignmentMapServ.from(element2, new DateExtension(dragStartBarValues.barStart));
							 assignmentMapServ.to(element2, new DateExtension(movedXMoment));
						  }
						  break;
						case "mid":
						  const zoomLevelDurationKey = this.zoomLevel;
						  if (!(0, import_lodash.isNil)(planningBoardDataService.getDateshiftConfig()) && assignmentMapServ.dateShift) {
							 assignmentMapServ.dateShift({
								el: element2,
								// needed for single shift
								startMoment: new DateExtension(dragStartBarValues.barStart).add(this.movedUnits, zoomLevelDurationKey),
								endMoment: new DateExtension(dragStartBarValues.barEnd).add(this.movedUnits, zoomLevelDurationKey),
								dateShiftConfig: planningBoardDataService.getDateshiftConfig(),
								dataService: planningBoardDataService,
								selectedAssignments: selectedAssignments.map((assignments) => assignments.originalEntity),
								// needed for multishift
								type: circle,
								durationOfMove: new DateExtensionDuration(this.movedUnits, zoomLevelDurationKey)
							 });
						  } else {
							 assignmentMapServ.from(element2, new DateExtension(dragStartBarValues.barStart).add(this.movedUnits, zoomLevelDurationKey));
							 assignmentMapServ.to(element2, new DateExtension(dragStartBarValues.barEnd).add(this.movedUnits, zoomLevelDurationKey));
						  }
						  break;
					 }
					 processFromAndToAfterShift(planningBoardDataService.assignments, assignmentMapServ);
					 return true;
				  } else {
					 return false;
				  }
				},
				setStartBarValues: function setStartBarValues(movedXMoment, circle) {
				  if (circle === "max") {
					 movedXMoment = movedXMoment.set({
						hour: +dragStartBarValues.barEnd.format("HH"),
						minutes: +dragStartBarValues.barEnd.format("mm"),
						seconds: +dragStartBarValues.barEnd.format("ss")
					 });
				  } else if (circle === "min") {
					 movedXMoment = movedXMoment.set({
						hour: +dragStartBarValues.barStart.format("HH"),
						minutes: +dragStartBarValues.barStart.format("mm"),
						seconds: +dragStartBarValues.barStart.format("ss")
					 });
				  }
				  return movedXMoment;
				}
			 };
			 function processFromAndToAfterShift(assignments, assignmentMapServ) {
				assignments.forEach((assignment) => {
				  let from2 = assignmentMapServ.from(assignment.originalEntity);
				  let to = assignmentMapServ.to(assignment.originalEntity);
				  if (!!from2.toDate) {
					 assignmentMapServ.from(assignment.originalEntity, new DateExtension(assignmentMapServ.from(assignment.originalEntity).toDate()));
				  } else {
					 assignmentMapServ.from(assignment.originalEntity, new DateExtension(assignmentMapServ.from(assignment.originalEntity)));
				  }
				  if (!!to.toDate) {
					 assignmentMapServ.to(assignment.originalEntity, new DateExtension(assignmentMapServ.to(assignment.originalEntity).toDate()));
				  } else {
					 assignmentMapServ.to(assignment.originalEntity, new DateExtension(assignmentMapServ.to(assignment.originalEntity)));
				  }
				});
			 }
			 function findPlanningBoardConatinerElement() {
				let pbContainingDiv = [element.nativeElement];
				return pbContainingDiv;
			 }
			 function onSettingsChange() {
				if (findPlanningBoardConatinerElement().length > 0) {
				  settingsChanged = true;
				  const rowHeight = planningBoardDataService.rowHeight();
				  if (planningBoardDataService.showAggregations()) {
					 aggregationHeight = planningBoardDataService.defaultAggregationHeight();
					 const currentPBsettings = planningBoardDataService.getPlanningBoardSettingsList();
					 currentPBsettings["planningBoard.chart.presentation.settings"].rowHeightAssignments = rowHeight - aggregationHeight;
				  } else {
					 aggregationHeight = 0;
				  }
				  if (!(0, import_lodash.isNil)(supplierScale)) {
					 supplierScale.setLineHeight(rowHeight);
				  }
				  setup();
				  updateAll();
				}
			 }
			 planningBoardDataService.getPlanningBoardConfigService().registerOnSettingsChanged(onSettingsChange);
			 let verticalScrollOffset = 0;
			 let supplierScrollValue = 0;
			 function init2() {
				containerLink?.unregisterDataUpdated(init2);
				containerLink?.registerDataUpdated(update);
				if (planningBoardDataService.getAssignmentConfig().dataService.capacityPerDay) {
				  planningBoardDataService.getHelperServices().aggregationService.updateCapacities(planningBoardDataService.getAssignmentConfig().dataService.capacityPerDay);
				}
				unRegister();
				setup();
				update();
			 }
			 function placeholderHeightCorrection(containerUUID, correcCalculatedtHeight) {
				const pbContainingDiv = document.getElementsByClassName(containerUUID);
				if (pbContainingDiv.length > 0) {
				  const gridFitlerPlaceholderElems = pbContainingDiv[0].getElementsByClassName("filterPlaceholder");
				  const assignmentFilterPlaceholderElem = elementRef.nativeElement.parentElement.getElementsByClassName("assignmentfilterplaceholder")[0];
				  const phHeight = getAdditionalHeight();
				  Array.from(gridFitlerPlaceholderElems).forEach((filterElem) => filterElem.style.height = `${phHeight}px`);
				  assignmentFilterPlaceholderElem.style.height = `${correcCalculatedtHeight}px`;
				}
				resize();
				planningBoardDataService.getHelperServices().eventHandligSubjectService.onPlaceholderHeightCorrectionDone$.fire(placeholderHeightCorrection);
			 }
			 planningBoardDataService.getHelperServices().eventHandligSubjectService.onAssignmentFilterButtonClicked$.subscribe([selectAssignmentOnFilterSelectionChanged]);
			 planningBoardDataService.getHelperServices().eventHandligSubjectService.onAssignmentFilterSearchChanged$.subscribe([updateAssignmentsFilter]);
			 planningBoardDataService.getHelperServices().eventHandligSubjectService.onPlaceholderHeightCorrectionStart$.subscribe([placeholderHeightCorrection]);
			 planningBoardDataService.getHelperServices().eventHandligSubjectService.onShowAssignmentFilterPanel$.subscribe([adaptHeaders]);
			 containerLink.registerFinalizer(function cleanupHandlers() {
				(0, import_lodash.over)(unregister)();
				unregister = [];
				containerLink?.unregisterDataUpdated(update);
				unRegister();
				planningBoardDataService.getPlanningBoardConfigService().unregisterOnSettingsChanged(onSettingsChange);
				planningBoardDataService.getHelperServices().eventHandligSubjectService.onAssignmentFilterButtonClicked$.unsubscribe([selectAssignmentOnFilterSelectionChanged]);
				planningBoardDataService.getHelperServices().eventHandligSubjectService.onAssignmentFilterSearchChanged$.unsubscribe([updateAssignmentsFilter]);
				planningBoardDataService.getHelperServices().eventHandligSubjectService.onPlaceholderHeightCorrectionStart$.unsubscribe([placeholderHeightCorrection]);
				planningBoardDataService.getHelperServices().eventHandligSubjectService.onShowAssignmentFilterPanel$.unsubscribe([adaptHeaders]);
			 });
			 unregister.push(containerLink?.$watch(function() {
				return {
				  width: element.nativeElement.offsetWidth,
				  height: element.nativeElement.offsetHeight
				};
			 }, function() {
				const currentWidth = element.nativeElement.offsetWidth;
				const currentHeight = element.nativeElement.offsetHeight;
				if (currentWidth !== panelWidth || currentHeight !== panelWidth) {
				  panelWidth = currentWidth;
				  panelHeight = currentHeight;
				  if (layers) {
					 updatePanelWidthDependencies();
				  }
				  if (supplierScale) {
					 updateAll();
				  }
				}
			 }, true));
			 planningBoardDataService.sharedData.status = "";
			 containerLink.registerDataUpdated(init2);
			 function onScroll(e, elem2) {
				const supplierGridElem = document.getElementsByTagName("app-planning-board-supplier-grid");
				const hasScrollbarMoved = supplierGridElem.length > 0 && supplierGridElem[0].contains(elem2.grid.getContainer()[0]) && supplierScrollValue !== arguments[1].scrollTop;
				if (hasScrollbarMoved || supplierChanged) {
				  supplierScrollValue = arguments[1].scrollTop;
				  verticalScrollOffset = -supplierScrollValue;
				  assignmentCollections.setSupplierScrollValue(supplierScrollValue);
				  assignmentComponentItems.setSupplierScrollValue(supplierScrollValue);
				  tagItems.setSupplierScrollValue(supplierScrollValue);
				  supplierScale.setVerticalIndex(setVisibleVerticalIndex(elem2.grid));
				  const scrollContentElem = findPlanningBoardConatinerElement()[0].getElementsByClassName("scrollContent")[0];
				  scrollContentElem.setAttribute("transform", "translate(0, " + verticalScrollOffset + ")");
				  clearTimeout(OnScrollDrawTimeOut);
				  OnScrollDrawTimeOut = setTimeout(update, 5);
				}
			 }
			 function setVisibleVerticalIndex(grid2) {
				let customVerticalIndex = /* @__PURE__ */ new Map();
				if (grid2) {
				  const indexToSupplierIdMap = indexToSupplierId(planningBoardDataService.sharedData.getFilteredItems(planningBoardDataService.getSupplierConfig().uuid));
				  let visibleSupplierIndices = [];
				  if ((0, import_lodash.isFunction)(grid2.getRenderedRange) && grid2.getRenderedRange().bottom >= 0) {
					 for (let i = grid2.getRenderedRange().top; i < grid2.getRenderedRange().bottom; i++) {
						visibleSupplierIndices.push(i);
					 }
				  } else {
					 planningBoardDataService.getSupplierConfig().dataService.getList().forEach((obj, index) => visibleSupplierIndices.push(index));
				  }
				  let addidionalIndex = 0;
				  if (!(0, import_lodash.isUndefined)(visibleSupplierIndices.at(-1))) {
					 addidionalIndex = visibleSupplierIndices.at(-1) + 1;
				  }
				  if (indexToSupplierIdMap.has(addidionalIndex)) {
					 visibleSupplierIndices.push(addidionalIndex);
				  }
				  customVerticalIndex = new Map(visibleSupplierIndices.map((index) => [indexToSupplierIdMap.get(index), index]));
				}
				return customVerticalIndex;
			 }
			 function indexToSupplierId(map3) {
				const inversed = /* @__PURE__ */ new Map();
				map3.forEach((vv, kk) => {
				  inversed.set(vv, kk);
				});
				return inversed;
			 }
			 ;
			 function onSortOrFilter(e, elem2) {
				$timeout(function() {
				  planningBoardDataService.sharedData.verticalIndex = planningBoardDataService.sharedData.getFilteredItems(planningBoardDataService.getSupplierConfig().uuid);
				  if (elem2 && elem2.grid) {
					 supplierScale.setVerticalIndex(setVisibleVerticalIndex(elem2.grid));
				  } else {
					 supplierScale.setVerticalIndex(planningBoardDataService.sharedData.verticalIndex);
				  }
				  calendarlineobject.setHeight(calculatedCurrentSizeY);
				  updateAll();
				});
			 }
			 function onSupplierGridRowCountChanged() {
				if (!supplierChanged) {
				  supplierChanged = true;
				  const grid2 = PlanningBoardExternalServices.platformGridAPI.grids.element("id", planningBoardDataService.getSupplierConfig().uuid);
				  if (grid2.instance && grid2.dataView) {
					 onSortOrFilter(void 0, { grid: grid2 });
				  } else {
					 onSortOrFilter();
				  }
				}
				setTimeout(function() {
				  supplierChanged = false;
				}, 100);
			 }
			 const demandDragStart = function(e) {
				if (e.isDragging) {
				  const demandConfig = planningBoardDataService.getDemandConfig();
				  if (e.draggedData && e.draggedData.sourceGrid && e.draggedData.sourceGrid.data[0] && findPlanningBoardConatinerElement().length > 0 && demandConfig) {
					 const sourceDemandData = e.draggedData.sourceGrid.data[0];
					 const tempAssignmentFromDemand = new AssignmentData((0, import_lodash.cloneDeep)(sourceDemandData));
					 demandInfo = tempAssignmentFromDemand;
					 demandInfo.groupingData.height = supplierScale.getLineHeight();
					 demandInfo.validationData.isValid = true;
					 demandInfo.modificationData.isDragging = true;
					 const demandMapServ = demandConfig.mappingService;
					 platformDragdropService.setDraggedText(demandMapServ.dragInformation(sourceDemandData));
					 let topY = supplierScale.getHeaderLineHeight();
					 let bottomY = supplierScale.getHeaderLineHeight() + planningBoardDataService.sharedData.verticalIndex.size * supplierScale.getLineHeight();
					 if ((0, import_lodash.isNumber)(demandMapServ.supplier(sourceDemandData))) {
						const tempAssignmentObj = {
						  originalEntity: demandMapServ.supplierObj(sourceDemandData)
						};
						const assignmentTopY = supplierScale.get(tempAssignmentObj, "top");
						const assignmentBottomY = supplierScale.get(tempAssignmentObj, "bottom");
						if ((0, import_lodash.isNumber)(assignmentTopY) && assignmentTopY > 0 && (0, import_lodash.isNumber)(assignmentBottomY) && assignmentBottomY > 0) {
						  topY = assignmentTopY;
						  bottomY = assignmentBottomY;
						}
					 }
					 removeToolTip();
					 const demandEnd = new DateExtension(demandMapServ.to(sourceDemandData));
					 const demandStart = new DateExtension(demandMapServ.from(sourceDemandData));
					 bgPreviewLayer.append("rect").classed("dateRangePreview", true).attr("x", timeScale(DateExtension.utc(demandMapServ.from(sourceDemandData))).toString()).attr("y", topY).attr("width", Math.max(10, timeScale(DateExtension.utc(demandEnd)) - timeScale(DateExtension.utc(demandStart)))).attr("height", bottomY - topY).attr("pointer-events", "none");
				  }
				} else {
				  removeToolTip();
				}
			 };
			 function unRegister() {
				platformDragdropService.unregisterDragStateChanged(demandDragStart);
				containerLink?.unregisterDataUpdated(updateAll);
				containerLink?.unregisterDataUpdated(init2);
				platformGridAPI.events.unregister(planningBoardDataService.getSupplierConfig().uuid, "onScroll", onScroll);
				platformGridAPI.events.unregister(planningBoardDataService.getSupplierConfig().uuid, "onSort", onSortOrFilter);
				platformGridAPI.events.unregister(planningBoardDataService.getSupplierConfig().uuid, "onRowCountChanged", onSupplierGridRowCountChanged);
				platformGridAPI.events.unregister(planningBoardDataService.getSupplierConfig().uuid, "onFilterChanged", onSupplierGridRowCountChanged);
			 }
			 function setup() {
				platformDragdropService.registerDragStateChanged(demandDragStart);
				setupDrawing();
				if (platformGridAPI.grids.exist(planningBoardDataService.getSupplierConfig().uuid)) {
				  platformGridAPI.events.register(planningBoardDataService.getSupplierConfig().uuid, "onScroll", onScroll);
				  platformGridAPI.events.register(planningBoardDataService.getSupplierConfig().uuid, "onSort", onSortOrFilter);
				  platformGridAPI.events.register(planningBoardDataService.getSupplierConfig().uuid, "onRowCountChanged", onSupplierGridRowCountChanged);
				  platformGridAPI.events.register(planningBoardDataService.getSupplierConfig().uuid, "onFilterChanged", onSupplierGridRowCountChanged);
				}
				containerLink?.onContentResized(updatePlanningBoardCanvasSize);
				updatePlanningBoardCanvasSize();
			 }
			 function adaptHeaders() {
				$timeout(function() {
				  const isColumfilterVisible = platformGridAPI.grids.getGridState(planningBoardDataService.getSupplierConfig().uuid, true).showFilterRow;
				  planningBoardDataService.sharedData.columnSearchToolbarIcon.value = isColumfilterVisible;
				  parentContainerLink.tools.update();
				  const correcCalculatedtHeight = planningBoardDataService.sharedData.activeSearchMode === "columnSearch" ? platformGridAPI.filters.getFilterRowProperties().height : 0;
				  placeholderHeightCorrection(containerLink.getContainerUUID(), correcCalculatedtHeight);
				  updatePlanningBoardCanvasSize();
				  resize();
				  update(void 0, true);
				  planningBoardDataService.getHelperServices().eventHandligSubjectService.onAdaptHeadersDone$.fire(adaptHeaders);
				}, 10);
			 }
			 function setupDrawing() {
				const pbParentContainerElem = document.getElementsByClassName("planningboardMain")[0].parentElement;
				containerLink.getCurrentDimensions = () => {
				  const pbElementBounds = pbParentContainerElem.getBoundingClientRect();
				  return {
					 height: pbElementBounds.height,
					 width: pbElementBounds.width
				  };
				};
				root2 = select_default2(element.nativeElement);
				const dsConfig = planningBoardDataService.getDateshiftConfig();
				if (dsConfig && planningBoardDataService.getAssignmentConfig().mappingService.dateShift) {
				  root2.on("click", function() {
					 platformDateshiftPlanningboardHelperService.resetMultishift(dsConfig.dataService);
				  });
				}
				viewPort = root2.select("div.viewport");
				pBoardCanvas = root2.select("div.planningboardCanvas");
				let svgDefs = viewPort.select("defs");
				if (svgDefs.empty()) {
				  svgDefs = viewPort.append("defs");
				}
				svgDefs.selectAll().remove();
				const assignmentMapping = planningBoardDataService.getAssignmentConfig().mappingService;
				if (planningBoardDataService.assignmentTypeItems.length === 0) {
				  assignmentMapping.getTypeService().getAssignmentType().then(function(types) {
					 let assignmentTypeIcon = assignmentMapping.getTypeService().getAssignmentTypeIcons(types);
					 if (assignmentTypeIcon.then) {
						assignmentTypeIcon.then((typeIcons) => {
						  cloudDesktopSvgIconService.appendIconDefs("type-icons", typeIcons, "", svgDefs.node());
						});
					 } else if (assignmentTypeIcon.lenght) {
						cloudDesktopSvgIconService.appendIconDefs("type-icons", assignmentTypeIcon, "", svgDefs.node());
					 }
				  });
				} else {
				  let assignmentTypeIcon = assignmentMapping.getTypeService().getAssignmentTypeIcons(planningBoardDataService.assignmentTypeItems);
				  if (assignmentTypeIcon.then) {
					 assignmentTypeIcon.then((typeIcons) => {
						cloudDesktopSvgIconService.appendIconDefs("type-icons", typeIcons, "", svgDefs.node());
					 });
				  } else if (assignmentTypeIcon.lenght) {
					 cloudDesktopSvgIconService.appendIconDefs("type-icons", assignmentTypeIcon, "", svgDefs.node());
				  }
				}
				if (planningBoardDataService.assignmentStatusItems.length === 0) {
				  assignmentMapping.getStatusService().getAssignmentStatus().then((status) => {
					 let assignmentStatusIcon = assignmentMapping.getStatusService().getAssignmentStatusIcons(status);
					 if (assignmentStatusIcon instanceof Promise) {
						assignmentStatusIcon.then((typeIcons) => {
						  cloudDesktopSvgIconService.appendIconDefs("type-icons", typeIcons, "", svgDefs.node());
						});
					 } else if (assignmentStatusIcon.length) {
						cloudDesktopSvgIconService.appendIconDefs("type-icons", assignmentStatusIcon, "", svgDefs.node());
					 }
				  });
				} else {
				  let assignmentStatusIcon = assignmentMapping.getStatusService().getAssignmentStatusIcons(planningBoardDataService.assignmentStatusItems);
				  if (assignmentStatusIcon instanceof Promise) {
					 assignmentStatusIcon.then((typeIcons) => {
						cloudDesktopSvgIconService.appendIconDefs("type-icons", typeIcons, "", svgDefs.node());
					 });
				  } else if (assignmentStatusIcon.length) {
					 cloudDesktopSvgIconService.appendIconDefs("type-icons", assignmentStatusIcon, "", svgDefs.node());
				  }
				}
				dragSel = root2.select("svg.planningboard");
				dragSVG = dragSel.node();
				backgroundLayer = root2.select("svg.planningboard g.background");
				bgPreviewLayer = root2.select("svg.planningboard g.scPreview");
				hePreviewLayer = root2.select("svg.planningboard g.hcPreview");
				laneLayer = root2.select("svg.planningboard g.lanes");
				layers = {
				  headerContent: root2.select("g.headerContent"),
				  calendarLine: root2.select("g.calendarLine"),
				  linesAxis: root2.select("g.dayLinesAxis"),
				  assignments: root2.select("g.assignments"),
				  aggregationContainer: root2.select("g.aggregation-container"),
				  aggregationSumContainer: root2.select("g.aggregation-sum-container"),
				  assignmentTags: root2.select("g.tag-container"),
				  footerContent: root2.select("g.footer-content"),
				  footerLinesAxis: root2.select("g.footer-content g.dayLinesAxis"),
				  assignmentBaseContainer: root2.select("g.assignment-preview-container"),
				  assignmentGroups: root2.select("g.assignment-group-container"),
				  assignmentGroupTooltips: root2.select("g.assignment-tooltip-container"),
				  assignmentGroupMaxLoadLine: root2.select("g.assignment-group-max-load-indicator-container")
				};
				if (dragSVG) {
				  const ddTarget = new platformDragdropService.DragdropTarget(platformDragdropService.dragAreas.main, (0, import_lodash.uniqueId)("assignment"));
				  ddTarget.canDrop = function(info) {
					 if (planningBoardDataService.sharedData.planningBoardMode.actionType === "setStatus" || planningBoardDataService.sharedData.planningBoardMode.actionType === "grouping") {
						demandInfo.validationData.isValid = false;
						return false;
					 }
					 if (info.draggedData && info.draggedData) {
						if (planningBoardDataService.getPlanningBoardSettingsList()["planningBoard.chart.presentation.settings"].validateAssignments && info.event.offsetY && info.draggedData.sourceGrid.data[0]) {
						  return validateDraggingDemand(info.draggedData.sourceGrid.data[0], info.event.offsetY);
						} else {
						  return true;
						}
					 }
					 return false;
				  };
				  ddTarget.drop = function(info) {
					 removeIndicators();
					 demandDragEnd(info);
				  };
				  dragSel.on("mouseenter", function(event) {
					 firstMouseEnter = true;
					 platformDragdropService.mouseEnterTarget(ddTarget, event);
					 if (demandInfo && demandInfo.validationData.isValid && planningBoardDataService.sharedData.showDemandPreview && supplierScale.supplierIdForYpx(event.offsetY + supplierScrollValue) > 0) {
						appendDemandPreview(event);
					 }
				  });
				  dragSel.on("mouseleave", function(event) {
					 firstMouseEnter = false;
					 removeIndicators();
				  });
				  dragSel.on("mousemove", function(event) {
					 firstMouseEnter = false;
					 if (demandInfo && demandInfo.validationData.isValid && demandInfo.modificationData.isDragging && planningBoardDataService.sharedData.showDemandPreview && supplierScale.supplierIdForYpx(event.offsetY + supplierScrollValue) > 0) {
						moveDemandPreview(event);
					 }
				  });
				}
				calendarDrag = drag_default().filter((event, d) => {
				  return true;
				}).on("start", calendarDragStart).on("drag", calendarDragging).on("end", calendarDragEnd);
				zoom$1 = zoom_default2().on("zoom", onMouseZoom);
				viewPort.call(calendarDrag).call(zoom$1).on("click", function(event) {
				  if (isCalendarClicked) {
					 calendarClicked(event);
					 isCalendarClicked = false;
					 if (event.srcElement.classList.contains("planningboard")) {
						planningBoardDataService.assignmentDataService.setSelected(null, []);
						deselectAssignmentComponents(false);
						update(event);
					 }
				  }
				});
				const assignmentFullDrag2 = drag_default().filter((event, d) => {
				  return true;
				}).on("start", assigmentFullDragStart).on("drag", assignmentDragging).on("end", assignmentDragEnd);
				assignmentStartDrag = drag_default().filter((event, d) => {
				  return true;
				}).on("start", assignmentStartDragStart).on("drag", assignmentDragging).on("end", assignmentDragEnd);
				assignmentEndDrag = drag_default().filter((event, d) => {
				  return true;
				}).on("start", assignmentEndDragStart).on("drag", assignmentDragging).on("end", assignmentDragEnd);
				timeScale = utcTime().domain([planningBoardDataService.getDateStart(), planningBoardDataService.getDateEnd()]).range([0, panelWidth]);
				timeaxis = planningBoardDataService.getChartBase().timeaxis().setScale(timeScale);
				planningBoardDataService.setTimeAxis(timeaxis);
				layers.headerContent.call(timeaxis);
				const sizeY = calculatedCurrentSizeY;
				calendarlineobject = planningBoardDataService.getChartBase().calendarlines().setScale(timeScale).setTickvalues(timeaxis.getTickValues()).setMaintickvalues(timeaxis.getMainTickValues()).setShowVerticalLines(true).setHeight(sizeY);
				const gridInstance = platformGridAPI.grids.element("id", planningBoardDataService.getSupplierConfig().uuid).instance;
				supplierScale = PlanningBoardSupplierScaleComponent.supplierScale().setLineHeight(planningBoardDataService.rowHeight()).setHeaderLineHeight(defaultHeaderlineHeight).setVerticalIndex(gridInstance ? setVisibleVerticalIndex(gridInstance) : planningBoardDataService.sharedData.verticalIndex).setMapService(planningBoardDataService.getAssignmentConfig().mappingService);
				assignmentCollection = PlanningBoardAssignmentCollectionComponent.assignmentCollection().setCalendarScale(timeScale).setSupplierScale(supplierScale).setMapService(planningBoardDataService.getAssignmentConfig().mappingService).setCollectionConfig(planningBoardDataService.collectionConfig());
				assignmentComponentItems = PlanningBoardAssignmentItemsComponent.assignmentItems().setCalendarScale(timeScale).setSupplierScale(supplierScale).setAssignmentCollection(assignmentCollection).setDragHandler(assignmentFullDrag2).setClickHandler(onAssignmentClick).setDoubleClickEvent(onAssignmentDoubleClick).setAssignmentStartDragHandler(assignmentStartDrag).setAssignmentEndDragHandler(assignmentEndDrag).setShowHeaderColor(planningBoardDataService.showHeaderColor()).setShowSameAssignments(planningBoardDataService.showSameAssignments()).setShowStatusIcon(planningBoardDataService.showStatusIcon()).setBackgroundColorConfig(planningBoardDataService.backgroundColorConfig()).setStatusIconItems(planningBoardDataService.assignmentStatusItems).setShowInTransportIcon(planningBoardDataService.showInTransportIcon()).setShowTypeIcon(planningBoardDataService.showTypeIcon()).setShowMainText(planningBoardDataService.showMainText()).setShowInfo1Text(planningBoardDataService.showInfo1Text()).setShowInfo2Text(planningBoardDataService.showInfo2Text()).setShowInfo3Text(planningBoardDataService.showInfo3Text()).setMainInfoLabel(planningBoardDataService.mainInfoLabel()).setInfo1Label(planningBoardDataService.info1Label()).setInfo2Label(planningBoardDataService.info2Label()).setInfo3Label(planningBoardDataService.info3Label()).setTypeIconItems(planningBoardDataService.assignmentTypeItems).setMapService(planningBoardDataService.getAssignmentConfig().mappingService).setAssignmentDataService(planningBoardDataService.getAssignmentConfig().dataService).setAssignments(planningBoardDataService.assignments).setDraggingAssignmentSupplier(0).setIsMultiSelect(false).setAggregationHeight(aggregationHeight).setUseTaggingSystem(planningBoardDataService.useTaggingSystem()).setCalendarDateStart(planningBoardDataService.getDateStart()).setCalendarDateEnd(planningBoardDataService.getDateEnd()).setContainerDimensions(containerLink.getCurrentDimensions).setSupplierScrollValue(supplierScrollValue);
				assignmentCollections = PlanningBoardAssignmentCollectionComponent.assignmentCollection().setCalendarScale(timeScale).setSupplierScale(supplierScale).setMapService(planningBoardDataService.getAssignmentConfig().mappingService).setCollectionConfig(planningBoardDataService.collectionConfig()).setAssignments([]).setSupplierScrollValue(supplierScrollValue).setCalendarDateStart(planningBoardDataService.getDateStart()).setCalendarDateEnd(planningBoardDataService.getDateEnd());
				indicatorAreaComponent = PlanningBoardIndicatorAreasComponent.indicatorAreas().setSupplierScale(supplierScale).setCalendarScale(timeScale).setIndicatorY(0).setStartDate(new DateExtension()).setEndDate(new DateExtension()).setMapService(planningBoardDataService.getSupplierConfig().mappingService);
				lanesComponent = PlanningBoardLanesComponent.lanes().setSupplierScale(supplierScale).setPanelWidth(panelWidth);
				aggregateItems = PlanningBoardAggregateItemsComponent.aggregateItems().setSupplierScale(supplierScale).setClickEvent(onAggregationClick).setCalendarScale(timeScale).setMapService(planningBoardDataService.getAssignmentConfig().mappingService).setAggregationHeight(aggregationHeight).setAggregationTrafficLightsConfig(planningBoardDataService.aggregationTrafficLightsConfig()).setAggregates([]);
				aggregateSumItems = PlanningBoardAggregateSumItemsComponent.aggregateSumItems().setCalendarScale(timeScale).setMapService(planningBoardDataService.getAssignmentConfig().mappingService).setClickEventHandler(onAggregationClick).setSumAggregates([]).setSumHeight(footerHeight).setTextLines({
				  "line1": planningBoardDataService.sumAggregationLine1(),
				  "line2": planningBoardDataService.sumAggregationLine2(),
				  "line3": planningBoardDataService.sumAggregationLine3()
				}).setAggregationTrafficLightsConfig(planningBoardDataService.aggregationTrafficLightsConfig()).setPlanningBoardDataService(planningBoardDataService);
				tagItems = PlanningBoardAssignmentTagComponent.assignmentTags().setSupplierScale(supplierScale).setCalendarScale(timeScale).setMapService(planningBoardDataService.getAssignmentConfig().mappingService).setTagConfig(planningBoardDataService.tagConfig()).setStatusIconItems(planningBoardDataService.assignmentStatusItems).setTypeIconItems(planningBoardDataService.assignmentTypeItems).setShowSameAssignments(planningBoardDataService.showSameAssignments()).setUseFilter(false).setCalendarDateStart(planningBoardDataService.getDateStart()).setCalendarDateEnd(planningBoardDataService.getDateEnd()).setClickEventHandler((event, assignment) => {
				  onAssignmentClick(event, assignment);
				  layers.assignments.call(assignmentComponentItems);
				}).setDragHandler(assignmentFullDrag2).setContainerDimensions(containerLink.getCurrentDimensions).setSupplierScrollValue(supplierScrollValue).setGetCurrentZoomUnit(function() {
				  let chartInstance = planningBoardDataService.getChartBase();
				  return chartInstance.getZoomLevel(chartInstance.timeaxis().setScale(timeScale));
				});
				backgroundComponent = PlanningBoardBackgroundsComponent.backgrounds().setSupplierScale(supplierScale).setBgExceptionDayClckHandler(bgExceptionDayClickHandler).setTimeScale(timeScale).setContainerDimensins(containerLink.getCurrentDimensions).setSupplierScrollVaue(supplierScrollValue);
				assignmentGroups = PlanningBoardAssignmentBaseGroupComponent.baseAssignment().setSupplierScale(supplierScale).setCalendarScale(timeScale).setMapService(planningBoardDataService.getAssignmentConfig().mappingService).setTimeScale(timeScale).setSupplierScrollValue(supplierScrollValue).setOnHover(function(event, d) {
				  assignmentGroupTooltips.setAssignments(d.reservations);
				  assignmentGroupTooltips.setSupplierScrollValue(supplierScrollValue);
				  if (event && event.offsetX) {
					 assignmentGroupTooltips.setPositionX(event.offsetX + 10);
				  }
				  layers.assignmentGroupTooltips.call(assignmentGroupTooltips.selection);
				  layers.assignmentGroupTooltips.transition().duration(100).style("opacity", 0.9);
				}).setOnMouseOut(function() {
				  layers.assignmentGroupTooltips.transition().duration(100).style("opacity", 0);
				  const tooltipDiv = layers.assignmentGroupTooltips.selectAll("rect");
				  const tooltipDiv2 = layers.assignmentGroupTooltips.selectAll("text");
				  tooltipDiv.remove();
				  tooltipDiv2.remove();
				});
				demandDragView = PlanningBoardAssignmentBaseGroupComponent.baseAssignment().setSupplierScale(supplierScale).setCalendarScale(timeScale).setTimeScale(timeScale).setSupplierScrollValue(supplierScrollValue).setDeactivatePointerEvents(true);
				planningBoardDataService.getDemandConfig()?.mappingService ? demandDragView.setMapService(planningBoardDataService.getDemandConfig().mappingService) : false;
				assignmentGroupTooltips = PlanningBoardTooltipComponent.tooltip().setSupplierScale(supplierScale).setCalendarScale(timeScale).setMapService(planningBoardDataService.getAssignmentConfig().mappingService).setSupplierScrollValue(supplierScrollValue);
				assignmentMaxLoadLines = PlanningBoardLineComponent.line().setSupplierScale(supplierScale).setCalendarScale(timeScale).setMapService(planningBoardDataService.getAssignmentConfig().mappingService).setTimeScale(timeScale);
				addEventListenerToHeader();
				updateTimeScaleTicks();
				resize();
				setupTools();
				let startCalDragX = 0, startCalDragY = 0, startCalDragDateStart, startCalDragDateEnd;
				function calendarDragStart(event) {
				  if (planningBoardDataService.isCalendarLocked()) {
					 return false;
				  }
				  isCalendarClicked = true;
				  bgExceptionDayClickHandler();
				  event.sourceEvent.stopPropagation();
				  event.sourceEvent.preventDefault();
				  startCalDragX = event.x;
				  startCalDragY = event.y;
				  startCalDragDateStart = new DateExtension(planningBoardDataService.getDateStart());
				  startCalDragDateEnd = new DateExtension(planningBoardDataService.getDateEnd());
				  if (planningBoardDataService.sharedData.planningBoardMode && planningBoardDataService.sharedData.planningBoardMode.actionType === "createAssignment") {
					 const supplierId = supplierScale.supplierIdForYpx(event.sourceEvent.offsetY + supplierScrollValue);
					 const supplierIdx = supplierScale.getVerticalIndex().get(supplierId);
					 const indicatorY = supplierScale.getHeaderLineHeight() + supplierIdx * supplierScale.getLineHeight();
					 indicatorAreas = layers.assignments.selectAll(".indicator-area").data([{
						"Scale": 10
					 }]);
					 indicatorAreaComponent.setIndicatorY(indicatorY);
				  }
				  return true;
				}
				function calendarDragging(event) {
				  if (planningBoardDataService.isCalendarLocked()) {
					 return false;
				  }
				  if (event.x !== 0 || event.y !== 0) {
					 isCalendarClicked = false;
					 isCalendarDragging = true;
					 const currentX = event.x;
					 const stepX = timeScale(DateExtension.utc(new DateExtension(planningBoardDataService.getDateStart()).add(planningBoardDataService.getTimeScaleHoursX(), "hour")));
					 const offsetX = startCalDragX - currentX;
					 const stepCountX = offsetX / stepX;
					 let newStart = new DateExtension(startCalDragDateStart);
					 let newEnd = new DateExtension(startCalDragDateEnd);
					 newStart = newStart.add(stepCountX * planningBoardDataService.getTimeScaleHoursX(), "hour");
					 newEnd = newEnd.add(stepCountX * planningBoardDataService.getTimeScaleHoursX(), "hour");
					 if (planningBoardDataService.sharedData.planningBoardMode && planningBoardDataService.sharedData.planningBoardMode.actionType === "createAssignment") {
						removeIndicators();
						newStart = new DateExtension(startCalDragDateStart);
						newStart = newStart.add(startCalDragX / stepX * planningBoardDataService.getTimeScaleHoursX(), "hour");
						newEnd = new DateExtension(startCalDragDateStart);
						newEnd = newEnd.add(currentX / stepX * planningBoardDataService.getTimeScaleHoursX(), "hour");
						indicatorAreaComponent.setStartDate(newStart);
						indicatorAreaComponent.setEndDate(newEnd);
						indicatorAreas.call(indicatorAreaComponent);
					 } else {
						planningBoardDataService.getDateStart(newStart);
						planningBoardDataService.getDateEnd(newEnd);
						timeScale.domain([newStart, newEnd]).range([0, panelWidth]);
						timeaxis.setScale(timeScale);
						PlanningBoardAssignmentItemsComponent.assignmentItems().setCalendarScale(timeScale);
						PlanningBoardBackgroundsComponent.backgrounds().setStartDate(newStart);
						if (stepCountX !== lastAmountOfStepsX) {
						  lastAmountOfStepsX = stepCountX;
						  update(event);
						}
						clearTimeout(CalDragTimeOut);
						CalDragTimeOut = setTimeout(planningBoardDataService.loadRest, 500);
					 }
				  }
				  return true;
				}
				function calendarDragEnd(event) {
				  if (planningBoardDataService.isCalendarLocked()) {
					 return false;
				  }
				  removeIndicators();
				  if (!isCalendarClicked && (planningBoardDataService.sharedData.planningBoardMode && planningBoardDataService.sharedData.planningBoardMode.actionType === "createAssignment")) {
					 const currentX = event.x;
					 const stepX = timeScale(DateExtension.utc(new DateExtension(planningBoardDataService.getDateStart()).add(planningBoardDataService.getTimeScaleHoursX(), "hour")));
					 let newStart = new DateExtension(startCalDragDateStart);
					 newStart = newStart.add(startCalDragX / stepX * planningBoardDataService.getTimeScaleHoursX(), "hour");
					 let newEnd = new DateExtension(startCalDragDateStart);
					 newEnd = newEnd.add(currentX / stepX * planningBoardDataService.getTimeScaleHoursX(), "hour");
					 const sDemand = _getSelectedDemand();
					 if (sDemand) {
						const creationData = {
						  info: null,
						  demand: sDemand,
						  offsetY: startCalDragY,
						  from: newStart,
						  to: newEnd,
						  offsetX: startCalDragX
						};
						const assignmentMappingService = planningBoardDataService.getAssignmentConfig().mappingService;
						if (assignmentMappingService.intersectSequence && assignmentMappingService.showIntersectSequenceDialog) {
						  const dataForDialog = {
							 creationData,
							 planningBoardDate: DateExtension.utc(new DateExtension(timeScale.invert(creationData.offsetX))),
							 sequenceData: planningBoardDataService.getDateshiftConfig().dateShiftHelperService.getSequenceData(planningBoardDataService.getDateshiftConfig().dataService.getServiceName()),
							 supplierOffsetY: creationData.offsetY,
							 supplierId: supplierScale.supplierIdForYpx(creationData.offsetY + supplierScrollValue),
							 items: planningBoardDataService.assignments,
							 createAssignment: _createAssignment,
							 calendarData: planningBoardDataService.getDateshiftConfig().dateShiftHelperService.getCalendarData(planningBoardDataService.getDateshiftConfig().dataService.getServiceName())
						  };
						  assignmentMappingService.showIntersectSequenceDialog(dataForDialog);
						} else {
						  _createAssignment(creationData);
						}
					 }
				  }
				  lastAmountOfStepsX = 0;
				  isCalendarDragging = false;
				  return true;
				}
				function calendarClicked(event) {
				  if (planningBoardDataService.sharedData.planningBoardMode && planningBoardDataService.sharedData.planningBoardMode.actionType === "createAssignment") {
					 const currentX = event.x;
					 const stepX = timeScale(DateExtension.utc(new DateExtension(planningBoardDataService.getDateStart()).add(planningBoardDataService.getTimeScaleHoursX(), "hour")));
					 const offsetX = startCalDragX - currentX;
					 const stepCountX = offsetX / stepX;
					 let newStart = new DateExtension(startCalDragDateStart);
					 newStart = newStart.add(stepCountX * planningBoardDataService.getTimeScaleHoursX(), "hour");
					 const sDemand = _getSelectedDemand();
					 if (sDemand) {
						const creationData = {
						  info: { event },
						  demand: sDemand
						};
						const assignmentMappingService = planningBoardDataService.getAssignmentConfig().mappingService;
						if (assignmentMappingService.intersectSequence && assignmentMappingService.showIntersectSequenceDialog) {
						  const dataForDialog = {
							 creationData,
							 planningBoardDate: DateExtension.utc(new DateExtension(timeScale.invert(creationData.info.event.offsetX))),
							 sequenceData: planningBoardDataService.getDateshiftConfig().dateShiftHelperService.getSequenceData(planningBoardDataService.getDateshiftConfig().dataService.getServiceName()),
							 supplierOffsetY: creationData.info.event.offsetY,
							 supplierId: supplierScale.supplierIdForYpx(creationData.info.event.offsetY + supplierScrollValue),
							 items: planningBoardDataService.assignments,
							 createAssignment: _createAssignment,
							 calendarData: planningBoardDataService.getDateshiftConfig().dateShiftHelperService.getCalendarData(planningBoardDataService.getDateshiftConfig().dataService.getServiceName())
						  };
						  assignmentMappingService.showIntersectSequenceDialog(dataForDialog);
						} else {
						  _createAssignment(creationData);
						}
					 }
				  }
				}
				let zoomTimeOut;
				let currentZoomLevelTimeOut;
				function onMouseZoom(event) {
				  if (planningBoardDataService.isCalendarLocked()) {
					 return false;
				  }
				  if (event.sourceEvent.currentTarget && event.sourceEvent.currentTarget.hasOwnProperty("__zoom")) {
					 removeToolTip();
					 let d3ZoomVal = 0;
					 d3ZoomVal = event.sourceEvent.currentTarget["__zoom"].y;
					 if (Math.abs(d3ZoomVal) < 150) {
						const prop = event.sourceEvent.offsetX / panelWidth;
						const zoomStep = (d3ZoomVal > 0 ? 4 : -6) * planningBoardDataService.getTimeScaleHoursX();
						let type2 = "hour";
						let newStart = new DateExtension(planningBoardDataService.getDateStart()).subtract(zoomStep * prop, type2);
						let newEnd = new DateExtension(planningBoardDataService.getDateEnd()).add(zoomStep * (1 - prop), type2);
						if (newEnd.diff(newStart, "days") >= 1) {
						  if (newEnd.diff(newStart, "days") >= 14) {
							 type2 = "day";
							 newStart = newStart.startOf(type2);
							 newEnd = newEnd.startOf(type2).add(1, type2);
						  }
						  planningBoardDataService.getDateStart(newStart);
						  planningBoardDataService.getDateEnd(newEnd);
						  clearTimeout(zoomTimeOut);
						  if (d3ZoomVal > 0) {
							 zoomTimeOut = setTimeout(planningBoardDataService.loadRest, 500);
						  }
						  timeScale.domain([newStart, newEnd]).range([0, panelWidth]);
						  timeaxis.setScale(timeScale);
						  PlanningBoardAssignmentItemsComponent.assignmentItems().setCalendarScale(timeScale);
						  PlanningBoardBackgroundsComponent.backgrounds().setStartDate(newStart);
						  update(event);
						}
						planningBoardDataService.setCurrentZoomLevel(newStart, newEnd);
						if (!(0, import_lodash.isUndefined)(planningBoardDataService.sharedData.saveLastZoom) && planningBoardDataService.sharedData.saveLastZoom) {
						  clearTimeout(currentZoomLevelTimeOut);
						  currentZoomLevelTimeOut = setTimeout(planningBoardDataService.saveCurrentZoomLevel, 500);
						}
					 }
					 event.sourceEvent.currentTarget["__zoom"].y = 0;
				  }
				  return true;
				}
				let editMode = "fullAssignment";
				function assigmentFullDragStart(event, assignment) {
				  editMode = "fullAssignment";
				  assignmentDragStartAll(assignment, event);
				}
				function assignmentStartDragStart(event, assignment) {
				  editMode = "assignmentStart";
				  assignmentDragStartAll(assignment, event);
				}
				function assignmentEndDragStart(event, assignment) {
				  editMode = "assignmentEnd";
				  assignmentDragStartAll(assignment, event);
				}
				function assignmentDragStartAll(assignment, event) {
				  const mapServ = planningBoardDataService.getAssignmentConfig().mappingService;
				  if ((0, import_lodash.isFunction)(mapServ.isReadOnly) && mapServ.isReadOnly(assignment.originalEntity)) {
					 return false;
				  }
				  oldXMoment = void 0;
				  adjustCircleObj.movedUnits = 0;
				  if (!(0, import_lodash.isUndefined)(assignment)) {
					 dragStartBarValues = {
						barStart: new DateExtension(mapServ.from(assignment.originalEntity)),
						barEnd: new DateExtension(mapServ.to(assignment.originalEntity))
					 };
				  }
				  event.sourceEvent.stopPropagation();
				  event.sourceEvent.preventDefault();
				  assignmentDragStartX = event.x;
				  assignmentDragStartY = event.y;
				  selectedAssignments.length = 0;
				  selectedAssignments.push((0, import_lodash.clone)(assignment));
				  planningBoardDataService.assignments.forEach((assignment2) => {
					 if (assignment2.modificationData.selectedFlag && !assignment2.modificationData.activeFlag) {
						selectedAssignments.push((0, import_lodash.clone)(assignment2));
					 }
				  });
				  assignment.modificationData.isDragging = true;
				  return true;
				}
				function assignmentDragging(event, assignment) {
				  const clonedAssignment = (0, import_lodash.cloneDeep)(assignment);
				  const assignmentMapServ = planningBoardDataService.getAssignmentConfig().mappingService;
				  const isMultiSelect = event && event.sourceEvent.ctrlKey;
				  const canDragHorizontally = !(0, import_lodash.isFunction)(assignmentMapServ.canDragHorizontally) || assignmentMapServ.canDragHorizontally && !assignmentMapServ.canDragHorizontally();
				  const draggedAssignment = selectedAssignments.find((selectedAssignment) => assignmentMapServ.id(selectedAssignment.originalEntity) === assignmentMapServ.id(assignment.originalEntity));
				  let canDrag = true;
				  if (planningBoardDataService.sharedData.planningBoardMode && planningBoardDataService.sharedData.planningBoardMode.events && !planningBoardDataService.sharedData.planningBoardMode.events.drag) {
					 canDrag = false;
				  }
				  if ((0, import_lodash.isFunction)(assignmentMapServ.isReadOnly) && selectedAssignments.some((selAssignment) => assignmentMapServ.isReadOnly(selAssignment.originalEntity))) {
					 canDrag = false;
				  }
				  if ((0, import_lodash.isFunction)(assignmentMapServ.isDraggable) && !assignmentMapServ.isDraggable(assignment.originalEntity, selectedAssignments.map((assignment2) => assignment2.originalEntity), planningBoardDataService.getDateshiftConfig())) {
					 canDrag = false;
				  }
				  if (canDrag && draggedAssignment) {
					 if (!(0, import_lodash.isUndefined)(popupInstance)) {
						popupInstance.close();
					 }
					 const currentY = event.sourceEvent.offsetY + supplierScrollValue;
					 const originalYtop = supplierScale.get(draggedAssignment, "top");
					 let newY = originalYtop;
					 const assignmentSupplierHasChanged = supplierScale.get(draggedAssignment, "top") > currentY && supplierScale.get(draggedAssignment, "bottom") > currentY || supplierScale.get(draggedAssignment, "top") < currentY && supplierScale.get(draggedAssignment, "bottom") < currentY;
					 if ((0, import_lodash.isFunction)(assignmentMapServ.canDragVertically) && !assignmentMapServ.canDragVertically(assignment.originalEntity, selectedAssignments.map((sA) => sA.originalEntity), planningBoardDataService.getDateshiftConfig())) {
						assignmentDragStartY = 0;
					 } else {
						if (assignmentSupplierHasChanged) {
						  newY = currentY;
						}
					 }
					 const resId = supplierScale.supplierIdForYpx(newY);
					 assignmentComponentItems.setIsMultiSelect(isMultiSelect);
					 if (!isMultiSelect) {
						singleAssignmentDragging(assignment, assignmentMapServ, resId, assignmentSupplierHasChanged, event, !!canDragHorizontally);
					 } else {
						if (!assignment.modificationData.selectedFlag) {
						  assignment.modificationData.activeFlag = true;
						  assignment.modificationData.selectedFlag = true;
						  planningBoardDataService.addToSelectedAssignment(assignment);
						}
						multipleAssignmentDragging(assignment, assignmentMapServ, resId, assignmentSupplierHasChanged, event, !!canDragHorizontally);
					 }
					 const assignmentMomentHasChanged = !assignmentMapServ.from(clonedAssignment.originalEntity).isSame(assignmentMapServ.from(draggedAssignment.originalEntity)) || !assignmentMapServ.to(clonedAssignment.originalEntity).isSame(assignmentMapServ.to(draggedAssignment.originalEntity));
					 if (assignmentMomentHasChanged || assignmentSupplierHasChanged) {
						assignmentMapServ.from(draggedAssignment.originalEntity, assignmentMapServ.from(clonedAssignment.originalEntity));
						assignmentMapServ.to(draggedAssignment.originalEntity, assignmentMapServ.to(clonedAssignment.originalEntity));
						assignmentComponentItems.setDraggingAssignmentSupplier(assignmentMapServ.supplier(draggedAssignment.originalEntity));
						assignmentComponentItems.setDraggingAssignment(draggedAssignment);
						updateData();
						updateAggregations();
						planningBoardDataService.updateAssignment(draggedAssignment);
						const previousUseFilter = tagItems.getUseFilter();
						draw();
						updateDayLinesPosition();
					 }
				  }
				}
				function multipleAssignmentDragging(assignment, assignmentMapServ, resourceIdOfDragged, assignmentSupplierHasChanged, event, canDragHorizontally) {
				  const from2 = assignmentMapServ.from(assignment.originalEntity), to = assignmentMapServ.to(assignment.originalEntity);
				  from2.seconds(0);
				  to.seconds(0);
				  let validationResultDragging = { isValid: true };
				  const selectedAssignmentIds = selectedAssignments.map((selectedAssignment) => assignmentMapServ.id(selectedAssignment.originalEntity));
				  if (event.sourceEvent.movementX !== 0 && (0, import_lodash.isFunction)(assignmentMapServ.canMultiShiftAssignment) && assignmentMapServ.canMultiShiftAssignment(selectedAssignments.map((sA) => sA.originalEntity))) {
					 if (!planningBoardDataService.getDateshiftConfig()) {
						if (canDragHorizontally) {
						  moveAssigmentInXAxis(assignment.originalEntity, event, planningBoardDataService.sharedData.activeMoveMode);
						}
						const firstSelectedAssignment = selectedAssignments[0];
						const minsDiffFrom = from2.diff(assignmentMapServ.from(firstSelectedAssignment.originalEntity), "minutes");
						const minsDiffTo = to.diff(assignmentMapServ.to(firstSelectedAssignment.originalEntity), "minutes");
						Array.from(planningBoardDataService.assignments.values()).filter((assignmentElement) => assignmentElement.modificationData.selectedFlag && !assignmentElement.modificationData.activeFlag && selectedAssignmentIds.includes(assignmentMapServ.id(assignmentElement.originalEntity))).forEach((assignmentElement) => {
						  selectedAssignments.forEach((selectedAssignment, idx) => {
							 if (idx !== 0 && assignmentMapServ.id(selectedAssignment.originalEntity) === assignmentMapServ.id(assignmentElement.originalEntity)) {
								const newTo = new DateExtension(assignmentMapServ.to(selectedAssignment.originalEntity)).add(minsDiffTo, "minutes");
								assignmentMapServ.to(assignmentElement.originalEntity, newTo);
								const newFrom = new DateExtension(assignmentMapServ.from(selectedAssignment.originalEntity)).add(minsDiffFrom, "minutes");
								assignmentMapServ.from(assignmentElement.originalEntity, newFrom);
							 }
						  });
						});
					 } else if (canDragHorizontally) {
						moveAssigmentInXAxis(assignment.originalEntity, event, planningBoardDataService.sharedData.activeMoveMode);
					 }
				  }
				  if (assignmentSupplierHasChanged && assignmentDragStartY > 0 && (0, import_lodash.isFunction)(assignmentMapServ.canMultiShiftAssignment) && assignmentMapServ.canMultiShiftAssignment(selectedAssignments.map((sA) => sA.originalEntity))) {
					 selectedAssignments.forEach((selectedAssignment) => {
						let foundDemand = (0, import_lodash.find)(planningBoardDataService.demands, { Id: assignmentMapServ.demand(selectedAssignment.originalEntity) });
						if (foundDemand && foundDemand instanceof DemandData) {
						  validationResultDragging = planningBoardDataService.getHelperServices().validationService.validateEntityAgainstSupplier(foundDemand.originalEntity, "demand", resourceIdOfDragged);
						}
						const selectedFromAssignment = planningBoardDataService.assignments.get(assignmentMapServ.id(selectedAssignment.originalEntity));
						if (resourceIdOfDragged > 0 && validationResultDragging.isValid && selectedFromAssignment) {
						  assignmentMapServ.supplier(selectedFromAssignment.originalEntity, resourceIdOfDragged);
						  assignmentMapServ.supplier(selectedAssignment.originalEntity, resourceIdOfDragged);
						}
					 });
				  }
				  if (assignmentSupplierHasChanged && (0, import_lodash.isFunction)(assignmentMapServ.onSupplierChanged)) {
					 selectedAssignments.forEach((selectedAssignment) => assignmentMapServ.onSupplierChanged(selectedAssignment.originalEntity, planningBoardDataService));
				  }
				}
				function singleAssignmentDragging(assignment, assignmnetMapServ, resourceIdOfDragged, assignmentSupplierHasChanged, event, canDragHorizontally) {
				  if ((0, import_lodash.isFunction)(assignmnetMapServ.isReadOnly) && assignmnetMapServ.isReadOnly(assignment.originalEntity)) {
					 return false;
				  }
				  if (editMode === "fullAssignment" && (0, import_lodash.find)(planningBoardDataService.sharedData.demands, { Id: assignmnetMapServ.demand(assignment.originalEntity) })) {
					 const demandMapServ = planningBoardDataService.getDemandConfig()?.mappingService;
					 const foundDemand2 = planningBoardDataService.sharedData.demands.find((demand) => demandMapServ?.id(demand.originalEntity) === assignmnetMapServ.demand(assignment.originalEntity));
					 if (foundDemand2) {
						drawIndicatorArea(foundDemand2.originalEntity);
					 }
				  }
				  if (canDragHorizontally) {
					 moveAssigmentInXAxis(assignment.originalEntity, event, planningBoardDataService.sharedData.activeMoveMode);
				  }
				  let validationResultDragging = { isValid: true };
				  let foundDemand = (0, import_lodash.find)(planningBoardDataService.demands, { Id: assignmnetMapServ.demand(assignment.originalEntity) });
				  if (foundDemand && foundDemand instanceof DemandData) {
					 validationResultDragging = planningBoardDataService.getHelperServices().validationService.validateEntityAgainstSupplier(foundDemand.originalEntity, "demand", resourceIdOfDragged);
				  }
				  if (resourceIdOfDragged > 0 && validationResultDragging.isValid) {
					 assignmnetMapServ.supplier(assignment.originalEntity, resourceIdOfDragged);
				  }
				  if (assignmentSupplierHasChanged && (0, import_lodash.isFunction)(assignmnetMapServ.onSupplierChanged)) {
					 assignmnetMapServ.onSupplierChanged(assignment.originalEntity, planningBoardDataService);
				  }
				  return true;
				}
				function validateMovedXPosition(assignmentToMove, event, editMode2, activeMoveMode) {
				  let movedX = event.sourceEvent.offsetX;
				  const rangeStart = timeScale.range()[0];
				  const rangeEnd = timeScale.range()[1];
				  const mapServ = planningBoardDataService.getAssignmentConfig().mappingService;
				  let rangeMid = 0;
				  movedX = movedX < rangeStart + radius ? rangeStart + radius : movedX;
				  movedX = movedX > rangeEnd - radius ? rangeEnd - radius : movedX;
				  if (editMode2 === "assignmentStart" && movedX < timeScale.range([rangeStart, rangeEnd])(mapServ.from(assignmentToMove)) || editMode2 === "assignmentEnd" && movedX > timeScale.range([rangeStart, rangeEnd])(mapServ.from(assignmentToMove))) {
					 const newPlannedStart = new DateExtension(mapServ.from(assignmentToMove)).subtract(1, activeMoveMode);
					 rangeMid = (timeScale.rangeRound([rangeStart, rangeEnd])(mapServ.from(assignmentToMove)) - timeScale.rangeRound([rangeStart, rangeEnd])(newPlannedStart)) / 2;
				  }
				  return movedX + rangeMid;
				}
				function moveAssigmentInXAxis(assignmentToMove, event, activeMoveMode) {
				  if (event.sourceEvent.movementX !== 0) {
					 let type2 = "mid";
					 switch (editMode) {
						case "fullAssignment":
						  type2 = "mid";
						  break;
						case "assignmentStart":
						  type2 = "min";
						  break;
						case "assignmentEnd":
						  type2 = "max";
						  break;
					 }
					 const movedX = validateMovedXPosition(assignmentToMove, event, editMode, activeMoveMode);
					 adjustCircleObj.move(assignmentToMove, movedX, type2, activeMoveMode);
				  }
				  return assignmentToMove;
				}
				function onAssignmentClick(event, assignmentItem) {
				  if ((0, import_lodash.isUndefined)(planningBoardDataService.sharedData.planningBoardMode)) {
					 planningBoardDataService.sharedData.planningBoardMode = {
						"actionType": "setDefault"
					 };
				  }
				  switch (planningBoardDataService.sharedData.planningBoardMode.actionType) {
					 case "setStatus":
						setAssignmentStatusChanged(assignmentItem);
						draw();
						break;
					 case "createAssignment":
						calendarClicked(event);
						break;
					 default:
						containerLink.$apply();
						defaultAssignmentClick(event, assignmentItem);
						layers.assignments.call(assignmentComponentItems);
						break;
				  }
				}
				function defaultAssignmentClick(event, assignmentItem) {
				  planningBoardDataService.loadVirtualForSelected(assignmentItem.originalEntity);
				  const isMultiSelect = event && event.ctrlKey;
				  assignmentComponentItems.setIsMultiSelect(isMultiSelect);
				  if (!isMultiSelect) {
					 openAssignmentPopup(assignmentItem, event);
				  }
				  deselectAssignmentComponents(isMultiSelect);
				  const mapServ = planningBoardDataService.getAssignmentConfig().mappingService;
				  const isAlreadySelected = assignmentItem && assignmentItem.modificationData.selectedFlag;
				  planningBoardDataService.sharedData.status = "";
				  if (assignmentItem) {
					 if (isAlreadySelected && isMultiSelect) {
						assignmentItem.modificationData.activeFlag = false;
						assignmentItem.modificationData.selectedFlag = false;
					 } else {
						assignmentItem.modificationData.activeFlag = true;
						assignmentItem.modificationData.selectedFlag = true;
					 }
					 planningBoardDataService.assignments.forEach((assignment) => {
						assignment.modificationData.areRelated = mapServ.areRelated(assignmentItem.originalEntity, assignment.originalEntity);
					 });
					 planningBoardDataService.sharedData.status = mapServ.statusPanelText(assignmentItem.originalEntity);
				  }
				  if (isMultiSelect) {
					 planningBoardDataService.addToSelectedAssignment(assignmentItem);
				  } else {
					 planningBoardDataService.setSelectedAssignment(assignmentItem);
				  }
				}
				function getFormConfigForShowingAssignment(assignmentItem) {
				  const mapServ = planningBoardDataService.getAssignmentConfig().mappingService;
				  if (mapServ.getAssignmentModalFormConfig) {
					 return mapServ.getAssignmentModalFormConfig(assignmentItem);
				  }
				  const defaultConfig = {
					 fid: "example",
					 version: "1.0.0",
					 showGrouping: true,
					 groups: [{
						gid: "default",
						header: "Details",
						isOpen: true
					 }],
					 rows: []
				  };
				  if (mapServ.description(assignmentItem)) {
					 defaultConfig.rows.push({
						gid: "default",
						rid: "description",
						label: "*Description",
						type: "description",
						model: "Description"
					 });
				  }
				  if (mapServ.comment && mapServ.comment(assignmentItem)) {
					 defaultConfig.rows.push({
						gid: "default",
						rid: "comment",
						label: "*Comment",
						type: "comment",
						model: "Comment",
						domain: "comment"
					 });
				  }
				  if (mapServ.code && mapServ.code(assignmentItem)) {
					 defaultConfig.rows.push({
						gid: "default",
						rid: "code",
						label: "*Code",
						type: "description",
						model: "Code",
						domain: "description"
					 });
				  }
				  return defaultConfig;
				}
				function updateAssignmentProperties(originalEntity, changedObject, assignmentToUpdate) {
				  const properties = Object.getOwnPropertyNames(originalEntity);
				  let changedProp = null;
				  properties.forEach((prop) => {
					 changedProp = changedObject[prop];
					 if (changedProp && changedProp.toDate) {
						changedProp = new DateExtension(changedProp.toDate());
					 }
					 originalEntity[prop] = changedProp;
				  });
				  if (assignmentToUpdate) {
					 planningBoardDataService.updateAssignment(assignmentToUpdate);
				  }
				  return originalEntity;
				}
				function updateAssignmentPropertiesOfDialog(assignmentItem, result) {
				  if (!(0, import_lodash.isEmpty)(result)) {
					 const assignmentMapServ = planningBoardDataService.getAssignmentConfig().mappingService;
					 const assignmentToUpdate = planningBoardDataService.assignments.get(assignmentMapServ.id(result));
					 const originalEntityOfAssignment = assignmentToUpdate.originalEntity;
					 let circle = "mid";
					 if (!assignmentMapServ.from(originalEntityOfAssignment).isSame(assignmentMapServ.from(result))) {
						circle = "min";
					 } else if (!assignmentMapServ.to(originalEntityOfAssignment).isSame(assignmentMapServ.to(result))) {
						circle = "max";
					 }
					 updateAssignmentProperties(assignmentItem, result);
					 updateAssignmentProperties(originalEntityOfAssignment, assignmentItem, assignmentToUpdate);
					 const dateshiftConfig = planningBoardDataService.getAssignmentConfig().mappingService.dateShift;
					 if (dateshiftConfig) {
						dateshiftConfig({
						  startMoment: assignmentMapServ.from(originalEntityOfAssignment),
						  endMoment: assignmentMapServ.to(originalEntityOfAssignment),
						  el: originalEntityOfAssignment,
						  type: circle,
						  dateShiftConfig: planningBoardDataService.getDateshiftConfig(),
						  dataService: planningBoardDataService
						});
					 }
					 const assignmentChangedFn = dateshiftConfig && planningBoardDataService.getAssignmentConfig().mappingService.assignmentChanged;
					 if (assignmentChangedFn) {
						assignmentChangedFn({
						  el: originalEntityOfAssignment,
						  dateShiftConfig: planningBoardDataService.getDateshiftConfig(),
						  dataService: planningBoardDataService
						});
					 }
					 Object.assign(result, originalEntityOfAssignment);
					 deselectAssignmentComponents(false);
					 planningBoardDataService.assignmentDataService.setSelected(null, []);
					 if (!(0, import_lodash.isNil)(planningBoardDataService.getDateshiftConfig()) && !planningBoardDataService.assignments.get(assignmentMapServ.id(assignmentItem)).modificationData.selectedFlag) {
						planningBoardDataService.getDateshiftConfig().dateShiftHelperService.resetDateshift();
					 }
					 update();
				  }
				}
				function onAssignmentDoubleClick(assignmentItemData) {
				  planningBoardDataService.loadVirtualForSelected(assignmentItemData);
				  const originalAssignmentState = (0, import_lodash.cloneDeep)(assignmentItemData);
				  const assignmentItem = (0, import_lodash.cloneDeep)(assignmentItemData);
				  isDoubleClick = true;
				  if (!(0, import_lodash.isUndefined)(popupInstance)) {
					 popupInstance.close();
				  }
				  if (assignmentItem) {
					 const dialogOptions = {
						dialogTitle: "platform.planningboard.editAssignment",
						title: "Edit Assignment",
						resizeable: true,
						items: []
					 };
					 if (planningBoardDataService.getAssignmentConfig().uiStandardService && planningBoardDataService.getAssignmentConfig().dataServiceForDetail) {
						createOptionsForCustomDetailDialog(dialogOptions, assignmentItem);
					 } else {
						const customSettings2 = {
						  Name: translate2.instant("platform.planningboard.assignment"),
						  form: getFormConfigForShowingAssignment(assignmentItem)
						};
						dialogOptions.items.push(customSettings2);
						dialogOptions.items.find((item) => item.Name === translate2.instant("platform.planningboard.assignment")).form.rows.forEach((row) => {
						  row.change = function(entity) {
							 let tempAssignmentFromResult = updateAssignmentProperties(Object.assign({}, entity), entity);
							 updateAssignmentPropertiesOfDialog(assignmentItem, tempAssignmentFromResult);
						  };
						});
					 }
					 const mapServ = planningBoardDataService.getAssignmentConfig().mappingService;
					 const customSettings = mapServ.getCustomSettings;
					 if (customSettings) {
						dialogOptions.items = dialogOptions.items.concat(customSettings());
					 }
					 const properties = Object.getOwnPropertyNames(assignmentItem);
					 let changedProp = null;
					 properties.forEach((prop) => {
						changedProp = assignmentItem[prop];
						if (changedProp && changedProp instanceof DateExtension) {
						  changedProp = changedProp.toMoment();
						}
						assignmentItem[prop] = changedProp;
					 });
					 Object.assign(dialogOptions.items[0], assignmentItem);
					 const dataServiceForDetail = planningBoardDataService.getAssignmentConfig().dataServiceForDetail;
					 const selectionPromise = dataServiceForDetail.setSelected || new Promise((value) => false);
					 selectionPromise(assignmentItem).then(() => {
						return platformMasterDetailDialogService.show(dialogOptions).then().catch((result) => {
						  if (result === "cancel" && !planningBoardDataService.getDateshiftConfig()) {
							 updateAssignmentPropertiesOfDialog(assignmentItem, originalAssignmentState);
						  }
						}).finally(() => {
						  isDoubleClick = false;
						});
					 });
				  }
				}
				function createOptionsForCustomDetailDialog(dialogOptions, assignmentItem) {
				  dialogOptions.items.push({
					 Name: translate2.instant("platform.planningboard.assignment"),
					 form: {
						fid: "assignmentDetail",
						version: "1.0.0",
						showGrouping: false,
						groups: [
						  {
							 gid: "assignmentDetail",
							 header: "Assignment Detail",
							 // TOD missing translation
							 isOpen: true,
							 visible: true,
							 sortOrder: 1
						  }
						],
						rows: [
						  {
							 gid: "assignmentDetail",
							 rid: "assignmentDetailRow",
							 visible: true,
							 sortOrder: 1,
							 readonly: false,
							 type: "directive",
							 //directive: 'app-planning-board-edit-assignment-dialog', // TODO use new component if possible and needed. maybe it's not...
							 directive: "platform-planning-board-edit-assignment-dialog-directive",
							 options: {
								uiStandardService: planningBoardDataService.getAssignmentConfig().uiStandardService,
								dataServiceForDetail: planningBoardDataService.getAssignmentConfig().dataServiceForDetail,
								dataService: planningBoardDataService
							 }
						  }
						]
					 }
				  });
				  let uiStandardService = planningBoardDataService.getAssignmentConfig().uiStandardService;
				  const detailView = uiStandardService && uiStandardService.getStandardConfigForDetailView ? uiStandardService.getStandardConfigForDetailView() : null;
				  const detailDataService = planningBoardDataService.getAssignmentConfig().dataServiceForDetail;
				  if (detailView && detailDataService) {
					 detailView.rows.forEach((row) => {
						row.change = function(entity, field) {
						  if (detailDataService && detailDataService.handleFieldChanged) {
							 detailDataService.handleFieldChanged(entity, field);
						  }
						  let tempAssignmentFromResult = updateAssignmentProperties(Object.assign({}, entity), entity);
						  updateAssignmentPropertiesOfDialog(assignmentItem, tempAssignmentFromResult);
						};
					 });
				  }
				}
				function assignmentDragEnd(event, assignment) {
				  const mapServ = planningBoardDataService.getAssignmentConfig().mappingService;
				  const isMultiSelect = event && event.sourceEvent.ctrlKey;
				  const assignmentChanged = !!assignment.modificationData.pBoardModified;
				  if (isMultiSelect) {
					 selectedAssignments[0].modificationData.selectedFlag = assignment.modificationData.selectedFlag;
				  }
				  if (planningBoardDataService.getDateshiftConfig() && assignmentChanged) {
					 if (planningBoardDataService.getDateshiftConfig().dataService.hasOwnProperty("isDateshiftDeactivated") && !planningBoardDataService.getDateshiftConfig().dataService.isDateshiftDeactivated) {
						planningBoardDataService.getDateshiftConfig().dateShiftHelperService.updateSequenceData(planningBoardDataService.getDateshiftConfig().dataService.getServiceName());
					 }
				  }
				  if ((0, import_lodash.isFunction)(mapServ.isReadOnly) && mapServ.isReadOnly(assignment.originalEntity)) {
					 return false;
				  }
				  if ((0, import_lodash.isFunction)(mapServ.onDrop) && assignmentChanged) {
					 mapServ.onDrop(assignment.originalEntity, isMultiSelect ? selectedAssignments.map((sA) => sA.originalEntity) : [], planningBoardDataService).then(() => {
						if (planningBoardDataService.getDateshiftConfig() && assignmentChanged) {
						  planningBoardDataService.getDateshiftConfig().dateShiftHelperService.updateSequenceData(planningBoardDataService.getDateshiftConfig().dataService.getServiceName());
						}
						postAssignmentDragEnd(assignment, event);
					 });
				  } else {
					 postAssignmentDragEnd(assignment, event);
				  }
				  return true;
				}
				function postAssignmentDragEnd(assignment, event) {
				  const mapServ = planningBoardDataService.getAssignmentConfig().mappingService;
				  assignment.timeData.startDateInMs = mapServ.from(assignment.originalEntity).toDate().getTime();
				  assignment.timeData.endDateInMs = mapServ.from(assignment.originalEntity).toDate().getTime();
				  let assignmentFromSelected = selectedAssignments.find((sA) => mapServ.id(sA.originalEntity) === mapServ.id(assignment.originalEntity));
				  assignment.modificationData.isDragging = assignmentFromSelected.modificationData.isDragging = false;
				  assignmentComponentItems.setDraggingAssignmentSupplier(false);
				  if (assignmentDragStartX === event.x && assignmentDragStartY === event.y) {
					 layers.assignments.selectAll("g.assignment-item").classed("ourActiveClass", false);
				  } else {
					 const firstSelected = selectedAssignments[0];
					 if (firstSelected) {
						const startEndOrSupplierChanged = !mapServ.from(firstSelected.originalEntity).isSame(mapServ.from(assignment.originalEntity)) || !mapServ.to(firstSelected.originalEntity).isSame(mapServ.to(assignment.originalEntity)) || mapServ.supplier(firstSelected.originalEntity) !== mapServ.supplier(assignment.originalEntity);
						if (startEndOrSupplierChanged) {
						  planningBoardDataService.updateAssignment(assignment);
						  planningBoardDataService.assignments.forEach((assignment2) => {
							 if (assignment2.modificationData.selectedFlag && !assignment2.modificationData.activeFlag) {
								planningBoardDataService.updateAssignment(assignment2);
							 }
						  });
						  layers.assignments.call(assignmentComponentItems);
						}
						conflictAssignments = [];
					 }
				  }
				  editMode = "fullAssignment";
				  tagItems.setUseFilter(false);
				  resetIndicatorArea();
				  update();
				}
				function demandDragEnd(info) {
				  parentContainerLink.dateShiftModeTools = planningBoardDataService.sharedData.dateShiftModeTools;
				  layers.assignmentBaseContainer.selectAll("*").remove();
				  const assignmentMappingService = planningBoardDataService.getAssignmentConfig().mappingService;
				  demandInfo.validationData.isValid = false;
				  if (info.draggedData.sourceGrid.data.length > 0) {
					 const creationData = {
						info,
						demand: info.draggedData.sourceGrid.data[0],
						from: null,
						to: null,
						offsetY: null
					 };
					 const showIntersectSeqDialog = assignmentMappingService.intersectSequence && assignmentMappingService.showIntersectSequenceDialog;
					 if (showIntersectSeqDialog) {
						const dataForDialog = {
						  creationData,
						  planningBoardDate: DateExtension.utc(new DateExtension(timeScale.invert(info.event.offsetX))),
						  sequenceData: planningBoardDataService.getDateshiftConfig().dateShiftHelperService.getSequenceData(planningBoardDataService.getDateshiftConfig().dataService.getServiceName()),
						  supplierOffsetY: creationData.info.event.offsetY,
						  supplierId: supplierScale.supplierIdForYpx(creationData.info.event.offsetY + supplierScrollValue),
						  items: planningBoardDataService.assignments,
						  createAssignment: _createAssignment,
						  calendarData: planningBoardDataService.getDateshiftConfig().dateShiftHelperService.getCalendarData(planningBoardDataService.getDateshiftConfig().dataService.getServiceName())
						};
						showIntersectSeqDialog(dataForDialog);
					 } else {
						_createAssignment(creationData);
					 }
				  }
				}
			 }
			 function onAggregationClick(d, event) {
				openAggregationPopup(d, event);
			 }
			 function appendDemandPreview(event) {
				demandDragView.setSupplierScrollValue(supplierScrollValue);
				demandDragView.setAssignments([demandInfo]);
				layers.assignmentBaseContainer.call(demandDragView, event);
			 }
			 function moveDemandPreview(event) {
				layers.assignmentBaseContainer.call(demandDragView, event);
			 }
			 function updateAssignmentGrouping() {
				if (planningBoardDataService.sharedData.planningBoardMode.actionType === "grouping" && planningBoardDataService.getAssignmentConfig().mappingService.grouping) {
				  const updateGroupingData = {
					 planningBoardMode: planningBoardDataService.sharedData.planningBoardMode,
					 timeaxis,
					 timeScale,
					 supplierScale,
					 dataService: planningBoardDataService,
					 chartBase: planningBoardDataService.getChartBase()
				  };
				  const groups = PlanningBoardUpdateService.updateAssignmentGrouping(updateGroupingData);
				  updateGroupLineComponents(groups);
				  assignmentGroups.setAssignments(groups.groupViews);
				}
			 }
			 function updateGroupLineComponents(groups) {
				const maxLoadColor = PlanningBoardDrawingUtilitiesService.decToHexColor(planningBoardDataService.aggregationTrafficLightsConfig()["maxload"]);
				let assigmentsOfGroup = groups.maxCapacityLineViews.map((val) => planningBoardDataService.assignments.get(val.Id));
				assignmentMaxLoadLines.setAssignments(assigmentsOfGroup);
				assignmentMaxLoadLines.setLineColor(maxLoadColor);
			 }
			 function getParentPanelWidth() {
				return +element.nativeElement.offsetWidth;
			 }
			 function getParentPanelHeight() {
				return element.nativeElement.offsetHeight;
			 }
			 function setupTools() {
				parentContainerLink = containerLink.$parent;
				while (parentContainerLink && !parentContainerLink.hasOwnProperty("setTools")) {
				  parentContainerLink = parentContainerLink.$parent;
				}
			 }
			 function gridIsReady(gridid) {
				let localgrid;
				grid = null;
				if (platformGridAPI.grids.exist(gridid)) {
				  localgrid = platformGridAPI.grids.element("id", gridid);
				  if (localgrid.instance && localgrid.dataView) {
					 grid = localgrid;
					 return true;
				  }
				}
				return false;
			 }
			 function deselectAssignmentComponents(isMultiSelect) {
				planningBoardDataService.assignments.forEach((assignment) => {
				  assignment.modificationData.activeFlag = false;
				  if (!isMultiSelect) {
					 assignment.modificationData.selectedFlag = false;
					 assignment.modificationData.areRelated = false;
				  }
				});
			 }
			 function updateAll() {
				zoneRef.runOutsideAngular(() => {
				  resize();
				  updatePlanningBoardCanvasSize();
				});
				update();
			 }
			 function updateAssignmentsFilter(elem2) {
				const pbContainerDiv = findPlanningBoardConatinerElement();
				const pbDivContainsFilterElem = elem2 && pbContainerDiv && pbContainerDiv.length > 0 && pbContainerDiv[0].parentElement.contains(elem2);
				if (pbDivContainsFilterElem) {
				  planningBoardDataService.sharedData.searchString = elem2.value;
				  let filteredAssignments = PlanningBoardUpdateService.updateAssignmentsFilter(elem2.value, Array.from(planningBoardDataService.assignments.values()), planningBoardDataService);
				  filteredAssignments = (0, import_lodash.sortBy)(filteredAssignments, [function(a) {
					 return planningBoardDataService.getAssignmentConfig().mappingService.from(a.originalEntity);
				  }]);
				  const assignmentInitSelect = (0, import_lodash.sortBy)(filteredAssignments, [function(a) {
					 return Math.abs(planningBoardDataService.getDateStart().diff(planningBoardDataService.getAssignmentConfig().mappingService.from(a.originalEntity)));
				  }])[0];
				  planningBoardDataService.getHelperServices().eventHandligSubjectService.onAssignmentFilterUpdateDone$.fire(updateAssignmentsFilter, assignmentInitSelect, filteredAssignments, containerLink.uuid);
				  selectAssignmentOnFilterSelectionChanged(assignmentInitSelect, pbDivContainsFilterElem);
				}
			 }
			 function selectAssignmentOnFilterSelectionChanged(assignmentToSelect, pbDivContainsFilterElem) {
				if (pbDivContainsFilterElem) {
				  const assignmentMappingServ = planningBoardDataService.getAssignmentConfig().mappingService;
				  const supplierDataServ = planningBoardDataService.getSupplierConfig().dataService;
				  deselectAssignmentComponents(false);
				  if (assignmentToSelect) {
					 const selectedInDataService = planningBoardDataService.assignments.get(assignmentMappingServ.id(assignmentToSelect.originalEntity));
					 assignmentToSelect = selectedInDataService || assignmentToSelect;
					 assignmentToSelect.modificationData.activeFlag = true;
					 assignmentToSelect.modificationData.selectedFlag = true;
					 planningBoardDataService.loadVirtualForSelected(assignmentToSelect.originalEntity);
					 planningBoardDataService.getAssignmentConfig().dataService.setSelected(assignmentToSelect.originalEntity);
					 const supplierOfSelected = supplierDataServ.getItemById(assignmentMappingServ.supplier(assignmentToSelect.originalEntity));
					 platformGridAPI.rows.scrollIntoViewByItem(planningBoardDataService.getSupplierConfig().uuid, supplierOfSelected, false);
					 const startDateDefined = assignmentMappingServ.from(assignmentToSelect.originalEntity) instanceof DateExtension;
					 const tickValues = timeaxis.getTickValues();
					 const startDateInRange = startDateDefined && assignmentMappingServ.from(assignmentToSelect.originalEntity).isBetween(tickValues[0], tickValues.at(-1) || tickValues[0]);
					 if (!startDateInRange) {
						planningBoardDataService.calendarSnapToDate(assignmentMappingServ.from(assignmentToSelect.originalEntity));
					 }
				  }
				  const updateStatusData = {
					 assignmentAvailableStatusMatrix: planningBoardDataService.assignmentAvailableStatusMatrix,
					 assignmentArray: layers.assignments.data()[0],
					 layers,
					 draw,
					 dataService: planningBoardDataService
				  };
				  PlanningBoardUpdateService.updateAssignmentStatus(updateStatusData);
				  if (!planningBoardDataService.sharedData.planningBoardMode || planningBoardDataService.sharedData.planningBoardMode.actionType !== "setStatus" && planningBoardDataService.sharedData.planningBoardMode.actionType !== "createAssignment") {
					 draw();
				  }
				}
			 }
			 function update(event, isHighlight) {
				zoneRef.runOutsideAngular(() => {
				  if (event && hasStepChanged(event) || !event) {
					 const supplierCalendars = PlanningBoardCalendarService.getCachedCalendars(planningBoardDataService.getSupplierConfig().uuid);
					 calculatedCurrentSizeY = calculateCurrentSizeY();
					 updateAssignmentStatusItems();
					 updateAssignmentTypeItems();
					 updateScale();
					 updateData();
					 updateAggregations();
					 updateLanes();
					 updateBackgrounds([...supplierCalendars.values()]);
					 updateStatusPanel();
					 updateTimeScaleTicks();
					 updateAssignmentGrouping();
					 draw();
					 if (event && isHighlight) {
						updateHighlightAssignments();
					 }
					 updateDayLinesPosition();
				  }
				});
			 }
			 function updateDayLinesPosition() {
				if (layers.linesAxis) {
				  layers.linesAxis.selectAll(".tick").nodes().forEach((tickElem) => {
					 const parsedTransformAttr2 = tickElem.attributes["transform"].value.slice(tickElem.attributes["transform"].value.indexOf("(") + 1, tickElem.attributes["transform"].value.indexOf(","));
					 tickElem.attributes["transform"].value = `translate(${parsedTransformAttr2}, ${supplierScrollValue})`;
				  });
				  let domainTransformArrt = layers.linesAxis.select(".domain").nodes()[0].attributes["transform"];
				  if (!domainTransformArrt) {
					 domainTransformArrt = layers.linesAxis.select("path.domain").attr("transform", "translate(0, 0)").nodes()[0].attributes["transform"];
				  }
				  const parsedTransformAttr = domainTransformArrt.value.slice(domainTransformArrt.value.indexOf("(") + 1, domainTransformArrt.value.indexOf(","));
				  domainTransformArrt.value = `translate(${parsedTransformAttr}, ${supplierScrollValue})`;
				}
			 }
			 function updateAssignmentStatusItems() {
				planningBoardDataService.assignmentStatusItems = planningBoardDataService.assignmentStatusItems || [];
				if (assignmentComponentItems && assignmentComponentItems.setStatusIconItems) {
				  assignmentComponentItems.setStatusIconItems(planningBoardDataService.assignmentStatusItems);
				}
			 }
			 function updateAssignmentTypeItems() {
				if (assignmentComponentItems) {
				  assignmentComponentItems.setTypeIconItems(planningBoardDataService.assignmentTypeItems || []);
				  tagItems.setTypeIconItems(planningBoardDataService.assignmentTypeItems || []);
				}
			 }
			 function resize() {
				if (!(0, import_lodash.isUndefined)(supplierScale)) {
				  const resizeData = {
					 transY: supplierScale.getHeaderLineHeight() + calculatedCurrentSizeY,
					 calendarlineobject,
					 timeScale,
					 panelWidth,
					 assignmentItems: assignmentComponentItems,
					 assignmentCollections,
					 assignmentGroups,
					 aggregateItems,
					 timeaxis,
					 layers
				  };
				  PlanningBoardUpdateService.resize(resizeData);
				}
				if (gridIsReady(planningBoardDataService.getSupplierConfig().uuid)) {
				  const currentSupplierGridConfig = (0, import_lodash.cloneDeep)(platformGridAPI.grids.getGridState(planningBoardDataService.getSupplierConfig().uuid));
				  currentSupplierGridConfig.rowHeight = planningBoardDataService.getRowHeightFromSettings();
				  platformGridAPI.grids.setOptions(planningBoardDataService.getSupplierConfig().uuid, currentSupplierGridConfig);
				}
			 }
			 function updateStatusPanel() {
				PlanningBoardUpdateService.updateStatusPanel(panelWidth);
			 }
			 function updateScale() {
				const updateScaleData = {
				  dataService: planningBoardDataService,
				  panelWidth,
				  aggregateItems,
				  assignmentCollections,
				  tagItems,
				  timeScale,
				  supplierScale,
				  assignmentItems: assignmentComponentItems
				};
				PlanningBoardUpdateService.updateScale(updateScaleData);
			 }
			 function updateData() {
				if (!(0, import_lodash.isUndefined)(timeaxis)) {
				  const updateDataData = {
					 calendarlineobject,
					 timeaxis,
					 isCalendarDragging,
					 dataService: planningBoardDataService,
					 settingsChanged,
					 assignmentCollections,
					 assignmentAvailableStatusMatrix: planningBoardDataService.assignmentAvailableStatusMatrix,
					 draw,
					 layers,
					 panelWidth,
					 oldAssignmentArray: oldAssignmentArr,
					 visibleSupplierIds: [...supplierScale.getVerticalIndex().keys()]
				  };
				  PlanningBoardUpdateService.updateData(planningBoardDataService.sharedData.searchString, updateDataData);
				  settingsChanged = updateDataData.settingsChanged;
				}
			 }
			 function updateAggregations() {
				if (!(0, import_lodash.isUndefined)(timeaxis)) {
				  const updateAggregationData = {
					 timeaxis,
					 aggregateItems,
					 aggregateSumItems,
					 dataService: planningBoardDataService
				  };
				  PlanningBoardUpdateService.updateAggregations(updateAggregationData);
				}
			 }
			 function updateLanes() {
				if ((0, import_lodash.isObject)(planningBoardDataService.sharedData.verticalIndex)) {
				  const updateLanesData = {
					 verticalIndex: planningBoardDataService.sharedData.verticalIndex,
					 laneLayer,
					 lanesComponent,
					 panelWidth,
					 supplierScrollValue,
					 containerDimensions: containerLink.getCurrentDimensions,
					 supplierScale
				  };
				  PlanningBoardUpdateService.updateLanes(updateLanesData);
				}
			 }
			 function updateBackgrounds(supplierCalendars) {
				if ((0, import_lodash.isObject)(planningBoardDataService.getDateStart)) {
				  const updateBackgroundsData = {
					 backgroundComponent,
					 backgroundLayer,
					 timeScale,
					 supplierScale,
					 parseDecToRgba: PlanningBoardDrawingUtilitiesService.intToRgbColor,
					 bgExceptionDayClickHandler,
					 dataService: planningBoardDataService,
					 supplierScrollValue,
					 supplierCalendars
				  };
				  PlanningBoardUpdateService.updateBackgrounds(updateBackgroundsData);
				  PlanningBoardUpdateService.updateFooterBackground(layers.footerContent, panelWidth, footerHeight);
				}
			 }
			 function updateTimeScaleTicks() {
				const dayLineHeight = planningBoardDataService.sharedData.verticalIndex.size * supplierScale.getLineHeight();
				const updateTicksData = {
				  sizeY: dayLineHeight,
				  supplierScale,
				  timeScale,
				  timeaxis
				};
				dayLinesAxis = PlanningBoardUpdateService.updateTimeScaleTicks(updateTicksData);
				updateTicksData.sizeY = footerHeight;
				footerDayLinesAxis = PlanningBoardUpdateService.updateTimeScaleTicks(updateTicksData);
			 }
			 function updatePlanningBoardCanvasSize() {
				let heightCorrection = 0;
				switch (planningBoardDataService.sharedData.activeSearchMode) {
				  case "columnSearch":
					 heightCorrection = 33;
					 break;
				  case "searchBoth":
					 heightCorrection = 27;
					 break;
				  default:
					 heightCorrection = 0;
					 break;
				}
				const updateCanvasData = {
				  curDimensionHeight: containerLink.getCurrentDimensions().height - heightCorrection,
				  viewPort,
				  pBoardCanvas,
				  dragSel,
				  footerContent: layers.footerContent
				};
				PlanningBoardUpdateService.updatePlanningBoardCanvasSize(updateCanvasData);
				const pbContainerDiv = findPlanningBoardConatinerElement();
				if (pbContainerDiv && pbContainerDiv.length > 0) {
				  const filterInputElem = pbContainerDiv[0].parentElement.querySelector(".filterInput");
				  if (filterInputElem) {
					 filterInputElem.style.width = panelWidth - 66 + "px";
				  }
				}
				updateScale();
			 }
			 function updatePanelWidthDependencies() {
				PlanningBoardUpdateService.updatePanelWidthDependencies(layers, panelWidth);
			 }
			 function updateHighlightAssignments() {
				const updateHighlightAssignmentData = {
				  layers,
				  dataService: planningBoardDataService
				};
				PlanningBoardUpdateService.updateHighlightAssignments(updateHighlightAssignmentData);
			 }
			 function draw() {
				const sizeY = calculatedCurrentSizeY + supplierScale.getHeaderLineHeight();
				let transXH2 = 25;
				let transXH3 = 15;
				let hourDiff;
				processFromAndToAfterShift(planningBoardDataService.assignments, planningBoardDataService.getAssignmentConfig().mappingService);
				layers.headerContent.call(timeaxis);
				calendarlineobject.setHeight(calculatedCurrentSizeY + supplierScale.getHeaderLineHeight() + calculatedCurrentSizeY / 4);
				calendarlineobject.setOffset(supplierScrollValue - calculatedCurrentSizeY / 4);
				layers.calendarLine.call(calendarlineobject);
				if (planningBoardDataService.getDateEnd) {
				  const tickStart = new DateExtension(planningBoardDataService.getDateStart());
				  const tickEnd = new DateExtension(planningBoardDataService.getDateEnd());
				  hourDiff = tickEnd.diff(tickStart, "hour");
				  if (hourDiff < 36) {
					 transXH3 = 25;
				  }
				  if (hourDiff < 48) {
					 transXH2 = 35;
				  }
				}
				layers.linesAxis.call(dayLinesAxis);
				layers.linesAxis.attr("transform", "translate(0, " + sizeY + ")");
				if (planningBoardDataService.showSumAggregations()) {
				  layers.footerLinesAxis.call(footerDayLinesAxis);
				} else {
				  layers.footerContent.select("rect.footer-background").attr("height", 0);
				  layers.footerLinesAxis.selectAll("*").remove();
				}
				if (planningBoardDataService.sharedData.planningBoardMode.actionType !== "grouping") {
				  layers.assignments.call(assignmentComponentItems);
				  if (planningBoardDataService.useTaggingSystem()) {
					 layers.assignmentTags.call(tagItems);
				  } else {
					 layers.assignmentTags.selectAll("*").remove();
				  }
				  layers.assignments.call(assignmentCollections);
				  layers.assignmentGroups.selectAll("*").remove();
				  layers.assignmentGroupMaxLoadLine.selectAll("*").remove();
				} else {
				  layers.assignmentTags.selectAll("*").remove();
				  layers.assignmentBaseContainer.selectAll("*").remove();
				  layers.assignments.selectAll("g.assignment-item").remove();
				  layers.assignments.selectAll("g.collection").remove();
				  layers.assignmentGroups.call(assignmentGroups);
				  layers.assignmentGroupMaxLoadLine.call(assignmentMaxLoadLines);
				}
				if (planningBoardDataService.showAggregations()) {
				  layers.aggregationContainer.call(aggregateItems);
				} else {
				  layers.aggregationContainer.selectAll("g.aggregation").remove();
				}
				if (planningBoardDataService.showSumAggregations()) {
				  layers.aggregationSumContainer.call(aggregateSumItems);
				} else {
				  layers.aggregationSumContainer.selectAll("g.aggregation").remove();
				}
			 }
			 let toolTipTimeOut;
			 function removeToolTip() {
				bgPreviewLayer.selectAll("*").remove();
				hePreviewLayer.selectAll("*").remove();
			 }
			 function removeIndicators() {
				layers.assignments.selectAll(".indicator-area").remove();
				platformDragdropService.mouseLeaveTarget({});
				if (demandInfo && demandInfo.validationData.isValid && demandInfo.modificationData.isDragging) {
				  layers.assignmentBaseContainer.selectAll("rect.base-assignment").remove();
				  demandInfo.validationData.isValid = false;
				}
			 }
			 function bgExceptionDayClickHandler(event, day) {
				exceptionDayClickHandler(bgPreviewLayer, verticalScrollOffset, day, event);
			 }
			 function needRemoveTooltip(day) {
				if (day) {
				  let needTooltipRemove = lastClickedDay !== day || day.type === "today";
				  if (!needTooltipRemove) {
					 needTooltipRemove = toolTipBackgroundComponent.getDay().day && day.day && toolTipBackgroundComponent.getDay().day.isSame(day.day);
				  }
				  return needTooltipRemove;
				}
				return false;
			 }
			 function exceptionDayClickHandler(layer, offset, day, event) {
				const canEditCalendar = planningBoardDataService.getAssignmentConfig().mappingService.canEditCalendar && planningBoardDataService.getAssignmentConfig().mappingService.canEditCalendar();
				if (!canEditCalendar || needRemoveTooltip(day)) {
				  removeToolTip();
				}
				if (day) {
				  planningBoardDataService.assignmentDataService.setSelected(null, []);
				  deselectAssignmentComponents(false);
				  update(event);
				  lastClickedDay = day;
				  if (day.day.toDate) {
					 day.day = day.day.toDate();
				  }
				  let infoMsg = day.day.toLocaleDateString("en-GB");
				  infoMsg += day.info ? " - " + day.info : "";
				  toolTipBackgroundComponent = PlanningBoardTooltipBackgroundComponent.toolTipBackground().setTimeScale(timeScale).setOffset(offset).setDay(day).setInfoMsg(infoMsg);
				  if (canEditCalendar) {
					 toolTipBackgroundComponent.setOnDblClickFn(() => {
						PlanningBoardCalendarService.openCalendarDayEditDialog(day, planningBoardDataService);
						removeToolTip();
					 });
				  }
				  layer.call(toolTipBackgroundComponent, event);
				  clearTimeout(toolTipTimeOut);
				  toolTipTimeOut = setTimeout(removeToolTip, 1500);
				}
			 }
			 function validateDraggingDemand(draggingDemand, offsetY) {
				const demandMappingService = planningBoardDataService.getDemandConfig().mappingService;
				const supplierId = supplierScale.supplierIdForYpx(offsetY + supplierScrollValue);
				const pbGridDefaultSettingValue = planningBoardDataService.gridSettings.validateDemandAgainstSuppliers instanceof Function && planningBoardDataService.gridSettings.validateDemandAgainstSuppliers();
				const validationResultDragging = planningBoardDataService.getHelperServices().validationService.validateEntityAgainstSupplier(draggingDemand, "demand", supplierId, pbGridDefaultSettingValue);
				let dragText = translate2.instant("platform.planningboard.missingSkill") + ": ";
				if (validationResultDragging.invalidItems && validationResultDragging.invalidItems.length > 0) {
				  (0, import_lodash.forEach)(validationResultDragging.invalidItems, (val) => {
					 const demandPropsMap = val;
					 dragText += demandPropsMap.DescriptionInfo.Description + ", ";
				  });
				  dragText = dragText.slice(0, -2);
				} else {
				  if (demandMappingService.description(draggingDemand)) {
					 dragText = demandMappingService.description(draggingDemand);
				  } else if (demandMappingService.code) {
					 dragText = demandMappingService.code(draggingDemand);
				  }
				}
				platformDragdropService.setDraggedText(dragText);
				if (firstMouseEnter) {
				  drawIndicatorArea(draggingDemand);
				}
				return validationResultDragging.isValid;
			 }
			 function drawIndicatorArea(draggingDemand) {
				const visibleSuppliers = platformGridAPI.grids.element("id", planningBoardDataService.getSupplierConfig().uuid).dataView.getItems();
				let validSupplierList = planningBoardDataService.getHelperServices().validationService.validateSelectedAgainstList(draggingDemand, visibleSuppliers, "demand", "supplier");
				const supplierMapService = planningBoardDataService.getSupplierConfig().mappingService;
				indicatorAreaComponent.setStartDate(planningBoardDataService.getDateStart()).setEndDate(planningBoardDataService.getDateEnd()).setIndicatorY(false);
				const invalidSupplierList = [...(0, import_lodash.difference)(visibleSuppliers, validSupplierList).values()];
				const idMapFn = supplierMapService.actualId || supplierMapService.id;
				(0, import_lodash.forEach)(invalidSupplierList, (invalidSupplier) => {
				  const validationResultDemand = planningBoardDataService.getHelperServices().validationService.validateEntityAgainstSupplier(draggingDemand, "demand", idMapFn(invalidSupplier));
				  if (!(0, import_lodash.isUndefined)(validationResultDemand.invalidItems) && validationResultDemand.invalidItems.length > 0) {
					 const mandatoryIndex = (0, import_lodash.findIndex)(validationResultDemand.invalidItems, function(result) {
						const isMandatoryFn = planningBoardDataService.getSupplierConfig().mappingService.isMandatory;
						return isMandatoryFn && isMandatoryFn(result);
					 });
					 if (mandatoryIndex > -1 && supplierMapService.indicationAreaType) {
						supplierMapService.indicationAreaType(invalidSupplier, "error");
					 }
				  }
				});
				const arraySupIds = [];
				platformGridAPI.grids.element("id", planningBoardDataService.getSupplierConfig().uuid).instance.getRenderedRowIds().forEach((id3) => {
				  arraySupIds.push(platformGridAPI.grids.element("id", planningBoardDataService.getSupplierConfig().uuid).dataView.getItemByIdx(id3).Id);
				});
				validSupplierList = validSupplierList.filter((validSupplier) => arraySupIds.includes(supplierMapService.actualId(validSupplier) || supplierMapService.id(validSupplier)));
				(0, import_lodash.forEach)(validSupplierList, function(validSupplier) {
				  const validationResultDemand = planningBoardDataService.getHelperServices().validationService.validateEntityAgainstSupplier(draggingDemand, "demand", idMapFn(validSupplier));
				  if (!(0, import_lodash.isUndefined)(validationResultDemand.invalidItems) && validationResultDemand.invalidItems.length > 0 && supplierMapService.indicationAreaType) {
					 supplierMapService.indicationAreaType(validSupplier, "warning");
					 invalidSupplierList.push(validSupplier);
				  }
				});
				indicatorAreas = layers.assignments.selectAll(".indicator-area").data(invalidSupplierList);
				indicatorAreas.call(indicatorAreaComponent);
			 }
			 function resetIndicatorArea() {
				const indicatorAreas2 = layers.assignments.selectAll(".indicator-area").data([]);
				indicatorAreas2.call(indicatorAreaComponent);
			 }
			 function _createAssignment(creationData) {
				layers.assignmentBaseContainer.selectAll("rect.base-assignment").remove();
				const supplierOffsetY = creationData.offsetY || creationData.info && creationData.info.event.offsetY || 0;
				const supplierId = supplierScale.supplierIdForYpx(supplierOffsetY + supplierScrollValue);
				if (supplierId > 0) {
				  const demandMapService = planningBoardDataService.getDemandConfig().mappingService;
				  let demands = [];
				  if (demandMapService.getDemandList) {
					 demands = demandMapService.getDemandList(creationData.demand);
				  } else {
					 demands.push(creationData.demand);
				  }
				  if ((0, import_lodash.isNull)(creationData.from)) {
					 const offsetX = creationData.offsetX || creationData.info && creationData.info.event.offsetX || 0;
					 creationData.from = new DateExtension(timeScale.invert(offsetX));
				  }
				  if ((0, import_lodash.isNull)(creationData.from) && planningBoardDataService.useDemandTimesForReservation()) {
					 planningBoardDataService.calendarSnapToDate(creationData.from);
				  }
				  const dsModeToolsFromContainer = containerLink.dateShiftModeTools = planningBoardDataService.sharedData.dateShiftModeTools;
				  const dsModeTools = planningBoardDataService.getDateshiftConfig() && dsModeToolsFromContainer.length > 0 && dsModeToolsFromContainer[0].list ? dsModeToolsFromContainer[0].list : null;
				  const originalDSMode = dsModeTools ? dsModeTools.activeValue : null;
				  if (planningBoardDataService.getDateshiftConfig() && dsModeTools) {
					 const foundTool = dsModeTools.items.find((tool) => tool.value === "fullPush");
					 if (foundTool && foundTool.fn) {
						foundTool.fn();
					 }
				  }
				  planningBoardDataService.createAssignment(demands, supplierId, creationData).then((result) => {
					 if (planningBoardDataService.getDateshiftConfig() && !!originalDSMode && dsModeTools) {
						const foundTool = dsModeTools.items.find((tool) => tool.value === originalDSMode);
						if (foundTool && foundTool.fn) {
						  foundTool.fn();
						}
					 }
					 update();
				  });
				}
			 }
			 function _getSelectedDemand() {
				let selectedDemand = platformGridAPI.rows.selection({
				  gridId: planningBoardDataService.getDemandConfig().uuid
				});
				if ((0, import_lodash.isUndefined)(selectedDemand)) {
				  const timer2 = 3e3;
				  const message2 = PlanningBoardExternalServices.PlatformTranslateService.instant("platform.planningboard.selectDemandMsg");
				  showToastMessage(message2, timer2);
				}
				return selectedDemand;
			 }
			 function showToastMessage(message2, timer2 = 3e3) {
				const toastTemplate = `
					<div class="alarm-overlay ds-message">
						<div class="alert" role="alert" style="text-align:center">
							${message2}
							<p class="timer">(${timer2 / 1e3}s)</p>
						</div>
					</div>
					`;
				let toastElem = new DOMParser().parseFromString(toastTemplate, "text/html").getElementsByClassName("alarm-overlay")[0];
				let timerElem = toastElem.getElementsByClassName("timer")[0];
				let activeElem = document.getElementsByTagName("body")[0];
				activeElem.appendChild(toastElem);
				let timerInterval = setInterval(() => {
				  timer2 -= 1e3;
				  timerElem.innerHTML = `(${timer2 / 1e3}s)`;
				}, 1e3);
				setTimeout(() => {
				  clearInterval(timerInterval);
				  toastElem.remove();
				}, timer2);
			 }
			 function openAssignmentPopup(assignment, event) {
				const assignmentMapServ = planningBoardDataService.getAssignmentConfig().mappingService;
				const supplierMapServ = planningBoardDataService.getSupplierConfig().mappingService;
				const demandMapServ = planningBoardDataService.getDemandConfig() ? planningBoardDataService.getDemandConfig().mappingService : null;
				let dataForPopUp = {
				  pbPopup: {
					 headline: translate2.instant("platform.planningboard.assignment") + " - " + assignmentMapServ.description(assignment.originalEntity),
					 from: new DateExtension(assignmentMapServ.from(assignment.originalEntity)).format("MMM dd yyyy, HH:mm"),
					 to: new DateExtension(assignmentMapServ.to(assignment.originalEntity)).format("MMM dd yyyy, HH:mm"),
					 items: []
				  },
				  isSumAggrigationPopup: false
				};
				createTextLine(assignment, planningBoardDataService.showMainText(), planningBoardDataService.mainInfoLabel(), true, assignmentMapServ, dataForPopUp);
				createTextLine(assignment, planningBoardDataService.showInfo1Text(), planningBoardDataService.info1Label(), false, assignmentMapServ, dataForPopUp);
				createTextLine(assignment, planningBoardDataService.showInfo2Text(), planningBoardDataService.info2Label(), false, assignmentMapServ, dataForPopUp);
				createTextLine(assignment, planningBoardDataService.showInfo3Text(), planningBoardDataService.info3Label(), false, assignmentMapServ, dataForPopUp);
				(0, import_lodash.forEach)(planningBoardDataService.tagConfig(), function(tag) {
				  let projectColor = 0;
				  let projectColorStr = "0";
				  let validationColor = "";
				  let ppsHeaderColor = 0;
				  let ppsHeaderColorStr = "0";
				  if (tag.visible) {
					 switch (tag.id) {
						case "project":
						  projectColor = assignmentMapServ.headerColor(assignment.originalEntity);
						  if ((0, import_lodash.isNumber)(projectColor)) {
							 projectColorStr = rainbow_default(projectColor);
						  } else {
							 projectColorStr = PlanningBoardDrawingUtilitiesService.intToRgbColor(+tag.color).toString();
						  }
						  dataForPopUp.pbPopup.items.push({
							 "color": projectColorStr,
							 "label": tag.name,
							 "value": (0, import_lodash.isFunction)(assignmentMapServ.projectName) ? assignmentMapServ.projectName(assignment.originalEntity) : ""
						  });
						  break;
						case "status":
						  if (assignmentMapServ.status) {
							 const statusId = assignmentMapServ.status(assignment.originalEntity);
							 if (statusId) {
								let statusColor = "";
								let statusDescription = "";
								planningBoardDataService.assignmentStatusItems.forEach((asi) => {
								  if (asi.Id === statusId && asi.BackgroundColor) {
									 statusColor = PlanningBoardDrawingUtilitiesService.intToRgbColor(asi.BackgroundColor).toString();
								  }
								  if (statusColor === "" && tag.color) {
									 statusColor = PlanningBoardDrawingUtilitiesService.intToRgbColor(+tag.color).toString();
								  }
								  if (asi.Id === statusId && asi.Description) {
									 statusDescription = asi.Description;
								  }
								});
								const statusLabel = translate2.instant("platform.planningboard.status");
								dataForPopUp.pbPopup.items.push({
								  "color": statusColor,
								  "label": statusLabel,
								  "value": statusDescription
								});
							 }
						  }
						  break;
						case "type":
						  if (assignmentMapServ.type) {
							 const typeId = assignmentMapServ.type(assignment.originalEntity);
							 if (typeId) {
								let typeColor = "";
								let typeDescription = "";
								let typeColorRGBAString = "";
								planningBoardDataService.assignmentTypeItems.forEach((ati) => {
								  if (ati.Id === typeId && ati.BackgroundColor) {
									 typeColorRGBAString = PlanningBoardDrawingUtilitiesService.intToRgbColor(ati.BackgroundColor).toString();
								  }
								  if (typeColor === "" && tag.color) {
									 typeColorRGBAString = PlanningBoardDrawingUtilitiesService.intToRgbColor(+tag.color).toString();
								  }
								  if (ati.Id === typeId && ati.Description) {
									 typeDescription = ati.Description;
								  }
								});
								const typeLabel = translate2.instant("platform.planningboard.type");
								dataForPopUp.pbPopup.items.push({
								  "color": typeColorRGBAString,
								  "label": typeLabel,
								  "value": typeDescription
								});
							 }
						  }
						  break;
						case "validation":
						  validationColor = "";
						  if (assignment.validationData.isValid && assignment.validationData.invalidItems.length > 0) {
							 validationColor = "rgb(205,133,25)";
						  } else if (assignment.validationData.isValid) {
							 validationColor = "rgb(66,205,25)";
						  } else {
							 validationColor = "rgb(201,34,34)";
						  }
						  dataForPopUp.pbPopup.items.push({
							 "color": validationColor,
							 "label": tag.name
						  });
						  if (assignment.validationData.invalidItems.length > 0 && demandMapServ) {
							 let itemColor = "";
							 (0, import_lodash.forEach)(assignment.validationData.invalidItems, (itemId) => {
								let demandById = planningBoardDataService.demands.find((demand) => demandMapServ.id(demand.originalEntity) === itemId);
								if (demandById && supplierMapServ.isMandatory && supplierMapServ.isMandatory(demandById.originalEntity)) {
								  itemColor = "rgb(201,34,34)";
								} else {
								  itemColor = "rgb(205,133,25)";
								}
								dataForPopUp.pbPopup.items.push({
								  "color": itemColor,
								  "label": supplierMapServ.description && demandById ? supplierMapServ.description(demandById.originalEntity) : ""
								});
							 });
						  }
						  break;
						case "ppsHeader":
						  if (assignmentMapServ.ppsHeaderColor && assignmentMapServ.ppsHeaderColor(assignment.originalEntity)) {
							 ppsHeaderColor = assignmentMapServ.ppsHeaderColor(assignment.originalEntity);
							 if ((0, import_lodash.isNumber)(ppsHeaderColor)) {
								const ppsHeaderColorRBGA = PlanningBoardDrawingUtilitiesService.intToRgbColor(ppsHeaderColor);
								ppsHeaderColorStr = "rgba(" + ppsHeaderColorRBGA.r + "," + ppsHeaderColorRBGA.g + "," + ppsHeaderColorRBGA.b + "," + ppsHeaderColorRBGA.opacity + ")";
							 }
							 dataForPopUp.pbPopup.items.push({
								"color": ppsHeaderColorStr,
								"label": tag.name
							 });
						  }
						  break;
						default:
						  dataForPopUp.pbPopup.items.push({
							 "label": tag.name,
							 "value": ""
						  });
						  break;
					 }
				  }
				});
				const dialogClickPosition = setDialogClickPosition(event);
				if (!(0, import_lodash.isUndefined)(containerLink.$apply)) {
				  dataForPopUp = Object.assign(containerLink, dataForPopUp);
				}
				const popupOptions = {
				  scope: dataForPopUp,
				  hasDefaultWidth: false,
				  templateUrl: PlatformConfigurationService.appBaseUrl + "app/components/planningboard/partials/platform-planning-board-popup-partial.html",
				  focusedElement: dialogClickPosition,
				  plainMode: true
				};
				if (!(0, import_lodash.isUndefined)(popupInstance)) {
				  popupInstance.close();
				}
				if (!timerRunning) {
				  timerRunning = true;
				  canOpenTimeout = $timeout(() => {
					 canOpen = true;
					 timerRunning = false;
				  }, 200);
				}
				if (canOpen) {
				  popupInstance = basicsLookupdataPopupService.showPopup(popupOptions);
				  canOpen = false;
				}
				popupInstance.opened.then((instance) => {
				  const el = document.querySelector(".popup-container");
				  if (el !== null) {
					 el.style.margin = "3px";
				  }
				  if (isDoubleClick) {
					 instance.close();
				  }
				});
			 }
			 function createTextLine(assignment, isShowText, property, isMainLabel, assignmentMapServ, dataForPopUp) {
				if (planningBoardDataService.showInfo3Text() && planningBoardDataService.info3Label() !== "") {
				  const infoForTextLine = {
					 property,
					 assignmentOriginal: assignment.originalEntity,
					 mapService: assignmentMapServ,
					 basicsUnitLookupDataService,
					 isMainInfoLabel: isMainLabel
				  };
				  if (PlanningBoardUpdateService.isJson(property)) {
					 dataForPopUp.pbPopup.items.push({
						"label": PlanningBoardTextLineComponent.textLine(infoForTextLine),
						"value": ""
					 });
				  } else {
					 dataForPopUp.pbPopup.items.push({
						"label": (0, import_lodash.get)(assignment.originalEntity, property),
						"value": ""
					 });
				  }
				}
			 }
			 function openAggregationPopup(aggregationItem, event) {
				function getAggregationTextLine(lineConfig, pbPopupItems, mapService2) {
				  if (typeof lineConfig.value === "string" && lineConfig.value !== "") {
					 const getSumAggregationLineCaption = lineConfig.caption;
					 const getSumAggregationLineId = lineConfig.id;
					 const sumAggregationLineProp = getAggregationPopupProperties(getSumAggregationLineCaption, getSumAggregationLineId);
					 pbPopupItems.push({
						"label": sumAggregationLineProp.caption,
						"value": "" + planningBoardDataService.getHelperServices().aggregationService.getAggregationValue(aggregationItem, lineConfig.value)
					 });
				  }
				}
				let dataForPopUp = {
				  pbPopup: {
					 headline: translate2.instant("platform.planningboard.aggregation"),
					 from: new DateExtension(aggregationItem.startDate).format("MMM dd yyyy"),
					 to: new DateExtension(aggregationItem.endDate).format("MMM dd yyyy"),
					 items: []
				  },
				  isSumAggrigationPopup: true
				};
				const mapService = planningBoardDataService.getAssignmentConfig().mappingService;
				if (!(0, import_lodash.isFunction)(mapService.aggregateType)) {
				  dataForPopUp.pbPopup.items = [];
				  getAggregationTextLine(planningBoardDataService.sumAggregationLine1(), dataForPopUp.pbPopup.items, mapService);
				  getAggregationTextLine(planningBoardDataService.sumAggregationLine2(), dataForPopUp.pbPopup.items, mapService);
				  getAggregationTextLine(planningBoardDataService.sumAggregationLine3(), dataForPopUp.pbPopup.items, mapService);
				} else {
				  if (aggregationItem.aggregates && aggregationItem.aggregates.length > 0) {
					 dataForPopUp.pbPopup.items = [];
				  }
				  (0, import_lodash.forEach)(aggregationItem.aggregates, (aggregate) => {
					 const itemFromAggregate = {
						label: "" + aggregate.reference,
						value: (aggregate.sum / aggregate.displayFactor).toFixed(2) + " " + aggregate.uomDescription
					 };
					 dataForPopUp.pbPopup.items.push(itemFromAggregate);
					 if (aggregationItem.sum !== null && aggregate.sum > 0) {
						const sumItemFromAggragate = {
						  label: "",
						  value: ""
						};
						dataForPopUp.pbPopup.sumItem = sumItemFromAggragate;
						dataForPopUp.pbPopup.sumItem.label = translate2.instant("platform.planningboard.total");
						dataForPopUp.pbPopup.sumItem.value = (aggregationItem.sum / aggregationItem.displayFactor).toFixed(2) + " " + aggregationItem.uomDescription;
					 }
				  });
				}
				const dialogClickPosition = setDialogClickPosition(event);
				dataForPopUp.isSumAggrigationPopup = true;
				if (!(0, import_lodash.isUndefined)(containerLink.$apply)) {
				  dataForPopUp = Object.assign(containerLink, dataForPopUp);
				}
				const popupOptions = {
				  scope: dataForPopUp,
				  hasDefaultWidth: false,
				  templateUrl: PlatformConfigurationService.appBaseUrl + "app/components/planningboard/partials/platform-planning-board-popup-partial.html",
				  focusedElement: dialogClickPosition,
				  plainMode: true
				};
				if (!(0, import_lodash.isUndefined)(popupInstance)) {
				  popupInstance.close();
				}
				popupInstance = basicsLookupdataPopupService.showPopup(popupOptions);
			 }
			 function getAggregationPopupProperties(columnName, id3) {
				const mapServ = planningBoardDataService.getAssignmentConfig().mappingService;
				const getAssignmentModalFormConfig = mapServ.getAssignmentModalFormConfig && mapServ.getAssignmentModalFormConfig();
				if (getAssignmentModalFormConfig && getAssignmentModalFormConfig.rows) {
				  const translationInfo = getAssignmentModalFormConfig.rows;
				  const translationFallbackString = translationInfo ? translationInfo.find((info) => info.model === id3) : null;
				  const translationFallback = translationFallbackString ? translate2.instant(translationFallbackString.label$tr$) : "";
				  return {
					 value: columnName,
					 id: columnName,
					 caption: translationFallback || columnName
				  };
				} else {
				  return {
					 value: columnName,
					 id: columnName,
					 caption: columnName
				  };
				}
			 }
			 function setDialogClickPosition(event) {
				const pbContainingDiv = findPlanningBoardConatinerElement();
				if (pbContainingDiv.length > 0) {
				  const dialogClickPosition = $(pbContainingDiv[0]).find(".dialog-click-position");
				  if (dialogClickPosition) {
					 dialogClickPosition.remove();
				  }
				  const generatedDialogClickPosition = $(`<div class="dialog-click-position" style="pointer-events: none; position: absolute; top: ${event.offsetY}px; left: ${event.offsetX}px; height: 1px; width: 1px;"></div>`);
				  $(pbContainingDiv[0]).find(".planningboardCanvas").append(generatedDialogClickPosition);
				  return generatedDialogClickPosition;
				}
				return null;
			 }
			 function addEventListenerToHeader() {
				element.nativeElement.querySelector(".headerContent").addEventListener("click", (event) => {
				  if (planningBoardDataService.sharedData.planningBoardMode.actionType === "setStatus") {
					 const dateByEventOffset = DateExtension.utc(new DateExtension(timeScale.invert(event.offsetX)));
					 const assignmnetMappingService = planningBoardDataService.getAssignmentConfig().mappingService;
					 let endBound = new DateExtension(dateByEventOffset).endOf("hour");
					 let startBound = new DateExtension(dateByEventOffset).startOf("hour");
					 timeaxis.getTickValues().forEach((tick, index) => {
						if (index > 0 && dateByEventOffset.isBetween(timeaxis.getTickValues()[index - 1], tick)) {
						  startBound = DateExtension.utc(new DateExtension(timeaxis.getTickValues()[index - 1]));
						  endBound = DateExtension.utc(new DateExtension(tick));
						}
					 });
					 if (planningBoardDataService.assignments.size > 0) {
						const assignmentsArray = Array.from(planningBoardDataService.assignments.values());
						const assignmentsInBounds = assignmentsArray.filter((assignment) => !assignment.modificationData.Disabled && assignmnetMappingService.from(assignment.originalEntity).isBefore(endBound) && assignmnetMappingService.to(assignment.originalEntity).isAfter(startBound));
						assignmentsInBounds.forEach((assignmentItem) => {
						  setAssignmentStatusChanged(assignmentItem);
						});
					 }
					 draw();
				  }
				});
			 }
			 function hasStepChanged(event) {
				const currentX = event.x;
				const currentY = event.y;
				const stepX = timeScale(DateExtension.utc(new DateExtension(planningBoardDataService.getDateStart()).add(planningBoardDataService.getTimeScaleHoursX(), "hour")));
				const offsetX = startDragX - currentX;
				const stepCountX = Math.abs(offsetX) / stepX;
				const offsetY = startDragY - currentY;
				if (stepCountX > 0 && stepCountX !== lastAmountOfStepsX || offsetY !== 0) {
				  startDragX = currentX;
				  lastAmountOfStepsX = stepCountX;
				  startDragY = currentY;
				  return true;
				} else {
				  return false;
				}
			 }
			 function calculateCurrentSizeY() {
				return planningBoardDataService.sharedData.verticalIndex.size * planningBoardDataService.rowHeight() < containerLink.getCurrentDimensions().height ? planningBoardDataService.sharedData.verticalIndex.size * planningBoardDataService.rowHeight() : containerLink.getCurrentDimensions().height;
			 }
			 function setAssignmentStatusChanged(assignmentItem) {
				const assignmnetMappingService = planningBoardDataService.getAssignmentConfig().mappingService;
				if (planningBoardDataService.sharedData.planningBoardMode.id) {
				  let toStatusId = +planningBoardDataService.sharedData.planningBoardMode.id.split("_")[1];
				  let assignmentKeys = new Map(Object.entries(assignmentItem.originalEntity));
				  const assignmentStatus = assignmentKeys.get(assignmnetMappingService.statusKey());
				  if ((0, import_lodash.isNull)(assignmentItem.statusData.originalStatusFrom)) {
					 assignmentItem.statusData.originalStatusFrom = assignmentStatus;
				  }
				  if (assignmentStatus === toStatusId) {
					 toStatusId = assignmentItem.statusData.originalStatusFrom;
				  }
				  planningBoardDataService.updateAssignment(assignmentItem);
				  assignmentKeys.set(assignmnetMappingService.statusKey(), toStatusId);
				  PlanningBoardStatusService.setAssignmentStatusChanged(assignmentItem, toStatusId, assignmnetMappingService);
				}
			 }
			 function getAdditionalHeight() {
				let phHeight = 0;
				switch (planningBoardDataService.sharedData.activeSearchMode) {
				  case "columnSearch":
					 phHeight = 6;
					 break;
				  case "searchBoth":
					 phHeight = 30;
					 break;
				  default:
					 phHeight = 36;
					 break;
				}
				return phHeight;
			 }
		  }
		  static {
			 this.\u0275fac = function PlanningBoardMainComponent_Factory(t) {
				return new (t || _PlanningBoardMainComponent)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(NgZone));
			 };
		  }
		  static {
			 this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _PlanningBoardMainComponent, selectors: [["app-planning-board-main"]], inputs: { containerLink: "containerLink" }, standalone: true, features: [\u0275\u0275ProvidersFeature([
				PlanningBoardEditAssignmentDialogComponent
			 ]), \u0275\u0275StandaloneFeature], decls: 31, vars: 0, consts: [[1, "chart", "planningboard", "widthheight100"], [1, "viewport", "widthheight100", "hiddenOverflow"], [1, "planningboardCanvas", 2, "height", "100%", "width", "100%"], [1, "planningboard", 2, "height", "100%", "width", "100%"], [1, "scrollContent"], [1, "calendarLine"], [1, "dayLinesAxis"], [1, "lanes"], [1, "background"], [1, "assignments"], [1, "tag-container"], [1, "collection-container"], [1, "assignment-preview-container"], [1, "assignment-grouping"], [1, "assignment-group-container"], [1, "assignment-group-max-load-indicator-container"], [1, "aggregation-container"], [1, "assignment-tooltip-container"], [1, "scPreview"], [1, "headerContent"], [1, "header", "header-light-grey"], [1, "header", "header-white"], [1, "headerTopAxis"], [1, "headerMiddleAxis"], [1, "headerBottomAxis"], [1, "hcPreview"], [1, "footer-content"], [1, "footer-background"], [1, "aggregation-sum-container"], [1, "dayLinesAxis", 2, "transform", "translate(0, -17px)"], ["id", "statusPanel", 1, "statusPanel"]], template: function PlanningBoardMainComponent_Template(rf, ctx) {
				if (rf & 1) {
				  \u0275\u0275elementStart(0, "div", 0)(1, "div", 1)(2, "div", 2);
				  \u0275\u0275namespaceSVG();
				  \u0275\u0275elementStart(3, "svg", 3)(4, "g", 4);
				  \u0275\u0275element(5, "g", 5)(6, "g", 6)(7, "g", 7)(8, "g", 8);
				  \u0275\u0275elementStart(9, "g", 9);
				  \u0275\u0275element(10, "g", 10)(11, "g", 11);
				  \u0275\u0275elementEnd();
				  \u0275\u0275element(12, "g", 12);
				  \u0275\u0275elementStart(13, "g", 13);
				  \u0275\u0275element(14, "g", 14)(15, "g", 15);
				  \u0275\u0275elementEnd();
				  \u0275\u0275element(16, "g", 16)(17, "g", 17)(18, "g", 18);
				  \u0275\u0275elementEnd();
				  \u0275\u0275elementStart(19, "g", 19);
				  \u0275\u0275element(20, "rect", 20)(21, "rect", 21)(22, "g", 22)(23, "g", 23)(24, "g", 24)(25, "g", 25);
				  \u0275\u0275elementEnd();
				  \u0275\u0275elementStart(26, "g", 26);
				  \u0275\u0275element(27, "rect", 27)(28, "g", 28)(29, "g", 29);
				  \u0275\u0275elementEnd()();
				  \u0275\u0275namespaceHTML();
				  \u0275\u0275element(30, "div", 30);
				  \u0275\u0275elementEnd()()();
				}
			 } });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlanningBoardMainComponent, [{
			 type: Component,
			 args: [{ standalone: true, selector: "app-planning-board-main", providers: [
				PlanningBoardEditAssignmentDialogComponent
			 ], template: '<div class="chart planningboard widthheight100">\r\n	<div class="viewport widthheight100 hiddenOverflow">\r\n		<div class="planningboardCanvas" style="height: 100%; width: 100%;">\r\n			<svg class="planningboard" style="height: 100%; width: 100%;">\r\n				<g class="scrollContent">\r\n					<g class="calendarLine"></g>\r\n					<g class="dayLinesAxis"></g>\r\n					<g class="lanes"></g>\r\n					<g class="background"></g>\r\n					<g class="assignments">\r\n						<g class="tag-container"></g>\r\n						<g class="collection-container"></g>\r\n					</g>\r\n					<g class="assignment-preview-container"></g>\r\n					<g class="assignment-grouping">\r\n						<g class="assignment-group-container"></g>\r\n						<g class="assignment-group-max-load-indicator-container"></g>\r\n					</g>\r\n					<g class="aggregation-container"></g>\r\n					<g class="assignment-tooltip-container"></g>\r\n					<g class="scPreview"></g>\r\n				</g>\r\n				<g class="headerContent">\r\n					<rect class="header header-light-grey"></rect>\r\n					<rect class="header header-white"></rect>\r\n					<g class="headerTopAxis"></g>\r\n					<g class="headerMiddleAxis"></g>\r\n					<g class="headerBottomAxis"></g>\r\n					<g class="hcPreview"></g>\r\n				</g>\r\n				<g class="footer-content">\r\n					<rect class="footer-background"></rect>\r\n					<g class="aggregation-sum-container"></g>\r\n					<g class="dayLinesAxis" style="transform: translate(0, -17px)"></g>\r\n				</g>\r\n			</svg>\r\n			<div id="statusPanel" class="statusPanel">\r\n			</div>\r\n		</div>\r\n	</div>\r\n</div>\r\n' }]
		  }], () => [{ type: ElementRef }, { type: NgZone }], { containerLink: [{
			 type: Input
		  }] });
		})();
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(PlanningBoardMainComponent, { className: "PlanningBoardMainComponent", filePath: "lib\\components\\planning-board-main\\planning-board-main.component.ts", lineNumber: 63 });
		})();
		var PlanningBoardAssignmentsFilterBarComponent = class _PlanningBoardAssignmentsFilterBarComponent {
		  ngAfterViewInit() {
			 const uuid = this.containerLink.getContainerUUID() || "";
			 const pbDataService = PlanningBoardDataServiceInterfaceService.getPlanningBoardDataServiceByUUID(uuid);
			 const eventHandlingSubjects = pbDataService.getHelperServices().eventHandligSubjectService;
			 const nativeElement = this.nativeElement;
			 const filterBarElem = nativeElement;
			 const filterInputElem = nativeElement.getElementsByClassName("filterinput")[0];
			 const filterPanelElem = filterBarElem.getElementsByClassName("filterPanel")[0];
			 this.prevBtnElem = this.nativeElement.getElementsByClassName("filterButtonPrev")[0];
			 this.nextBtnElem = this.nativeElement.getElementsByClassName("filterButtonNext")[0];
			 this.prevBtnElem.disabled = true;
			 this.nextBtnElem.disabled = true;
			 const setButtonsFormat = () => {
				const styleStr = "width: 28px; height:28px; --icon-main-color: var(--company-color); display: none";
				this.prevBtnElem.style.cssText = this.nextBtnElem.style.cssText = styleStr;
			 };
			 const setButtonsOnClickEvents = (prevBtn, nextBtn) => {
				prevBtn.onclick = (e) => {
				  selectPrevAssignment();
				};
				nextBtn.onclick = (e) => {
				  selectNextAssignment();
				};
			 };
			 setButtonsOnClickEvents(this.prevBtnElem, this.nextBtnElem);
			 setButtonsFormat();
			 const setFilterKeyUp = (elem2) => {
				const delay = /* @__PURE__ */ function() {
				  let timer2 = 0;
				  return function(callback, ms) {
					 clearTimeout(timer2);
					 timer2 = setTimeout(callback, ms, true);
				  };
				}();
				elem2.onkeyup = (e) => {
				  delay(() => {
					 if (e.key === "Escape") {
						filterInputElem.value = "";
					 }
					 eventHandlingSubjects.onAssignmentFilterSearchChanged$.fire(setFilterKeyUp, filterInputElem);
				  }, 250);
				};
			 };
			 setFilterKeyUp(nativeElement);
			 const handleShowFilterPanel = (show) => {
				filterPanelElem.style.display = show ? "block" : "none";
				this.prevBtnElem.style.display = this.nextBtnElem.style.display = show ? "block" : "none";
			 };
			 let filteredAssignments = [];
			 let selectedAssignment;
			 const handleAssignmentFilterChanged = (newSelectedAssignment, newFilteredAssignments) => {
				if ((0, import_lodash.isArray)(newFilteredAssignments) && newFilteredAssignments.length > 0) {
				  filteredAssignments = newFilteredAssignments;
				  selectedAssignment = newSelectedAssignment;
				  updateFilterButtonsState();
				} else {
				  this.prevBtnElem.disabled = true;
				  this.nextBtnElem.disabled = true;
				}
			 };
			 const updateFilterButtonsState = () => {
				this.prevBtnElem.disabled = filteredAssignments.indexOf(selectedAssignment) === 0;
				this.nextBtnElem.disabled = selectedAssignment === filteredAssignments.at(-1);
			 };
			 const selectPrevAssignment = () => {
				selectAssignmentByFilter(-1, selectPrevAssignment);
			 };
			 const selectNextAssignment = () => {
				selectAssignmentByFilter(1, selectPrevAssignment);
			 };
			 eventHandlingSubjects.onAssignmentFilterUpdateDone$.subscribe([handleAssignmentFilterChanged]);
			 eventHandlingSubjects.onShowAssignmentFilterPanel$.subscribe([handleShowFilterPanel]);
			 this.onDestroyFn = () => {
				eventHandlingSubjects.onAssignmentFilterUpdateDone$.unsubscribe([handleAssignmentFilterChanged]);
				;
				eventHandlingSubjects.onShowAssignmentFilterPanel$.unsubscribe([handleShowFilterPanel]);
				;
			 };
			 function selectAssignmentByFilter(direction, triggeredByFn) {
				const assignmentConfig = pbDataService.getAssignmentConfig();
				if (!selectedAssignment.modificationData.selectedFlag) {
				  const selectedInAssignmentDS = assignmentConfig.dataService.getSelected() || [...pbDataService.assignments.values()].find((x) => x.modificationData.selectedFlag)?.originalEntity;
				  const idOfSelected = selectedInAssignmentDS ? assignmentConfig.mappingService.id(selectedInAssignmentDS) : -1;
				  if (pbDataService.assignments.has(idOfSelected)) {
					 selectedAssignment = pbDataService.assignments.get(idOfSelected);
				  }
				}
				if (filteredAssignments && selectedAssignment) {
				  const indexOfSelected = filteredAssignments.map((aD) => assignmentConfig.mappingService.id(aD.originalEntity)).indexOf(assignmentConfig.mappingService.id(selectedAssignment.originalEntity));
				  if (indexOfSelected > 0) {
					 selectedAssignment.modificationData.selectedFlag = false;
					 selectedAssignment.modificationData.activeFlag = false;
					 selectedAssignment = filteredAssignments[indexOfSelected + direction];
					 eventHandlingSubjects.onAssignmentFilterButtonClicked$.fire(triggeredByFn, selectedAssignment, filterInputElem);
				  }
				}
				updateFilterButtonsState();
			 }
		  }
		  ngOnDestroy() {
			 this.onDestroyFn();
		  }
		  constructor(elementRef) {
			 this.elementRef = elementRef;
			 this.containerLink = this.containerLink ? this.containerLink : document.getElementsByTagName("platform-planningboard-component")[0].scope;
			 this.PlatformTranslateService = PlanningBoardExternalServices.PlatformTranslateService;
			 this.nativeElement = elementRef.nativeElement;
		  }
		  static {
			 this.\u0275fac = function PlanningBoardAssignmentsFilterBarComponent_Factory(t) {
				return new (t || _PlanningBoardAssignmentsFilterBarComponent)(\u0275\u0275directiveInject(ElementRef));
			 };
		  }
		  static {
			 this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _PlanningBoardAssignmentsFilterBarComponent, selectors: [["lib-planning-board-assignments-filter-bar"]], inputs: { containerLink: "containerLink", PlatformTranslateService: "PlatformTranslateService" }, standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 10, vars: 7, consts: [[1, "assignmentfilterplaceholder"], [1, "filterPrevNextButtons", 2, "display", "flex"], ["title", "Go to Previous", 1, "filterButton", "filterButtonPrev", "navbar-btn", "e2e-navbar-btn-previous", "ng-scope"], ["data-sprite", "tlb-wh-icons", "data-image", "ico-rec-next"], ["href", "cloud.style/content/images/tlb-wh-icons.svg#ico-rec-previous"], ["title", "Go to Next", 1, "filterButton", "filterButtonNext", "navbar-btn", "e2e-navbar-btn-next", "ng-scope"], ["href", "cloud.style/content/images/tlb-wh-icons.svg#ico-rec-next"], [2, "display", "none"], ["type", "text", 3, "placeholder"]], template: function PlanningBoardAssignmentsFilterBarComponent_Template(rf, ctx) {
				if (rf & 1) {
				  \u0275\u0275element(0, "div", 0);
				  \u0275\u0275elementStart(1, "div", 1)(2, "button", 2);
				  \u0275\u0275namespaceSVG();
				  \u0275\u0275elementStart(3, "svg", 3);
				  \u0275\u0275element(4, "use", 4);
				  \u0275\u0275elementEnd()();
				  \u0275\u0275namespaceHTML();
				  \u0275\u0275elementStart(5, "button", 5);
				  \u0275\u0275namespaceSVG();
				  \u0275\u0275elementStart(6, "svg", 3);
				  \u0275\u0275element(7, "use", 6);
				  \u0275\u0275elementEnd()()();
				  \u0275\u0275namespaceHTML();
				  \u0275\u0275elementStart(8, "div", 7);
				  \u0275\u0275element(9, "input", 8);
				  \u0275\u0275elementEnd();
				}
				if (rf & 2) {
				  \u0275\u0275advance(8);
				  \u0275\u0275classMapInterpolate1("filterPanel ", ctx.containerLink == null ? null : ctx.containerLink.getContainerUUID(), " grid-container");
				  \u0275\u0275advance();
				  \u0275\u0275classMapInterpolate1("filterinput form-control ", ctx.containerLink == null ? null : ctx.containerLink.getContainerUUID(), "");
				  \u0275\u0275propertyInterpolate("placeholder", ctx.PlatformTranslateService.instant("platform.searchPanelString"));
				}
			 } });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlanningBoardAssignmentsFilterBarComponent, [{
			 type: Component,
			 args: [{ selector: "lib-planning-board-assignments-filter-bar", standalone: true, imports: [], template: `<div class="assignmentfilterplaceholder"></div>\r
		<div class="filterPrevNextButtons" style="display: flex">\r
			<button title="Go to Previous" class="filterButton filterButtonPrev navbar-btn e2e-navbar-btn-previous ng-scope">\r
				<svg data-sprite="tlb-wh-icons" data-image="ico-rec-next">\r
					<use href="cloud.style/content/images/tlb-wh-icons.svg#ico-rec-previous"></use>\r
				</svg>\r
			</button>\r
			<button title="Go to Next" class="filterButton filterButtonNext navbar-btn e2e-navbar-btn-next ng-scope">\r
				<svg data-sprite="tlb-wh-icons" data-image="ico-rec-next">\r
					<use href="cloud.style/content/images/tlb-wh-icons.svg#ico-rec-next"></use>\r
				</svg>\r
			</button>\r
		</div>\r
		<div class="filterPanel {{containerLink?.getContainerUUID()}} grid-container" style="display: none;">\r
			<!-- <input type="text" placeholder="{{'platform.searchPanelString' | translate }}" class="filterinput form-control {{data.state}}"> -->\r
			<!-- <input type="text" placeholder="{{'platform.searchPanelString'}}" -->\r
			<input type="text" placeholder="{{PlatformTranslateService.instant('platform.searchPanelString')}}"\r
				class="filterinput form-control {{containerLink?.getContainerUUID()}}">\r
		</div>` }]
		  }], () => [{ type: ElementRef }], { containerLink: [{
			 type: Input
		  }], PlatformTranslateService: [{
			 type: Input
		  }] });
		})();
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(PlanningBoardAssignmentsFilterBarComponent, { className: "PlanningBoardAssignmentsFilterBarComponent", filePath: "lib\\components\\planning-board-assignments-filter-bar\\planning-board-assignments-filter-bar.component.ts", lineNumber: 16 });
		})();
		var PlanningBoardAssignmentComponent = class _PlanningBoardAssignmentComponent {
		  constructor(element) {
			 this.element = element;
			 const containerLink = this.containerLink ? this.containerLink : document.getElementsByTagName("platform-planningboard-component")[0].scope;
			 const platformGridAPI = PlanningBoardExternalServices.platformGridAPI, BasicsSharedStatusIconService = PlanningBoardExternalServices.BasicsSharedStatusIconService, BasicsSharedChangeStatusService = PlanningBoardExternalServices.BasicsSharedChangeStatusService, platformPlanningBoardStatusService = PlanningBoardStatusService, ModuleNavBarService = PlanningBoardExternalServices.ModuleNavBarService, UiCommonMessageBoxService = PlanningBoardExternalServices.UiCommonMessageBoxService, platformDataServiceModificationTrackingExtension = PlanningBoardExternalServices.platformDataServiceModificationTrackingExtension;
			 const planningBoardDataService = PlanningBoardDataServiceInterfaceService.getPlanningBoardDataServiceByUUID(containerLink.getContainerUUID());
			 const platformPlanningBoardConfigService = planningBoardDataService.getPlanningBoardConfigService();
			 let planningBoardTools, containerScope, moveModeTools;
			 planningBoardDataService.sharedData.planningBoardDefaultSave = ModuleNavBarService.getById("save").fn;
			 containerScope = containerLink?.$parent;
			 while (containerScope && !containerScope.hasOwnProperty("setTools")) {
				containerScope = containerScope.$parent;
			 }
			 const addStatusbarFilter = () => {
				function copyToScope(selectedItem) {
				  let start2, end;
				  switch (selectedItem.chartIntervalFk) {
					 case 2:
						start2 = DateExtension.utc().startOf("year");
						end = new DateExtension(start2).endOf("year");
						break;
					 case 3:
						start2 = DateExtension.utc().startOf("quarter");
						end = new DateExtension(start2).endOf("quarter");
						break;
					 case 4:
						start2 = selectedItem.intervalStart.clone();
						end = selectedItem.intervalEnd.clone();
						break;
					 default:
						start2 = DateExtension.utc().startOf("month");
						end = new DateExtension(start2).endOf("month");
						break;
				  }
				  planningBoardDataService.getDateStart(start2);
				  planningBoardDataService.getDateEnd(end);
				  planningBoardDataService.saveCurrentZoomLevel();
				  planningBoardDataService.planningBoardReDraw();
				  planningBoardDataService.loadRest();
				}
				if (!planningBoardDataService.sharedData.selectedItem) {
				  let tempSelItem = {
					 chartIntervalFk: 1,
					 intervalStart: DateExtension.utc(planningBoardDataService.getDateStart()),
					 intervalEnd: DateExtension.utc(planningBoardDataService.getDateEnd())
				  };
				  planningBoardDataService.sharedData.selectedItem = tempSelItem;
				}
				setTimeout(() => {
				  PlanningBoardExternalServices.platformChartInterval.init(containerLink, planningBoardDataService.sharedData.selectedItem, copyToScope, "chartIntervalFk", "intervalStart", "intervalEnd").extendStatusBar();
				}, 200);
			 };
			 const planningBoardModes = {
				"setDefault": {
				  id: "setDefault",
				  name: "platform.planningboard.setDefault",
				  actionType: "setDefault",
				  iconClass: "status-icons ico-status06",
				  events: {
					 "drag": true
				  }
				},
				"createMode": {
				  id: "createAssignmentWithDemand",
				  name: "platform.planningboard.onDemand",
				  actionType: "createAssignment",
				  iconClass: "status-icons ico-status63",
				  events: {
					 "drag": false
				  }
				}
			 };
			 let statusActionListItems = [];
			 const assignmentStatusService = planningBoardDataService.getAssignmentConfig().mappingService.getStatusService();
			 assignmentStatusService.getAssignmentStatus().then((list) => {
				list.forEach((val) => {
				  if (val.isLive) {
					 const resStatusIconPath = val.icon ? BasicsSharedStatusIconService.select({ Icon: val.icon }) : "";
					 const item = {
						id: "statusItem_" + val.Id,
						type: "item",
						actionType: "setStatus",
						caption: val.Description,
						iconClass: resStatusIconPath,
						events: {
						  "drag": false
						},
						fn: function() {
						  setPlanningBoardMode(this);
						}
					 };
					 statusActionListItems.push(item);
				  }
				});
				updateToolbarButtonStates();
			 });
			 const searchToolbarIcon = {
				id: "searchBoth",
				sort: 100,
				caption: "cloud.common.taskBarSearch",
				type: "check",
				iconClass: "tlb-icons ico-search other",
				value: false,
				fn: function(id3) {
				  planningBoardDataService.sharedData.activeSearchMode = this.value ? id3 : "";
				  platformGridAPI.filters.showSearch(planningBoardDataService.getSupplierConfig().uuid, this.value);
				  const demantConfig = planningBoardDataService.getDemandConfig();
				  if (demantConfig) {
					 platformGridAPI.filters.showSearch(demantConfig.uuid, this.value);
				  }
				  if (this.value) {
					 platformGridAPI.filters.showColumnSearch(planningBoardDataService.getSupplierConfig().uuid, false);
					 if (demantConfig) {
						platformGridAPI.filters.showColumnSearch(demantConfig.uuid, false);
					 }
				  }
				  columnSearchToolbarIcon.value = false;
				  planningBoardDataService.getHelperServices().eventHandligSubjectService.onShowAssignmentFilterPanel$.fire(this.fn, planningBoardDataService.sharedData.activeSearchMode === "searchBoth");
				},
				disabled: function() {
				  return !!planningBoardDataService.sharedData.showInfoOverlay;
				}
			 };
			 const columnSearchToolbarIcon = {
				id: "columnSearch",
				sort: 110,
				caption: "cloud.common.taskBarColumnFilter",
				type: "check",
				iconClass: "tlb-icons ico-search-column",
				value: false,
				fn: function(id3) {
				  planningBoardDataService.sharedData.activeSearchMode = this.value ? id3 : "";
				  platformGridAPI.filters.showColumnSearch(planningBoardDataService.getSupplierConfig().uuid, !!this.value);
				  const demantConfig = planningBoardDataService.getDemandConfig();
				  if (demantConfig) {
					 platformGridAPI.filters.showColumnSearch(demantConfig.uuid, !!this.value);
				  }
				  if (this.value) {
					 platformGridAPI.filters.showSearch(planningBoardDataService.getSupplierConfig().uuid, false);
					 if (demantConfig) {
						platformGridAPI.filters.showSearch(demantConfig.uuid, false);
					 }
				  }
				  searchToolbarIcon.value = false;
				  planningBoardDataService.getHelperServices().eventHandligSubjectService.onShowAssignmentFilterPanel$.fire(this.fn, planningBoardDataService.sharedData.activeSearchMode === "searchBoth");
				},
				disabled: function() {
				  return !!containerLink.showInfoOverlay;
				}
			 };
			 planningBoardDataService.sharedData.columnSearchToolbarIcon = columnSearchToolbarIcon;
			 planningBoardTools = [
				{
				  id: "planningBordModes",
				  sort: 10,
				  iconClass: "status-icons ico-status06",
				  type: "dropdown-btn",
				  caption: "planningBoardMode",
				  showTitles: false,
				  list: {
					 showImages: true,
					 cssClass: "dropdown-menu-right",
					 items: [
						{
						  id: "setDefault",
						  caption: "platform.planningboard.setDefault",
						  type: "item",
						  iconClass: "status-icons ico-status06",
						  actionType: "setDefault",
						  events: {
							 "drag": true
						  },
						  fn: function() {
							 setPlanningBoardMode(this);
						  }
						},
						{
						  id: "createAssignment",
						  caption: "platform.planningboard.create",
						  tooltip: "platform.planningboard.createAssignmentTooltip",
						  type: "item",
						  iconClass: "tlb-icons ico-draw",
						  actionType: "createAssignment",
						  events: {
							 "drag": false
						  },
						  fn: function() {
							 setPlanningBoardMode(this);
						  }
						},
						{
						  id: "setStatus",
						  caption: "platform.planningboard.setStatus",
						  type: "dropdown-btn",
						  list: {
							 showImages: true,
							 items: statusActionListItems
						  }
						}
					 ]
				  }
				},
				{
				  id: "delAssignment",
				  sort: 3,
				  caption: "Delete Assignment",
				  type: "item",
				  iconClass: "tlb-icons ico-rec-delete",
				  fn: planningBoardDataService.deleteSelectedAssignment,
				  disabled: function() {
					 return !planningBoardDataService.canDeleteAssignment();
				  }
				},
				// grouping destroys grid with unusual or extraordinary line height
				/* {
												id: 'groupBoth',
												sort: 5,
												caption: 'cloud.common.taskBarGrouping',
												type: 'check',
												iconClass: 'tlb-icons ico-group-columns',
												value: false,
												fn: function () {
													 platformGridAPI.grouping.toggleGroupPanel($scope.supplierGridId, this.value); // supplierGridId
													 platformGridAPI.grouping.toggleGroupPanel($scope.demandGridId, this.value); // demandGridId

												},
												disabled: function () {
													 return $scope.showInfoOverlay;
												}
										  }, */
				/*
								{
									 id: 'weekBack',
									 sort: 10,
									 caption: 'platform.planningboard.weekBack',
									 type: 'item',
									 iconClass: 'tlb-icons ico-rec-first',
									 fn: function () {
										  platformPlanningBoardDataService.decDate(7);
									 }
								},
								{
									 id: 'dayBack',
									 sort: 20,
									 caption: 'platform.planningboard.dayBack',
									 type: 'item',
									 iconClass: 'tlb-icons ico-rec-previous',
									 fn: function () {
										  platformPlanningBoardDataService.decDate(1);
									 }
								},
								*/
				{
				  id: "lockCalendar",
				  sort: 25,
				  caption: "platform.planningboard.lockCalendar",
				  type: "check",
				  value: false,
				  // must be dynamic
				  iconClass: "tlb-icons ico-break",
				  fn: function() {
					 planningBoardDataService.isCalendarLocked(!!this.value);
				  }
				},
				{
				  id: "dayToday",
				  sort: 30,
				  caption: "platform.planningboard.today",
				  type: "item",
				  iconClass: "tlb-icons ico-date",
				  fn: function() {
					 planningBoardDataService.clickToday();
				  }
				},
				/*
								{
									 id: 'dayForward',
									 sort: 40,
									 caption: 'platform.planningboard.dayForward',
									 type: 'item',
									 iconClass: 'tlb-icons ico-rec-next',
									 fn: function () {
										  platformPlanningBoardDataService.incDate(1);
									 }
								},
								{
									 id: 'weekForward',
									 sort: 50,
									 caption: 'platform.planningboard.weekForward',
									 type: 'item',
									 iconClass: 'tlb-icons ico-rec-last',
									 fn: function () {
										  platformPlanningBoardDataService.incDate(7);
									 }
								},
								 */
				{
				  id: "zoomIn",
				  sort: 60,
				  caption: "platform.planningboard.zoomIn",
				  type: "item",
				  iconClass: "tlb-icons ico-zoom-in",
				  fn: function() {
					 planningBoardDataService.zoomIn();
				  }
				},
				{
				  id: "zoomNorm",
				  sort: 70,
				  caption: "platform.planningboard.zoomNormal",
				  type: "dropdown-btn",
				  iconClass: "tlb-icons ico-zoom-100",
				  list: {
					 showImages: true,
					 cssClass: "dropdown-menu-right",
					 items: [{
						id: "zoomOneWeek",
						type: "item",
						iconClass: " tlb-icons ico-zoom-100",
						caption: "platform.planningboard.zoomOneWeek",
						fn: function() {
						  planningBoardDataService.zoomReset(1, "week");
						},
						sort: 0
					 }, {
						id: "zoomTwoWeek",
						type: "item",
						iconClass: " tlb-icons ico-zoom-100",
						caption: "platform.planningboard.zoomTwoWeek",
						fn: function() {
						  planningBoardDataService.zoomReset(2, "week");
						},
						sort: 0
					 }, {
						id: "zoomOneMonth",
						type: "item",
						iconClass: " tlb-icons ico-zoom-100",
						caption: "platform.planningboard.zoomOneMonth",
						fn: function() {
						  planningBoardDataService.zoomReset(1, "month");
						},
						sort: 0
					 }]
				  }
				},
				{
				  id: "zoomOut",
				  sort: 80,
				  caption: "platform.planningboard.zoomOut",
				  type: "item",
				  iconClass: "tlb-icons ico-zoom-out",
				  fn: function() {
					 planningBoardDataService.zoomOut();
				  }
				},
				// {
				// id: 'refreshData',
				// sort: 90,
				// caption: 'platform.planningboard.refreshData',
				// type: 'item',
				// iconClass: 'tlb-icons ico-refresh',
				// fn: function () {
				// platformPlanningBoardDataService.load();
				// }
				// },
				searchToolbarIcon,
				columnSearchToolbarIcon,
				{
				  id: "gridSettingsGroup",
				  sort: 120,
				  iconClass: "gridSettingsGroup",
				  type: "sublist",
				  caption: "platform.planningboard.settingsGroup",
				  list: {
					 showTitles: false,
					 items: [{
						id: "platform.planningboard.settings",
						caption: "platform.planningboard.settings",
						type: "dropdown-btn",
						iconClass: " tlb-icons ico-settings",
						list: {
						  showImages: false,
						  cssClass: "dropdown-menu-right",
						  items: [{
							 id: "supplierGridSetting",
							 type: "item",
							 caption: "platform.planningboard.supplierSettings",
							 fn: function() {
								platformGridAPI.configuration.openConfigDialog(planningBoardDataService.getSupplierConfig().uuid);
							 },
							 sort: 0,
							 iconClass: ""
						  }, {
							 id: "demandGridSetting",
							 type: "item",
							 caption: "platform.planningboard.demandSettings",
							 fn: function() {
								const demantConfig = planningBoardDataService.getDemandConfig();
								if (demantConfig) {
								  platformGridAPI.configuration.openConfigDialog(demantConfig.uuid);
								}
							 },
							 hideItem: () => {
								const demantConfig = planningBoardDataService.getDemandConfig();
								return !(demantConfig && demantConfig.uuid);
							 }
						  }, {
							 id: "assignmentTimeline",
							 type: "item",
							 caption: "platform.planningboard.configDialog",
							 fn: function() {
								if (!platformGridAPI.grids.exist(PlanningBoardTagGridConfigService.uuid)) {
								}
								platformPlanningBoardConfigService.show(containerScope.getContainerUUID());
							 },
							 sort: 0,
							 iconClass: ""
						  }]
						}
					 }]
				  }
				}
			 ];
			 moveModeTools = [{
				id: "moveModes",
				sort: 9,
				iconClass: "tlb-icons ico-move-day",
				type: "dropdown-btn",
				caption: "platform.gantt.moveModes",
				showTitles: false,
				list: {
				  showImages: true,
				  cssClass: "dropdown-menu-right",
				  activeValue: "day",
				  items: [{
					 id: "auto",
					 caption: "platform.gantt.auto",
					 type: "radio",
					 value: "auto",
					 iconClass: "tlb-icons ico-move-automatic",
					 fn: function() {
						setMoveMode(this);
					 }
				  }, {
					 id: "hour",
					 caption: "platform.gantt.hour",
					 type: "radio",
					 value: "hour",
					 iconClass: "tlb-icons ico-move-hour",
					 fn: function() {
						setMoveMode(this);
					 }
				  }, {
					 id: "day",
					 caption: "platform.gantt.day",
					 type: "radio",
					 value: "day",
					 iconClass: "tlb-icons ico-move-day",
					 fn: function() {
						setMoveMode(this);
					 }
				  }, {
					 id: "week",
					 caption: "platform.gantt.week",
					 type: "radio",
					 value: "week",
					 iconClass: "tlb-icons ico-move-week",
					 fn: function() {
						setMoveMode(this);
					 }
				  }]
				}
			 }];
			 moveModeTools.forEach((tool) => {
				planningBoardTools.unshift(tool);
			 });
			 const dateShiftConfig = planningBoardDataService.getDateshiftConfig();
			 const { dateShiftHelperService, dataService, dateShiftToolConfig } = dateShiftConfig || {};
			 if (dateShiftHelperService && dataService && (0, import_lodash.isEmpty)(planningBoardDataService.sharedData.dateShiftModeTools)) {
				const toolsConfig = dateShiftToolConfig && dateShiftToolConfig.tools ? dateShiftToolConfig.tools : [];
				const configId = dateShiftToolConfig && dateShiftToolConfig.configId ? dateShiftToolConfig.configId : null;
				planningBoardDataService.sharedData.dateShiftModeTools = dateShiftHelperService.getDateshiftTools(dataService.getServiceName(), toolsConfig, configId, containerLink);
			 }
			 if (!(0, import_lodash.isUndefined)(planningBoardDataService.sharedData.dateShiftModeTools)) {
				planningBoardDataService.sharedData.dateShiftModeTools.forEach((tool) => {
				  planningBoardTools.unshift(tool);
				});
			 }
			 if ((0, import_lodash.isFunction)(planningBoardDataService.getAssignmentConfig().mappingService.grouping)) {
				planningBoardTools.forEach((planningboardMode) => {
				  if (planningboardMode.id === "planningBordModes") {
					 planningboardMode.list?.items.unshift({
						id: "grouping",
						caption: "platform.planningboard.capacityHistogram",
						type: "item",
						iconClass: "tlb-icons ico-group-columns",
						actionType: "grouping",
						events: {
						  "drag": true
						},
						fn: function() {
						  setPlanningBoardMode(this);
						  planningBoardDataService.planningBoardReDraw(true);
						}
					 });
				  }
				});
			 }
			 if (!(0, import_lodash.isUndefined)(planningBoardDataService.sharedData.toolbarConfig) && !(0, import_lodash.isUndefined)(planningBoardDataService.sharedData.toolbarConfig.customTools)) {
				planningBoardTools.unshift({
				  id: "dType",
				  sort: 19,
				  type: "divider",
				  iconClass: "",
				  caption: ""
				});
				(0, import_lodash.forEach)(planningBoardDataService.sharedData.toolbarConfig.customTools, function(tool) {
				  planningBoardTools.unshift(tool);
				});
			 }
			 if (!(0, import_lodash.isUndefined)(planningBoardDataService.sharedData.toolbarConfig) && !(0, import_lodash.isUndefined)(planningBoardDataService.sharedData.toolbarConfig.removeTools)) {
				planningBoardTools = planningBoardTools.filter((tool) => {
				  return removeToolsDeep(tool, planningBoardDataService.sharedData.toolbarConfig.removeTools);
				});
			 }
			 function removeToolsDeep(tool, toolsToRemove) {
				if (toolsToRemove.indexOf(tool.id) === -1) {
				  if (!(0, import_lodash.isUndefined)(tool.list) && !(0, import_lodash.isUndefined)(tool.list.items) && tool.list.items.length > 0) {
					 tool.list.items = tool.list.items.filter((item) => {
						return removeToolsDeep(item, toolsToRemove);
					 });
				  }
				  return tool;
				}
				return tool;
			 }
			 if (containerScope.setTools) {
				containerScope.setTools({
				  showImages: true,
				  showTitles: true,
				  cssClass: "tools",
				  items: planningBoardTools
				});
			 }
			 function updateToolbarButtonStates() {
				const commonToolbarSettingIndex = (0, import_lodash.findIndex)(containerScope.tools.items, { "caption": "cloud.common.toolbarSetting" });
				if (commonToolbarSettingIndex > -1) {
				  containerScope.tools.items.splice(commonToolbarSettingIndex, 1);
				}
				containerScope.tools.update();
			 }
			 function updateSettingsRowHeight(newLineHeight) {
				platformPlanningBoardConfigService.updateSettingsRowHeight(containerScope.getContainerUUID(), newLineHeight);
			 }
			 const planningboardChangeMultipleStatus = function() {
				const config2 = {
				  isSimpleStatus: false,
				  statusName: planningBoardDataService.getAssignmentConfig().mappingService.entityTypeName(),
				  // 'resreservationstatus',
				  remark: ""
				};
				return BasicsSharedChangeStatusService.changeStatus(config2, platformPlanningBoardStatusService.getAssignmentStatusChanged()).then(function(result) {
				  result.forEach((item) => {
					 let changedAssignmentId = item.entityId || 0;
					 let statusEntityIdFn = planningBoardDataService.getAssignmentConfig().mappingService.statusEntityId;
					 if ((0, import_lodash.isFunction)(planningBoardDataService.getAssignmentConfig().mappingService.useStatusProperties) && planningBoardDataService.getAssignmentConfig().mappingService.useStatusProperties()) {
						let changedAssignment = Array.from(planningBoardDataService.assignments.values()).find((assignment2) => {
						  return statusEntityIdFn && statusEntityIdFn(assignment2.originalEntity) === changedAssignmentId;
						});
						if (changedAssignment) {
						  changedAssignmentId = planningBoardDataService.getAssignmentConfig().mappingService.id(changedAssignment.originalEntity);
						}
					 }
					 let assignment = planningBoardDataService.assignments.get(changedAssignmentId);
					 if (assignment) {
						if (!(0, import_lodash.isNull)(item.ErrorMsg)) {
						  assignment.validationData.isValid = false;
						} else {
						  if (!(0, import_lodash.isUndefined)(assignment.validationData.isValid) && !assignment.validationData.isValid) {
							 assignment.validationData.isValid = true;
						  }
						}
					 }
				  });
				  platformPlanningBoardStatusService.clearAssignmentStatusChanged();
				  return planningBoardDataService.load();
				});
			 };
			 function setPlanningBoardMode(item) {
				let hasModifications = platformDataServiceModificationTrackingExtension.hasModifications(planningBoardDataService.getAssignmentConfig().dataService);
				if (hasModifications) {
				  UiCommonMessageBoxService.showYesNoDialog("platform.planningboard.sureToSaveChanges", "platform.planningboard.assignmentModifications").then((result) => {
					 if (result.yes) {
						return ModuleNavBarService.getById("save").fn().then(() => {
						  afterModeChanged(item);
						  planningBoardDataService.planningBoardReDraw(true);
						});
					 } else {
						afterModeChanged(item);
						return planningBoardDataService.load();
					 }
				  });
				} else {
				  afterModeChanged(item);
				  if (item.actionType === "setStatus" && planningBoardDataService.assignmentAvailableStatusMatrix.size === 0) {
					 planningBoardDataService.load();
				  } else {
					 planningBoardDataService.planningBoardReDraw(true);
				  }
				}
			 }
			 function afterModeChanged(item) {
				if (item.actionType) {
				  changePlanningBoardCursor(item);
				  changeSaveFn(item.actionType);
				  planningBoardTools.forEach((tool) => {
					 if (tool.id === "planningBordModes") {
						tool.iconClass = item.iconClass;
					 }
				  });
				  updateToolbarButtonStates();
				  const planningBoardMode = {
					 id: item.id,
					 name: item.caption,
					 actionType: item.actionType,
					 events: item.events
				  };
				  planningBoardDataService.sharedData.planningBoardMode = planningBoardMode;
				}
			 }
			 function changePlanningBoardCursor(item) {
				if (item.actionType === "createAssignment") {
				  document.querySelector(".planningboard").style.cursor = "crosshair";
				} else {
				  document.querySelector(".planningboard").style.cursor = "default";
				}
			 }
			 planningBoardDataService.sharedData.activeMoveMode = "day";
			 function setMoveMode(tool) {
				planningBoardDataService.sharedData.activeMoveMode = tool.id;
				const moveModes = containerLink.tools.items.find((item) => item.id === "moveModes");
				if (moveModes && moveModes.list) {
				  moveModes.iconClass = moveModes.list.items.find((item) => item.id === tool.id).iconClass;
				}
				containerLink.tools.update();
			 }
			 updateToolbarButtonStates();
			 updateSharedDataAndRegister(true);
			 planningBoardDataService.registerInfoChanged(updateSharedDataAndRegister);
			 platformPlanningBoardConfigService.registerOnSettingsChanged(() => {
				updateSharedDataAndRegister(true);
			 });
			 containerLink.registerDataUpdated = planningBoardDataService.registerInfoChanged;
			 containerLink.unregisterDataUpdated = planningBoardDataService.unregisterInfoChanged;
			 planningBoardDataService.registerSelectionChanged(updateToolbarButtonStates);
			 function updateSharedDataAndRegister(isInitial = false) {
				planningBoardDataService.sharedData.updateSettingsRowHeight = updateSettingsRowHeight;
				planningBoardDataService.sharedData.validateAssignments = planningBoardDataService.validateAssignments();
				planningBoardDataService.sharedData.showAggregations = planningBoardDataService.showAggregations();
				planningBoardDataService.sharedData.showSumAggregations = planningBoardDataService.showSumAggregations();
				planningBoardDataService.sharedData.useMinAggregation = planningBoardDataService.useMinAggregation();
				planningBoardDataService.sharedData.useTaggingSystem = planningBoardDataService.useTaggingSystem();
				planningBoardDataService.sharedData.useFixedAssignmentHeight = planningBoardDataService.useFixedAssignmentHeight();
				planningBoardDataService.sharedData.tagConfig = planningBoardDataService.tagConfig();
				planningBoardDataService.sharedData.collectionConfig = planningBoardDataService.collectionConfig();
				planningBoardDataService.sharedData.aggregationTrafficLightsConfig = planningBoardDataService.aggregationTrafficLightsConfig();
				planningBoardDataService.sharedData.rowHeight = planningBoardDataService.getRowHeightFromSettings();
				planningBoardDataService.sharedData.flexibleRowHeight = planningBoardDataService.useFlexibleRowHeight();
				planningBoardDataService.sharedData.showDemandPreview = planningBoardDataService.showDemandPreview();
				planningBoardDataService.sharedData.rowHeightAssignments = planningBoardDataService.getRowHeightFromSettings();
				planningBoardDataService.sharedData.rowHeightAssignments = !planningBoardDataService.sharedData.showAggregations ? planningBoardDataService.sharedData.rowHeightAssignments : planningBoardDataService.sharedData.rowHeightAssignments - planningBoardDataService.sharedData.defaultAggregationHeight;
				planningBoardDataService.sharedData.showHeaderColor = planningBoardDataService.showHeaderColor();
				planningBoardDataService.sharedData.showStatusIcon = planningBoardDataService.showStatusIcon();
				planningBoardDataService.sharedData.backgroundColorConfig = planningBoardDataService.backgroundColorConfig();
				planningBoardDataService.sharedData.showTypeIcon = planningBoardDataService.showTypeIcon();
				planningBoardDataService.sharedData.showHeaderBackground = planningBoardDataService.showHeaderBackground();
				planningBoardDataService.sharedData.showSameAssignments = planningBoardDataService.showSameAssignments();
				planningBoardDataService.sharedData.showMainText = planningBoardDataService.showMainText();
				planningBoardDataService.sharedData.showInfo1Text = planningBoardDataService.showInfo1Text();
				planningBoardDataService.sharedData.showInfo2Text = planningBoardDataService.showInfo2Text();
				planningBoardDataService.sharedData.showInfo3Text = planningBoardDataService.showInfo3Text();
				planningBoardDataService.sharedData.mainInfoLabel = planningBoardDataService.mainInfoLabel();
				planningBoardDataService.sharedData.info1Label = planningBoardDataService.info1Label();
				planningBoardDataService.sharedData.info2Label = planningBoardDataService.info2Label();
				planningBoardDataService.sharedData.info3Label = planningBoardDataService.info3Label();
				planningBoardDataService.sharedData.snapToDays = planningBoardDataService.snapToDays();
				planningBoardDataService.sharedData.saveLastZoom = planningBoardDataService.saveLastZoom();
				planningBoardDataService.sharedData.selectedZoomLevel = planningBoardDataService.selectedZoomLevel();
				planningBoardDataService.sharedData.minAggregationLevel = planningBoardDataService.minAggregationLevel();
				planningBoardDataService.sharedData.sumAggregationLine1 = planningBoardDataService.sumAggregationLine1();
				planningBoardDataService.sharedData.sumAggregationLine2 = planningBoardDataService.sumAggregationLine2();
				planningBoardDataService.sharedData.sumAggregationLine3 = planningBoardDataService.sumAggregationLine3();
				planningBoardDataService.sharedData.useDemandTimesForReservation = planningBoardDataService.useDemandTimesForReservation();
				let gridSettings = {
				  validateDemandAgainstSuppliers: planningBoardDataService.gridSettings.validateDemandAgainstSuppliers instanceof Function ? planningBoardDataService.gridSettings.validateDemandAgainstSuppliers() : planningBoardDataService.gridSettings.validateDemandAgainstSuppliers,
				  filterDemands: planningBoardDataService.gridSettings.filterDemands instanceof Function ? planningBoardDataService.gridSettings.filterDemands() : planningBoardDataService.gridSettings.filterDemands
				};
				planningBoardDataService.sharedData.gridSettings = gridSettings;
				planningBoardDataService.sharedData.exceptionDays = planningBoardDataService.exceptionDays;
				planningBoardDataService.sharedData.weekDays = planningBoardDataService.weekDays;
				planningBoardDataService.sharedData.suppliers = planningBoardDataService.suppliers;
				planningBoardDataService.sharedData.assignments = planningBoardDataService.assignments;
				planningBoardDataService.sharedData.demands = planningBoardDataService.demands;
				planningBoardDataService.sharedData.assignmentStatusItems = planningBoardDataService.assignmentStatusItems;
				planningBoardDataService.sharedData.assignmentTypeItems = planningBoardDataService.assignmentTypeItems;
				planningBoardDataService.sharedData.getDateStart = planningBoardDataService.getDateStart;
				planningBoardDataService.sharedData.getDateEnd = planningBoardDataService.getDateEnd;
				planningBoardDataService.sharedData.getTimeScaleHoursX = planningBoardDataService.getTimeScaleHoursX;
				planningBoardDataService.sharedData.createAssignment = planningBoardDataService.createAssignment;
				planningBoardDataService.sharedData.updateAssignment = planningBoardDataService.updateAssignment;
				planningBoardDataService.sharedData.updateDemand = planningBoardDataService.updateDemand;
				planningBoardDataService.sharedData.setSelectedAssignment = planningBoardDataService.setSelectedAssignment;
				planningBoardDataService.sharedData.addToSelectedAssignment = planningBoardDataService.addToSelectedAssignment;
				planningBoardDataService.sharedData.load = planningBoardDataService.load;
				planningBoardDataService.sharedData.loadRest = planningBoardDataService.loadRest;
				planningBoardDataService.sharedData.supplierConfig = planningBoardDataService.getSupplierConfig();
				planningBoardDataService.sharedData.assignmentConfig = planningBoardDataService.getAssignmentConfig();
				planningBoardDataService.sharedData.demandConfig = planningBoardDataService.getDemandConfig();
				planningBoardDataService.sharedData.getFilteredItems = getFilteredItems;
				if (!planningBoardDataService.sharedData.verticalIndex || planningBoardDataService.sharedData.verticalIndex.size === 0) {
				  planningBoardDataService.sharedData.verticalIndex = planningBoardDataService.sharedData.getFilteredItems(planningBoardDataService.getSupplierConfig().uuid);
				}
				if (isInitial) {
				  addStatusbarFilter();
				}
			 }
			 function changeSaveFn(type2) {
				switch (type2) {
				  case "setStatus":
					 ModuleNavBarService.getById("save").fn = planningboardChangeMultipleStatus;
					 break;
				  case "setDefault":
					 ModuleNavBarService.getById("save").fn = planningBoardDataService.sharedData.planningBoardDefaultSave;
					 break;
				}
			 }
			 containerLink.registerFinalizer(function cleanupHandlers() {
				planningBoardTools.forEach((tool) => {
				  if (tool.id === "planningBordModes") {
					 tool.iconClass = "status-icons ico-status06";
				  }
				});
				statusActionListItems = [];
				if (containerScope.tools) {
				  containerScope.tools.items = [];
				  containerScope.tools.update();
				}
				planningBoardDataService.unregisterInfoChanged(updateSharedDataAndRegister);
				planningBoardDataService.unregisterSelectionChanged(updateToolbarButtonStates);
				planningBoardDataService.unregisterUpdateDone();
				planningBoardDataService.unregisterSupplierListLoaded();
				planningBoardDataService.unregisterSelectedAssignmentChanged();
				planningBoardDataService.unregisterAssignmentListLoaded();
				planningBoardDataService.unregisterParentDataServiceListLoadStarted();
				platformPlanningBoardConfigService.unregisterOnSettingsChanged(addStatusbarFilter);
			 });
			 function getFilteredItems(containerId) {
				const platformGridAPI2 = PlanningBoardExternalServices.platformGridAPI;
				const result = platformGridAPI2.grids.getGridState(containerId, false);
				const itemsmap = /* @__PURE__ */ new Map();
				if (result && result.filteredItems.size > 0) {
				  let idx = 0;
				  result.filteredItems.forEach((val, key) => {
					 itemsmap.set(key, idx++);
				  });
				}
				return itemsmap;
			 }
		  }
		  ngAfterViewInit() {
			 PlanningBoardExternalServices.angularJScompile(this.containerLink, this.element.nativeElement);
		  }
		  static {
			 this.\u0275fac = function PlanningBoardAssignmentComponent_Factory(t) {
				return new (t || _PlanningBoardAssignmentComponent)(\u0275\u0275directiveInject(ElementRef));
			 };
		  }
		  static {
			 this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _PlanningBoardAssignmentComponent, selectors: [["app-planning-board-assignment"]], inputs: { containerLink: "containerLink" }, standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 3, vars: 2, consts: [[1, "filterContainer"], [2, "display", "flex", 3, "containerLink"], [3, "containerLink"]], template: function PlanningBoardAssignmentComponent_Template(rf, ctx) {
				if (rf & 1) {
				  \u0275\u0275elementStart(0, "div", 0);
				  \u0275\u0275element(1, "lib-planning-board-assignments-filter-bar", 1);
				  \u0275\u0275elementEnd();
				  \u0275\u0275element(2, "app-planning-board-main", 2);
				}
				if (rf & 2) {
				  \u0275\u0275advance();
				  \u0275\u0275property("containerLink", ctx.containerLink);
				  \u0275\u0275advance();
				  \u0275\u0275property("containerLink", ctx.containerLink);
				}
			 }, dependencies: [PlanningBoardMainComponent, PlanningBoardAssignmentsFilterBarComponent] });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlanningBoardAssignmentComponent, [{
			 type: Component,
			 args: [{ standalone: true, selector: "app-planning-board-assignment", imports: [PlanningBoardMainComponent, PlanningBoardAssignmentsFilterBarComponent], schemas: [CUSTOM_ELEMENTS_SCHEMA], template: '<div class="filterContainer">\r\n<!--   <platform-filter-input-buttons-directive class="filterPrevNextButtons" ></platform-filter-input-buttons-directive>\r\n  <platform-filter-input-directive class="filterInput" ></platform-filter-input-directive> -->\r\n  <lib-planning-board-assignments-filter-bar style="display: flex" [containerLink]="containerLink"></lib-planning-board-assignments-filter-bar>\r\n</div>\r\n<app-planning-board-main [containerLink]="containerLink"></app-planning-board-main>\r\n' }]
		  }], () => [{ type: ElementRef }], { containerLink: [{
			 type: Input
		  }] });
		})();
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(PlanningBoardAssignmentComponent, { className: "PlanningBoardAssignmentComponent", filePath: "lib\\components\\planning-board-assignment\\planning-board-assignment.component.ts", lineNumber: 26 });
		})();
		var _c0 = ["planningboardSplitterRoot"];
		var _c1 = ["app-planning-board-grid", ""];
		function PlanningBoardGridComponent_Conditional_10_Template(rf, ctx) {
		  if (rf & 1) {
			 \u0275\u0275elementStart(0, "div", 10);
			 \u0275\u0275element(1, "div", 3)(2, "app-planning-board-demand-grid", 4);
			 \u0275\u0275elementEnd();
		  }
		  if (rf & 2) {
			 const ctx_r0 = \u0275\u0275nextContext();
			 \u0275\u0275advance(2);
			 \u0275\u0275property("containerLink", ctx_r0.containerLink);
		  }
		}
		var PlanningBoardGridComponent = class _PlanningBoardGridComponent {
		  ngAfterViewInit() {
			 this.setupSplitter(this.containerLink.uuid);
			 setTimeout(this.resizeContainers, 250);
		  }
		  constructor(elementRef) {
			 this.elementRef = elementRef;
			 const _this = this;
			 this.containerLink = this.containerLink ? this.containerLink : document.getElementsByTagName("platform-planningboard-component")[0].scope;
			 const containerLink = this.containerLink;
			 const platformGridAPI = PlanningBoardExternalServices.platformGridAPI, mainViewService = PlanningBoardExternalServices.mainViewService;
			 const planningBoardDataService = this.planningBoardDataService = PlanningBoardDataServiceInterfaceService.getPlanningBoardDataServiceByUUID(containerLink.uuid);
			 let panelWidth = getParentPanelWidth();
			 let splitterRootElement, splitter, splitterstate = {
				left: 25,
				mid: 50,
				right: 25,
				leftcollapsed: false,
				midcollapsed: false,
				rightcollapsed: false
			 }, lastSplitterstate = {};
			 (0, import_lodash.assign)(splitterstate, mainViewService.customData(planningBoardDataService.getSupplierConfig().uuid, "splitterstate"));
			 (0, import_lodash.assign)(lastSplitterstate, splitterstate);
			 _this.elementRef.nativeElement.classList.add(containerLink.uuid);
			 window.addEventListener("resize", onContainerResize);
			 containerLink.onContentResized(onContainerResize);
			 planningBoardDataService.registerOnSettingsChanged(onSettingsChangedOrInit);
			 onSettingsChangedOrInit();
			 containerLink.registerFinalizer(function cleanupHandlers() {
				unregisterResizeEvents();
				platformGridAPI.events.unregister(planningBoardDataService.getSupplierConfig().uuid, "onHeaderToggled", onHeaderToggled);
			 });
			 containerLink.$watch(() => {
				return {
				  width: _this.elementRef.nativeElement.offsetWidth
				};
			 }, () => {
				const currentWidth = _this.elementRef.nativeElement.offsetWidth;
				if (currentWidth !== panelWidth) {
				  panelWidth = currentWidth;
				}
			 }, true);
			 planningBoardDataService.sharedData.status = "";
			 function saveSplitterState() {
				const leftpane = +(splitterRootElement.find("div#ui-layout-west.k-pane").width() || 0);
				const midpaneElem = splitterRootElement.find("div#ui-layout-center.k-pane");
				const midpane = +(midpaneElem.width() || 0);
				midpaneElem.find("#pane-c")[0].style.height = "100%";
				const rightPaneElem = splitterRootElement.find(" div#ui-layout-east.k-pane");
				let rightpane = 0;
				if (!(0, import_lodash.isNull)(rightPaneElem) && rightPaneElem.width() !== void 0) {
				  rightpane = +(rightPaneElem.width() || 0);
				}
				const fullWidth = leftpane + midpane + rightpane;
				splitterstate.leftcollapsed = 0 === leftpane;
				splitterstate.midcollapsed = 0 === midpane;
				splitterstate.rightcollapsed = 0 === rightpane;
				if (!splitterstate.leftcollapsed) {
				  splitterstate.left = Math.round(100 / fullWidth * leftpane || 0);
				}
				if (!splitterstate.midcollapsed) {
				  splitterstate.mid = Math.round(100 / fullWidth * midpane || 0);
				}
				if (!splitterstate.rightcollapsed) {
				  splitterstate.right = Math.round(100 / fullWidth * rightpane || 0);
				}
				if (!(0, import_lodash.isEqual)(splitterstate, lastSplitterstate)) {
				  mainViewService.customData(planningBoardDataService.getSupplierConfig().uuid, "splitterstate", splitterstate);
				  (0, import_lodash.assign)(lastSplitterstate, splitterstate);
				}
			 }
			 let lastSearchPanelOpen = false;
			 function onSettingsChangedOrInit() {
				platformGridAPI.events.register(planningBoardDataService.getSupplierConfig().uuid, "onHeaderToggled", onHeaderToggled);
			 }
			 function onHeaderToggled(event, info) {
				const filterrow = info.grid.filterRowVisibility();
				if (!lastSearchPanelOpen && info.findpanel && filterrow) {
				  info.grid.filterRowVisibility(false);
				}
				lastSearchPanelOpen = info.findpanel;
				_this.resizeContainers();
			 }
			 this.resizeContainers = () => {
				function asynchResize(gridId) {
				  setTimeout(function() {
					 const container = splitterRootElement.find("#" + gridId);
					 if (container) {
						resolvePromise(container);
					 } else {
						asynchResize(gridId);
					 }
				  }, 100);
				  return resolvePromise();
				}
				function fetchElements(gridId) {
				  let additionalHeight = 47;
				  if (planningBoardDataService.showSumAggregations()) {
					 additionalHeight += planningBoardDataService.sharedData.defaultFooterHeight - 8;
				  }
				  switch (planningBoardDataService.sharedData.activeSearchMode) {
					 case "columnSearch":
						additionalHeight -= 30;
						break;
					 case "searchBoth":
						additionalHeight -= 12;
						break;
					 default:
						break;
				  }
				  const gridContainer = splitterRootElement.find("#" + gridId);
				  if (gridContainer.length > 0) {
					 calculateResize(gridId, additionalHeight);
				  } else {
					 asynchResize(gridId).then(function() {
						calculateResize(gridId, additionalHeight);
					 });
				  }
				}
				function calculateResize(gridId, phHeight) {
				  if (containerLink.getCurrentDimensions) {
					 const pbParentContainerElem = document.getElementsByClassName("planningboardMain")[0].parentElement;
					 containerLink.getCurrentDimensions = () => {
						const pbElementBounds = pbParentContainerElem.getBoundingClientRect();
						return {
						  height: pbElementBounds.height,
						  width: pbElementBounds.width
						};
					 };
					 const dimensions = containerLink.getCurrentDimensions();
					 splitter.css("height", dimensions.height);
					 const splitBars = splitter.find(".k-splitbar");
					 if (splitBars.length > 0) {
						Array.from(splitBars).forEach((splitBarElem) => {
						  splitBarElem.style.height = "" + dimensions.height;
						});
					 }
					 const kPanes = splitter.find(".k-pane");
					 if (kPanes.length > 0) {
						Array.from(kPanes).forEach((kPaneElem) => {
						  kPaneElem.style.height = "" + dimensions.height;
						});
					 }
					 const pbGrids = splitter.find(".planningboard-grid");
					 if (pbGrids.length > 0) {
						Array.from(pbGrids).forEach((gridElem) => {
						  gridElem.style.height = dimensions.height - phHeight + "px";
						  gridElem.childNodes[0].style.height = "inherit";
						});
					 }
					 platformGridAPI.grids.resize(gridId);
				  }
				}
				fetchElements(planningBoardDataService.getSupplierConfig().uuid);
				const demandConfig = planningBoardDataService.getDemandConfig();
				if (demandConfig) {
				  fetchElements(demandConfig.uuid);
				}
			 };
			 this.setupSplitter = (uuid) => {
				splitterRootElement = $(".cid_" + uuid + " .planningboardMain");
				const panes = [
				  { collapsible: true, size: splitterstate.left + "%", collapsed: splitterstate.leftcollapsed },
				  { collapsible: true, size: splitterstate.mid + "%", collapsed: splitterstate.midcollapsed }
				];
				if (planningBoardDataService.getDemandConfig()) {
				  panes.push({
					 collapsible: true,
					 size: splitterstate.right + "%",
					 collapsed: splitterstate.rightcollapsed
				  });
				}
				splitter = splitterRootElement.find("div.planningboardSplitterRoot").kendoSplitter({
				  panes,
				  orientation: "horizontal"
				});
				splitter.data("kendoSplitter").bind("resize", onContainerResize);
				if ((0, import_lodash.isNil)(planningBoardDataService.getDemandConfig())) {
				  splitter.data("kendoSplitter").remove("#ui-layout-east");
				}
				setTimeout(() => {
				  const supplierFilterOptions = platformGridAPI.filters.getFilterOptions(planningBoardDataService.getSupplierConfig().uuid);
				  const activeFilterMode = Object.entries(supplierFilterOptions).filter((x) => x[1]).flatMap((x) => x)[0] || null;
				  const demandConfig = planningBoardDataService.getDemandConfig();
				  let filterModeString = "";
				  switch (activeFilterMode) {
					 case "showFilterRow":
						filterModeString = "columnSearch";
						break;
					 case "showMainTopPanel":
						filterModeString = "searchBoth";
						break;
					 default:
						break;
				  }
				  planningBoardDataService.sharedData.activeSearchMode = filterModeString;
				  if (demandConfig) {
					 platformGridAPI.filters.showSearch(demandConfig.uuid, filterModeString === "searchBoth");
					 platformGridAPI.filters.showColumnSearch(demandConfig.uuid, filterModeString === "columnSearch");
				  }
				  platformGridAPI.filters.showSearch(planningBoardDataService.getSupplierConfig().uuid, filterModeString === "searchBoth");
				  platformGridAPI.filters.showColumnSearch(planningBoardDataService.getSupplierConfig().uuid, filterModeString === "columnSearch");
				  _this.resizeContainers();
				  planningBoardDataService.getHelperServices().eventHandligSubjectService.onShowAssignmentFilterPanel$.fire(this.setupSplitter, filterModeString === "searchBoth", containerLink.getContainerUUID());
				}, 500);
				registerResizeEvents();
			 };
			 function registerResizeEvents() {
				const splitter2 = document.getElementById("planningboardSplitter");
				if (splitter2) {
				  splitter2.onresize = onContainerResize;
				}
			 }
			 function unregisterResizeEvents() {
				const splitter2 = document.getElementById("planningboardSplitter");
				if (splitter2) {
				  splitter2.onresize = null;
				}
				window.removeEventListener("resize", onContainerResize);
			 }
			 function onContainerResize() {
				panelWidth = getParentPanelWidth();
				if (splitterRootElement) {
				  saveSplitterState();
				  _this.resizeContainers();
				}
			 }
			 function getParentPanelWidth() {
				const firstElem = _this.elementRef.nativeElement;
				return firstElem.offsetWidth;
			 }
			 function resolvePromise(...data) {
				return new Promise((resolve, reject) => {
				  try {
					 resolve(data);
				  } catch {
					 reject("Oops... something went wrong");
				  }
				});
			 }
		  }
		  static {
			 this.\u0275fac = function PlanningBoardGridComponent_Factory(t) {
				return new (t || _PlanningBoardGridComponent)(\u0275\u0275directiveInject(ElementRef));
			 };
		  }
		  static {
			 this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _PlanningBoardGridComponent, selectors: [["", "app-planning-board-grid", ""]], viewQuery: function PlanningBoardGridComponent_Query(rf, ctx) {
				if (rf & 1) {
				  \u0275\u0275viewQuery(_c0, 5);
				}
				if (rf & 2) {
				  let _t;
				  \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.planningboardSplitterRoot = _t.first);
				}
			 }, inputs: { containerLink: "containerLink", planningBoardDataService: "planningBoardDataService" }, standalone: true, features: [\u0275\u0275StandaloneFeature], attrs: _c1, decls: 11, vars: 3, consts: [["planningboardSplitterRoot", ""], ["id", "planningboardSplitter", 1, "planningboardSplitterRoot"], ["id", "ui-layout-west"], [1, "filterPlaceholder", 2, "height", "0px"], [1, "planningboard-grid", 3, "containerLink"], ["id", "ui-layout-center"], ["id", "pane-c", 1, "flex-element", "centerPane"], [3, "containerLink"], ["data-basics-common-white-board", "", "data-show", "overlayInfo", "data-info", "overlayInfo"], ["cloud-common-overlay", "", "data-loading", "showLoadingOverlay"], ["id", "ui-layout-east"]], template: function PlanningBoardGridComponent_Template(rf, ctx) {
				if (rf & 1) {
				  \u0275\u0275elementStart(0, "div", 1, 0)(2, "div", 2);
				  \u0275\u0275element(3, "div", 3)(4, "app-planning-board-supplier-grid", 4);
				  \u0275\u0275elementEnd();
				  \u0275\u0275elementStart(5, "div", 5)(6, "div", 6);
				  \u0275\u0275element(7, "app-planning-board-assignment", 7)(8, "div", 8)(9, "div", 9);
				  \u0275\u0275elementEnd()();
				  \u0275\u0275template(10, PlanningBoardGridComponent_Conditional_10_Template, 3, 1, "div", 10);
				  \u0275\u0275elementEnd();
				}
				if (rf & 2) {
				  \u0275\u0275advance(4);
				  \u0275\u0275property("containerLink", ctx.containerLink);
				  \u0275\u0275advance(3);
				  \u0275\u0275property("containerLink", ctx.containerLink);
				  \u0275\u0275advance(3);
				  \u0275\u0275conditional(10, ctx.planningBoardDataService.getDemandConfig() ? 10 : -1);
				}
			 }, dependencies: [
				PlanningBoardSupplierGridComponent,
				PlanningBoardDemandGridComponent,
				PlanningBoardAssignmentComponent
			 ] });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlanningBoardGridComponent, [{
			 type: Component,
			 args: [{ standalone: true, selector: "[app-planning-board-grid]", imports: [
				PlanningBoardSupplierGridComponent,
				PlanningBoardDemandGridComponent,
				PlanningBoardAssignmentComponent
			 ], schemas: [CUSTOM_ELEMENTS_SCHEMA], template: '<div #planningboardSplitterRoot class="planningboardSplitterRoot" id="planningboardSplitter">\r\n	<div id="ui-layout-west">\r\n		<div class="filterPlaceholder" style="height: 0px;"></div>\r\n		<app-planning-board-supplier-grid [containerLink]="containerLink" class="planningboard-grid">\r\n\r\n		</app-planning-board-supplier-grid>\r\n	</div>\r\n	<div id="ui-layout-center">\r\n		<div id="pane-c" class="flex-element centerPane">\r\n			<app-planning-board-assignment [containerLink]="containerLink">\r\n\r\n			</app-planning-board-assignment>\r\n			<div data-basics-common-white-board data-show="overlayInfo" data-info="overlayInfo"></div>\r\n			<div cloud-common-overlay data-loading="showLoadingOverlay"></div>\r\n		</div>\r\n	</div>\r\n  @if (planningBoardDataService.getDemandConfig()) {\r\n    <div id="ui-layout-east">\r\n      <div class="filterPlaceholder" style="height: 0px;"></div>\r\n      <app-planning-board-demand-grid [containerLink]="containerLink" class="planningboard-grid">\r\n\r\n      </app-planning-board-demand-grid>\r\n    </div>\r\n  }\r\n\r\n</div>\r\n' }]
		  }], () => [{ type: ElementRef }], { containerLink: [{
			 type: Input
		  }], planningBoardDataService: [{
			 type: Input
		  }], planningboardSplitterRoot: [{
			 type: ViewChild,
			 args: ["planningboardSplitterRoot"]
		  }] });
		})();
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(PlanningBoardGridComponent, { className: "PlanningBoardGridComponent", filePath: "lib\\components\\planning-board-grid\\planning-board-grid.component.ts", lineNumber: 26 });
		})();

		// src/app/componentsForElements/planning-board-main-component-element/planning-board-main-component-element.component.ts
		var PlanningBoardMainComponentElementComponent = class _PlanningBoardMainComponentElementComponent {
		  constructor(elementRef) {
			 selection_default.prototype.attrs = function(object) {
				Object.entries(object).forEach((entry) => {
				  this.attr(entry[0], entry[1]);
				});
				return this;
			 };
			 selection_default.prototype.parent = function selectParent() {
				return this.select(() => {
				  return this.parentNode;
				});
			 };
			 this.scope = elementRef.nativeElement.scope;
		  }
		  static {
			 this.\u0275fac = function PlanningBoardMainComponentElementComponent_Factory(t) {
				return new (t || _PlanningBoardMainComponentElementComponent)(\u0275\u0275directiveInject(ElementRef));
			 };
		  }
		  static {
			 this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _PlanningBoardMainComponentElementComponent, selectors: [["app-planning-board-main-component-element"]], standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 1, vars: 1, consts: [["app-planning-board-grid", "", 3, "containerLink"]], template: function PlanningBoardMainComponentElementComponent_Template(rf, ctx) {
				if (rf & 1) {
				  \u0275\u0275element(0, "div", 0);
				}
				if (rf & 2) {
				  \u0275\u0275property("containerLink", ctx.scope);
				}
			 }, dependencies: [PlanningBoardGridComponent] });
		  }
		};
		(() => {
		  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(PlanningBoardMainComponentElementComponent, { className: "PlanningBoardMainComponentElementComponent", filePath: "src\\app\\componentsForElements\\planning-board-main-component-element\\planning-board-main-component-element.component.ts", lineNumber: 14 });
		})();

		// src/main.ts
		var elem = document.getElementById("appContainer");
		if (elem) {
		  elem.classList.add("app-root");
		}
		createApplication().then((appRef) => {
		  if (!customElements.get("platform-planningboard-component")) {
			 const planningBoardMainComponentElem = createCustomElement(PlanningBoardMainComponentElementComponent, {
				injector: appRef.injector
			 });
			 customElements.define("platform-planningboard-component", planningBoardMainComponentElem);
		  }
		});
		// node_modules/zone.js/fesm2015/zone.js

		function __symbol__(name) {
		  const symbolPrefix = copyGlobalForElem["__Zone_symbol_prefix"] || "__zone_symbol__";
		  return symbolPrefix + name;
		}
		function initZone() {
		  const performance = copyGlobalForElem["performance"];
		  function mark(name) {
			 performance && performance["mark"] && performance["mark"](name);
		  }
		  function performanceMeasure(name, label) {
			 performance && performance["measure"] && performance["measure"](name, label);
		  }
		  mark("Zone");
		  class ZoneImpl {
			 static {
				this.__symbol__ = __symbol__;
			 }
			 static assertZonePatched() {
				if (copyGlobalForElem["Promise"] !== patches["ZoneAwarePromise"]) {
				  throw new Error("Zone.js has detected that ZoneAwarePromise `(window|copyGlobalForElem).Promise` has been overwritten.\nMost likely cause is that a Promise polyfill has been loaded after Zone.js (Polyfilling Promise api is not necessary when zone.js is loaded. If you must load one, do so before loading zone.js.)");
				}
			 }
			 static get root() {
				let zone = ZoneImpl.current;
				while (zone.parent) {
				  zone = zone.parent;
				}
				return zone;
			 }
			 static get current() {
				return _currentZoneFrame.zone;
			 }
			 static get currentTask() {
				return _currentTask;
			 }
			 // tslint:disable-next-line:require-internal-with-underscore
			 static __load_patch(name, fn, ignoreDuplicate = false) {
				if (patches.hasOwnProperty(name)) {
				  const checkDuplicate = copyGlobalForElem[__symbol__("forceDuplicateZoneCheck")] === true;
				  if (!ignoreDuplicate && checkDuplicate) {
					 throw Error("Already loaded patch: " + name);
				  }
				} else if (!copyGlobalForElem["__Zone_disable_" + name]) {
				  const perfName = "Zone:" + name;
				  mark(perfName);
				  patches[name] = fn(copyGlobalForElem, ZoneImpl, _api);
				  performanceMeasure(perfName, perfName);
				}
			 }
			 get parent() {
				return this._parent;
			 }
			 get name() {
				return this._name;
			 }
			 constructor(parent, zoneSpec) {
				this._parent = parent;
				this._name = zoneSpec ? zoneSpec.name || "unnamed" : "<root>";
				this._properties = zoneSpec && zoneSpec.properties || {};
				this._zoneDelegate = new _ZoneDelegate(this, this._parent && this._parent._zoneDelegate, zoneSpec);
			 }
			 get(key) {
				const zone = this.getZoneWith(key);
				if (zone)
				  return zone._properties[key];
			 }
			 getZoneWith(key) {
				let current = this;
				while (current) {
				  if (current._properties.hasOwnProperty(key)) {
					 return current;
				  }
				  current = current._parent;
				}
				return null;
			 }
			 fork(zoneSpec) {
				if (!zoneSpec)
				  throw new Error("ZoneSpec required!");
				return this._zoneDelegate.fork(this, zoneSpec);
			 }
			 wrap(callback, source) {
				if (typeof callback !== "function") {
				  throw new Error("Expecting function got: " + callback);
				}
				const _callback = this._zoneDelegate.intercept(this, callback, source);
				const zone = this;
				return function() {
				  return zone.runGuarded(_callback, this, arguments, source);
				};
			 }
			 run(callback, applyThis, applyArgs, source) {
				_currentZoneFrame = { parent: _currentZoneFrame, zone: this };
				try {
				  return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);
				} finally {
				  _currentZoneFrame = _currentZoneFrame.parent;
				}
			 }
			 runGuarded(callback, applyThis = null, applyArgs, source) {
				_currentZoneFrame = { parent: _currentZoneFrame, zone: this };
				try {
				  try {
					 return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);
				  } catch (error) {
					 if (this._zoneDelegate.handleError(this, error)) {
						throw error;
					 }
				  }
				} finally {
				  _currentZoneFrame = _currentZoneFrame.parent;
				}
			 }
			 runTask(task, applyThis, applyArgs) {
				if (task.zone != this) {
				  throw new Error("A task can only be run in the zone of creation! (Creation: " + (task.zone || NO_ZONE).name + "; Execution: " + this.name + ")");
				}
				const zoneTask = task;
				const { type, data: { isPeriodic = false, isRefreshable = false } = {} } = task;
				if (task.state === notScheduled && (type === eventTask || type === macroTask)) {
				  return;
				}
				const reEntryGuard = task.state != running;
				reEntryGuard && zoneTask._transitionTo(running, scheduled);
				const previousTask = _currentTask;
				_currentTask = zoneTask;
				_currentZoneFrame = { parent: _currentZoneFrame, zone: this };
				try {
				  if (type == macroTask && task.data && !isPeriodic && !isRefreshable) {
					 task.cancelFn = void 0;
				  }
				  try {
					 return this._zoneDelegate.invokeTask(this, zoneTask, applyThis, applyArgs);
				  } catch (error) {
					 if (this._zoneDelegate.handleError(this, error)) {
						throw error;
					 }
				  }
				} finally {
				  const state = task.state;
				  if (state !== notScheduled && state !== unknown) {
					 if (type == eventTask || isPeriodic || isRefreshable && state === scheduling) {
						reEntryGuard && zoneTask._transitionTo(scheduled, running, scheduling);
					 } else {
						const zoneDelegates = zoneTask._zoneDelegates;
						this._updateTaskCount(zoneTask, -1);
						reEntryGuard && zoneTask._transitionTo(notScheduled, running, notScheduled);
						if (isRefreshable) {
						  zoneTask._zoneDelegates = zoneDelegates;
						}
					 }
				  }
				  _currentZoneFrame = _currentZoneFrame.parent;
				  _currentTask = previousTask;
				}
			 }
			 scheduleTask(task) {
				if (task.zone && task.zone !== this) {
				  let newZone = this;
				  while (newZone) {
					 if (newZone === task.zone) {
						throw Error(`can not reschedule task to ${this.name} which is descendants of the original zone ${task.zone.name}`);
					 }
					 newZone = newZone.parent;
				  }
				}
				task._transitionTo(scheduling, notScheduled);
				const zoneDelegates = [];
				task._zoneDelegates = zoneDelegates;
				task._zone = this;
				try {
				  task = this._zoneDelegate.scheduleTask(this, task);
				} catch (err) {
				  task._transitionTo(unknown, scheduling, notScheduled);
				  this._zoneDelegate.handleError(this, err);
				  throw err;
				}
				if (task._zoneDelegates === zoneDelegates) {
				  this._updateTaskCount(task, 1);
				}
				if (task.state == scheduling) {
				  task._transitionTo(scheduled, scheduling);
				}
				return task;
			 }
			 scheduleMicroTask(source, callback, data, customSchedule) {
				return this.scheduleTask(new ZoneTask(microTask, source, callback, data, customSchedule, void 0));
			 }
			 scheduleMacroTask(source, callback, data, customSchedule, customCancel) {
				return this.scheduleTask(new ZoneTask(macroTask, source, callback, data, customSchedule, customCancel));
			 }
			 scheduleEventTask(source, callback, data, customSchedule, customCancel) {
				return this.scheduleTask(new ZoneTask(eventTask, source, callback, data, customSchedule, customCancel));
			 }
			 cancelTask(task) {
				if (task.zone != this)
				  throw new Error("A task can only be cancelled in the zone of creation! (Creation: " + (task.zone || NO_ZONE).name + "; Execution: " + this.name + ")");
				if (task.state !== scheduled && task.state !== running) {
				  return;
				}
				task._transitionTo(canceling, scheduled, running);
				try {
				  this._zoneDelegate.cancelTask(this, task);
				} catch (err) {
				  task._transitionTo(unknown, canceling);
				  this._zoneDelegate.handleError(this, err);
				  throw err;
				}
				this._updateTaskCount(task, -1);
				task._transitionTo(notScheduled, canceling);
				task.runCount = -1;
				return task;
			 }
			 _updateTaskCount(task, count) {
				const zoneDelegates = task._zoneDelegates;
				if (count == -1) {
				  task._zoneDelegates = null;
				}
				for (let i = 0; i < zoneDelegates.length; i++) {
				  zoneDelegates[i]._updateTaskCount(task.type, count);
				}
			 }
		  }
		  const DELEGATE_ZS = {
			 name: "",
			 onHasTask: (delegate, _, target, hasTaskState) => delegate.hasTask(target, hasTaskState),
			 onScheduleTask: (delegate, _, target, task) => delegate.scheduleTask(target, task),
			 onInvokeTask: (delegate, _, target, task, applyThis, applyArgs) => delegate.invokeTask(target, task, applyThis, applyArgs),
			 onCancelTask: (delegate, _, target, task) => delegate.cancelTask(target, task)
		  };
		  class _ZoneDelegate {
			 get zone() {
				return this._zone;
			 }
			 constructor(zone, parentDelegate, zoneSpec) {
				this._taskCounts = {
				  "microTask": 0,
				  "macroTask": 0,
				  "eventTask": 0
				};
				this._zone = zone;
				this._parentDelegate = parentDelegate;
				this._forkZS = zoneSpec && (zoneSpec && zoneSpec.onFork ? zoneSpec : parentDelegate._forkZS);
				this._forkDlgt = zoneSpec && (zoneSpec.onFork ? parentDelegate : parentDelegate._forkDlgt);
				this._forkCurrZone = zoneSpec && (zoneSpec.onFork ? this._zone : parentDelegate._forkCurrZone);
				this._interceptZS = zoneSpec && (zoneSpec.onIntercept ? zoneSpec : parentDelegate._interceptZS);
				this._interceptDlgt = zoneSpec && (zoneSpec.onIntercept ? parentDelegate : parentDelegate._interceptDlgt);
				this._interceptCurrZone = zoneSpec && (zoneSpec.onIntercept ? this._zone : parentDelegate._interceptCurrZone);
				this._invokeZS = zoneSpec && (zoneSpec.onInvoke ? zoneSpec : parentDelegate._invokeZS);
				this._invokeDlgt = zoneSpec && (zoneSpec.onInvoke ? parentDelegate : parentDelegate._invokeDlgt);
				this._invokeCurrZone = zoneSpec && (zoneSpec.onInvoke ? this._zone : parentDelegate._invokeCurrZone);
				this._handleErrorZS = zoneSpec && (zoneSpec.onHandleError ? zoneSpec : parentDelegate._handleErrorZS);
				this._handleErrorDlgt = zoneSpec && (zoneSpec.onHandleError ? parentDelegate : parentDelegate._handleErrorDlgt);
				this._handleErrorCurrZone = zoneSpec && (zoneSpec.onHandleError ? this._zone : parentDelegate._handleErrorCurrZone);
				this._scheduleTaskZS = zoneSpec && (zoneSpec.onScheduleTask ? zoneSpec : parentDelegate._scheduleTaskZS);
				this._scheduleTaskDlgt = zoneSpec && (zoneSpec.onScheduleTask ? parentDelegate : parentDelegate._scheduleTaskDlgt);
				this._scheduleTaskCurrZone = zoneSpec && (zoneSpec.onScheduleTask ? this._zone : parentDelegate._scheduleTaskCurrZone);
				this._invokeTaskZS = zoneSpec && (zoneSpec.onInvokeTask ? zoneSpec : parentDelegate._invokeTaskZS);
				this._invokeTaskDlgt = zoneSpec && (zoneSpec.onInvokeTask ? parentDelegate : parentDelegate._invokeTaskDlgt);
				this._invokeTaskCurrZone = zoneSpec && (zoneSpec.onInvokeTask ? this._zone : parentDelegate._invokeTaskCurrZone);
				this._cancelTaskZS = zoneSpec && (zoneSpec.onCancelTask ? zoneSpec : parentDelegate._cancelTaskZS);
				this._cancelTaskDlgt = zoneSpec && (zoneSpec.onCancelTask ? parentDelegate : parentDelegate._cancelTaskDlgt);
				this._cancelTaskCurrZone = zoneSpec && (zoneSpec.onCancelTask ? this._zone : parentDelegate._cancelTaskCurrZone);
				this._hasTaskZS = null;
				this._hasTaskDlgt = null;
				this._hasTaskDlgtOwner = null;
				this._hasTaskCurrZone = null;
				const zoneSpecHasTask = zoneSpec && zoneSpec.onHasTask;
				const parentHasTask = parentDelegate && parentDelegate._hasTaskZS;
				if (zoneSpecHasTask || parentHasTask) {
				  this._hasTaskZS = zoneSpecHasTask ? zoneSpec : DELEGATE_ZS;
				  this._hasTaskDlgt = parentDelegate;
				  this._hasTaskDlgtOwner = this;
				  this._hasTaskCurrZone = this._zone;
				  if (!zoneSpec.onScheduleTask) {
					 this._scheduleTaskZS = DELEGATE_ZS;
					 this._scheduleTaskDlgt = parentDelegate;
					 this._scheduleTaskCurrZone = this._zone;
				  }
				  if (!zoneSpec.onInvokeTask) {
					 this._invokeTaskZS = DELEGATE_ZS;
					 this._invokeTaskDlgt = parentDelegate;
					 this._invokeTaskCurrZone = this._zone;
				  }
				  if (!zoneSpec.onCancelTask) {
					 this._cancelTaskZS = DELEGATE_ZS;
					 this._cancelTaskDlgt = parentDelegate;
					 this._cancelTaskCurrZone = this._zone;
				  }
				}
			 }
			 fork(targetZone, zoneSpec) {
				return this._forkZS ? this._forkZS.onFork(this._forkDlgt, this.zone, targetZone, zoneSpec) : new ZoneImpl(targetZone, zoneSpec);
			 }
			 intercept(targetZone, callback, source) {
				return this._interceptZS ? this._interceptZS.onIntercept(this._interceptDlgt, this._interceptCurrZone, targetZone, callback, source) : callback;
			 }
			 invoke(targetZone, callback, applyThis, applyArgs, source) {
				return this._invokeZS ? this._invokeZS.onInvoke(this._invokeDlgt, this._invokeCurrZone, targetZone, callback, applyThis, applyArgs, source) : callback.apply(applyThis, applyArgs);
			 }
			 handleError(targetZone, error) {
				return this._handleErrorZS ? this._handleErrorZS.onHandleError(this._handleErrorDlgt, this._handleErrorCurrZone, targetZone, error) : true;
			 }
			 scheduleTask(targetZone, task) {
				let returnTask = task;
				if (this._scheduleTaskZS) {
				  if (this._hasTaskZS) {
					 returnTask._zoneDelegates.push(this._hasTaskDlgtOwner);
				  }
				  returnTask = this._scheduleTaskZS.onScheduleTask(this._scheduleTaskDlgt, this._scheduleTaskCurrZone, targetZone, task);
				  if (!returnTask)
					 returnTask = task;
				} else {
				  if (task.scheduleFn) {
					 task.scheduleFn(task);
				  } else if (task.type == microTask) {
					 scheduleMicroTask(task);
				  } else {
					 throw new Error("Task is missing scheduleFn.");
				  }
				}
				return returnTask;
			 }
			 invokeTask(targetZone, task, applyThis, applyArgs) {
				return this._invokeTaskZS ? this._invokeTaskZS.onInvokeTask(this._invokeTaskDlgt, this._invokeTaskCurrZone, targetZone, task, applyThis, applyArgs) : task.callback.apply(applyThis, applyArgs);
			 }
			 cancelTask(targetZone, task) {
				let value;
				if (this._cancelTaskZS) {
				  value = this._cancelTaskZS.onCancelTask(this._cancelTaskDlgt, this._cancelTaskCurrZone, targetZone, task);
				} else {
				  if (!task.cancelFn) {
					 throw Error("Task is not cancelable");
				  }
				  value = task.cancelFn(task);
				}
				return value;
			 }
			 hasTask(targetZone, isEmpty) {
				try {
				  this._hasTaskZS && this._hasTaskZS.onHasTask(this._hasTaskDlgt, this._hasTaskCurrZone, targetZone, isEmpty);
				} catch (err) {
				  this.handleError(targetZone, err);
				}
			 }
			 // tslint:disable-next-line:require-internal-with-underscore
			 _updateTaskCount(type, count) {
				const counts = this._taskCounts;
				const prev = counts[type];
				const next = counts[type] = prev + count;
				if (next < 0) {
				  throw new Error("More tasks executed then were scheduled.");
				}
				if (prev == 0 || next == 0) {
				  const isEmpty = {
					 microTask: counts["microTask"] > 0,
					 macroTask: counts["macroTask"] > 0,
					 eventTask: counts["eventTask"] > 0,
					 change: type
				  };
				  this.hasTask(this._zone, isEmpty);
				}
			 }
		  }
		  class ZoneTask {
			 constructor(type, source, callback, options, scheduleFn, cancelFn) {
				this._zone = null;
				this.runCount = 0;
				this._zoneDelegates = null;
				this._state = "notScheduled";
				this.type = type;
				this.source = source;
				this.data = options;
				this.scheduleFn = scheduleFn;
				this.cancelFn = cancelFn;
				if (!callback) {
				  throw new Error("callback is not defined");
				}
				this.callback = callback;
				const self2 = this;
				if (type === eventTask && options && options.useG) {
				  this.invoke = ZoneTask.invokeTask;
				} else {
				  this.invoke = function() {
					 return ZoneTask.invokeTask.call(copyGlobalForElem, self2, this, arguments);
				  };
				}
			 }
			 static invokeTask(task, target, args) {
				if (!task) {
				  task = this;
				}
				_numberOfNestedTaskFrames++;
				try {
				  task.runCount++;
				  return task.zone.runTask(task, target, args);
				} finally {
				  if (_numberOfNestedTaskFrames == 1) {
					 drainMicroTaskQueue();
				  }
				  _numberOfNestedTaskFrames--;
				}
			 }
			 get zone() {
				return this._zone;
			 }
			 get state() {
				return this._state;
			 }
			 cancelScheduleRequest() {
				this._transitionTo(notScheduled, scheduling);
			 }
			 // tslint:disable-next-line:require-internal-with-underscore
			 _transitionTo(toState, fromState1, fromState2) {
				if (this._state === fromState1 || this._state === fromState2) {
				  this._state = toState;
				  if (toState == notScheduled) {
					 this._zoneDelegates = null;
				  }
				} else {
				  throw new Error(`${this.type} '${this.source}': can not transition to '${toState}', expecting state '${fromState1}'${fromState2 ? " or '" + fromState2 + "'" : ""}, was '${this._state}'.`);
				}
			 }
			 toString() {
				if (this.data && typeof this.data.handleId !== "undefined") {
				  return this.data.handleId.toString();
				} else {
				  return Object.prototype.toString.call(this);
				}
			 }
			 // add toJSON method to prevent cyclic error when
			 // call JSON.stringify(zoneTask)
			 toJSON() {
				return {
				  type: this.type,
				  state: this.state,
				  source: this.source,
				  zone: this.zone.name,
				  runCount: this.runCount
				};
			 }
		  }
		  const symbolSetTimeout = __symbol__("setTimeout");
		  const symbolPromise = __symbol__("Promise");
		  const symbolThen = __symbol__("then");
		  let _microTaskQueue = [];
		  let _isDrainingMicrotaskQueue = false;
		  let nativeMicroTaskQueuePromise;
		  function nativeScheduleMicroTask(func) {
			 if (!nativeMicroTaskQueuePromise) {
				if (copyGlobalForElem[symbolPromise]) {
				  nativeMicroTaskQueuePromise = copyGlobalForElem[symbolPromise].resolve(0);
				}
			 }
			 if (nativeMicroTaskQueuePromise) {
				let nativeThen = nativeMicroTaskQueuePromise[symbolThen];
				if (!nativeThen) {
				  nativeThen = nativeMicroTaskQueuePromise["then"];
				}
				nativeThen.call(nativeMicroTaskQueuePromise, func);
			 } else {
				copyGlobalForElem[symbolSetTimeout](func, 0);
			 }
		  }
		  function scheduleMicroTask(task) {
			 if (_numberOfNestedTaskFrames === 0 && _microTaskQueue.length === 0) {
				nativeScheduleMicroTask(drainMicroTaskQueue);
			 }
			 task && _microTaskQueue.push(task);
		  }
		  function drainMicroTaskQueue() {
			 if (!_isDrainingMicrotaskQueue) {
				_isDrainingMicrotaskQueue = true;
				while (_microTaskQueue.length) {
				  const queue = _microTaskQueue;
				  _microTaskQueue = [];
				  for (let i = 0; i < queue.length; i++) {
					 const task = queue[i];
					 try {
						task.zone.runTask(task, null, null);
					 } catch (error) {
						_api.onUnhandledError(error);
					 }
				  }
				}
				_api.microtaskDrainDone();
				_isDrainingMicrotaskQueue = false;
			 }
		  }
		  const NO_ZONE = { name: "NO ZONE" };
		  const notScheduled = "notScheduled", scheduling = "scheduling", scheduled = "scheduled", running = "running", canceling = "canceling", unknown = "unknown";
		  const microTask = "microTask", macroTask = "macroTask", eventTask = "eventTask";
		  const patches = {};
		  const _api = {
			 symbol: __symbol__,
			 currentZoneFrame: () => _currentZoneFrame,
			 onUnhandledError: noop,
			 microtaskDrainDone: noop,
			 scheduleMicroTask,
			 showUncaughtError: () => !ZoneImpl[__symbol__("ignoreConsoleErrorUncaughtError")],
			 patchEventTarget: () => [],
			 patchOnProperties: noop,
			 patchMethod: () => noop,
			 bindArguments: () => [],
			 patchThen: () => noop,
			 patchMacroTask: () => noop,
			 patchEventPrototype: () => noop,
			 isIEOrEdge: () => false,
			 getGlobalObjects: () => void 0,
			 ObjectDefineProperty: () => noop,
			 ObjectGetOwnPropertyDescriptor: () => void 0,
			 ObjectCreate: () => void 0,
			 ArraySlice: () => [],
			 patchClass: () => noop,
			 wrapWithCurrentZone: () => noop,
			 filterProperties: () => [],
			 attachOriginToPatched: () => noop,
			 _redefineProperty: () => noop,
			 patchCallbacks: () => noop,
			 nativeScheduleMicroTask
		  };
		  let _currentZoneFrame = { parent: null, zone: new ZoneImpl(null, null) };
		  let _currentTask = null;
		  let _numberOfNestedTaskFrames = 0;
		  function noop() {
		  }
		  performanceMeasure("Zone", "Zone");
		  return ZoneImpl;
		}
		function loadZone() {
		  const global2 = globalThis;
		  const checkDuplicate = global2[__symbol__("forceDuplicateZoneCheck")] === true;
		  if (global2["Zone"] && (checkDuplicate || typeof global2["Zone"].__symbol__ !== "function")) {
			 throw new Error("Zone already loaded.");
		  }
		  global2["Zone"] ??= initZone();
		  return global2["Zone"];
		}
		var ObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
		var ObjectDefineProperty = Object.defineProperty;
		var ObjectGetPrototypeOf = Object.getPrototypeOf;
		var ObjectCreate = Object.create;
		var ArraySlice = Array.prototype.slice;
		var ADD_EVENT_LISTENER_STR = "addEventListener";
		var REMOVE_EVENT_LISTENER_STR = "removeEventListener";
		var ZONE_SYMBOL_ADD_EVENT_LISTENER = __symbol__(ADD_EVENT_LISTENER_STR);
		var ZONE_SYMBOL_REMOVE_EVENT_LISTENER = __symbol__(REMOVE_EVENT_LISTENER_STR);
		var TRUE_STR = "true";
		var FALSE_STR = "false";
		var ZONE_SYMBOL_PREFIX = __symbol__("");
		function wrapWithCurrentZone(callback, source) {
		  return Zone.current.wrap(callback, source);
		}
		function scheduleMacroTaskWithCurrentZone(source, callback, data, customSchedule, customCancel) {
		  return Zone.current.scheduleMacroTask(source, callback, data, customSchedule, customCancel);
		}
		var zoneSymbol = __symbol__;
		var isWindowExists = typeof window !== "undefined";
		var internalWindow = isWindowExists ? window : void 0;
		var _global = isWindowExists && internalWindow || globalThis;
		var REMOVE_ATTRIBUTE = "removeAttribute";
		function bindArguments(args, source) {
		  for (let i = args.length - 1; i >= 0; i--) {
			 if (typeof args[i] === "function") {
				args[i] = wrapWithCurrentZone(args[i], source + "_" + i);
			 }
		  }
		  return args;
		}
		function patchPrototype(prototype, fnNames) {
		  const source = prototype.constructor["name"];
		  for (let i = 0; i < fnNames.length; i++) {
			 const name = fnNames[i];
			 const delegate = prototype[name];
			 if (delegate) {
				const prototypeDesc = ObjectGetOwnPropertyDescriptor(prototype, name);
				if (!isPropertyWritable(prototypeDesc)) {
				  continue;
				}
				prototype[name] = ((delegate2) => {
				  const patched = function() {
					 return delegate2.apply(this, bindArguments(arguments, source + "." + name));
				  };
				  attachOriginToPatched(patched, delegate2);
				  return patched;
				})(delegate);
			 }
		  }
		}
		function isPropertyWritable(propertyDesc) {
		  if (!propertyDesc) {
			 return true;
		  }
		  if (propertyDesc.writable === false) {
			 return false;
		  }
		  return !(typeof propertyDesc.get === "function" && typeof propertyDesc.set === "undefined");
		}
		var isWebWorker = typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope;
		var isNode = !("nw" in _global) && typeof _global.process !== "undefined" && _global.process.toString() === "[object process]";
		var isBrowser = !isNode && !isWebWorker && !!(isWindowExists && internalWindow["HTMLElement"]);
		var isMix = typeof _global.process !== "undefined" && _global.process.toString() === "[object process]" && !isWebWorker && !!(isWindowExists && internalWindow["HTMLElement"]);
		var zoneSymbolEventNames$1 = {};
		var enableBeforeunloadSymbol = zoneSymbol("enable_beforeunload");
		var wrapFn = function(event) {
		  event = event || _global.event;
		  if (!event) {
			 return;
		  }
		  let eventNameSymbol = zoneSymbolEventNames$1[event.type];
		  if (!eventNameSymbol) {
			 eventNameSymbol = zoneSymbolEventNames$1[event.type] = zoneSymbol("ON_PROPERTY" + event.type);
		  }
		  const target = this || event.target || _global;
		  const listener = target[eventNameSymbol];
		  let result;
		  if (isBrowser && target === internalWindow && event.type === "error") {
			 const errorEvent = event;
			 result = listener && listener.call(this, errorEvent.message, errorEvent.filename, errorEvent.lineno, errorEvent.colno, errorEvent.error);
			 if (result === true) {
				event.preventDefault();
			 }
		  } else {
			 result = listener && listener.apply(this, arguments);
			 if (
				// https://github.com/angular/angular/issues/47579
				// https://www.w3.org/TR/2011/WD-html5-20110525/history.html#beforeunloadevent
				// This is the only specific case we should check for. The spec defines that the
				// `returnValue` attribute represents the message to show the user. When the event
				// is created, this attribute must be set to the empty string.
				event.type === "beforeunload" && // To prevent any breaking changes resulting from this change, given that
				// it was already causing a significant number of failures in G3, we have hidden
				// that behavior behind a copyGlobalForElem configuration flag. Consumers can enable this
				// flag explicitly if they want the `beforeunload` event to be handled as defined
				// in the specification.
				_global[enableBeforeunloadSymbol] && // The IDL event definition is `attribute DOMString returnValue`, so we check whether
				// `typeof result` is a string.
				typeof result === "string"
			 ) {
				event.returnValue = result;
			 } else if (result != void 0 && !result) {
				event.preventDefault();
			 }
		  }
		  return result;
		};
		function patchProperty(obj, prop, prototype) {
		  let desc = ObjectGetOwnPropertyDescriptor(obj, prop);
		  if (!desc && prototype) {
			 const prototypeDesc = ObjectGetOwnPropertyDescriptor(prototype, prop);
			 if (prototypeDesc) {
				desc = { enumerable: true, configurable: true };
			 }
		  }
		  if (!desc || !desc.configurable) {
			 return;
		  }
		  const onPropPatchedSymbol = zoneSymbol("on" + prop + "patched");
		  if (obj.hasOwnProperty(onPropPatchedSymbol) && obj[onPropPatchedSymbol]) {
			 return;
		  }
		  delete desc.writable;
		  delete desc.value;
		  const originalDescGet = desc.get;
		  const originalDescSet = desc.set;
		  const eventName = prop.slice(2);
		  let eventNameSymbol = zoneSymbolEventNames$1[eventName];
		  if (!eventNameSymbol) {
			 eventNameSymbol = zoneSymbolEventNames$1[eventName] = zoneSymbol("ON_PROPERTY" + eventName);
		  }
		  desc.set = function(newValue) {
			 let target = this;
			 if (!target && obj === _global) {
				target = _global;
			 }
			 if (!target) {
				return;
			 }
			 const previousValue = target[eventNameSymbol];
			 if (typeof previousValue === "function") {
				target.removeEventListener(eventName, wrapFn);
			 }
			 originalDescSet && originalDescSet.call(target, null);
			 target[eventNameSymbol] = newValue;
			 if (typeof newValue === "function") {
				target.addEventListener(eventName, wrapFn, false);
			 }
		  };
		  desc.get = function() {
			 let target = this;
			 if (!target && obj === _global) {
				target = _global;
			 }
			 if (!target) {
				return null;
			 }
			 const listener = target[eventNameSymbol];
			 if (listener) {
				return listener;
			 } else if (originalDescGet) {
				let value = originalDescGet.call(this);
				if (value) {
				  desc.set.call(this, value);
				  if (typeof target[REMOVE_ATTRIBUTE] === "function") {
					 target.removeAttribute(prop);
				  }
				  return value;
				}
			 }
			 return null;
		  };
		  ObjectDefineProperty(obj, prop, desc);
		  obj[onPropPatchedSymbol] = true;
		}
		function patchOnProperties(obj, properties, prototype) {
		  if (properties) {
			 for (let i = 0; i < properties.length; i++) {
				patchProperty(obj, "on" + properties[i], prototype);
			 }
		  } else {
			 const onProperties = [];
			 for (const prop in obj) {
				if (prop.slice(0, 2) == "on") {
				  onProperties.push(prop);
				}
			 }
			 for (let j = 0; j < onProperties.length; j++) {
				patchProperty(obj, onProperties[j], prototype);
			 }
		  }
		}
		var originalInstanceKey = zoneSymbol("originalInstance");
		function patchClass(className) {
		  const OriginalClass = _global[className];
		  if (!OriginalClass)
			 return;
		  _global[zoneSymbol(className)] = OriginalClass;
		  _global[className] = function() {
			 const a = bindArguments(arguments, className);
			 switch (a.length) {
				case 0:
				  this[originalInstanceKey] = new OriginalClass();
				  break;
				case 1:
				  this[originalInstanceKey] = new OriginalClass(a[0]);
				  break;
				case 2:
				  this[originalInstanceKey] = new OriginalClass(a[0], a[1]);
				  break;
				case 3:
				  this[originalInstanceKey] = new OriginalClass(a[0], a[1], a[2]);
				  break;
				case 4:
				  this[originalInstanceKey] = new OriginalClass(a[0], a[1], a[2], a[3]);
				  break;
				default:
				  throw new Error("Arg list too long.");
			 }
		  };
		  attachOriginToPatched(_global[className], OriginalClass);
		  const instance = new OriginalClass(function() {
		  });
		  let prop;
		  for (prop in instance) {
			 if (className === "XMLHttpRequest" && prop === "responseBlob")
				continue;
			 (function(prop2) {
				if (typeof instance[prop2] === "function") {
				  _global[className].prototype[prop2] = function() {
					 return this[originalInstanceKey][prop2].apply(this[originalInstanceKey], arguments);
				  };
				} else {
				  ObjectDefineProperty(_global[className].prototype, prop2, {
					 set: function(fn) {
						if (typeof fn === "function") {
						  this[originalInstanceKey][prop2] = wrapWithCurrentZone(fn, className + "." + prop2);
						  attachOriginToPatched(this[originalInstanceKey][prop2], fn);
						} else {
						  this[originalInstanceKey][prop2] = fn;
						}
					 },
					 get: function() {
						return this[originalInstanceKey][prop2];
					 }
				  });
				}
			 })(prop);
		  }
		  for (prop in OriginalClass) {
			 if (prop !== "prototype" && OriginalClass.hasOwnProperty(prop)) {
				_global[className][prop] = OriginalClass[prop];
			 }
		  }
		}
		function patchMethod(target, name, patchFn) {
		  let proto = target;
		  while (proto && !proto.hasOwnProperty(name)) {
			 proto = ObjectGetPrototypeOf(proto);
		  }
		  if (!proto && target[name]) {
			 proto = target;
		  }
		  const delegateName = zoneSymbol(name);
		  let delegate = null;
		  if (proto && (!(delegate = proto[delegateName]) || !proto.hasOwnProperty(delegateName))) {
			 delegate = proto[delegateName] = proto[name];
			 const desc = proto && ObjectGetOwnPropertyDescriptor(proto, name);
			 if (isPropertyWritable(desc)) {
				const patchDelegate = patchFn(delegate, delegateName, name);
				proto[name] = function() {
				  return patchDelegate(this, arguments);
				};
				attachOriginToPatched(proto[name], delegate);
			 }
		  }
		  return delegate;
		}
		function patchMacroTask(obj, funcName, metaCreator) {
		  let setNative = null;
		  function scheduleTask(task) {
			 const data = task.data;
			 data.args[data.cbIdx] = function() {
				task.invoke.apply(this, arguments);
			 };
			 setNative.apply(data.target, data.args);
			 return task;
		  }
		  setNative = patchMethod(obj, funcName, (delegate) => function(self2, args) {
			 const meta = metaCreator(self2, args);
			 if (meta.cbIdx >= 0 && typeof args[meta.cbIdx] === "function") {
				return scheduleMacroTaskWithCurrentZone(meta.name, args[meta.cbIdx], meta, scheduleTask);
			 } else {
				return delegate.apply(self2, args);
			 }
		  });
		}
		function attachOriginToPatched(patched, original) {
		  patched[zoneSymbol("OriginalDelegate")] = original;
		}
		var isDetectedIEOrEdge = false;
		var ieOrEdge = false;
		function isIE() {
		  try {
			 const ua = internalWindow.navigator.userAgent;
			 if (ua.indexOf("MSIE ") !== -1 || ua.indexOf("Trident/") !== -1) {
				return true;
			 }
		  } catch (error) {
		  }
		  return false;
		}
		function isIEOrEdge() {
		  if (isDetectedIEOrEdge) {
			 return ieOrEdge;
		  }
		  isDetectedIEOrEdge = true;
		  try {
			 const ua = internalWindow.navigator.userAgent;
			 if (ua.indexOf("MSIE ") !== -1 || ua.indexOf("Trident/") !== -1 || ua.indexOf("Edge/") !== -1) {
				ieOrEdge = true;
			 }
		  } catch (error) {
		  }
		  return ieOrEdge;
		}
		function isFunction(value) {
		  return typeof value === "function";
		}
		function isNumber(value) {
		  return typeof value === "number";
		}
		var passiveSupported = false;
		if (typeof window !== "undefined") {
		  try {
			 const options = Object.defineProperty({}, "passive", {
				get: function() {
				  passiveSupported = true;
				}
			 });
			 window.addEventListener("test", options, options);
			 window.removeEventListener("test", options, options);
		  } catch (err) {
			 passiveSupported = false;
		  }
		}
		var OPTIMIZED_ZONE_EVENT_TASK_DATA = {
		  useG: true
		};
		var zoneSymbolEventNames = {};
		var globalSources = {};
		var EVENT_NAME_SYMBOL_REGX = new RegExp("^" + ZONE_SYMBOL_PREFIX + "(\\w+)(true|false)$");
		var IMMEDIATE_PROPAGATION_SYMBOL = zoneSymbol("propagationStopped");
		function prepareEventNames(eventName, eventNameToString) {
		  const falseEventName = (eventNameToString ? eventNameToString(eventName) : eventName) + FALSE_STR;
		  const trueEventName = (eventNameToString ? eventNameToString(eventName) : eventName) + TRUE_STR;
		  const symbol = ZONE_SYMBOL_PREFIX + falseEventName;
		  const symbolCapture = ZONE_SYMBOL_PREFIX + trueEventName;
		  zoneSymbolEventNames[eventName] = {};
		  zoneSymbolEventNames[eventName][FALSE_STR] = symbol;
		  zoneSymbolEventNames[eventName][TRUE_STR] = symbolCapture;
		}
		function patchEventTarget(_global2, api, apis, patchOptions) {
		  const ADD_EVENT_LISTENER = patchOptions && patchOptions.add || ADD_EVENT_LISTENER_STR;
		  const REMOVE_EVENT_LISTENER = patchOptions && patchOptions.rm || REMOVE_EVENT_LISTENER_STR;
		  const LISTENERS_EVENT_LISTENER = patchOptions && patchOptions.listeners || "eventListeners";
		  const REMOVE_ALL_LISTENERS_EVENT_LISTENER = patchOptions && patchOptions.rmAll || "removeAllListeners";
		  const zoneSymbolAddEventListener = zoneSymbol(ADD_EVENT_LISTENER);
		  const ADD_EVENT_LISTENER_SOURCE = "." + ADD_EVENT_LISTENER + ":";
		  const PREPEND_EVENT_LISTENER = "prependListener";
		  const PREPEND_EVENT_LISTENER_SOURCE = "." + PREPEND_EVENT_LISTENER + ":";
		  const invokeTask = function(task, target, event) {
			 if (task.isRemoved) {
				return;
			 }
			 const delegate = task.callback;
			 if (typeof delegate === "object" && delegate.handleEvent) {
				task.callback = (event2) => delegate.handleEvent(event2);
				task.originalDelegate = delegate;
			 }
			 let error;
			 try {
				task.invoke(task, target, [event]);
			 } catch (err) {
				error = err;
			 }
			 const options = task.options;
			 if (options && typeof options === "object" && options.once) {
				const delegate2 = task.originalDelegate ? task.originalDelegate : task.callback;
				target[REMOVE_EVENT_LISTENER].call(target, event.type, delegate2, options);
			 }
			 return error;
		  };
		  function globalCallback(context, event, isCapture) {
			 event = event || _global2.event;
			 if (!event) {
				return;
			 }
			 const target = context || event.target || _global2;
			 const tasks = target[zoneSymbolEventNames[event.type][isCapture ? TRUE_STR : FALSE_STR]];
			 if (tasks) {
				const errors = [];
				if (tasks.length === 1) {
				  const err = invokeTask(tasks[0], target, event);
				  err && errors.push(err);
				} else {
				  const copyTasks = tasks.slice();
				  for (let i = 0; i < copyTasks.length; i++) {
					 if (event && event[IMMEDIATE_PROPAGATION_SYMBOL] === true) {
						break;
					 }
					 const err = invokeTask(copyTasks[i], target, event);
					 err && errors.push(err);
				  }
				}
				if (errors.length === 1) {
				  throw errors[0];
				} else {
				  for (let i = 0; i < errors.length; i++) {
					 const err = errors[i];
					 api.nativeScheduleMicroTask(() => {
						throw err;
					 });
				  }
				}
			 }
		  }
		  const globalZoneAwareCallback = function(event) {
			 return globalCallback(this, event, false);
		  };
		  const globalZoneAwareCaptureCallback = function(event) {
			 return globalCallback(this, event, true);
		  };
		  function patchEventTargetMethods(obj, patchOptions2) {
			 if (!obj) {
				return false;
			 }
			 let useGlobalCallback = true;
			 if (patchOptions2 && patchOptions2.useG !== void 0) {
				useGlobalCallback = patchOptions2.useG;
			 }
			 const validateHandler = patchOptions2 && patchOptions2.vh;
			 let checkDuplicate = true;
			 if (patchOptions2 && patchOptions2.chkDup !== void 0) {
				checkDuplicate = patchOptions2.chkDup;
			 }
			 let returnTarget = false;
			 if (patchOptions2 && patchOptions2.rt !== void 0) {
				returnTarget = patchOptions2.rt;
			 }
			 let proto = obj;
			 while (proto && !proto.hasOwnProperty(ADD_EVENT_LISTENER)) {
				proto = ObjectGetPrototypeOf(proto);
			 }
			 if (!proto && obj[ADD_EVENT_LISTENER]) {
				proto = obj;
			 }
			 if (!proto) {
				return false;
			 }
			 if (proto[zoneSymbolAddEventListener]) {
				return false;
			 }
			 const eventNameToString = patchOptions2 && patchOptions2.eventNameToString;
			 const taskData = {};
			 const nativeAddEventListener = proto[zoneSymbolAddEventListener] = proto[ADD_EVENT_LISTENER];
			 const nativeRemoveEventListener = proto[zoneSymbol(REMOVE_EVENT_LISTENER)] = proto[REMOVE_EVENT_LISTENER];
			 const nativeListeners = proto[zoneSymbol(LISTENERS_EVENT_LISTENER)] = proto[LISTENERS_EVENT_LISTENER];
			 const nativeRemoveAllListeners = proto[zoneSymbol(REMOVE_ALL_LISTENERS_EVENT_LISTENER)] = proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER];
			 let nativePrependEventListener;
			 if (patchOptions2 && patchOptions2.prepend) {
				nativePrependEventListener = proto[zoneSymbol(patchOptions2.prepend)] = proto[patchOptions2.prepend];
			 }
			 function buildEventListenerOptions(options, passive) {
				if (!passiveSupported && typeof options === "object" && options) {
				  return !!options.capture;
				}
				if (!passiveSupported || !passive) {
				  return options;
				}
				if (typeof options === "boolean") {
				  return { capture: options, passive: true };
				}
				if (!options) {
				  return { passive: true };
				}
				if (typeof options === "object" && options.passive !== false) {
				  return { ...options, passive: true };
				}
				return options;
			 }
			 const customScheduleGlobal = function(task) {
				if (taskData.isExisting) {
				  return;
				}
				return nativeAddEventListener.call(taskData.target, taskData.eventName, taskData.capture ? globalZoneAwareCaptureCallback : globalZoneAwareCallback, taskData.options);
			 };
			 const customCancelGlobal = function(task) {
				if (!task.isRemoved) {
				  const symbolEventNames = zoneSymbolEventNames[task.eventName];
				  let symbolEventName;
				  if (symbolEventNames) {
					 symbolEventName = symbolEventNames[task.capture ? TRUE_STR : FALSE_STR];
				  }
				  const existingTasks = symbolEventName && task.target[symbolEventName];
				  if (existingTasks) {
					 for (let i = 0; i < existingTasks.length; i++) {
						const existingTask = existingTasks[i];
						if (existingTask === task) {
						  existingTasks.splice(i, 1);
						  task.isRemoved = true;
						  if (task.removeAbortListener) {
							 task.removeAbortListener();
							 task.removeAbortListener = null;
						  }
						  if (existingTasks.length === 0) {
							 task.allRemoved = true;
							 task.target[symbolEventName] = null;
						  }
						  break;
						}
					 }
				  }
				}
				if (!task.allRemoved) {
				  return;
				}
				return nativeRemoveEventListener.call(task.target, task.eventName, task.capture ? globalZoneAwareCaptureCallback : globalZoneAwareCallback, task.options);
			 };
			 const customScheduleNonGlobal = function(task) {
				return nativeAddEventListener.call(taskData.target, taskData.eventName, task.invoke, taskData.options);
			 };
			 const customSchedulePrepend = function(task) {
				return nativePrependEventListener.call(taskData.target, taskData.eventName, task.invoke, taskData.options);
			 };
			 const customCancelNonGlobal = function(task) {
				return nativeRemoveEventListener.call(task.target, task.eventName, task.invoke, task.options);
			 };
			 const customSchedule = useGlobalCallback ? customScheduleGlobal : customScheduleNonGlobal;
			 const customCancel = useGlobalCallback ? customCancelGlobal : customCancelNonGlobal;
			 const compareTaskCallbackVsDelegate = function(task, delegate) {
				const typeOfDelegate = typeof delegate;
				return typeOfDelegate === "function" && task.callback === delegate || typeOfDelegate === "object" && task.originalDelegate === delegate;
			 };
			 const compare = patchOptions2 && patchOptions2.diff ? patchOptions2.diff : compareTaskCallbackVsDelegate;
			 const unpatchedEvents = Zone[zoneSymbol("UNPATCHED_EVENTS")];
			 const passiveEvents = _global2[zoneSymbol("PASSIVE_EVENTS")];
			 function copyEventListenerOptions(options) {
				if (typeof options === "object" && options !== null) {
				  const newOptions = { ...options };
				  if (options.signal) {
					 newOptions.signal = options.signal;
				  }
				  return newOptions;
				}
				return options;
			 }
			 const makeAddListener = function(nativeListener, addSource, customScheduleFn, customCancelFn, returnTarget2 = false, prepend = false) {
				return function() {
				  const target = this || _global2;
				  let eventName = arguments[0];
				  if (patchOptions2 && patchOptions2.transferEventName) {
					 eventName = patchOptions2.transferEventName(eventName);
				  }
				  let delegate = arguments[1];
				  if (!delegate) {
					 return nativeListener.apply(this, arguments);
				  }
				  if (isNode && eventName === "uncaughtException") {
					 return nativeListener.apply(this, arguments);
				  }
				  let isHandleEvent = false;
				  if (typeof delegate !== "function") {
					 if (!delegate.handleEvent) {
						return nativeListener.apply(this, arguments);
					 }
					 isHandleEvent = true;
				  }
				  if (validateHandler && !validateHandler(nativeListener, delegate, target, arguments)) {
					 return;
				  }
				  const passive = passiveSupported && !!passiveEvents && passiveEvents.indexOf(eventName) !== -1;
				  const options = copyEventListenerOptions(buildEventListenerOptions(arguments[2], passive));
				  const signal = options?.signal;
				  if (signal?.aborted) {
					 return;
				  }
				  if (unpatchedEvents) {
					 for (let i = 0; i < unpatchedEvents.length; i++) {
						if (eventName === unpatchedEvents[i]) {
						  if (passive) {
							 return nativeListener.call(target, eventName, delegate, options);
						  } else {
							 return nativeListener.apply(this, arguments);
						  }
						}
					 }
				  }
				  const capture = !options ? false : typeof options === "boolean" ? true : options.capture;
				  const once = options && typeof options === "object" ? options.once : false;
				  const zone = Zone.current;
				  let symbolEventNames = zoneSymbolEventNames[eventName];
				  if (!symbolEventNames) {
					 prepareEventNames(eventName, eventNameToString);
					 symbolEventNames = zoneSymbolEventNames[eventName];
				  }
				  const symbolEventName = symbolEventNames[capture ? TRUE_STR : FALSE_STR];
				  let existingTasks = target[symbolEventName];
				  let isExisting = false;
				  if (existingTasks) {
					 isExisting = true;
					 if (checkDuplicate) {
						for (let i = 0; i < existingTasks.length; i++) {
						  if (compare(existingTasks[i], delegate)) {
							 return;
						  }
						}
					 }
				  } else {
					 existingTasks = target[symbolEventName] = [];
				  }
				  let source;
				  const constructorName = target.constructor["name"];
				  const targetSource = globalSources[constructorName];
				  if (targetSource) {
					 source = targetSource[eventName];
				  }
				  if (!source) {
					 source = constructorName + addSource + (eventNameToString ? eventNameToString(eventName) : eventName);
				  }
				  taskData.options = options;
				  if (once) {
					 taskData.options.once = false;
				  }
				  taskData.target = target;
				  taskData.capture = capture;
				  taskData.eventName = eventName;
				  taskData.isExisting = isExisting;
				  const data = useGlobalCallback ? OPTIMIZED_ZONE_EVENT_TASK_DATA : void 0;
				  if (data) {
					 data.taskData = taskData;
				  }
				  if (signal) {
					 taskData.options.signal = void 0;
				  }
				  const task = zone.scheduleEventTask(source, delegate, data, customScheduleFn, customCancelFn);
				  if (signal) {
					 taskData.options.signal = signal;
					 const onAbort = () => task.zone.cancelTask(task);
					 nativeListener.call(signal, "abort", onAbort, { once: true });
					 task.removeAbortListener = () => signal.removeEventListener("abort", onAbort);
				  }
				  taskData.target = null;
				  if (data) {
					 data.taskData = null;
				  }
				  if (once) {
					 taskData.options.once = true;
				  }
				  if (!(!passiveSupported && typeof task.options === "boolean")) {
					 task.options = options;
				  }
				  task.target = target;
				  task.capture = capture;
				  task.eventName = eventName;
				  if (isHandleEvent) {
					 task.originalDelegate = delegate;
				  }
				  if (!prepend) {
					 existingTasks.push(task);
				  } else {
					 existingTasks.unshift(task);
				  }
				  if (returnTarget2) {
					 return target;
				  }
				};
			 };
			 proto[ADD_EVENT_LISTENER] = makeAddListener(nativeAddEventListener, ADD_EVENT_LISTENER_SOURCE, customSchedule, customCancel, returnTarget);
			 if (nativePrependEventListener) {
				proto[PREPEND_EVENT_LISTENER] = makeAddListener(nativePrependEventListener, PREPEND_EVENT_LISTENER_SOURCE, customSchedulePrepend, customCancel, returnTarget, true);
			 }
			 proto[REMOVE_EVENT_LISTENER] = function() {
				const target = this || _global2;
				let eventName = arguments[0];
				if (patchOptions2 && patchOptions2.transferEventName) {
				  eventName = patchOptions2.transferEventName(eventName);
				}
				const options = arguments[2];
				const capture = !options ? false : typeof options === "boolean" ? true : options.capture;
				const delegate = arguments[1];
				if (!delegate) {
				  return nativeRemoveEventListener.apply(this, arguments);
				}
				if (validateHandler && !validateHandler(nativeRemoveEventListener, delegate, target, arguments)) {
				  return;
				}
				const symbolEventNames = zoneSymbolEventNames[eventName];
				let symbolEventName;
				if (symbolEventNames) {
				  symbolEventName = symbolEventNames[capture ? TRUE_STR : FALSE_STR];
				}
				const existingTasks = symbolEventName && target[symbolEventName];
				if (existingTasks) {
				  for (let i = 0; i < existingTasks.length; i++) {
					 const existingTask = existingTasks[i];
					 if (compare(existingTask, delegate)) {
						existingTasks.splice(i, 1);
						existingTask.isRemoved = true;
						if (existingTasks.length === 0) {
						  existingTask.allRemoved = true;
						  target[symbolEventName] = null;
						  if (!capture && typeof eventName === "string") {
							 const onPropertySymbol = ZONE_SYMBOL_PREFIX + "ON_PROPERTY" + eventName;
							 target[onPropertySymbol] = null;
						  }
						}
						existingTask.zone.cancelTask(existingTask);
						if (returnTarget) {
						  return target;
						}
						return;
					 }
				  }
				}
				return nativeRemoveEventListener.apply(this, arguments);
			 };
			 proto[LISTENERS_EVENT_LISTENER] = function() {
				const target = this || _global2;
				let eventName = arguments[0];
				if (patchOptions2 && patchOptions2.transferEventName) {
				  eventName = patchOptions2.transferEventName(eventName);
				}
				const listeners = [];
				const tasks = findEventTasks(target, eventNameToString ? eventNameToString(eventName) : eventName);
				for (let i = 0; i < tasks.length; i++) {
				  const task = tasks[i];
				  let delegate = task.originalDelegate ? task.originalDelegate : task.callback;
				  listeners.push(delegate);
				}
				return listeners;
			 };
			 proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER] = function() {
				const target = this || _global2;
				let eventName = arguments[0];
				if (!eventName) {
				  const keys = Object.keys(target);
				  for (let i = 0; i < keys.length; i++) {
					 const prop = keys[i];
					 const match = EVENT_NAME_SYMBOL_REGX.exec(prop);
					 let evtName = match && match[1];
					 if (evtName && evtName !== "removeListener") {
						this[REMOVE_ALL_LISTENERS_EVENT_LISTENER].call(this, evtName);
					 }
				  }
				  this[REMOVE_ALL_LISTENERS_EVENT_LISTENER].call(this, "removeListener");
				} else {
				  if (patchOptions2 && patchOptions2.transferEventName) {
					 eventName = patchOptions2.transferEventName(eventName);
				  }
				  const symbolEventNames = zoneSymbolEventNames[eventName];
				  if (symbolEventNames) {
					 const symbolEventName = symbolEventNames[FALSE_STR];
					 const symbolCaptureEventName = symbolEventNames[TRUE_STR];
					 const tasks = target[symbolEventName];
					 const captureTasks = target[symbolCaptureEventName];
					 if (tasks) {
						const removeTasks = tasks.slice();
						for (let i = 0; i < removeTasks.length; i++) {
						  const task = removeTasks[i];
						  let delegate = task.originalDelegate ? task.originalDelegate : task.callback;
						  this[REMOVE_EVENT_LISTENER].call(this, eventName, delegate, task.options);
						}
					 }
					 if (captureTasks) {
						const removeTasks = captureTasks.slice();
						for (let i = 0; i < removeTasks.length; i++) {
						  const task = removeTasks[i];
						  let delegate = task.originalDelegate ? task.originalDelegate : task.callback;
						  this[REMOVE_EVENT_LISTENER].call(this, eventName, delegate, task.options);
						}
					 }
				  }
				}
				if (returnTarget) {
				  return this;
				}
			 };
			 attachOriginToPatched(proto[ADD_EVENT_LISTENER], nativeAddEventListener);
			 attachOriginToPatched(proto[REMOVE_EVENT_LISTENER], nativeRemoveEventListener);
			 if (nativeRemoveAllListeners) {
				attachOriginToPatched(proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER], nativeRemoveAllListeners);
			 }
			 if (nativeListeners) {
				attachOriginToPatched(proto[LISTENERS_EVENT_LISTENER], nativeListeners);
			 }
			 return true;
		  }
		  let results = [];
		  for (let i = 0; i < apis.length; i++) {
			 results[i] = patchEventTargetMethods(apis[i], patchOptions);
		  }
		  return results;
		}
		function findEventTasks(target, eventName) {
		  if (!eventName) {
			 const foundTasks = [];
			 for (let prop in target) {
				const match = EVENT_NAME_SYMBOL_REGX.exec(prop);
				let evtName = match && match[1];
				if (evtName && (!eventName || evtName === eventName)) {
				  const tasks = target[prop];
				  if (tasks) {
					 for (let i = 0; i < tasks.length; i++) {
						foundTasks.push(tasks[i]);
					 }
				  }
				}
			 }
			 return foundTasks;
		  }
		  let symbolEventName = zoneSymbolEventNames[eventName];
		  if (!symbolEventName) {
			 prepareEventNames(eventName);
			 symbolEventName = zoneSymbolEventNames[eventName];
		  }
		  const captureFalseTasks = target[symbolEventName[FALSE_STR]];
		  const captureTrueTasks = target[symbolEventName[TRUE_STR]];
		  if (!captureFalseTasks) {
			 return captureTrueTasks ? captureTrueTasks.slice() : [];
		  } else {
			 return captureTrueTasks ? captureFalseTasks.concat(captureTrueTasks) : captureFalseTasks.slice();
		  }
		}
		function patchEventPrototype(global2, api) {
		  const Event = global2["Event"];
		  if (Event && Event.prototype) {
			 api.patchMethod(Event.prototype, "stopImmediatePropagation", (delegate) => function(self2, args) {
				self2[IMMEDIATE_PROPAGATION_SYMBOL] = true;
				delegate && delegate.apply(self2, args);
			 });
		  }
		}
		function patchQueueMicrotask(global2, api) {
		  api.patchMethod(global2, "queueMicrotask", (delegate) => {
			 return function(self2, args) {
				Zone.current.scheduleMicroTask("queueMicrotask", args[0]);
			 };
		  });
		}
		var taskSymbol = zoneSymbol("zoneTask");
		function patchTimer(window2, setName, cancelName, nameSuffix) {
		  let setNative = null;
		  let clearNative = null;
		  setName += nameSuffix;
		  cancelName += nameSuffix;
		  const tasksByHandleId = {};
		  function scheduleTask(task) {
			 const data = task.data;
			 data.args[0] = function() {
				return task.invoke.apply(this, arguments);
			 };
			 const handleOrId = setNative.apply(window2, data.args);
			 if (isNumber(handleOrId)) {
				data.handleId = handleOrId;
			 } else {
				data.handle = handleOrId;
				data.isRefreshable = isFunction(handleOrId.refresh);
			 }
			 return task;
		  }
		  function clearTask(task) {
			 const { handle, handleId } = task.data;
			 return clearNative.call(window2, handle ?? handleId);
		  }
		  setNative = patchMethod(window2, setName, (delegate) => function(self2, args) {
			 if (isFunction(args[0])) {
				const options = {
				  isRefreshable: false,
				  isPeriodic: nameSuffix === "Interval",
				  delay: nameSuffix === "Timeout" || nameSuffix === "Interval" ? args[1] || 0 : void 0,
				  args
				};
				const callback = args[0];
				args[0] = function timer() {
				  try {
					 return callback.apply(this, arguments);
				  } finally {
					 const { handle: handle2, handleId: handleId2, isPeriodic: isPeriodic2, isRefreshable: isRefreshable2 } = options;
					 if (!isPeriodic2 && !isRefreshable2) {
						if (handleId2) {
						  delete tasksByHandleId[handleId2];
						} else if (handle2) {
						  handle2[taskSymbol] = null;
						}
					 }
				  }
				};
				const task = scheduleMacroTaskWithCurrentZone(setName, args[0], options, scheduleTask, clearTask);
				if (!task) {
				  return task;
				}
				const { handleId, handle, isRefreshable, isPeriodic } = task.data;
				if (handleId) {
				  tasksByHandleId[handleId] = task;
				} else if (handle) {
				  handle[taskSymbol] = task;
				  if (isRefreshable && !isPeriodic) {
					 const originalRefresh = handle.refresh;
					 handle.refresh = function() {
						const { zone, state } = task;
						if (state === "notScheduled") {
						  task._state = "scheduled";
						  zone._updateTaskCount(task, 1);
						} else if (state === "running") {
						  task._state = "scheduling";
						}
						return originalRefresh.call(this);
					 };
				  }
				}
				return handle ?? handleId ?? task;
			 } else {
				return delegate.apply(window2, args);
			 }
		  });
		  clearNative = patchMethod(window2, cancelName, (delegate) => function(self2, args) {
			 const id = args[0];
			 let task;
			 if (isNumber(id)) {
				task = tasksByHandleId[id];
				delete tasksByHandleId[id];
			 } else {
				task = id?.[taskSymbol];
				if (task) {
				  id[taskSymbol] = null;
				} else {
				  task = id;
				}
			 }
			 if (task?.type) {
				if (task.cancelFn) {
				  task.zone.cancelTask(task);
				}
			 } else {
				delegate.apply(window2, args);
			 }
		  });
		}
		function patchCustomElements(_global2, api) {
		  const { isBrowser: isBrowser2, isMix: isMix2 } = api.getGlobalObjects();
		  if (!isBrowser2 && !isMix2 || !_global2["customElements"] || !("customElements" in _global2)) {
			 return;
		  }
		  const callbacks = [
			 "connectedCallback",
			 "disconnectedCallback",
			 "adoptedCallback",
			 "attributeChangedCallback",
			 "formAssociatedCallback",
			 "formDisabledCallback",
			 "formResetCallback",
			 "formStateRestoreCallback"
		  ];
		  api.patchCallbacks(api, _global2.customElements, "customElements", "define", callbacks);
		}
		function eventTargetPatch(_global2, api) {
		  if (Zone[api.symbol("patchEventTarget")]) {
			 return;
		  }
		  const { eventNames, zoneSymbolEventNames: zoneSymbolEventNames2, TRUE_STR: TRUE_STR2, FALSE_STR: FALSE_STR2, ZONE_SYMBOL_PREFIX: ZONE_SYMBOL_PREFIX2 } = api.getGlobalObjects();
		  for (let i = 0; i < eventNames.length; i++) {
			 const eventName = eventNames[i];
			 const falseEventName = eventName + FALSE_STR2;
			 const trueEventName = eventName + TRUE_STR2;
			 const symbol = ZONE_SYMBOL_PREFIX2 + falseEventName;
			 const symbolCapture = ZONE_SYMBOL_PREFIX2 + trueEventName;
			 zoneSymbolEventNames2[eventName] = {};
			 zoneSymbolEventNames2[eventName][FALSE_STR2] = symbol;
			 zoneSymbolEventNames2[eventName][TRUE_STR2] = symbolCapture;
		  }
		  const EVENT_TARGET = _global2["EventTarget"];
		  if (!EVENT_TARGET || !EVENT_TARGET.prototype) {
			 return;
		  }
		  api.patchEventTarget(_global2, api, [EVENT_TARGET && EVENT_TARGET.prototype]);
		  return true;
		}
		function patchEvent(global2, api) {
		  api.patchEventPrototype(global2, api);
		}
		function filterProperties(target, onProperties, ignoreProperties) {
		  if (!ignoreProperties || ignoreProperties.length === 0) {
			 return onProperties;
		  }
		  const tip = ignoreProperties.filter((ip) => ip.target === target);
		  if (!tip || tip.length === 0) {
			 return onProperties;
		  }
		  const targetIgnoreProperties = tip[0].ignoreProperties;
		  return onProperties.filter((op) => targetIgnoreProperties.indexOf(op) === -1);
		}
		function patchFilteredProperties(target, onProperties, ignoreProperties, prototype) {
		  if (!target) {
			 return;
		  }
		  const filteredProperties = filterProperties(target, onProperties, ignoreProperties);
		  patchOnProperties(target, filteredProperties, prototype);
		}
		function getOnEventNames(target) {
		  return Object.getOwnPropertyNames(target).filter((name) => name.startsWith("on") && name.length > 2).map((name) => name.substring(2));
		}
		function propertyDescriptorPatch(api, _global2) {
		  if (isNode && !isMix) {
			 return;
		  }
		  if (Zone[api.symbol("patchEvents")]) {
			 return;
		  }
		  const ignoreProperties = _global2["__Zone_ignore_on_properties"];
		  let patchTargets = [];
		  if (isBrowser) {
			 const internalWindow2 = window;
			 patchTargets = patchTargets.concat([
				"Document",
				"SVGElement",
				"Element",
				"HTMLElement",
				"HTMLBodyElement",
				"HTMLMediaElement",
				"HTMLFrameSetElement",
				"HTMLFrameElement",
				"HTMLIFrameElement",
				"HTMLMarqueeElement",
				"Worker"
			 ]);
			 const ignoreErrorProperties = isIE() ? [{ target: internalWindow2, ignoreProperties: ["error"] }] : [];
			 patchFilteredProperties(internalWindow2, getOnEventNames(internalWindow2), ignoreProperties ? ignoreProperties.concat(ignoreErrorProperties) : ignoreProperties, ObjectGetPrototypeOf(internalWindow2));
		  }
		  patchTargets = patchTargets.concat([
			 "XMLHttpRequest",
			 "XMLHttpRequestEventTarget",
			 "IDBIndex",
			 "IDBRequest",
			 "IDBOpenDBRequest",
			 "IDBDatabase",
			 "IDBTransaction",
			 "IDBCursor",
			 "WebSocket"
		  ]);
		  for (let i = 0; i < patchTargets.length; i++) {
			 const target = _global2[patchTargets[i]];
			 target && target.prototype && patchFilteredProperties(target.prototype, getOnEventNames(target.prototype), ignoreProperties);
		  }
		}
		function patchBrowser(Zone2) {
		  Zone2.__load_patch("legacy", (global2) => {
			 const legacyPatch = global2[Zone2.__symbol__("legacyPatch")];
			 if (legacyPatch) {
				legacyPatch();
			 }
		  });
		  Zone2.__load_patch("timers", (global2) => {
			 const set = "set";
			 const clear = "clear";
			 patchTimer(global2, set, clear, "Timeout");
			 patchTimer(global2, set, clear, "Interval");
			 patchTimer(global2, set, clear, "Immediate");
		  });
		  Zone2.__load_patch("requestAnimationFrame", (global2) => {
			 patchTimer(global2, "request", "cancel", "AnimationFrame");
			 patchTimer(global2, "mozRequest", "mozCancel", "AnimationFrame");
			 patchTimer(global2, "webkitRequest", "webkitCancel", "AnimationFrame");
		  });
		  Zone2.__load_patch("blocking", (global2, Zone3) => {
			 const blockingMethods = ["alert", "prompt", "confirm"];
			 for (let i = 0; i < blockingMethods.length; i++) {
				const name = blockingMethods[i];
				patchMethod(global2, name, (delegate, symbol, name2) => {
				  return function(s, args) {
					 return Zone3.current.run(delegate, global2, args, name2);
				  };
				});
			 }
		  });
		  Zone2.__load_patch("EventTarget", (global2, Zone3, api) => {
			 patchEvent(global2, api);
			 eventTargetPatch(global2, api);
			 const XMLHttpRequestEventTarget = global2["XMLHttpRequestEventTarget"];
			 if (XMLHttpRequestEventTarget && XMLHttpRequestEventTarget.prototype) {
				api.patchEventTarget(global2, api, [XMLHttpRequestEventTarget.prototype]);
			 }
		  });
		  Zone2.__load_patch("MutationObserver", (global2, Zone3, api) => {
			 patchClass("MutationObserver");
			 patchClass("WebKitMutationObserver");
		  });
		  Zone2.__load_patch("IntersectionObserver", (global2, Zone3, api) => {
			 patchClass("IntersectionObserver");
		  });
		  Zone2.__load_patch("FileReader", (global2, Zone3, api) => {
			 patchClass("FileReader");
		  });
		  Zone2.__load_patch("on_property", (global2, Zone3, api) => {
			 propertyDescriptorPatch(api, global2);
		  });
		  Zone2.__load_patch("customElements", (global2, Zone3, api) => {
			 patchCustomElements(global2, api);
		  });
		  Zone2.__load_patch("XHR", (global2, Zone3) => {
			 patchXHR(global2);
			 const XHR_TASK = zoneSymbol("xhrTask");
			 const XHR_SYNC = zoneSymbol("xhrSync");
			 const XHR_LISTENER = zoneSymbol("xhrListener");
			 const XHR_SCHEDULED = zoneSymbol("xhrScheduled");
			 const XHR_URL = zoneSymbol("xhrURL");
			 const XHR_ERROR_BEFORE_SCHEDULED = zoneSymbol("xhrErrorBeforeScheduled");
			 function patchXHR(window2) {
				const XMLHttpRequest = window2["XMLHttpRequest"];
				if (!XMLHttpRequest) {
				  return;
				}
				const XMLHttpRequestPrototype = XMLHttpRequest.prototype;
				function findPendingTask(target) {
				  return target[XHR_TASK];
				}
				let oriAddListener = XMLHttpRequestPrototype[ZONE_SYMBOL_ADD_EVENT_LISTENER];
				let oriRemoveListener = XMLHttpRequestPrototype[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];
				if (!oriAddListener) {
				  const XMLHttpRequestEventTarget = window2["XMLHttpRequestEventTarget"];
				  if (XMLHttpRequestEventTarget) {
					 const XMLHttpRequestEventTargetPrototype = XMLHttpRequestEventTarget.prototype;
					 oriAddListener = XMLHttpRequestEventTargetPrototype[ZONE_SYMBOL_ADD_EVENT_LISTENER];
					 oriRemoveListener = XMLHttpRequestEventTargetPrototype[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];
				  }
				}
				const READY_STATE_CHANGE = "readystatechange";
				const SCHEDULED = "scheduled";
				function scheduleTask(task) {
				  const data = task.data;
				  const target = data.target;
				  target[XHR_SCHEDULED] = false;
				  target[XHR_ERROR_BEFORE_SCHEDULED] = false;
				  const listener = target[XHR_LISTENER];
				  if (!oriAddListener) {
					 oriAddListener = target[ZONE_SYMBOL_ADD_EVENT_LISTENER];
					 oriRemoveListener = target[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];
				  }
				  if (listener) {
					 oriRemoveListener.call(target, READY_STATE_CHANGE, listener);
				  }
				  const newListener = target[XHR_LISTENER] = () => {
					 if (target.readyState === target.DONE) {
						if (!data.aborted && target[XHR_SCHEDULED] && task.state === SCHEDULED) {
						  const loadTasks = target[Zone3.__symbol__("loadfalse")];
						  if (target.status !== 0 && loadTasks && loadTasks.length > 0) {
							 const oriInvoke = task.invoke;
							 task.invoke = function() {
								const loadTasks2 = target[Zone3.__symbol__("loadfalse")];
								for (let i = 0; i < loadTasks2.length; i++) {
								  if (loadTasks2[i] === task) {
									 loadTasks2.splice(i, 1);
								  }
								}
								if (!data.aborted && task.state === SCHEDULED) {
								  oriInvoke.call(task);
								}
							 };
							 loadTasks.push(task);
						  } else {
							 task.invoke();
						  }
						} else if (!data.aborted && target[XHR_SCHEDULED] === false) {
						  target[XHR_ERROR_BEFORE_SCHEDULED] = true;
						}
					 }
				  };
				  oriAddListener.call(target, READY_STATE_CHANGE, newListener);
				  const storedTask = target[XHR_TASK];
				  if (!storedTask) {
					 target[XHR_TASK] = task;
				  }
				  sendNative.apply(target, data.args);
				  target[XHR_SCHEDULED] = true;
				  return task;
				}
				function placeholderCallback() {
				}
				function clearTask(task) {
				  const data = task.data;
				  data.aborted = true;
				  return abortNative.apply(data.target, data.args);
				}
				const openNative = patchMethod(XMLHttpRequestPrototype, "open", () => function(self2, args) {
				  self2[XHR_SYNC] = args[2] == false;
				  self2[XHR_URL] = args[1];
				  return openNative.apply(self2, args);
				});
				const XMLHTTPREQUEST_SOURCE = "XMLHttpRequest.send";
				const fetchTaskAborting = zoneSymbol("fetchTaskAborting");
				const fetchTaskScheduling = zoneSymbol("fetchTaskScheduling");
				const sendNative = patchMethod(XMLHttpRequestPrototype, "send", () => function(self2, args) {
				  if (Zone3.current[fetchTaskScheduling] === true) {
					 return sendNative.apply(self2, args);
				  }
				  if (self2[XHR_SYNC]) {
					 return sendNative.apply(self2, args);
				  } else {
					 const options = {
						target: self2,
						url: self2[XHR_URL],
						isPeriodic: false,
						args,
						aborted: false
					 };
					 const task = scheduleMacroTaskWithCurrentZone(XMLHTTPREQUEST_SOURCE, placeholderCallback, options, scheduleTask, clearTask);
					 if (self2 && self2[XHR_ERROR_BEFORE_SCHEDULED] === true && !options.aborted && task.state === SCHEDULED) {
						task.invoke();
					 }
				  }
				});
				const abortNative = patchMethod(XMLHttpRequestPrototype, "abort", () => function(self2, args) {
				  const task = findPendingTask(self2);
				  if (task && typeof task.type == "string") {
					 if (task.cancelFn == null || task.data && task.data.aborted) {
						return;
					 }
					 task.zone.cancelTask(task);
				  } else if (Zone3.current[fetchTaskAborting] === true) {
					 return abortNative.apply(self2, args);
				  }
				});
			 }
		  });
		  Zone2.__load_patch("geolocation", (global2) => {
			 if (global2["navigator"] && global2["navigator"].geolocation) {
				patchPrototype(global2["navigator"].geolocation, ["getCurrentPosition", "watchPosition"]);
			 }
		  });
		  Zone2.__load_patch("PromiseRejectionEvent", (global2, Zone3) => {
			 function findPromiseRejectionHandler(evtName) {
				return function(e) {
				  const eventTasks = findEventTasks(global2, evtName);
				  eventTasks.forEach((eventTask) => {
					 const PromiseRejectionEvent = global2["PromiseRejectionEvent"];
					 if (PromiseRejectionEvent) {
						const evt = new PromiseRejectionEvent(evtName, {
						  promise: e.promise,
						  reason: e.rejection
						});
						eventTask.invoke(evt);
					 }
				  });
				};
			 }
			 if (global2["PromiseRejectionEvent"]) {
				Zone3[zoneSymbol("unhandledPromiseRejectionHandler")] = findPromiseRejectionHandler("unhandledrejection");
				Zone3[zoneSymbol("rejectionHandledHandler")] = findPromiseRejectionHandler("rejectionhandled");
			 }
		  });
		  Zone2.__load_patch("queueMicrotask", (global2, Zone3, api) => {
			 patchQueueMicrotask(global2, api);
		  });
		}
		function patchPromise(Zone2) {
		  Zone2.__load_patch("ZoneAwarePromise", (global2, Zone3, api) => {
			 const ObjectGetOwnPropertyDescriptor2 = Object.getOwnPropertyDescriptor;
			 const ObjectDefineProperty2 = Object.defineProperty;
			 function readableObjectToString(obj) {
				if (obj && obj.toString === Object.prototype.toString) {
				  const className = obj.constructor && obj.constructor.name;
				  return (className ? className : "") + ": " + JSON.stringify(obj);
				}
				return obj ? obj.toString() : Object.prototype.toString.call(obj);
			 }
			 const __symbol__2 = api.symbol;
			 const _uncaughtPromiseErrors = [];
			 const isDisableWrappingUncaughtPromiseRejection = global2[__symbol__2("DISABLE_WRAPPING_UNCAUGHT_PROMISE_REJECTION")] !== false;
			 const symbolPromise = __symbol__2("Promise");
			 const symbolThen = __symbol__2("then");
			 const creationTrace = "__creationTrace__";
			 api.onUnhandledError = (e) => {
				if (api.showUncaughtError()) {
				  const rejection = e && e.rejection;
				  if (rejection) {
					 console.error("Unhandled Promise rejection:", rejection instanceof Error ? rejection.message : rejection, "; Zone:", e.zone.name, "; Task:", e.task && e.task.source, "; Value:", rejection, rejection instanceof Error ? rejection.stack : void 0);
				  } else {
					 console.error(e);
				  }
				}
			 };
			 api.microtaskDrainDone = () => {
				while (_uncaughtPromiseErrors.length) {
				  const uncaughtPromiseError = _uncaughtPromiseErrors.shift();
				  try {
					 uncaughtPromiseError.zone.runGuarded(() => {
						if (uncaughtPromiseError.throwOriginal) {
						  throw uncaughtPromiseError.rejection;
						}
						throw uncaughtPromiseError;
					 });
				  } catch (error) {
					 handleUnhandledRejection(error);
				  }
				}
			 };
			 const UNHANDLED_PROMISE_REJECTION_HANDLER_SYMBOL = __symbol__2("unhandledPromiseRejectionHandler");
			 function handleUnhandledRejection(e) {
				api.onUnhandledError(e);
				try {
				  const handler = Zone3[UNHANDLED_PROMISE_REJECTION_HANDLER_SYMBOL];
				  if (typeof handler === "function") {
					 handler.call(this, e);
				  }
				} catch (err) {
				}
			 }
			 function isThenable(value) {
				return value && value.then;
			 }
			 function forwardResolution(value) {
				return value;
			 }
			 function forwardRejection(rejection) {
				return ZoneAwarePromise.reject(rejection);
			 }
			 const symbolState = __symbol__2("state");
			 const symbolValue = __symbol__2("value");
			 const symbolFinally = __symbol__2("finally");
			 const symbolParentPromiseValue = __symbol__2("parentPromiseValue");
			 const symbolParentPromiseState = __symbol__2("parentPromiseState");
			 const source = "Promise.then";
			 const UNRESOLVED = null;
			 const RESOLVED = true;
			 const REJECTED = false;
			 const REJECTED_NO_CATCH = 0;
			 function makeResolver(promise, state) {
				return (v) => {
				  try {
					 resolvePromise(promise, state, v);
				  } catch (err) {
					 resolvePromise(promise, false, err);
				  }
				};
			 }
			 const once = function() {
				let wasCalled = false;
				return function wrapper(wrappedFunction) {
				  return function() {
					 if (wasCalled) {
						return;
					 }
					 wasCalled = true;
					 wrappedFunction.apply(null, arguments);
				  };
				};
			 };
			 const TYPE_ERROR = "Promise resolved with itself";
			 const CURRENT_TASK_TRACE_SYMBOL = __symbol__2("currentTaskTrace");
			 function resolvePromise(promise, state, value) {
				const onceWrapper = once();
				if (promise === value) {
				  throw new TypeError(TYPE_ERROR);
				}
				if (promise[symbolState] === UNRESOLVED) {
				  let then = null;
				  try {
					 if (typeof value === "object" || typeof value === "function") {
						then = value && value.then;
					 }
				  } catch (err) {
					 onceWrapper(() => {
						resolvePromise(promise, false, err);
					 })();
					 return promise;
				  }
				  if (state !== REJECTED && value instanceof ZoneAwarePromise && value.hasOwnProperty(symbolState) && value.hasOwnProperty(symbolValue) && value[symbolState] !== UNRESOLVED) {
					 clearRejectedNoCatch(value);
					 resolvePromise(promise, value[symbolState], value[symbolValue]);
				  } else if (state !== REJECTED && typeof then === "function") {
					 try {
						then.call(value, onceWrapper(makeResolver(promise, state)), onceWrapper(makeResolver(promise, false)));
					 } catch (err) {
						onceWrapper(() => {
						  resolvePromise(promise, false, err);
						})();
					 }
				  } else {
					 promise[symbolState] = state;
					 const queue = promise[symbolValue];
					 promise[symbolValue] = value;
					 if (promise[symbolFinally] === symbolFinally) {
						if (state === RESOLVED) {
						  promise[symbolState] = promise[symbolParentPromiseState];
						  promise[symbolValue] = promise[symbolParentPromiseValue];
						}
					 }
					 if (state === REJECTED && value instanceof Error) {
						const trace = Zone3.currentTask && Zone3.currentTask.data && Zone3.currentTask.data[creationTrace];
						if (trace) {
						  ObjectDefineProperty2(value, CURRENT_TASK_TRACE_SYMBOL, {
							 configurable: true,
							 enumerable: false,
							 writable: true,
							 value: trace
						  });
						}
					 }
					 for (let i = 0; i < queue.length; ) {
						scheduleResolveOrReject(promise, queue[i++], queue[i++], queue[i++], queue[i++]);
					 }
					 if (queue.length == 0 && state == REJECTED) {
						promise[symbolState] = REJECTED_NO_CATCH;
						let uncaughtPromiseError = value;
						try {
						  throw new Error("Uncaught (in promise): " + readableObjectToString(value) + (value && value.stack ? "\n" + value.stack : ""));
						} catch (err) {
						  uncaughtPromiseError = err;
						}
						if (isDisableWrappingUncaughtPromiseRejection) {
						  uncaughtPromiseError.throwOriginal = true;
						}
						uncaughtPromiseError.rejection = value;
						uncaughtPromiseError.promise = promise;
						uncaughtPromiseError.zone = Zone3.current;
						uncaughtPromiseError.task = Zone3.currentTask;
						_uncaughtPromiseErrors.push(uncaughtPromiseError);
						api.scheduleMicroTask();
					 }
				  }
				}
				return promise;
			 }
			 const REJECTION_HANDLED_HANDLER = __symbol__2("rejectionHandledHandler");
			 function clearRejectedNoCatch(promise) {
				if (promise[symbolState] === REJECTED_NO_CATCH) {
				  try {
					 const handler = Zone3[REJECTION_HANDLED_HANDLER];
					 if (handler && typeof handler === "function") {
						handler.call(this, { rejection: promise[symbolValue], promise });
					 }
				  } catch (err) {
				  }
				  promise[symbolState] = REJECTED;
				  for (let i = 0; i < _uncaughtPromiseErrors.length; i++) {
					 if (promise === _uncaughtPromiseErrors[i].promise) {
						_uncaughtPromiseErrors.splice(i, 1);
					 }
				  }
				}
			 }
			 function scheduleResolveOrReject(promise, zone, chainPromise, onFulfilled, onRejected) {
				clearRejectedNoCatch(promise);
				const promiseState = promise[symbolState];
				const delegate = promiseState ? typeof onFulfilled === "function" ? onFulfilled : forwardResolution : typeof onRejected === "function" ? onRejected : forwardRejection;
				zone.scheduleMicroTask(source, () => {
				  try {
					 const parentPromiseValue = promise[symbolValue];
					 const isFinallyPromise = !!chainPromise && symbolFinally === chainPromise[symbolFinally];
					 if (isFinallyPromise) {
						chainPromise[symbolParentPromiseValue] = parentPromiseValue;
						chainPromise[symbolParentPromiseState] = promiseState;
					 }
					 const value = zone.run(delegate, void 0, isFinallyPromise && delegate !== forwardRejection && delegate !== forwardResolution ? [] : [parentPromiseValue]);
					 resolvePromise(chainPromise, true, value);
				  } catch (error) {
					 resolvePromise(chainPromise, false, error);
				  }
				}, chainPromise);
			 }
			 const ZONE_AWARE_PROMISE_TO_STRING = "function ZoneAwarePromise() { [native code] }";
			 const noop = function() {
			 };
			 const AggregateError = global2.AggregateError;
			 class ZoneAwarePromise {
				static toString() {
				  return ZONE_AWARE_PROMISE_TO_STRING;
				}
				static resolve(value) {
				  if (value instanceof ZoneAwarePromise) {
					 return value;
				  }
				  return resolvePromise(new this(null), RESOLVED, value);
				}
				static reject(error) {
				  return resolvePromise(new this(null), REJECTED, error);
				}
				static withResolvers() {
				  const result = {};
				  result.promise = new ZoneAwarePromise((res, rej) => {
					 result.resolve = res;
					 result.reject = rej;
				  });
				  return result;
				}
				static any(values) {
				  if (!values || typeof values[Symbol.iterator] !== "function") {
					 return Promise.reject(new AggregateError([], "All promises were rejected"));
				  }
				  const promises = [];
				  let count = 0;
				  try {
					 for (let v of values) {
						count++;
						promises.push(ZoneAwarePromise.resolve(v));
					 }
				  } catch (err) {
					 return Promise.reject(new AggregateError([], "All promises were rejected"));
				  }
				  if (count === 0) {
					 return Promise.reject(new AggregateError([], "All promises were rejected"));
				  }
				  let finished = false;
				  const errors = [];
				  return new ZoneAwarePromise((resolve, reject) => {
					 for (let i = 0; i < promises.length; i++) {
						promises[i].then((v) => {
						  if (finished) {
							 return;
						  }
						  finished = true;
						  resolve(v);
						}, (err) => {
						  errors.push(err);
						  count--;
						  if (count === 0) {
							 finished = true;
							 reject(new AggregateError(errors, "All promises were rejected"));
						  }
						});
					 }
				  });
				}
				static race(values) {
				  let resolve;
				  let reject;
				  let promise = new this((res, rej) => {
					 resolve = res;
					 reject = rej;
				  });
				  function onResolve(value) {
					 resolve(value);
				  }
				  function onReject(error) {
					 reject(error);
				  }
				  for (let value of values) {
					 if (!isThenable(value)) {
						value = this.resolve(value);
					 }
					 value.then(onResolve, onReject);
				  }
				  return promise;
				}
				static all(values) {
				  return ZoneAwarePromise.allWithCallback(values);
				}
				static allSettled(values) {
				  const P = this && this.prototype instanceof ZoneAwarePromise ? this : ZoneAwarePromise;
				  return P.allWithCallback(values, {
					 thenCallback: (value) => ({ status: "fulfilled", value }),
					 errorCallback: (err) => ({ status: "rejected", reason: err })
				  });
				}
				static allWithCallback(values, callback) {
				  let resolve;
				  let reject;
				  let promise = new this((res, rej) => {
					 resolve = res;
					 reject = rej;
				  });
				  let unresolvedCount = 2;
				  let valueIndex = 0;
				  const resolvedValues = [];
				  for (let value of values) {
					 if (!isThenable(value)) {
						value = this.resolve(value);
					 }
					 const curValueIndex = valueIndex;
					 try {
						value.then((value2) => {
						  resolvedValues[curValueIndex] = callback ? callback.thenCallback(value2) : value2;
						  unresolvedCount--;
						  if (unresolvedCount === 0) {
							 resolve(resolvedValues);
						  }
						}, (err) => {
						  if (!callback) {
							 reject(err);
						  } else {
							 resolvedValues[curValueIndex] = callback.errorCallback(err);
							 unresolvedCount--;
							 if (unresolvedCount === 0) {
								resolve(resolvedValues);
							 }
						  }
						});
					 } catch (thenErr) {
						reject(thenErr);
					 }
					 unresolvedCount++;
					 valueIndex++;
				  }
				  unresolvedCount -= 2;
				  if (unresolvedCount === 0) {
					 resolve(resolvedValues);
				  }
				  return promise;
				}
				constructor(executor) {
				  const promise = this;
				  if (!(promise instanceof ZoneAwarePromise)) {
					 throw new Error("Must be an instanceof Promise.");
				  }
				  promise[symbolState] = UNRESOLVED;
				  promise[symbolValue] = [];
				  try {
					 const onceWrapper = once();
					 executor && executor(onceWrapper(makeResolver(promise, RESOLVED)), onceWrapper(makeResolver(promise, REJECTED)));
				  } catch (error) {
					 resolvePromise(promise, false, error);
				  }
				}
				get [Symbol.toStringTag]() {
				  return "Promise";
				}
				get [Symbol.species]() {
				  return ZoneAwarePromise;
				}
				then(onFulfilled, onRejected) {
				  let C = this.constructor?.[Symbol.species];
				  if (!C || typeof C !== "function") {
					 C = this.constructor || ZoneAwarePromise;
				  }
				  const chainPromise = new C(noop);
				  const zone = Zone3.current;
				  if (this[symbolState] == UNRESOLVED) {
					 this[symbolValue].push(zone, chainPromise, onFulfilled, onRejected);
				  } else {
					 scheduleResolveOrReject(this, zone, chainPromise, onFulfilled, onRejected);
				  }
				  return chainPromise;
				}
				catch(onRejected) {
				  return this.then(null, onRejected);
				}
				finally(onFinally) {
				  let C = this.constructor?.[Symbol.species];
				  if (!C || typeof C !== "function") {
					 C = ZoneAwarePromise;
				  }
				  const chainPromise = new C(noop);
				  chainPromise[symbolFinally] = symbolFinally;
				  const zone = Zone3.current;
				  if (this[symbolState] == UNRESOLVED) {
					 this[symbolValue].push(zone, chainPromise, onFinally, onFinally);
				  } else {
					 scheduleResolveOrReject(this, zone, chainPromise, onFinally, onFinally);
				  }
				  return chainPromise;
				}
			 }
			 ZoneAwarePromise["resolve"] = ZoneAwarePromise.resolve;
			 ZoneAwarePromise["reject"] = ZoneAwarePromise.reject;
			 ZoneAwarePromise["race"] = ZoneAwarePromise.race;
			 ZoneAwarePromise["all"] = ZoneAwarePromise.all;
			 const NativePromise = global2[symbolPromise] = global2["Promise"];
			 global2["Promise"] = ZoneAwarePromise;
			 const symbolThenPatched = __symbol__2("thenPatched");
			 function patchThen(Ctor) {
				const proto = Ctor.prototype;
				const prop = ObjectGetOwnPropertyDescriptor2(proto, "then");
				if (prop && (prop.writable === false || !prop.configurable)) {
				  return;
				}
				const originalThen = proto.then;
				proto[symbolThen] = originalThen;
				Ctor.prototype.then = function(onResolve, onReject) {
				  const wrapped = new ZoneAwarePromise((resolve, reject) => {
					 originalThen.call(this, resolve, reject);
				  });
				  return wrapped.then(onResolve, onReject);
				};
				Ctor[symbolThenPatched] = true;
			 }
			 api.patchThen = patchThen;
			 function zoneify(fn) {
				return function(self2, args) {
				  let resultPromise = fn.apply(self2, args);
				  if (resultPromise instanceof ZoneAwarePromise) {
					 return resultPromise;
				  }
				  let ctor = resultPromise.constructor;
				  if (!ctor[symbolThenPatched]) {
					 patchThen(ctor);
				  }
				  return resultPromise;
				};
			 }
			 if (NativePromise) {
				patchThen(NativePromise);
				patchMethod(global2, "fetch", (delegate) => zoneify(delegate));
			 }
			 Promise[Zone3.__symbol__("uncaughtPromiseErrors")] = _uncaughtPromiseErrors;
			 return ZoneAwarePromise;
		  });
		}
		function patchToString(Zone2) {
		  Zone2.__load_patch("toString", (global2) => {
			 const originalFunctionToString = Function.prototype.toString;
			 const ORIGINAL_DELEGATE_SYMBOL = zoneSymbol("OriginalDelegate");
			 const PROMISE_SYMBOL = zoneSymbol("Promise");
			 const ERROR_SYMBOL = zoneSymbol("Error");
			 const newFunctionToString = function toString() {
				if (typeof this === "function") {
				  const originalDelegate = this[ORIGINAL_DELEGATE_SYMBOL];
				  if (originalDelegate) {
					 if (typeof originalDelegate === "function") {
						return originalFunctionToString.call(originalDelegate);
					 } else {
						return Object.prototype.toString.call(originalDelegate);
					 }
				  }
				  if (this === Promise) {
					 const nativePromise = global2[PROMISE_SYMBOL];
					 if (nativePromise) {
						return originalFunctionToString.call(nativePromise);
					 }
				  }
				  if (this === Error) {
					 const nativeError = global2[ERROR_SYMBOL];
					 if (nativeError) {
						return originalFunctionToString.call(nativeError);
					 }
				  }
				}
				return originalFunctionToString.call(this);
			 };
			 newFunctionToString[ORIGINAL_DELEGATE_SYMBOL] = originalFunctionToString;
			 Function.prototype.toString = newFunctionToString;
			 const originalObjectToString = Object.prototype.toString;
			 const PROMISE_OBJECT_TO_STRING = "[object Promise]";
			 Object.prototype.toString = function() {
				if (typeof Promise === "function" && this instanceof Promise) {
				  return PROMISE_OBJECT_TO_STRING;
				}
				return originalObjectToString.call(this);
			 };
		  });
		}
		function patchCallbacks(api, target, targetName, method, callbacks) {
		  const symbol = Zone.__symbol__(method);
		  if (target[symbol]) {
			 return;
		  }
		  const nativeDelegate = target[symbol] = target[method];
		  target[method] = function(name, opts, options) {
			 if (opts && opts.prototype) {
				callbacks.forEach(function(callback) {
				  const source = `${targetName}.${method}::` + callback;
				  const prototype = opts.prototype;
				  try {
					 if (prototype.hasOwnProperty(callback)) {
						const descriptor = api.ObjectGetOwnPropertyDescriptor(prototype, callback);
						if (descriptor && descriptor.value) {
						  descriptor.value = api.wrapWithCurrentZone(descriptor.value, source);
						  api._redefineProperty(opts.prototype, callback, descriptor);
						} else if (prototype[callback]) {
						  prototype[callback] = api.wrapWithCurrentZone(prototype[callback], source);
						}
					 } else if (prototype[callback]) {
						prototype[callback] = api.wrapWithCurrentZone(prototype[callback], source);
					 }
				  } catch {
				  }
				});
			 }
			 return nativeDelegate.call(target, name, opts, options);
		  };
		  api.attachOriginToPatched(target[method], nativeDelegate);
		}
		function patchUtil(Zone2) {
		  Zone2.__load_patch("util", (global2, Zone3, api) => {
			 const eventNames = getOnEventNames(global2);
			 api.patchOnProperties = patchOnProperties;
			 api.patchMethod = patchMethod;
			 api.bindArguments = bindArguments;
			 api.patchMacroTask = patchMacroTask;
			 const SYMBOL_BLACK_LISTED_EVENTS = Zone3.__symbol__("BLACK_LISTED_EVENTS");
			 const SYMBOL_UNPATCHED_EVENTS = Zone3.__symbol__("UNPATCHED_EVENTS");
			 if (global2[SYMBOL_UNPATCHED_EVENTS]) {
				global2[SYMBOL_BLACK_LISTED_EVENTS] = global2[SYMBOL_UNPATCHED_EVENTS];
			 }
			 if (global2[SYMBOL_BLACK_LISTED_EVENTS]) {
				Zone3[SYMBOL_BLACK_LISTED_EVENTS] = Zone3[SYMBOL_UNPATCHED_EVENTS] = global2[SYMBOL_BLACK_LISTED_EVENTS];
			 }
			 api.patchEventPrototype = patchEventPrototype;
			 api.patchEventTarget = patchEventTarget;
			 api.isIEOrEdge = isIEOrEdge;
			 api.ObjectDefineProperty = ObjectDefineProperty;
			 api.ObjectGetOwnPropertyDescriptor = ObjectGetOwnPropertyDescriptor;
			 api.ObjectCreate = ObjectCreate;
			 api.ArraySlice = ArraySlice;
			 api.patchClass = patchClass;
			 api.wrapWithCurrentZone = wrapWithCurrentZone;
			 api.filterProperties = filterProperties;
			 api.attachOriginToPatched = attachOriginToPatched;
			 api._redefineProperty = Object.defineProperty;
			 api.patchCallbacks = patchCallbacks;
			 api.getGlobalObjects = () => ({
				globalSources,
				zoneSymbolEventNames,
				eventNames,
				isBrowser,
				isMix,
				isNode,
				TRUE_STR,
				FALSE_STR,
				ZONE_SYMBOL_PREFIX,
				ADD_EVENT_LISTENER_STR,
				REMOVE_EVENT_LISTENER_STR
			 });
		  });
		}
		function patchCommon(Zone2) {
		  patchPromise(Zone2);
		  patchToString(Zone2);
		  patchUtil(Zone2);
		}
		var Zone$1 = loadZone();
		patchCommon(Zone$1);
		patchBrowser(Zone$1);

		return PlanningBoardDataServiceInterfaceService;
	})();
}
