/**
 * Created by anl on 4/3/2019.
 */

(function (angular) {
	'use strict';

	var moduleName = 'productionplanning.accounting';

	angular.module(moduleName).factory('productionplanningAccountingRuleSetDataService', AccountingRuleSetDataService);

	AccountingRuleSetDataService.$inject = ['_', 'platformDataServiceFactory',
		'basicsLookupdataLookupDescriptorService',
		'productionplanningAccountingRuleSetProcessor',
		'$injector'];

	function AccountingRuleSetDataService(_, platformDataServiceFactory,
										  basicsLookupdataLookupDescriptorService,
										  ruleSetProcessor,
										  $injector) {

		function createNewComplete(config) {
			var serviceOptions = {
				flatRootItem: {
					module: moduleName,
					serviceName: 'productionplanningAccountingRuleSetDataService',
					entityNameTranslationID: 'productionplanning.accounting.entityRuleSet',
					httpCRUD: {
						route: globals.webApiBaseUrl + 'productionplanning/accounting/ruleset/',
						usePostForRead: true,
						endRead: 'filtered',
						endDelete: 'multidelete'
					},
					dataProcessor: [ruleSetProcessor],
					entityRole: {
						root: {
							itemName: 'RuleSets',
							moduleName: 'cloud.desktop.moduleDisplayNamePpsAccounting',
							descField: 'Description',
							handleUpdateDone: handleUpdateDone
						}
					},
					useItemFilter: true,
					entitySelection: {supportsMultiSelection: true},
					presenter: {
						list: {
							// incorporateDataRead: function (readData, data) {
							// 	basicsLookupdataLookupDescriptorService.attachData(readData);
							// 	var result = {
							// 		FilterResult: readData.FilterResult,
							// 		dtos: readData.Main || []
							// 	};
							//
							// 	var dataRead = serviceContainer.data.handleReadSucceeded(result, data);
							// 	return dataRead;
							// },
							handleCreateSucceeded: function (ruleset) {  // jshint ignore:line
							},
							initCreationData: function (creationData) { // jshint ignore:line
								//creationData.Pkey1 = selected
							}
						}
					},
					translation: {
						uid: 'productionplanningAccountingRuleSetDataService',
						title: 'productionplanning.accounting.entityRuleSet'
					},
					sidebarWatchList: {active: true},
					sidebarSearch: {
						options: {
							moduleName: moduleName,
							pattern: '',
							pageSize: 100,
							useCurrentClient: null,
							includeNonActiveItems: false,
							showOptions: true,
							withExecutionHints: true,
							enhancedSearchEnabled: true,
							enhancedSearchVersion: '2.0',
							pinningOptions: {
								isActive: false
							}
						}
					}
				}
			};

			if (config.extendBefore) {
				config.extendBefore(serviceOptions);
			}
			var serviceContainer = platformDataServiceFactory.createNewComplete(serviceOptions);

			if (config.extendAfter) {
				config.extendAfter(serviceContainer);
			}


			serviceContainer.service.doPrepareUpdateCall = function (updateData) {
				var selectedRuleSet = serviceContainer.service.getSelected();
				if (selectedRuleSet !== null && selectedRuleSet.AutoGenerated) {
					if (angular.isDefined(updateData.RuleSets) && updateData.RuleSets.length === 1) {
						updateData.RuleSets[0].AutoGenerated = false;
					}
					else if (angular.isDefined(updateData.RuleSets) && updateData.RuleSets.length > 1) {
						_.forEach(updateData.RuleSets, function (ruleSet) {
							ruleSet.AutoGenerated = false;
						});
					}
					else if (updateData.EntitiesCount > 0 && !angular.isDefined(updateData.RuleSets)) {
						selectedRuleSet.AutoGenerated = false;
						updateData.EntitiesCount++;
						updateData.RuleSets = [selectedRuleSet];
					}
				}
			};

			function handleUpdateDone(updateData, response, data) {
				data.handleOnUpdateSucceeded(updateData, response, data, true);

				if (response && response.ResultsToSave) {
					$injector.get('productionplanningAccountingResultDataService').gridRefresh();
				}
			}

			return serviceContainer.service;
		}

		var serviceCache = {};

		function getService(config) {
			var serviceKey = config.serviceKey;
			if (!serviceCache[serviceKey]) {
				serviceCache[serviceKey] = createNewComplete(config);
			}
			return serviceCache[serviceKey];
		}

		var service = createNewComplete({});
		service.getService = getService;
		return service;
	}

})(angular);